{
  "roots": [
    "js",
    "ui",
    "frames-and-windows",
    "binary",
    "data-storage",
    "animation",
    "web-components",
    "regular-expressions"
  ],
  "bySlugMap": {
    "js": {
      "type": "Article",
      "value": {
        "title": "JavaScript 编程语言",
        "slug": "js",
        "githubPath": "/1-js",
        "isFolder": true,
        "weight": 1,
        "content": "\n\n在这儿我们将从头开始学习 JavaScript，也会学习 OOP 等相关高级概念。\n\n本教程专注于语言本身，我们默认使用最小环境。",
        "libs": [],
        "children": [
          "getting-started",
          "first-steps",
          "code-quality",
          "object-basics",
          "data-types",
          "advanced-functions",
          "object-properties",
          "prototypes",
          "classes",
          "error-handling",
          "async",
          "generators-iterators",
          "modules",
          "js-misc"
        ]
      }
    },
    "getting-started": {
      "type": "Article",
      "value": {
        "title": "简介",
        "slug": "getting-started",
        "githubPath": "/1-js/01-getting-started",
        "isFolder": true,
        "weight": 1,
        "content": "\n\n介绍 JavaScript 语言及其开发环境。",
        "libs": [],
        "children": [
          "intro",
          "manuals-specifications",
          "code-editors",
          "devtools"
        ],
        "parent": "js"
      }
    },
    "intro": {
      "type": "Article",
      "value": {
        "title": "JavaScript 简介 测试",
        "slug": "intro",
        "githubPath": "/1-js/01-getting-started/1-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n让我们来看看3/9测试语录 JavaScript 有什么特别之处，我们可以用它实现什么，以及哪些其他技术可以与其搭配产生奇妙的效果。\n\n## 什么是 JavaScript？\n\n*JavaScript* 最初被创建的目的是“使网页更生动”。\n\n这种编程语言写出来的程序被称为 **脚本**。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。\n\n脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。\n\n这方面，JavaScript 和 [Java](https://en.wikipedia.org/wiki/Java_(programming_language)) 有很大的区别。\n\n```smart header=\"为什么叫 <u>Java</u>Script？\"\nJavaScript 在刚诞生的时候，它的名字叫 \"LiveScript\"。但是因为当时 Java 很流行，所以决定将一种新语言定位为 Java 的“弟弟”会有助于它的流行。\n\n随着 JavaScript 的发展，它已经成为了一门完全独立的语言，并且也拥有了自己的语言规范 [ECMAScript](http://en.wikipedia.org/wiki/ECMAScript)。现在，它和 Java 之间没有任何关系。\n```\n\n如今，JavaScript 不仅可以在浏览器中执行，也可以在服务端执行，甚至可以在任意搭载了 [JavaScript 引擎](https://en.wikipedia.org/wiki/JavaScript_engine) 的设备中执行。\n\n浏览器中嵌入了 JavaScript 引擎，有时也称作“JavaScript 虚拟机”。\n\n不同的引擎有不同的“代号”，例如：\n\n- [V8](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) —— Chrome、Opera 和 Edge 中的 JavaScript 引擎。\n- [SpiderMonkey](https://en.wikipedia.org/wiki/SpiderMonkey) —— Firefox 中的 JavaScript 引擎。\n- ……还有其他一些代号，像 \"Chakra\" 用于 IE，\"JavaScriptCore\"、\"Nitro\" 和 \"SquirrelFish\" 用于 Safari，等等。\n\n上面这些术语很容易记住，因为它们经常出现在开发者的文章中。我们也会用到这些术语。例如，如果“V8 支持某个功能”，那么我们可以认为这个功能大概能在 Chrome、Opera 和 Edge 中正常运行。\n\n```smart header=\"引擎是如何工作的？\"\n\n引擎很复杂，但是基本原理很简单。\n\n1. 引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。\n2. 然后，引擎将脚本转化（“编译”）为机器语言。\n3. 然后，机器代码快速地执行。\n\n引擎会对流程中的每个阶段都进行优化。它甚至可以在编译的脚本运行时监视它，分析流经该脚本的数据，并根据获得的信息进一步优化机器代码。\n```\n\n## 浏览器中的 JavaScript 能做什么？\n\n现代的 JavaScript 是一种“安全的”编程语言。它不提供对内存或 CPU 的底层访问，因为它最初是为浏览器创建的，不需要这些功能。\n\nJavaScript 的能力很大程度上取决于它运行的环境。例如，[Node.js](https://wikipedia.org/wiki/Node.js) 支持允许 JavaScript 读取/写入任意文件，执行网络请求等的函数。\n\n浏览器中的 JavaScript 可以做与网页操作、用户交互和 Web 服务器相关的所有事情。\n\n例如，浏览器中的 JavaScript 可以做下面这些事：\n\n- 在网页中添加新的 HTML，修改网页已有内容和网页的样式。\n- 响应用户的行为，响应鼠标的点击，指针的移动，按键的按动。\n- 向远程服务器发送网络请求，下载和上传文件（所谓的 [AJAX](https://en.wikipedia.org/wiki/Ajax_(programming)) 和 [COMET](https://en.wikipedia.org/wiki/Comet_(programming)) 技术）。\n- 获取或设置 cookie，向访问者提出问题或发送消息。\n- 记住客户端的数据（“本地存储”）。\n\n## 浏览器中的 JavaScript 不能做什么？\n\n为了用户的（信息）安全，在浏览器中的 JavaScript 的能力是受限的。目的是防止恶意网页获取用户私人信息或损害用户数据。\n\n此类限制的例子包括：\n\n- 网页中的 JavaScript 不能读、写、复制和执行硬盘上的任意文件。它没有直接访问操作系统的功能。\n\n  现代浏览器允许 JavaScript 做一些文件相关的操作，但是这个操作是受到限制的。仅当用户做出特定的行为，JavaScript 才能操作这个文件。例如，用户把文件“拖放”到浏览器中，或者通过 `<input>` 标签选择了文件。\n\n  有很多与相机/麦克风和其它设备进行交互的方式，但是这些都需要获得用户的明确许可。因此，启用了 JavaScript 的网页应该不会偷偷地启动网络摄像头观察你，并把你的信息发送到 [美国国家安全局](https://en.wikipedia.org/wiki/National_Security_Agency)。\n- 不同的标签页/窗口之间通常互不了解。有时候，也会有一些联系，例如一个标签页通过 JavaScript 打开的另外一个标签页。但即使在这种情况下，如果两个标签页打开的不是同一个网站（域名、协议或者端口任一不相同的网站），它们都不能相互通信。\n\n  这就是所谓的“同源策略”。为了解决“同源策略”问题，两个标签页必须 **都** 包含一些处理这个问题的特定的 JavaScript 代码，并均允许数据交换。本教程会讲到这部分相关的知识。\n\n  这个限制也是为了用户的信息安全。例如，用户打开的 `http://anysite.com` 网页必须不能访问 `http://gmail.com`（另外一个标签页打开的网页）也不能从那里窃取信息。\n- JavaScript 可以轻松地通过互联网与当前页面所在的服务器进行通信。但是从其他网站/域的服务器中接收数据的能力被削弱了。尽管可以，但是需要来自远程服务器的明确协议（在 HTTP header 中）。这也是为了用户的信息安全。\n\n![](limitations.svg)\n\n如果在浏览器环境外（例如在服务器上）使用 JavaScript，则不存在此类限制。现代浏览器还允许安装可能会要求扩展权限的插件/扩展。\n\n## 是什么使得 JavaScript 与众不同？\n\n至少有 **3** 件事值得一提：\n\n```compare\n+ 与 HTML/CSS 完全集成。\n+ 简单的事，简单地完成。\n+ 被所有的主流浏览器支持，并且默认开启。\n```\nJavaScript 是将这三件事结合在一起的唯一的浏览器技术。\n\n这就是为什么 JavaScript 与众不同。这也是为什么它是用于创建浏览器界面的使用最广泛的工具。\n\n此外，JavaScript 还可用于创建服务器和移动端应用程序等。\n\n## JavaScript “上层”语言\n\n不同的人想要不同的功能。JavaScript 的语法也不能满足所有人的需求。\n\n这是正常的，因为每个人的项目和需求都不一样。\n\n因此，最近出现了许多新语言，这些语言在浏览器中执行之前，都会被 **编译**（转化）成 JavaScript。\n\n现代化的工具使得编译速度非常快且透明，实际上允许开发者使用另一种语言编写代码并会将其“自动转换”为 JavaScript。\n\n此类语言的示例有：\n\n- [CoffeeScript](https://coffeescript.org/) 是 JavaScript 的一种语法糖。它引入了更加简短的语法，使我们可以编写更清晰简洁的代码。通常，Ruby 开发者喜欢它。\n- [TypeScript](https://www.typescriptlang.org/) 专注于添加“严格的数据类型”以简化开发，以更好地支持复杂系统的开发。由微软开发。\n- [Flow](https://flow.org/) 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。\n- [Dart](https://www.dartlang.org/) 是一门独立的语言。它拥有自己的引擎，该引擎可以在非浏览器环境中运行（例如手机应用），它也可以被编译成 JavaScript。由 Google 开发。\n- [Brython](https://brython.info/) 是一个 Python 到 JavaScript 的转译器，让我们可以在不使用 JavaScript 的情况下，以纯 Python 编写应用程序。\n- [Kotlin](https://kotlinlang.org/docs/reference/js-overview.html) 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 Node 环境中运行。\n\n这样的语言还有很多。当然，即使我们在使用此类编译语言，我们也需要了解 JavaScript。因为了解 JavaScript 才能让我们真正明白我们在做什么。\n\n## Mock 工具\n\n<a href=\"https://datayi.cn/w/QReKB8No\" target=\"_blank\"><img src=\"https://user-images.githubusercontent.com/26959437/189130319-846e1e33-3b47-4cbc-8fe1-0fa87db5362f.svg\" width=\"300px;\" target=\"_blank\"/></a>\n\n一个好用的开源接口 Mock 工具：[https://github.com/eolinker/eoapi](https://datayi.cn/w/QReKB8No)\n\n除了 Mock 功能，还集合了 API 管理和测试功能，还可以通过插件广场帮助你将 API 发布到各个应用平台，比如发布到网关上完成 API 上线，或者和低代码平台结合，将 API 快速变成低代码平台中可使用的组件等。\n\n## 总结\n\n- JavaScript 最开始是专门为浏览器设计的一门语言，但是现在也被用于很多其他的环境。\n- JavaScript 作为被应用最广泛的浏览器语言，且与 HTML/CSS 完全集成，具有独特的地位。\n- 有很多其他的语言可以被“编译”成 JavaScript，这些语言还提供了更多的功能。建议最好了解一下这些语言，至少在掌握了 JavaScript 之后大致的了解一下。",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1662643017
      }
    },
    "manuals-specifications": {
      "type": "Article",
      "value": {
        "title": "手册与规范",
        "slug": "manuals-specifications",
        "githubPath": "/1-js/01-getting-started/2-manuals-specifications",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n这本书是一个 **教程**。它旨在帮助你由浅入深掌握 JavaScript 这门语言。但是，当你已经熟悉了这门语言的基础知识，你就会需要其他资料。\n\n## 规范\n\n**ECMA-262 规范** 包含了大部分深入的、详细的、规范化的关于 JavaScript 的信息。这份规范明确地定义了这门语言。\n\n但正因其规范化，对于新手来说难以理解。所以，如果你需要关于这门语言细节最权威的信息来源，这份规范就很适合你（去阅读）。但它并不适合日常使用。\n\n每年都会发布一个新版本的规范。最新的规范草案请见 <https://tc39.es/ecma262/>。\n\n想了解最新最前沿的功能，包括“即将纳入规范的”（所谓的 \"stage 3\"），请看这里的提案 <https://github.com/tc39/proposals>。\n\n当然，如果你正在做浏览器相关的开发工作，那么本教程的 [第二部分](info:browser-environment) 涵盖了其他规范。\n\n## 手册\n\n- **MDN（Mozilla）JavaScript 索引** 是一个带有用例和其他信息的主要的手册。它是一个获取关于个别语言函数、方法等深入信息的很好的信息来源。\n\n    你可以在 <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference> 阅读它。\n\n不过，利用互联网搜索通常是最好的选择。只需在查询时输入“MDN [关键字]”，例如 <https://google.com/search?q=MDN+parseInt> 搜索 `parseInt` 函数。\n\n## 兼容性表\n\nJavaScript 是一门还在发展中的语言，定期会添加一些新的功能。\n\n要查看它们在基于浏览器的引擎及其他引擎中的支持情况，请看：\n\n- <https://caniuse.com> —— 每个功能的支持表，例如，查看哪个引擎支持现代加密（cryptography）函数：<https://caniuse.com/#feat=cryptography>。\n- <https://kangax.github.io/compat-table> —— 一份列有语言功能以及引擎是否支持这些功能的表格。\n\n所有这些资源在实际开发中都有用武之地，因为它们包含了有关语言细节，以及它们被支持的程度等非常有价值的信息。\n\n为了让你在真正需要深入了解特定功能的时候不会捉襟见肘，请记住它们（或者这一页）。",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1670644516
      }
    },
    "code-editors": {
      "type": "Article",
      "value": {
        "title": "代码编辑器",
        "slug": "code-editors",
        "githubPath": "/1-js/01-getting-started/3-code-editors",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n程序员接触时间最长的就是代码编辑器。\n\n代码编辑器主要分两种：IDE（集成开发环境）和轻量编辑器。很多人喜欢这两种各选一个。\n\n## IDE\n\n[IDE](https://en.wikipedia.org/wiki/Integrated_development_environment)（集成开发环境）是指用于管理整个项目的，具有强大功能的编辑器。顾名思义，它不仅仅是一个编辑器，而且还是个完整的“开发环境”。\n\nIDE 加载项目（通常包含很多文件），并且允许在不同文件之间导航（navigation）。IDE 还提供基于整个项目（不仅仅是打开的文件）的自动补全功能，集成版本控制（如 [git](https://git-scm.com/)）、集成测试环境等一些其他“项目层面”的东西。\n\n如果你还没考虑好选哪一款 IDE，可以考虑下面两个：\n\n- [Visual Studio Code](https://code.visualstudio.com/)（跨平台，免费）。\n- [WebStorm](https://www.jetbrains.com/webstorm/)（跨平台，收费）。\n\n对于 Windows 系统来说，也有个叫 \"Visual Studio\" 的 IDE，请不要跟 \"Visual Studio Code\" 混淆。\"Visual Studio\" 是一个收费的、强大的 Windows 专用编辑器，它十分适合于 .NET 开发。用它进行 JavaScript 开发也不错。\"Visual Studio\" 有个免费的版本 [Visual Studio Community](https://www.visualstudio.com/vs/community/)。\n\n很多 IDE 是收费的，但是它们都可以试用。购买 IDE 的费用对于一名合格的程序员的薪水来说，肯定算不了什么，所以去选一个对你来说最好的吧。\n\n## 轻量编辑器\n\n“轻量编辑器”没有 IDE 功能那么强大，但是它们一般很快、优雅而且简单。\n\n“轻量编辑器”主要用于快速打开和编辑文件。\n\n“轻量编辑器”和 \"IDE\" 最大的区别是，IDE 一般在项目中使用，这也就意味着在开启的时候要加载很多数据，如果需要的话还会分析项目的结构等。如果我们只需要编辑一个文件，那么“轻量编辑器”会更快。\n\n实际上，“轻量编辑器”一般都有各种各样的插件，这些插件可以做目录级（directory-level）的语法分析和代码补全。所以“轻量编辑器”和 IDE 也没有严格的界限。\n\n下面是一些值得你关注的“轻量编辑器”：\n\n- [Sublime Text](http://www.sublimetext.com)（跨平台，共享软件）。\n- [Notepad++](https://notepad-plus-plus.org/)（Windows，免费）。\n- [Vim](http://www.vim.org/) 和 [Emacs](https://www.gnu.org/software/emacs/) 也很棒，如果你知道怎么使用它们的话。\n\n## 不要争吵\n\n上面列表中的编辑器都是我和我的朋友（他们都是我认为很优秀的开发者）已经使用了很长时间并且很满意的。\n\n当然还有很多其他很好的编辑器，你可以选择一个你最喜欢的。\n\n选择编辑器就像选择其他工具一样，是很个人化的。具体取决于你的项目，习惯以及个人喜好。",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1657705346
      }
    },
    "devtools": {
      "type": "Article",
      "value": {
        "title": "开发者控制台",
        "slug": "devtools",
        "githubPath": "/1-js/01-getting-started/4-devtools",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n代码是很容易出现错误的。你也很可能犯错误……哦，我在说什么？只要你是人，你 **一定** 会犯错误（在写代码的时候），除非你是 [机器人](https://en.wikipedia.org/wiki/Bender_(Futurama))。\n\n但在浏览器中，默认情况下用户是看不到错误的。所以，如果脚本中有错误，我们看不到是什么错误，更不能够修复它。\n\n为了发现错误并获得一些与脚本相关且有用的信息，浏览器内置了“开发者工具”。\n\n通常，开发者倾向于使用 Chrome 或 Firefox 进行开发，因为它们有最好的开发者工具。一些其它的浏览器也提供开发者工具，有时还具有一些特殊的功能，通常它们都是在“追赶” Chrome 或 Firefox。所以大多数人都有“最喜欢”的浏览器，当遇到某个浏览器独有的问题的时候，人们就会切换到其它的浏览器。\n\n开发者工具很强大，功能丰富。首先，我们将学习如何打开它们，查找错误和运行 JavaScript 命令。\n\n## Google Chrome\n\n打开网页 [bug.html](bug.html)。\n\n在这个页面的 JavaScript 代码中有一个错误。一般的访问者看不到这个错误，所以让我们打开开发者工具看看吧。\n\n按下 `key:F12` 键，如果你使用 Mac，试试 `key:Cmd+Opt+J`。\n\n默认情况下，开发者工具会被在 Console 标签页中打开。\n\n就像这样：\n\n![chrome](chrome.png)\n\n具体什么样，要看你的 Chrome 版本。它随着时间一直在变，但是都很类似。\n\n- 在这我们能看到红色的错误提示信息。这个场景中，脚本里有一个未知的 \"lalala\" 命令。\n- 在右边，有个可点击的链接 `bug.html:12`。这个链接会链接到错误发生的行号。\n\n在错误信息的下方，有个 `>` 标志。它代表“命令行”，在“命令行”中，我们可以输入 JavaScript 命令，按下 `key:Enter` 来执行。\n\n现在，我们能看到错误就够了。稍后，在 <info:debugging-chrome> 一节中，我们会重新更加深入地学习开发者工具。\n\n```smart header=\"多行输入\"\n通常，当我们向控制台输入一行代码后，按 `key:Enter`，这行代码就会立即执行。\n\n如果想要插入多行代码，请按 `key:Shift+Enter` 来进行换行。这样就可以输入长片段的 JavaScript 代码了。\n```\n\n## Firefox、Edge 和其它浏览器\n\n大多数其它的浏览器都是通过 `key:F12` 来打开开发者工具。\n\n它们的外观和感觉都非常相似，一旦你学会了它们中的一个（可以先尝试 Chrome），其它的也就很快就可以熟悉了。\n\n## Safari\n\nSafari（Mac 系统中的浏览器，Windows 和 Linux 系统不支持）有一点点不同。我们需要先开启“开发菜单”。\n\n打开“偏好设置”，选择“高级”选项。选中最下方的那个选择框：\n\n![safari](safari.png)\n\n现在，我们通过 `key:Cmd+Opt+C` 就能打开或关闭控制台了。另外注意，有一个名字为“开发”的顶部菜单出现了。它有很多命令和选项。\n\n## 总结\n\n* 开发者工具允许我们查看错误、执行命令、检查变量等。\n* 在 Windows 系统中，可以通过 `key:F12` 开启开发者工具。Mac 系统下，Chrome 需要使用 `key:Cmd+Opt+J`，Safari 使用 `key:Cmd+Opt+C`（需要提前开启）。\n\n现在我们的环境准备好了。下一章，我们将正式开始学习 JavaScript。",
        "libs": [],
        "children": [],
        "parent": "getting-started",
        "updatedAt": 1602739853
      }
    },
    "first-steps": {
      "type": "Article",
      "value": {
        "title": "JavaScript 基础知识",
        "slug": "first-steps",
        "githubPath": "/1-js/02-first-steps",
        "isFolder": true,
        "weight": 2,
        "content": "\n\n让我们来一起学习 JavaScript 脚本构建的基础知识。",
        "libs": [],
        "children": [
          "hello-world",
          "structure",
          "strict-mode",
          "variables",
          "types",
          "alert-prompt-confirm",
          "type-conversions",
          "operators",
          "comparison",
          "ifelse",
          "logical-operators",
          "nullish-coalescing-operator",
          "while-for",
          "switch",
          "function-basics",
          "function-expressions",
          "arrow-functions-basics",
          "javascript-specials"
        ],
        "parent": "js"
      }
    },
    "hello-world": {
      "type": "Article",
      "value": {
        "title": "Hello, world!",
        "slug": "hello-world",
        "githubPath": "/1-js/02-first-steps/01-hello-world",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n本教程的这一部分内容是关于 JavaScript 语言本身的。\n\n但是，我们需要一个工作环境来运行我们的脚本，由于本教程是在线的，所以浏览器是一个不错的选择。我们会尽可能少地使用浏览器特定的命令（比如 `alert`），所以如果你打算专注于另一个环境（比如 Node.js），你就不必多花时间来关心这些特定指令了。我们将在本教程的 [下一部分](/ui) 中专注于浏览器中的 JavaScript。\n\n首先，让我们看看如何将脚本添加到网页上。对于服务器端环境（如 Node.js），你只需要使用诸如 `\"node my.js\"` 的命令行来执行它。\n\n\n## “script” 标签\n\n我们几乎可以使用 `<script>` 标签将 JavaScript 程序插入到 HTML 文档的任何位置。\n\n比如：\n\n```html run height=100\n<!DOCTYPE HTML>\n<html>\n\n<body>\n\n  <p>script 标签之前...</p>\n\n*!*\n  <script>\n    alert('Hello, world!');\n  </script>\n*/!*\n\n  <p>...script 标签之后</p>\n\n</body>\n\n</html>\n```\n\n```online\n你可以通过点击右上角的“播放”按钮来运行这个例子。\n```\n\n`<script>` 标签中包裹了 JavaScript 代码，当浏览器遇到 `<script>` 标签，代码会自动运行。\n\n\n## 现代的标记（markup）\n\n`<script>` 标签有一些现在很少用到的特性（attribute），但是我们可以在老代码中找到它们：\n\n`type` 特性：<code>&lt;script <u>type</u>=...&gt;</code>\n: 在老的 HTML4 标准中，要求 script 标签有 `type` 特性。通常是 `type=\"text/javascript\"`。这样的特性声明现在已经不再需要。而且，现代 HTML 标准已经完全改变了此特性的含义。现在，它可以用于 JavaScript 模块。但这是一个高阶话题，我们将在本教程的另一部分中探讨 JavaScript 模块。\n\n`language` 特性：<code>&lt;script <u>language</u>=...&gt;</code>\n: 这个特性是为了显示脚本使用的语言。这个特性现在已经没有任何意义，因为语言默认就是 JavaScript。不再需要使用它了。\n\n脚本前后的注释。\n: 在非常古老的书籍和指南中，你可能会在 `<script>` 标签里面找到注释，就像这样：\n\n    ```html no-beautify\n    <script type=\"text/javascript\"><!--\n        ...\n    //--></script>\n    ```\n\n    现代 JavaScript 中已经不这样使用了。这些注释是用于不支持 `<script>` 标签的古老的浏览器隐藏 JavaScript 代码的。由于最近 15 年内发布的浏览器都没有这样的问题，因此这种注释能帮你辨认出一些老掉牙的代码。\n\n\n## 外部脚本\n\n如果你有大量的 JavaScript 代码，我们可以将它放入一个单独的文件。\n\n脚本文件可以通过 `src` 特性（attribute）添加到 HTML 文件中。\n\n```html\n<script src=\"/path/to/script.js\"></script>\n```\n\n这里，`/path/to/script.js` 是脚本文件从网站根目录开始的绝对路径。当然也可以提供当前页面的相对路径。例如，`src =\"script.js\"`，就像 `src=\"./script.js\"`，表示当前文件夹中的 `\"script.js\"` 文件。\n\n我们也可以提供一个完整的 URL 地址，例如：\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\"></script>\n```\n\n要附加多个脚本，请使用多个标签：\n\n```html\n<script src=\"/js/script1.js\"></script>\n<script src=\"/js/script2.js\"></script>\n…\n```\n\n```smart\n一般来说，只有最简单的脚本才嵌入到 HTML 中。更复杂的脚本存放在单独的文件中。\n\n使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的 [缓存](https://en.wikipedia.org/wiki/Web_cache) 中。\n\n之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。\n\n这可以节省流量，并使得页面（加载）更快。\n```\n\n````warn header=\"如果设置了 `src` 特性，`script` 标签内容将会被忽略。\"\n一个单独的 `<script>` 标签不能同时有 `src` 特性和内部包裹的代码。\n\n这将不会工作：\n\n```html\n<script *!*src*/!*=\"file.js\">\n  alert(1); // 此内容会被忽略，因为设定了 src\n</script>\n```\n\n我们必须进行选择，要么使用外部的 `<script src=\"…\">`，要么使用正常包裹代码的 `<script>`。\n\n为了让上面的例子工作，我们可以将它分成两个 `<script>` 标签。\n\n```html\n<script src=\"file.js\"></script>\n<script>\n  alert(1);\n</script>\n```\n````\n\n## 总结\n\n- 我们可以使用一个 `<script>` 标签将 JavaScript 代码添加到页面中。\n- `type` 和 `language` 特性（attribute）不是必需的。\n- 外部的脚本可以通过 `<script src=\"path/to/script.js\"></script>` 的方式插入。\n\n\n有关浏览器脚本以及它们和网页的关系，还有很多可学的。但是请记住，教程的这部分主要是针对 JavaScript 语言本身的，所以我们不该被浏览器特定的实现分散自己的注意力。我们将使用浏览器作为运行 JavaScript 的一种方式，这种方式非常便于我们在线阅读，但这只是很多种方式中的一种。",
        "libs": [],
        "children": [
          "hello-alert",
          "hello-alert-ext"
        ],
        "parent": "first-steps",
        "updatedAt": 1657802976
      }
    },
    "hello-alert": {
      "type": "Task",
      "value": {
        "title": "显示一个提示语",
        "slug": "hello-alert",
        "githubPath": "/1-js/02-first-steps/01-hello-world/1-hello-alert",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个页面，然后显示一个消息 “I'm JavaScript!”。\n\n在沙箱中或者在你的硬盘上做这件事都无所谓，只要确保它能运行起来。\n\n[demo src=\"solution\"]",
        "solution": "[html src=\"index.html\"]",
        "parent": "hello-world",
        "version": 1
      }
    },
    "hello-alert-ext": {
      "type": "Task",
      "value": {
        "title": "使用外部的脚本显示一个提示语",
        "slug": "hello-alert-ext",
        "githubPath": "/1-js/02-first-steps/01-hello-world/2-hello-alert-ext",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n打开前一个任务 <info:task/hello-alert> 的答案。将脚本的内容提取到一个外部的 `alert.js` 文件中，放置在相同的文件夹中。\n\n打开页面，确保它能够工作。",
        "solution": "HTML 代码：\n\n[html src=\"index.html\"]\n\n同一个文件夹中的 `alert.js` 文件：\n\n[js src=\"alert.js\"]",
        "parent": "hello-world",
        "version": 1
      }
    },
    "structure": {
      "type": "Article",
      "value": {
        "title": "代码结构",
        "slug": "structure",
        "githubPath": "/1-js/02-first-steps/02-structure",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n我们将要学习的第一个内容就是构建代码块。\n\n## 语句\n\n语句是执行行为（action）的语法结构和命令。\n\n我们已经见过了 `alert('Hello, world!')` 这样可以用来显示消息的语句。\n\n我们可以在代码中编写任意数量的语句。语句之间可以使用分号进行分割。\n\n例如，我们将 \"Hello World\" 这条信息一分为二：\n\n```js run no-beautify\nalert('Hello'); alert('World');\n```\n\n通常，每条语句独占一行，以提高代码的可读性：\n\n```js run no-beautify\nalert('Hello');\nalert('World');\n```\n\n## 分号 [#semicolon]\n\n当存在换行符（line break）时，在大多数情况下可以省略分号。\n\n下面的代码也是可以运行的：\n\n```js run no-beautify\nalert('Hello')\nalert('World')\n```\n\n在这，JavaScript 将换行符理解成“隐式”的分号。这也被称为 [自动分号插入](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion)。\n\n**在大多数情况下，换行意味着一个分号。但是“大多数情况”并不意味着“总是”！**\n\n有很多换行并不是分号的例子，例如：\n\n```js run no-beautify\nalert(3 +\n1\n+ 2);\n```\n\n代码输出 `6`，因为 JavaScript 并没有在这里插入分号。显而易见的是，如果一行以加号 `\"+\"` 结尾，那么这是一个“不完整的表达式”，不需要分号。所以，这个例子得到了预期的结果。\n\n**但存在 JavaScript 无法确定是否真的需要自动插入分号的情况。**\n\n这种情况下发生的错误是很难被找到和解决的。\n\n````smart header=\"一个错误的例子\"\n如果你好奇地想知道一个这种错误的具体例子，那你可以看看下面这段代码：\n\n```js run\nalert(\"Hello\");\n\n[1, 2].forEach(alert);\n```\n\n你不需要考虑方括号 `[]` 和 `forEach` 的含义，现在它们并不重要，之后我们会学习它们。让我们先记住这段代码的运行结果：先显示 `Hello`，然后显示 `1`，然后 `2`。\n\n现在，让我们删除 `alert` 语句后的分号：\n\n```js run no-beautify\nalert(\"Hello\")\n\n[1, 2].forEach(alert);\n```\n\n与上面的代码相比只有一个字符的区别：第一行末尾的分号不见了。\n\n如果我们运行这段代码，只有第一个 `Hello` 会被显示出来（并且有一个报错，你可能需要打开控制台才能看到它）。并且不会再有数字被显示出来。\n\n这是因为，JavaScript 引擎并没有假设在方括号 `[...]` 前有一个分号。因此，最后一个示例中的代码被视为了单个语句。\n\n对于引擎来说，它是这样的：\n\n```js run no-beautify\nalert(\"Hello\")[1, 2].forEach(alert);\n```\n\n看起来很奇怪，对吧？在这种情况下，这样将两行代码合并到一起是不对的。我们需要在 `alert` 后面加一个分号，代码才能正常运行。\n\n这也可能发生在其他情况下。\n````\n\n即使语句被换行符分隔了，我们依然建议在它们之间加分号。这个规则被社区广泛采用。我们再次强调一下 —— 大部分时候可以省略分号，但是最好不要省略分号，尤其对新手来说。\n\n## 注释 [#code-comments]\n\n随着时间推移，程序变得越来越复杂。为代码添加 **注释** 来描述它做了什么和为什么要这样做，变得非常有必要了。\n\n你可以在脚本的任何地方添加注释，它们并不会影响代码的执行，因为引擎会直接忽略它们。\n\n**单行注释以两个正斜杠字符 `//` 开始。**\n\n这一行的剩余部分是注释。它可能独占一行或者跟随在一条语句的后面。\n\n就像这样：\n\n```js run\n// 这行注释独占一行\nalert('Hello');\n\nalert('World'); // 这行注释跟随在语句后面\n```\n\n**多行注释以一个正斜杠和星号开始 <code>\"/&#42;\"</code> 并以一个星号和正斜杠结束 <code>\"&#42;/\"</code>。**\n\n就像这样:\n\n```js run\n/* 两个消息的例子。\n这是一个多行注释。\n*/\nalert('Hello');\nalert('World');\n```\n\n注释的内容被忽略了，所以如果我们在 <code>/&#42; ... &#42;/</code> 中放入代码，并不会执行。\n\n有时候，可以很方便地临时禁用代码：\n\n```js run\n/* 注释代码\nalert('Hello');\n*/\nalert('World');\n```\n\n```smart header=\"使用快捷键！\"\n在大多数的编辑器中，一行代码可以使用 `key:Ctrl+/` 快捷键进行单行注释，诸如 `key:Ctrl+Shift+/` 的快捷键可以进行多行注释（选择代码，然后按下快捷键）。对于 Mac 电脑，应使用 `key:Cmd` 而不是 `key:Ctrl`，使用 `key:Option` 而不是 `key:Shift`。\n```\n\n````warn header=\"不支持注释嵌套！\"\n不要在 `/*...*/` 内嵌套另一个 `/*...*/`。\n\n下面这段代码报错而无法执行：\n\n```js run no-beautify\n/*\n  /* 嵌套注释 ?!? */\n*/\nalert( 'World' );\n```\n````\n\n对你的代码进行注释，这还有什么可犹豫的！\n\n注释会增加代码总量，但这一点也不是什么问题。有很多工具可以帮你在把代码部署到服务器之前缩减代码。这些工具会移除注释，这样注释就不会出现在发布的脚本中。所以，注释对我们的生产没有任何负面影响。\n\n在后面的教程中，会有一章 <info:code-quality> 的内容解释如何更好地写注释。",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1650345563
      }
    },
    "strict-mode": {
      "type": "Article",
      "value": {
        "title": "现代模式，\"use strict\"",
        "slug": "strict-mode",
        "githubPath": "/1-js/02-first-steps/03-strict-mode",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题。新的特性被加入，旧的功能也没有改变。\n\n这么做有利于兼容旧代码，但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中。\n\n这种情况一直持续到 2009 年 ECMAScript 5 (ES5) 的出现。ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— `\"use strict\"` 来明确地激活这些特性。\n\n## \"use strict\"\n\n这个指令看上去像一个字符串 `\"use strict\"` 或者 `'use strict'`。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。\n\n比如：\n\n```js\n\"use strict\";\n\n// 代码以现代模式工作\n...\n```\n\n很快我们就会学习到函数（一种组合命令的方式），所以让我们提前注意一下，`\"use strict\"` 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。\n\n````warn header=\"确保 \\\"use strict\\\" 出现在最顶部\"\n请确保 `\"use strict\"` 出现在脚本的最顶部，否则严格模式可能无法启用。\n\n这里的严格模式就没有被启用：\n\n```js no-strict\nalert(\"some code\");\n// 下面的 \"use strict\" 会被忽略，必须在最顶部。\n\n\"use strict\";\n\n// 严格模式没有被激活\n```\n\n只有注释可以出现在 `\"use strict\"` 的上面。\n````\n\n```warn header=\"没有办法取消 `use strict`\"\n没有类似于 `\"no use strict\"` 这样的指令可以使程序返回默认模式。\n\n一旦进入了严格模式，就没有回头路了。\n```\n\n## 浏览器控制台\n\n当你使用 [开发者控制台](info:devtools) 运行代码时，请注意它默认是不启动 `use strict` 的。\n\n有时，当 `use strict` 会对代码产生一些影响时，你会得到错误的结果。\n\n那么，怎么在控制台中启用 `use strict` 呢？\n\n首先，你可以尝试搭配使用 `key:Shift+Enter` 按键去输入多行代码，然后将 `use strict` 放在代码最顶部，就像这样：\n\n```js\n'use strict'; <Shift+Enter 换行>\n//  ...你的代码\n<按下 Enter 以运行>\n```\n\n它在大部分浏览器中都有效，像 Firefox 和 Chrome。\n\n如果依然不行，例如你使用的是旧版本的浏览器，那么有一种很丑但可靠的启用 `use strict` 的方法。将你的代码放在这样的包装器中：\n\n```js\n(function() {\n  'use strict';\n\n  // ...你的代码...\n})()\n```\n\n## 我们应该使用 \"use strict\" 吗？\n\n这个问题的答案好像很显而易见，但事实并非如此。\n\n有人可能会建议在脚本的最顶部放置 `\"use strict\"` 这行代码…… 但你知道更酷的方式吗？\n\n现代 JavaScript 支持 \"class\" 和 \"module\" —— 高级语言结构（本教程后续章节会讲到），它们会自动启用 `use strict`。因此，如果我们使用它们，则无需添加 `\"use strict\"` 指令。\n\n**因此，目前我们欢迎将 `\"use strict\";` 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 `\"use strict\";` 这行代码省略掉。**\n\n目前，我们已经基本了解了 `use strict`。\n\n在接下来的章节中，当我们学习语言功能时，我们会看到严格模式与旧的模式之间的差异。幸运的是，差异其实没有那么多。并且，这些差异实际上提升了我们的编程体验。\n\n本教程的所有例子都默认采用严格模式，除非特别指定（非常少）。",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1650347065
      }
    },
    "variables": {
      "type": "Article",
      "value": {
        "title": "变量",
        "slug": "variables",
        "githubPath": "/1-js/02-first-steps/04-variables",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n大多数情况下，JavaScript 应用需要处理信息。这有两个例子：\n1. 一个网上商店 —— 这里的信息可能包含正在售卖的商品和购物车。\n2. 一个聊天应用 —— 这里的信息可能包括用户和消息等等。\n\n变量就是用来储存这些信息的。\n\n## 变量\n\n[变量](https://en.wikipedia.org/wiki/Variable_(computer_science)) 是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。\n\n在 JavaScript 中创建一个变量，我们需要用到 `let` 关键字。\n\n下面的语句创建（也可以称为 **声明** 或者 **定义**）了一个名称为 “message” 的变量：\n\n```js\nlet message;\n```\n\n现在，我们可以通过赋值运算符 `=` 为变量添加一些数据：\n\n```js\nlet message;\n\n*!*\nmessage = 'Hello'; // 将字符串 'Hello' 保存在名为 message 的变量中\n*/!*\n```\n\n现在这个字符串已经保存到与该变量相关联的内存区域了，我们可以通过使用该变量名称访问它：\n\n```js run\nlet message;\nmessage = 'Hello!';\n\n*!*\nalert(message); // 显示变量内容\n*/!*\n```\n\n简洁一点，我们可以将变量定义和赋值合并成一行：\n\n```js run\nlet message = 'Hello!'; // 定义变量，并且赋值\n\nalert(message); // Hello!\n```\n\n也可以在一行中声明多个变量：\n\n```js no-beautify\nlet user = 'John', age = 25, message = 'Hello';\n```\n\n看上去代码长度更短，但并不推荐这样。为了更好的可读性，请一行只声明一个变量。\n\n多行变量声明有点长，但更容易阅读：\n\n```js\nlet user = 'John';\nlet age = 25;\nlet message = 'Hello';\n```\n\n一些程序员采用下面的形式书写多个变量：\n\n```js no-beautify\nlet user = 'John',\n  age = 25,\n  message = 'Hello';\n```\n\n……甚至使用“逗号在前”的形式：\n\n```js no-beautify\nlet user = 'John'\n  , age = 25\n  , message = 'Hello';\n```\n\n技术上讲，这些变体都有一样的效果。所以，这是个个人品味和审美方面的问题。\n\n````smart header=\"`var` 而不是 `let`\"\n在较老的脚本中，你也可能发现另一个关键字 `var`，而不是 `let`：\n\n```js\n*!*var*/!* message = 'Hello';\n```\n\n`var` 关键字与 `let` **大体** 相同，也用来声明变量，但稍微有些不同，也有点“老派”。\n\n`let` 和 `var` 之间有些微妙的差别，但目前对于我们来说并不重要。我们将会在 <info:var> 章节中介绍它们。\n````\n\n## 一个现实生活的类比\n\n如果将变量想象成一个“数据”的盒子，盒子上有一个唯一的标注盒子名字的贴纸。这样我们能更轻松地掌握“变量”的概念。\n\n例如，变量 `message` 可以被想象成一个标有 `\"message\"` 的盒子，盒子里面的值为 `\"Hello!\"`：\n\n![](variable.svg)\n\n我们可以在盒子内放入任何值。\n\n并且，这个盒子的值，我们想改变多少次，就可以改变多少次：\n\n```js run\nlet message;\n\nmessage = 'Hello!';\n\nmessage = 'World!'; // 值改变了\n\nalert(message);\n```\n\n当值改变的时候，之前的数据就被从变量中删除了：\n\n![](variable-change.svg)\n\n我们还可以声明两个变量，然后将其中一个变量的数据拷贝到另一个变量。\n\n```js run\nlet hello = 'Hello world!';\n\nlet message;\n\n*!*\n// 将字符串 'Hello world' 从变量 hello 拷贝到 message\nmessage = hello;\n*/!*\n\n// 现在两个变量保存着相同的数据\nalert(hello); // Hello world!\nalert(message); // Hello world!\n```\n\n````warn header=\"声明两次会触发 error\"\n一个变量应该只被声明一次。\n\n对同一个变量进行重复声明会触发 error：\n\n```js run\nlet message = \"This\";\n\n// 重复 'let' 会导致 error\nlet message = \"That\"; // SyntaxError: 'message' has already been declared\n```\n因此，我们对同一个变量应该只声明一次，之后在不使用 `let` 的情况下对其进行引用。\n````\n\n```smart header=\"函数式语言\"\n有趣的是，也存在禁止更改变量值的 [函数式](https://en.wikipedia.org/wiki/Functional_programming) 编程语言。比如 [Scala](http://www.scala-lang.org/) 或 [Erlang](http://www.erlang.org/)。\n\n在这种类型的语言中，一旦值保存在盒子中，就永远存在。如果你试图保存其他值，它会强制创建一个新盒子（声明一个新变量），无法重用之前的变量。\n\n虽然第一次看上去有点奇怪，但是这些语言有很大的发展潜力。不仅如此，在某些领域，比如并行计算，这个限制有一定的好处。研究这样的一门语言（即使不打算很快就用上它）有助于开阔视野。\n```\n\n## 变量命名 [#variable-naming]\n\nJavaScript 的变量命名有两个限制：\n\n1. 变量名称必须仅包含字母、数字、符号 `$` 和 `_`。\n2. 首字符必须非数字。\n\n有效的命名，例如：\n\n```js\nlet userName;\nlet test123;\n```\n\n如果命名包括多个单词，通常采用驼峰式命名法（[camelCase](https://en.wikipedia.org/wiki/CamelCase)）。也就是，单词一个接一个，除了第一个单词，其他的每个单词都以大写字母开头：`myVeryLongName`。\n\n有趣的是，美元符号 `'$'` 和下划线 `'_'` 也可以用于变量命名。它们是正常的符号，就跟字母一样，没有任何特殊的含义。\n\n下面的命名是有效的：\n\n```js run untrusted\nlet $ = 1; // 使用 \"$\" 声明一个变量\nlet _ = 2; // 现在用 \"_\" 声明一个变量\n\nalert($ + _); // 3\n```\n\n下面的变量命名不正确：\n\n```js no-beautify\nlet 1a; // 不能以数字开始\n\nlet my-name; // 连字符 '-' 不允许用于变量命名\n```\n\n```smart header=\"区分大小写\"\n命名为 `apple` 和 `APPLE` 的变量是不同的两个变量。\n```\n\n````smart header=\"允许非英文字母，但不推荐\"\n可以使用任何语言，包括西里尔字母（cyrillic letters）甚至是象形文字，就像这样：\n\n```js\nlet имя = '...';\nlet 我 = '...';\n```\n\n从技术上讲，这样没问题。这样的命名是完全允许的，但是用英文进行变量命名是国际惯例。哪怕我们正在写一个很小的脚本，它也有可能会被使用很久。某个时候，来自其他国家的人可能会需要阅读它。\n````\n\n````warn header=\"保留字\"\n有一张 [保留字列表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords)，这张表中的保留字无法用作变量命名，因为它们被用于编程语言本身了。\n\n比如，`let`、`class`、`return`、`function` 都被保留了。\n\n下面的代码将会抛出一个语法错误：\n\n```js run no-beautify\nlet let = 5; // 不能用 \"let\" 来命名一个变量，错误！\nlet return = 5; // 同样，不能使用 \"return\"，错误！\n```\n````\n\n````warn header=\"未采用 `use strict` 下的赋值\"\n\n一般，我们需要在使用一个变量前定义它。但是在早期，我们可以不使用 `let` 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 `use strict` 声明启用严格模式，这仍然可以正常工作，这是为了保持对旧脚本的兼容。\n\n```js run no-strict\n// 注意：这个例子中没有 \"use strict\"\n\nnum = 5; // 如果变量 \"num\" 不存在，就会被创建\n\nalert(num); // 5\n```\n\n上面这是个糟糕的做法，严格模式下会报错。\n\n```js run untrusted\n\"use strict\";\n\n*!*\nnum = 5; // 错误：num 未定义\n*/!*\n```\n````\n\n## 常量\n\n声明一个常数（不变）变量，可以使用 `const` 而非 `let`：\n\n```js\nconst myBirthday = '18.04.1982';\n```\n\n使用 `const` 声明的变量称为“常量”。它们不能被修改，如果你尝试修改就会发现报错：\n\n```js run\nconst myBirthday = '18.04.1982';\n\nmyBirthday = '01.01.2001'; // 错误，不能对常量重新赋值\n```\n\n当程序员能确定这个变量永远不会改变的时候，就可以使用 `const` 来确保这种行为，并且清楚地向别人传递这一事实。\n\n### 大写形式的常数\n\n一个普遍的做法是将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。\n\n使用大写字母和下划线来命名这些常量。\n\n例如，让我们以所谓的“web”（十六进制）格式为颜色声明常量：\n\n```js run\nconst COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n\n// ……当我们需要选择一个颜色\nlet color = COLOR_ORANGE;\nalert(color); // #FF7F00\n```\n\n好处：\n\n- `COLOR_ORANGE` 比 `\"#FF7F00\"` 更容易记忆。\n- 比起 `COLOR_ORANGE` 而言，`\"#FF7F00\"` 更容易输错。\n- 阅读代码时，`COLOR_ORANGE` 比 `#FF7F00` 更易懂。\n\n什么时候该为常量使用大写命名，什么时候进行常规命名？让我们弄清楚一点。\n\n作为一个“常数”，意味着值永远不变。但是有些常量在执行之前就已知了（比如红色的十六进制值），还有些在执行期间被“计算”出来，但初始赋值之后就不会改变。\n\n例如：\n\n```js\nconst pageLoadTime = /* 网页加载所需的时间 */;\n```\n\n`pageLoadTime` 的值在页面加载之前是未知的，所以采用常规命名。但是它仍然是个常量，因为赋值之后不会改变。\n\n换句话说，大写命名的常量仅用作“硬编码（hard-coded）”值的别名。\n\n## 正确命名变量\n\n谈到变量，还有一件非常重要的事。\n\n一个变量名应该有一个清晰、明显的含义，对其存储的数据进行描述。\n\n变量命名是编程过程中最重要且最复杂的技能之一。快速地浏览变量的命名就知道代码是一个初学者还是有经验的开发者写的。\n\n在一个实际项目中，大多数的时间都被用来修改和扩展现有的代码库，而不是从头开始写一些完全独立的代码。当一段时间后，我们做完其他事情，重新回到我们的代码，找到命名良好的信息要容易得多。换句话说，变量要有个好名字。\n\n声明变量之前，多花点时间思考它的更好的命名。你会受益良多。\n\n一些可以遵循的规则：\n\n- 使用易读的命名，比如 `userName` 或者 `shoppingCart`。\n- 离诸如 `a`、`b`、`c` 这种缩写和短名称远一点，除非你真的知道你在干什么。\n- 变量名在能够准确描述变量的同时要足够简洁。不好的例子就是 `data` 和 `value`，这样的名称等于什么都没说。如果能够非常明显地从上下文知道数据和值所表达的含义，这样使用它们也是可以的。\n- 脑海中的术语要和团队保持一致。如果网站的访客称为“用户”，则我们采用相关的变量命名，比如 `currentUser` 或者 `newUser`，而不要使用 `currentVisitor` 或者一个 `newManInTown`。\n\n听上去很简单？确实如此，但是在实践中选择一个一目了然的变量名称并非如此简单。大胆试试吧。\n\n```smart header=\"重用还是新建？\"\n最后一点，有一些懒惰的程序员，倾向于重用现有的变量，而不是声明一个新的变量。\n\n结果是，这个变量就像是被扔进不同东西盒子，但没有改变它的贴纸。现在里面是什么？谁知道呢。我们需要靠近一点，仔细检查才能知道。\n\n这样的程序员节省了一点变量声明的时间，但却在调试代码的时候损失数十倍时间。\n\n额外声明一个变量绝对是利大于弊的。\n\n现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。\n```\n\n## 总结\n\n我们可以使用 `var`、`let` 或 `const` 声明变量来存储数据。\n\n- `let` — 现代的变量声明方式。\n- `var` — 老旧的变量声明方式。一般情况下，我们不会再使用它。但是，我们会在 <info:var> 章节介绍 `var` 和 `let` 的微妙差别，以防你需要它们。\n- `const` — 类似于 `let`，但是变量的值无法被修改。\n\n变量应当以一种容易理解变量内部是什么的方式进行命名。",
        "libs": [],
        "children": [
          "hello-variables",
          "declare-variables",
          "uppercast-constant"
        ],
        "parent": "first-steps",
        "updatedAt": 1657705346
      }
    },
    "hello-variables": {
      "type": "Task",
      "value": {
        "title": "使用变量",
        "slug": "hello-variables",
        "githubPath": "/1-js/02-first-steps/04-variables/1-hello-variables",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\n\n1. 声明两个变量：`admin` 和 `name`。\n2. 将值 `\"John\"` 赋给 `name`。\n3. 从 `name` 变量中拷贝其值给 `admin`。\n4. 使用 `alert` 显示 `admin` 的值（必须输出 \"John\"）。",
        "solution": "下面的代码，每一行都对应着任务列表中的对应项。\n\n```js run\nlet admin, name; // 一次声明两个变量。\n\nname = \"John\";\n\nadmin = name;\n\nalert( admin ); // \"John\"\n```",
        "parent": "variables",
        "version": 1
      }
    },
    "declare-variables": {
      "type": "Task",
      "value": {
        "title": "给出正确的名字",
        "slug": "declare-variables",
        "githubPath": "/1-js/02-first-steps/04-variables/2-declare-variables",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\n\n1. 使用我们的星球的名字创建一个变量。你会怎么命名这个变量？\n2. 创建一个变量来存储当前浏览者的名字。你会怎么命名这个变量？",
        "solution": "## 代表我们星球的变量\n\n这很简单：\n\n```js\nlet ourPlanetName = \"Earth\";\n```\n\n注意，我们也可以用一个更简短的名字 `planet`，但这样可能并不能表达清楚它指的是哪个星球。再啰嗦一点也挺好的。至少让这个变量别太长就行。\n\n## 网站当前访问者的名字\n\n```js\nlet currentUserName = \"John\";\n```\n\n同样，如果我们的确知道用户就是当前的用户的话，我们可以使用更短的变量名 `userName`。\n\n现代编辑器的自动补全可以让长变量名变得容易编写。不要浪费这个特性。一个名字中包含三个词挺好的。\n\n如果你的编辑器没有合适的自动补全功能，换 [一个新的吧](/code-editors)。",
        "parent": "variables",
        "version": 1
      }
    },
    "uppercast-constant": {
      "type": "Task",
      "value": {
        "title": "大写的常量？",
        "slug": "uppercast-constant",
        "githubPath": "/1-js/02-first-steps/04-variables/3-uppercast-constant",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\n\n检查下面的代码：\n\n```js\nconst birthday = '18.04.1982';\n\nconst age = someCode(birthday);\n```\n\n这里我们有一个 `birthday` 日期常量和通过一些代码（为了保持简短这里没有提供，因为这些细节在这无关紧要）从 `birthday` 计算出的 `age` 常量。\n\n对于 `birthday` 使用大写方式正确吗？那么 `age` 呢？或者两者都用？\n\n```js\nconst BIRTHDAY = '18.04.1982'; // 使用大写？\n\nconst AGE = someCode(BIRTHDAY); // 使用大写？\n```",
        "solution": "我们通常用大写字母表示“硬编码（hard-coded）”的常量。或者，换句话说就是，当值在执行之前或在被写入代码的时候，我们就知道值是什么了。\n\n在这个代码中 `birthday` 确实是这样的。因此我们可以使用大写。\n\n在对照组中，`age` 是在程序运行时计算出的。今天我们有一个年龄，一年以后我们就会有另一个。它在某种意义上不会随着代码的执行而改变。但与 `birthday` 相比，它还是有一定的可变性：它是计算出来的，因此我们应该使用小写。",
        "parent": "variables",
        "version": 1
      }
    },
    "types": {
      "type": "Article",
      "value": {
        "title": "数据类型",
        "slug": "types",
        "githubPath": "/1-js/02-first-steps/05-types",
        "isFolder": false,
        "weight": 5,
        "content": "\n\nJavaScript 中的值都具有特定的类型。例如，字符串或数字。\n\n在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）。在这里，我们将对它们进行大体的介绍，在下一章中，我们将详细讨论它们。\n\n我们可以将任何类型的值存入变量。例如，一个变量可以在前一刻是个字符串，下一刻就存储一个数字：\n\n```js\n// 没有错误\nlet message = \"hello\";\nmessage = 123456;\n```\n\n允许这种操作的编程语言，例如 JavaScript，被称为“动态类型”（dynamically typed）的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型。\n\n## Number 类型\n\n```js\nlet n = 123;\nn = 12.345;\n```\n\n*number* 类型代表整数和浮点数。\n\n数字可以有很多操作，比如，乘法 `*`、除法 `/`、加法 `+`、减法 `-` 等等。\n\n除了常规的数字，还包括所谓的“特殊数值（\"special numeric values\"）”也属于这种类型：`Infinity`、`-Infinity` 和 `NaN`。\n\n- `Infinity` 代表数学概念中的 [无穷大](https://en.wikipedia.org/wiki/Infinity) ∞。是一个比任何数字都大的特殊值。\n\n    我们可以通过除以 0 来得到它：\n\n    ```js run\n    alert( 1 / 0 ); // Infinity\n    ```\n\n    或者在代码中直接使用它：\n\n    ```js run\n    alert( Infinity ); // Infinity\n    ```\n- `NaN` 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果，比如：\n\n    ```js run\n    alert( \"not a number\" / 2 ); // NaN，这样的除法是错误的\n    ```\n\n    `NaN` 是粘性的。任何对 `NaN` 的进一步数学运算都会返回 `NaN`：\n\n    ```js run\n    alert( NaN + 1 ); // NaN\n    alert( 3 * NaN ); // NaN\n    alert( \"not a number\" / 2 - 1 ); // NaN\n    ```\n\n    所以，如果在数学表达式中有一个 `NaN`，会被传播到最终结果（只有一个例外：`NaN ** 0` 结果为 `1`）。\n\n```smart header=\"数学运算是安全的\"\n在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。\n\n脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 `NaN` 的结果。\n```\n\n特殊的数值属于 \"number\" 类型。当然，对“特殊的数值”这个词的一般认识是，它们并不是数字。\n\n我们将在 <info:number> 一节中学习数字的更多细节。\n\n## BigInt 类型 [#bigint-type]\n\n在 JavaScript 中，\"number\" 类型无法安全地表示大于 <code>(2<sup>53</sup>-1)</code>（即 `9007199254740991`），或小于 <code>-(2<sup>53</sup>-1)</code> 的整数。\n\n更准确的说，\"number\" 类型可以存储更大的整数（最多 <code>1.7976931348623157 * 10<sup>308</sup></code>），但超出安全整数范围 <code>±(2<sup>53</sup>-1)</code> 会出现精度问题，因为并非所有数字都适合固定的 64 位存储。因此，可能存储的是“近似值”。\n\n例如，这两个数字（正好超出了安全整数范围）是相同的：\n\n```js\nconsole.log(9007199254740991 + 1); // 9007199254740992\nconsole.log(9007199254740991 + 2); // 9007199254740992\n```\n\n也就是说，所有大于 <code>(2<sup>53</sup>-1)</code> 的奇数都不能用 \"number\" 类型存储。\n\n在大多数情况下，<code>±(2<sup>53</sup>-1)</code> 范围就足够了，但有时候我们需要整个范围非常大的整数，例如用于密码学或微秒精度的时间戳。\n\n`BigInt` 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。\n\n可以通过将 `n` 附加到整数字段的末尾来创建 `BigInt` 值。\n\n```js\n// 尾部的 \"n\" 表示这是一个 BigInt 类型\nconst bigInt = 1234567890123456789012345678901234567890n;\n```\n\n由于很少需要 `BigInt` 类型的数字，我们在这没有对其进行讲解，我们在单独的章节 <info:bigint> 中专门对其进行了介绍。当你需要使用那样的大数字的时候，可以去阅读该章节。\n\n\n```smart header=\"兼容性问题\"\n目前 Firefox/Chrome/Edge/Safari 已经支持 `BigInt` 了，但 IE 还没有。\n```\n\n你可以查看 [*MDN* BigInt 兼容性表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) 以了解哪些版本的浏览器已经支持 BigInt 了。\n\n## String 类型\n\nJavaScript 中的字符串必须被括在引号里。\n\n```js\nlet str = \"Hello\";\nlet str2 = 'Single quotes are ok too';\nlet phrase = `can embed another ${str}`;\n```\n\n在 JavaScript 中，有三种包含字符串的方式。\n\n1. 双引号：`\"Hello\"`.\n2. 单引号：`'Hello'`.\n3. 反引号：<code>&#96;Hello&#96;</code>.\n\n双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。\n\n反引号是 **功能扩展** 引号。它们允许我们通过将变量和表达式包装在 `${…}` 中，来将它们嵌入到字符串中。例如：\n\n```js run\nlet name = \"John\";\n\n// 嵌入一个变量\nalert( `Hello, *!*${name}*/!*!` ); // Hello, John!\n\n// 嵌入一个表达式\nalert( `the result is *!*${1 + 2}*/!*` ); // the result is 3\n```\n\n`${…}` 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 `${…}` 内放置任何东西：诸如名为 `name` 的变量，或者诸如 `1 + 2` 的算数表达式，或者其他一些更复杂的。\n\n需要注意的是，这仅仅在反引号内有效，其他引号不允许这种嵌入。\n```js run\nalert( \"the result is ${1 + 2}\" ); // the result is ${1 + 2}（使用双引号则不会计算 ${…} 中的内容）\n```\n\n我们会在 <info:string> 一节中学习字符串的更多细节。\n\n```smart header=\"JavaScript 中没有 *character* 类型。\"\n在一些语言中，单个字符有一个特殊的 \"character\" 类型，在 C 语言和 Java 语言中被称为 \"char\"。\n\n在 JavaScript 中没有这种类型。只有一种 `string` 类型，一个字符串可以包含零个（为空）、一个或多个字符。\n```\n\n## Boolean 类型（逻辑类型）\n\nboolean 类型仅包含两个值：`true` 和 `false`。\n\n这种类型通常用于存储表示 yes 或 no 的值：`true` 意味着 “yes，正确”，`false` 意味着 “no，不正确”。\n\n比如：\n\n```js\nlet nameFieldChecked = true; // yes, name field is checked\nlet ageFieldChecked = false; // no, age field is not checked\n```\n\n布尔值也可作为比较的结果：\n\n```js run\nlet isGreater = 4 > 1;\n\nalert( isGreater ); // true（比较的结果是 \"yes\"）\n```\n\n更详细的内容将会在 <info:logical-operators> 一节中介绍。\n\n## null 值\n\n特殊的 `null` 值不属于上述任何一种类型。\n\n它构成了一个独立的类型，只包含 `null` 值：\n\n```js\nlet age = null;\n```\n\n相比较于其他编程语言，JavaScript 中的 `null` 不是一个“对不存在的 `object` 的引用”或者 “null 指针”。\n\nJavaScript 中的 `null` 仅仅是一个代表“无”、“空”或“值未知”的特殊值。\n\n上面的代码表示 `age` 是未知的。\n\n## undefined 值\n\n特殊值 `undefined` 和 `null` 一样自成类型。\n\n`undefined` 的含义是 `未被赋值`。\n\n如果一个变量已被声明，但未被赋值，那么它的值就是 `undefined`：\n\n```js run\nlet age;\n\nalert(age); // 弹出 \"undefined\"\n```\n\n从技术上讲，可以显式地将 `undefined` 赋值给变量：\n\n```js run\nlet age = 100;\n\n// 将值修改为 undefined\nage = undefined;\n\nalert(age); // \"undefined\"\n```\n\n……但是不建议这样做。通常，使用 `null` 将一个“空”或者“未知”的值写入变量中，而 `undefined` 则保留作为未进行初始化的事物的默认初始值。\n\n## Object 类型和 Symbol 类型\n\n`object` 类型是一个特殊的类型。\n\n其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，`object` 则用于储存数据集合和更复杂的实体。\n\n因为它非常重要，所以我们对其进行单独讲解。在充分学习了原始类型后，我们将会在 <info:object> 一章中介绍 `object`。\n\n`symbol` 类型用于创建对象的唯一标识符。我们在这里提到 `symbol` 类型是为了完整性，但我们要在学完 `object` 类型后再学习它。\n\n## typeof 运算符 [#type-typeof]\n\n`typeof` 运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。\n\n对 `typeof x` 的调用会以字符串的形式返回数据类型：\n\n```js\ntypeof undefined // \"undefined\"\n\ntypeof 0 // \"number\"\n\ntypeof 10n // \"bigint\"\n\ntypeof true // \"boolean\"\n\ntypeof \"foo\" // \"string\"\n\ntypeof Symbol(\"id\") // \"symbol\"\n\n*!*\ntypeof Math // \"object\"  (1)\n*/!*\n\n*!*\ntypeof null // \"object\"  (2)\n*/!*\n\n*!*\ntypeof alert // \"function\"  (3)\n*/!*\n```\n\n最后三行可能需要额外的说明：\n\n1. `Math` 是一个提供数学运算的内建 `object`。我们会在 <info:number> 一节中学习它。此处仅作为一个 `object` 的示例。\n2. `typeof null` 的结果为 `\"object\"`。这是官方承认的 `typeof` 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。`null` 绝对不是一个 `object`。`null` 有自己的类型，它是一个特殊值。`typeof` 的行为在这里是错误的。\n3. `typeof alert` 的结果是 `\"function\"`，因为 `alert` 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 \"function\" 类型。函数隶属于 `object` 类型。但是 `typeof` 会对函数区分对待，并返回 `\"function\"`。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。\n\n```smart header=\"`typeof(x)` 语法\"\n你可能还会遇到另一种语法：`typeof(x)`。它与 `typeof x` 相同。\n\n简单点说：`typeof` 是一个操作符，不是一个函数。这里的括号不是 `typeof` 的一部分。它是数学运算分组的括号。\n\n通常，这样的括号里包含的是一个数学表达式，例如 `(2 + 2)`，但这里它只包含一个参数 `(x)`。从语法上讲，它们允许在 `typeof` 运算符和其参数之间不打空格，有些人喜欢这样的风格。\n\n有些人更喜欢用 `typeof(x)`，尽管 `typeof x` 语法更为常见。\n```\n\n## 总结\n\nJavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始数据类型，而 `object` 为复杂数据类型）。\n\n- 七种原始数据类型：\n    - `number` 用于任何类型的数字：整数或浮点数，在 <code>±(2<sup>53</sup>-1)</code> 范围内的整数。\n    - `bigint` 用于任意长度的整数。\n    - `string` 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。\n    - `boolean` 用于 `true` 和 `false`。\n    - `null` 用于未知的值 —— 只有一个 `null` 值的独立类型。\n    - `undefined` 用于未定义的值 —— 只有一个 `undefined` 值的独立类型。\n    - `symbol` 用于唯一的标识符。\n- 以及一种非原始数据类型：\n    - `object` 用于更复杂的数据结构。\n\n我们可以通过 `typeof` 运算符查看存储在变量中的数据类型。\n\n- 通常用作 `typeof x`，但 `typeof(x)` 也可行。\n- 以字符串的形式返回类型名称，例如 `\"string\"`。\n- `typeof null` 会返回 `\"object\"` —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 `object`。\n\n在接下来的章节中，我们将重点介绍原始类型值，当你掌握了原始数据类型后，我们将继续学习 `object`。",
        "libs": [],
        "children": [
          "string-quotes"
        ],
        "parent": "first-steps",
        "updatedAt": 1657807739
      }
    },
    "string-quotes": {
      "type": "Task",
      "value": {
        "title": "字符串的反引号",
        "slug": "string-quotes",
        "githubPath": "/1-js/02-first-steps/05-types/1-string-quotes",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面的脚本会输出什么？\n\n```js\nlet name = \"Ilya\";\n\nalert( `hello ${1}` ); // ?\n\nalert( `hello ${\"name\"}` ); // ?\n\nalert( `hello ${name}` ); // ?\n```",
        "solution": "反引号将包装在 `${...}` 中的表达式嵌入到了字符串。\n\n```js run\nlet name = \"Ilya\";\n\n// 表达式为数字 1\nalert( `hello ${1}` ); // hello 1\n\n// 表达式是一个字符串 \"name\"\nalert( `hello ${\"name\"}` ); // hello name\n\n// 表达式是一个变量，嵌入进去了。\nalert( `hello ${name}` ); // hello Ilya\n```",
        "parent": "types",
        "version": 1
      }
    },
    "alert-prompt-confirm": {
      "type": "Article",
      "value": {
        "title": "交互：alert、prompt 和 confirm",
        "slug": "alert-prompt-confirm",
        "githubPath": "/1-js/02-first-steps/06-alert-prompt-confirm",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n由于我们将使用浏览器作为我们的演示环境，让我们看几个与用户交互的函数：`alert`，`prompt` 和`confirm`。\n\n## alert\n\n这个我们前面已经看到过了。它会显示一条信息，并等待用户按下 \"OK\"。\n\n例如：\n\n```js run\nalert(\"Hello\");\n```\n\n弹出的这个带有信息的小窗口被称为 **模态窗**。\"modal\" 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。\n\n## prompt\n\n`prompt` 函数接收两个参数：\n\n```js no-beautify\nresult = prompt(title, [default]);\n```\n\n浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。\n\n`title`\n: 显示给用户的文本\n\n`default`\n: 可选的第二个参数，指定 input 框的初始值。\n\n```smart header=\"语法中的方括号 `[...]`\"\n上述语法中 `default` 周围的方括号表示该参数是可选的，不是必需的。\n```\n\n访问者可以在提示输入栏中输入一些内容，然后按“确定”键。然后我们在 `result` 中获取该文本。或者他们可以按取消键或按 `key:Esc` 键取消输入，然后我们得到 `null` 作为 `result`。\n\n`prompt` 将返回用户在 `input` 框内输入的文本，如果用户取消了输入，则返回 `null`。\n\n举个例子：\n\n```js run\nlet age = prompt('How old are you?', 100);\n\nalert(`You are ${age} years old!`); // You are 100 years old!\n```\n\n````warn header=\"IE 浏览器会提供默认值\"\n第二个参数是可选的。但是如果我们不提供的话，Internet Explorer 会把 `\"undefined\"` 插入到 prompt。\n\n我们可以在 Internet Explorer 中运行下面这行代码来看看效果：\n\n```js run\nlet test = prompt(\"Test\");\n```\n\n所以，为了 prompt 在 IE 中有好的效果，我们建议始终提供第二个参数：\n\n```js run\nlet test = prompt(\"Test\", ''); // <-- 用于 IE 浏览器\n```\n````\n\n## confirm\n\n语法：\n\n```js\nresult = confirm(question);\n```\n\n`confirm` 函数显示一个带有 `question` 以及确定和取消两个按钮的模态窗口。\n\n点击确定返回 `true`，点击取消返回 `false`。\n\n例如：\n\n```js run\nlet isBoss = confirm(\"Are you the boss?\");\n\nalert( isBoss ); // 如果“确定”按钮被按下，则显示 true\n```\n\n## 总结\n\n我们学习了与用户交互的 3 个浏览器的特定函数：\n\n`alert`\n: 显示信息。\n\n`prompt`\n: 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 `key:Esc` 键返回 `null`。\n\n`confirm`\n: 显示信息等待用户点击确定或取消。点击确定返回 `true`，点击取消或按下 `key:Esc` 键返回 `false`。\n\n这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。\n\n上述所有方法共有两个限制：\n\n1. 模态窗口的确切位置由浏览器决定。通常在页面中心。\n2. 窗口的确切外观也取决于浏览器。我们不能修改它。\n\n这就是简单的代价。还有其他一些方式可以显示更漂亮的窗口，并与用户进行更丰富的交互，但如果“花里胡哨”不是非常重要，那使用本节讲的这些方法也挺好。",
        "libs": [],
        "children": [
          "simple-page"
        ],
        "parent": "first-steps",
        "updatedAt": 1651569705
      }
    },
    "simple-page": {
      "type": "Task",
      "value": {
        "title": "创建一个简单的页面",
        "slug": "simple-page",
        "githubPath": "/1-js/02-first-steps/06-alert-prompt-confirm/1-simple-page",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\n\n创建一个要求用户输入 `name`，并通过浏览器窗口对键入的内容进行输出的 web 页面。\n\n[demo]",
        "solution": "JavaScript 代码：\n\n```js demo run\nlet name = prompt(\"What is your name?\", \"\");\nalert(name);\n```\n\n整个页面的代码：\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n\n  <script>\n    'use strict';\n\n    let name = prompt(\"What is your name?\", \"\");\n    alert(name);\n  </script>\n\n</body>\n</html>\n```",
        "parent": "alert-prompt-confirm",
        "version": 1
      }
    },
    "type-conversions": {
      "type": "Article",
      "value": {
        "title": "类型转换",
        "slug": "type-conversions",
        "githubPath": "/1-js/02-first-steps/07-type-conversions",
        "isFolder": false,
        "weight": 7,
        "content": "\n\n大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型。\n\n比如，`alert` 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字。\n\n在某些情况下，我们需要将值显式地转换为我们期望的类型。\n\n```smart header=\"对象还未纳入讨论中\"\n在本章中，我们不会讨论 object 类型。目前，我们将只学习原始类型。\n\n之后，在我们学习完 object 类型后，我们会在 <info:object-toprimitive> 一章中学习对象 — 原始值转换。\n```\n\n## 字符串转换\n\n当我们需要一个字符串形式的值时，就会进行字符串转换。\n\n比如，`alert(value)` 将 `value` 转换为字符串类型，然后显示这个值。\n\n我们也可以显式地调用 `String(value)` 来将 `value` 转换为字符串类型：\n\n```js run\nlet value = true;\nalert(typeof value); // boolean\n\n*!*\nvalue = String(value); // 现在，值是一个字符串形式的 \"true\"\nalert(typeof value); // string\n*/!*\n```\n\n字符串转换最明显。`false` 变成 `\"false\"`，`null` 变成 `\"null\"` 等。\n\n## 数字型转换\n\n在算术函数和表达式中，会自动进行 number 类型转换。\n\n比如，当把除法 `/` 用于非 number 类型：\n\n```js run\nalert( \"6\" / \"2\" ); // 3, string 类型的值被自动转换成 number 类型后进行计算\n```\n\n我们也可以使用 `Number(value)` 显式地将这个 `value` 转换为 number 类型。\n\n```js run\nlet str = \"123\";\nalert(typeof str); // string\n\nlet num = Number(str); // 变成 number 类型 123\n\nalert(typeof num); // number\n```\n\n当我们从 string 类型源（如文本表单）中读取一个值，但期望输入一个数字时，通常需要进行显式转换。\n\n如果该字符串不是一个有效的数字，转换的结果会是 `NaN`。例如：\n\n```js run\nlet age = Number(\"an arbitrary string instead of a number\");\n\nalert(age); // NaN，转换失败\n```\n\nnumber 类型转换规则：\n\n| 值 | 变成…… |\n| --- | --- |\n| `undefined` | `NaN` |\n| `null` | `0` |\n|<code>true&nbsp;和&nbsp;false</code> | `1` and `0` |\n| `string` | 去掉首尾空白字符（空格、换行符 `\\n`、制表符 `\\t` 等）后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 `0`。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 `NaN`。 |\n\n例子：\n\n```js run\nalert( Number(\"   123   \") ); // 123\nalert( Number(\"123z\") );      // NaN（从字符串“读取”数字，读到 \"z\" 时出现错误）\nalert( Number(true) );        // 1\nalert( Number(false) );       // 0\n```\n\n请注意 `null` 和 `undefined` 在这有点不同：`null` 变成数字 `0`，`undefined` 变成 `NaN`。\n\n大多数数学运算符都执行这种转换，我们将在下一节中进行介绍。\n\n## 布尔型转换\n\n布尔（boolean）类型转换是最简单的一个。\n\n它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 Boolean(value) 显式地进行转换。\n\n转换规则如下：\n\n- 直观上为“空”的值（如 `0`、空字符串、`null`、`undefined` 和 `NaN`）将变为 `false`。\n- 其他值变成 `true`。\n\n比如：\n\n```js run\nalert( Boolean(1) ); // true\nalert( Boolean(0) ); // false\n\nalert( Boolean(\"hello\") ); // true\nalert( Boolean(\"\") ); // false\n```\n\n````warn header=\"请注意：包含 0 的字符串 `\\\"0\\\"` 是 `true`\"\n一些编程语言（比如 PHP）视 `\"0\"` 为 `false`。但在 JavaScript 中，非空的字符串总是 `true`。\n\n```js run\nalert( Boolean(\"0\") ); // true\nalert( Boolean(\" \") ); // 空格，也是 true（任何非空字符串都是 true）\n```\n````\n\n## 总结\n\n有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。\n\n**字符串转换** —— 转换发生在输出内容的时候，也可以通过 `String(value)` 进行显式转换。原始类型值的 string 类型转换通常是很明显的。\n\n**数字型转换** —— 转换发生在进行算术操作时，也可以通过 `Number(value)` 进行显式转换。\n\n数字型转换遵循以下规则：\n\n| 值 |  变成…… |\n|-------|-------------|\n| `undefined` | `NaN` |\n| `null` | `0` |\n| <code>true&nbsp;/&nbsp;false</code> | `1 / 0` |\n| `string` | “按原样读取”字符串，两端的空白字符（空格、换行符 `\\n`、制表符 `\\t` 等）会被忽略。空字符串变成 `0`。转换出错则输出 `NaN`。 |\n\n**布尔型转换** —— 转换发生在进行逻辑操作时，也可以通过 `Boolean(value)` 进行显式转换。\n\n布尔型转换遵循以下规则：\n\n| 值 |  变成…… |\n|-------|-------------|\n| `0`, `null`, `undefined`, `NaN`, `\"\"` | `false` |\n| 其他值 | `true` |\n\n\n上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：\n\n- 对 `undefined` 进行数字型转换时，输出结果为 `NaN`，而非 `0`。\n- 对 `\"0\"` 和只有空格的字符串（比如：`\"   \"`）进行布尔型转换时，输出结果为 `true`。\n\n我们在本小节没有讲 object 类型的转换。在我们学习完更多关于 JavaScript 的基础知识后，我们会在专门介绍 object 的章节 <info:object-toprimitive> 中详细讲解 object 类型转换。",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1667404307
      }
    },
    "operators": {
      "type": "Article",
      "value": {
        "title": "基础运算符，数学运算",
        "slug": "operators",
        "githubPath": "/1-js/02-first-steps/08-operators",
        "isFolder": false,
        "weight": 8,
        "content": "\n\n我们从学校里了解到过很多运算符，比如说加号 `+`、乘号 `*`、减号 `-` 等。\n\n在本章中，我们将从简单的运算符开始，然后着重介绍 JavaScript 特有的方面，这些是在学校中学习的数学运算所没有涵盖的。\n\n## 术语：“一元运算符”，“二元运算符”，“运算元”\n\n在正式开始前，我们先简单浏览一下常用术语。\n\n- **运算元** —— 运算符应用的对象。比如说乘法运算 `5 * 2`，有两个运算元：左运算元 `5` 和右运算元 `2`。有时候人们也称其为“参数”而不是“运算元”。\n- 如果一个运算符对应的只有一个运算元，那么它是 **一元运算符**。比如说一元负号运算符（unary negation）`-`，它的作用是对数字进行正负转换：\n\n    ```js run\n    let x = 1;\n\n    *!*\n    x = -x;\n    */!*\n    alert( x ); // -1，一元负号运算符生效\n    ```\n- 如果一个运算符拥有两个运算元，那么它是 **二元运算符**。减号还存在二元运算符形式：\n\n    ```js run no-beautify\n    let x = 1, y = 3;\n    alert( y - x ); // 2，二元运算符减号做减运算\n    ```\n\n    严格地说，在上面的示例中，我们使用一个相同的符号表征了两个不同的运算符：负号运算符，即反转符号的一元运算符，减法运算符，是从另一个数减去一个数的二元运算符。\n\n## 数学运算\n\n支持以下数学运算：\n\n- 加法 `+`,\n- 减法 `-`,\n- 乘法 `*`,\n- 除法 `/`,\n- 取余 `%`,\n- 求幂 `**`.\n\n前四个都很简单，而 `%` 和 `**` 则需要说一说。\n\n### 取余 %\n\n取余运算符是 `%`，尽管它看起来很像百分数，但实际并无关联。\n\n`a % b` 的结果是 `a` 整除 `b` 的 [余数](https://zh.wikipedia.org/zh-hans/%E4%BD%99%E6%95%B0)。\n\n例如：\n\n```js run\nalert( 5 % 2 ); // 1，5 除以 2 的余数\nalert( 8 % 3 ); // 2，8 除以 3 的余数\n```\n\n### 求幂 **\n\n求幂运算 `a ** b` 将 `a` 提升至 `a` 的 `b` 次幂。\n\n在数学运算中我们将其表示为 a<sup>b</sup>。\n\n例如：\n\n```js run\nalert( 2 ** 2 ); // 2² = 4\nalert( 2 ** 3 ); // 2³ = 8\nalert( 2 ** 4 ); // 2⁴ = 16\n```\n\n就像在数学运算中一样，幂运算也适用于非整数。\n\n例如，平方根是指数为 ½ 的幂运算：\n\n```js run\nalert( 4 ** (1/2) ); // 2（1/2 次方与平方根相同)\nalert( 8 ** (1/3) ); // 2（1/3 次方与立方根相同)\n```\n\n\n## 用二元运算符 + 连接字符串\n\n我们来看一些学校算术未涉及的 JavaScript 运算符的特性。\n\n通常，加号 `+` 用于求和。\n\n但是如果加号 `+` 被应用于字符串，它将合并（连接）各个字符串：\n\n```js\nlet s = \"my\" + \"string\";\nalert(s); // mystring\n```\n\n注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。\n\n举个例子：\n\n```js run\nalert( '1' + 2 ); // \"12\"\nalert( 2 + '1' ); // \"21\"\n```\n\n你看，第一个运算元和第二个运算元，哪个是字符串并不重要。\n\n下面是一个更复杂的例子：\n\n```js run\nalert(2 + 2 + '1' ); // \"41\"，不是 \"221\"\n```\n\n在这里，运算符是按顺序工作。第一个 `+` 将两个数字相加，所以返回 `4`，然后下一个 `+` 将字符串 `1` 加入其中，所以就是 `4 + '1' = '41'`。\n\n```js run\nalert('1' + 2 + 2); // \"122\"，不是 \"14\"\n```\n这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。`2` 被与 `'1'` 连接到了一起，也就是像 `'1' + 2 = \"12\"` 然后 `\"12\" + 2 = \"122\"` 这样。\n\n二元 `+` 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。\n\n下面是减法和除法运算的示例：\n\n```js run\nalert( 6 - '2' ); // 4，将 '2' 转换为数字\nalert( '6' / '2' ); // 3，将两个运算元都转换为数字\n```\n\n## 数字转化，一元运算符 +\n\n加号 `+` 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。\n\n一元运算符加号，或者说，加号 `+` 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 `+` 则会将其转化为数字。\n\n例如：\n\n```js run\n// 对数字无效\nlet x = 1;\nalert( +x ); // 1\n\nlet y = -2;\nalert( +y ); // -2\n\n*!*\n// 转化非数字\nalert( +true ); // 1\nalert( +\"\" );   // 0\n*/!*\n```\n\n它的效果和 `Number(...)` 相同，但是更加简短。\n\n我们经常会有将字符串转化为数字的需求。比如，如果我们正在从 HTML 表单中取值，通常得到的都是字符串。如果我们想对它们求和，该怎么办？\n\n二元运算符加号会把它们合并成字符串：\n\n```js run\nlet apples = \"2\";\nlet oranges = \"3\";\n\nalert( apples + oranges ); // \"23\"，二元运算符加号合并字符串\n```\n\n如果我们想把它们当做数字对待，我们需要转化它们，然后再求和：\n\n```js run\nlet apples = \"2\";\nlet oranges = \"3\";\n\n*!*\n// 在二元运算符加号起作用之前，所有的值都被转化为了数字\nalert( +apples + +oranges ); // 5\n*/!*\n\n// 更长的写法\n// alert( Number(apples) + Number(oranges) ); // 5\n```\n\n从一个数学家的视角来看，大量的加号可能很奇怪。但是从一个程序员的视角，没什么好奇怪的：一元运算符加号首先起作用，它们将字符串转为数字，然后二元运算符加号对它们进行求和。\n\n为什么一元运算符先于二元运算符作用于运算元？接下去我们将讨论到，这是由于它们拥有 **更高的优先级**。\n\n## 运算符优先级\n\n如果一个表达式拥有超过一个运算符，执行的顺序则由 **优先级** 决定。换句话说，所有的运算符中都隐含着优先级顺序。\n\n从小学开始，我们就知道在表达式 `1 + 2 * 2` 中，乘法先于加法计算。这就是一个优先级问题。乘法比加法拥有 **更高的优先级**。\n\n圆括号拥有最高优先级，所以如果我们对现有的运算顺序不满意，我们可以使用圆括号来修改运算顺序，就像这样：`(1 + 2) * 2`。\n\n在 JavaScript 中有众多运算符。每个运算符都有对应的优先级数字。数字越大，越先执行。如果优先级相同，则按照由左至右的顺序执行。\n\n这是一个摘抄自 Mozilla 的 [优先级表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)（你没有必要把这全记住，但要记住一元运算符优先级高于二元运算符）：\n\n| 优先级 | 名称 | 符号 |\n|------------|------|------|\n| ... | ... | ... |\n| 15 | 一元加号 | `+` |\n| 15 | 一元负号 | `-` |\n| 14 | 求幂 | `**` |\n| 13 | 乘号 | `*` |\n| 13 | 除号 | `/` |\n| 12 | 加号 | `+` |\n| 12 | 减号 | `-` |\n| ... | ... | ... |\n| 2 | 赋值符 | `=` |\n| ... | ... | ... |\n\n我们可以看到，“一元加号运算符”的优先级是 `15`，高于“二元加号运算符”的优先级 `12`。这也是为什么表达式 `\"+apples + +oranges\"` 中的一元加号先生效，然后才是二元加法。\n\n## 赋值运算符\n\n我们知道赋值符号 `=` 也是一个运算符。从优先级表中可以看到它的优先级非常低，只有 `2`。\n\n这也是为什么，当我们赋值时，比如 `x = 2 * 2 + 1`，所有的计算先执行，然后 `=` 才执行，将计算结果存储到 `x`。\n\n```js\nlet x = 2 * 2 + 1;\n\nalert( x ); // 5\n```\n\n### 赋值 = 返回一个值\n\n`=` 是一个运算符，而不是一个有着“魔法”作用的语言结构。\n\n在 JavaScript 中，所有运算符都会返回一个值。这对于 `+` 和 `-` 来说是显而易见的，但对于 `=` 来说也是如此。\n\n语句 `x = value` 将值 `value` 写入 `x` **然后返回 value**。\n\n下面是一个在复杂语句中使用赋值的例子：\n\n```js run\nlet a = 1;\nlet b = 2;\n\n*!*\nlet c = 3 - (a = b + 1);\n*/!*\n\nalert( a ); // 3\nalert( c ); // 0\n```\n\n上面这个例子，`(a = b + 1)` 的结果是赋给 `a` 的值（也就是 `3`）。然后该值被用于进一步的运算。\n\n有趣的代码，不是吗？我们应该了解它的工作原理，因为有时我们会在 JavaScript 库中看到它。\n\n不过，请不要写这样的代码。这样的技巧绝对不会使代码变得更清晰或可读。\n\n### 链式赋值（Chaining assignments）\n\n另一个有趣的特性是链式赋值：\n\n```js run\nlet a, b, c;\n\n*!*\na = b = c = 2 + 2;\n*/!*\n\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n```\n\n链式赋值从右到左进行计算。首先，对最右边的表达式 `2 + 2` 求值，然后将其赋给左边的变量：`c`、`b` 和 `a`。最后，所有的变量共享一个值。\n\n同样，出于可读性，最好将这种代码分成几行：\n\n```js\nc = 2 + 2;\nb = c;\na = c;\n```\n这样可读性更强，尤其是在快速浏览代码的时候。\n\n## 原地修改\n\n我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中。\n\n例如：\n\n```js\nlet n = 2;\nn = n + 5;\nn = n * 2;\n```\n\n可以使用运算符 `+=` 和 `*=` 来缩写这种表示。\n\n```js run\nlet n = 2;\nn += 5; // 现在 n = 7（等同于 n = n + 5）\nn *= 2; // 现在 n = 14（等同于 n = n * 2）\n\nalert( n ); // 14\n```\n\n所有算术和位运算符都有简短的“修改并赋值”运算符：`/=` 和 `-=` 等。\n\n这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：\n\n```js run\nlet n = 2;\n\nn *= 3 + 5;\n\nalert( n ); // 16 （右边部分先被计算，等同于 n *= 8）\n```\n\n## 自增/自减\n\n<!-- 在标题中无法写出 --，因为内建的解析器会将其转换为“长破折号” —— -->\n\n对一个数进行加一、减一是最常见的数学运算符之一。\n\n所以，对此有一些专门的运算符：\n\n- **自增** `++` 将变量与 1 相加：\n\n    ```js run no-beautify\n    let counter = 2;\n    counter++;      // 和 counter = counter + 1 效果一样，但是更简洁\n    alert( counter ); // 3\n    ```\n- **自减** `--` 将变量与 1 相减：\n\n    ```js run no-beautify\n    let counter = 2;\n    counter--;      // 和 counter = counter - 1 效果一样，但是更简洁\n    alert( counter ); // 1\n    ```\n\n```warn\n自增/自减只能应用于变量。试一下，将其应用于数值（比如 `5++`）则会报错。\n```\n\n运算符 `++` 和 `--` 可以置于变量前，也可以置于变量后。\n\n- 当运算符置于变量后，被称为“后置形式”：`counter++`。\n- 当运算符置于变量前，被称为“前置形式”：`++counter`。\n\n两者都做同一件事：将变量 `counter` 与 `1` 相加。\n\n那么它们有区别吗？有，但只有当我们使用 `++/--` 的返回值时才能看到区别。\n\n详细点说。我们知道，所有的运算符都有返回值。自增/自减也不例外。前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）。\n\n为了直观看到区别，看下面的例子：\n\n```js run\nlet counter = 1;\nlet a = ++counter; // (*)\n\nalert(a); // *!*2*/!*\n```\n\n`(*)` 所在的行是前置形式 `++counter`，对 `counter` 做自增运算，返回的是新的值 `2`。因此 `alert` 显示的是 `2`。\n\n下面让我们看看后置形式：\n\n```js run\nlet counter = 1;\nlet a = counter++; // (*) 将 ++counter 改为 counter++\n\nalert(a); // *!*1*/!*\n```\n\n`(*)` 所在的行是后置形式 `counter++`，它同样对 `counter` 做加法，但是返回的是 **旧值**（做加法之前的值）。因此 `alert` 显示的是 `1`。\n\n总结：\n\n- 如果自增/自减的值不会被使用，那么两者形式没有区别：\n\n    ```js run\n    let counter = 0;\n    counter++;\n    ++counter;\n    alert( counter ); // 2，以上两行作用相同\n    ```\n- 如果我们想要对变量进行自增操作，**并且** 需要立刻使用自增后的值，那么我们需要使用前置形式：\n\n    ```js run\n    let counter = 0;\n    alert( ++counter ); // 1\n    ```\n- 如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式：\n\n    ```js run\n    let counter = 0;\n    alert( counter++ ); // 0\n    ```\n\n````smart header=\"自增/自减和其它运算符的对比\"\n`++/--` 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。\n\n举个例子：\n\n```js run\nlet counter = 1;\nalert( 2 * ++counter ); // 4\n```\n\n与下方例子对比：\n\n```js run\nlet counter = 1;\nalert( 2 * counter++ ); // 2，因为 counter++ 返回的是“旧值”\n```\n\n尽管从技术层面上来说可行，但是这样的写法会降低代码的可阅读性。在一行上做多个操作 —— 这样并不好。\n\n当阅读代码时，快速的视觉“纵向”扫描会很容易漏掉 `counter++`，这样的自增操作并不明显。\n\n我们建议用“一行一个行为”的模式：\n\n```js run\nlet counter = 1;\nalert( 2 * counter );\ncounter++;\n```\n````\n\n## 位运算符\n\n位运算符把运算元当做 32 位整数，并在它们的二进制表现形式上操作。\n\n这些运算符不是 JavaScript 特有的。大部分的编程语言都支持这些运算符。\n\n下面是位运算符：\n\n- 按位与 ( `&` )\n- 按位或 ( `|` )\n- 按位异或 ( `^` )\n- 按位非 ( `~` )\n- 左移 ( `<<` )\n- 右移 ( `>>` )\n- 无符号右移 ( `>>>` )\n\n这些运算符很少被使用，一般是我们需要在最低级别（位）上操作数字时才使用。我们不会很快用到这些运算符，因为在 Web 开发中很少使用它们，但在某些特殊领域中，例如密码学，它们很有用。当你需要了解它们的时候，可以阅读 MDN 上的 [位操作符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators) 章节。\n\n## 逗号运算符\n\n逗号运算符 `,` 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。\n\n逗号运算符能让我们处理多个语句，使用 `,` 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。\n\n举个例子：\n\n```js run\n*!*\nlet a = (1 + 2, 3 + 4);\n*/!*\n\nalert( a ); // 7（3 + 4 的结果）\n```\n\n这里，第一个语句 `1 + 2` 运行了，但是它的结果被丢弃了。随后计算 `3 + 4`，并且该计算结果被返回。\n\n```smart header=\"逗号运算符的优先级非常低\"\n请注意逗号运算符的优先级非常低，比 `=` 还要低，因此上面你的例子中圆括号非常重要。\n\n如果没有圆括号：`a = 1 + 2, 3 + 4` 会先执行 `+`，将数值相加得到 `a = 3, 7`，然后赋值运算符 `=` 执行 `a = 3`，然后逗号之后的数值 `7` 不会再执行，它被忽略掉了。相当于 `(a = 1 + 2), 3 + 4`。\n```\n\n为什么我们需要这样一个运算符，它只返回最后一个值呢？\n\n有时候，人们会使用它把几个行为放在一行上来进行复杂的运算。\n\n举个例子：\n\n```js\n// 一行上有三个运算符\nfor (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {\n ...\n}\n```\n\n这样的技巧在许多 JavaScript 框架中都有使用，这也是为什么我们提到它。但是通常它并不能提升代码的可读性，使用它之前，我们要想清楚。",
        "libs": [],
        "children": [
          "increment-order",
          "assignment-result",
          "primitive-conversions-questions",
          "fix-prompt"
        ],
        "parent": "first-steps",
        "updatedAt": 1668130455
      }
    },
    "increment-order": {
      "type": "Task",
      "value": {
        "title": "后置运算符和前置运算符",
        "slug": "increment-order",
        "githubPath": "/1-js/02-first-steps/08-operators/1-increment-order",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n以下代码中变量 `a`、`b`、`c`、`d` 的最终值分别是多少？\n\n```js\nlet a = 1, b = 1;\n\nlet c = ++a; // ?\nlet d = b++; // ?\n```",
        "solution": "答案如下：\n\n- `a = 2`\n- `b = 2`\n- `c = 2`\n- `d = 1`\n\n```js run no-beautify\nlet a = 1, b = 1;\n\nalert( ++a ); // 2，前置运算符返回最新值\nalert( b++ ); // 1，后置运算符返回旧值\n\nalert( a ); // 2，自增一次\nalert( b ); // 2，自增一次\n```",
        "parent": "operators",
        "version": 1
      }
    },
    "assignment-result": {
      "type": "Task",
      "value": {
        "title": "赋值结果",
        "slug": "assignment-result",
        "githubPath": "/1-js/02-first-steps/08-operators/2-assignment-result",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\n\n下面这段代码运行完成后，代码中的 `a` 和 `x` 的值是多少？\n\n```js\nlet a = 2;\n\nlet x = 1 + (a *= 2);\n```",
        "solution": "答案如下：\n\n- `a = 4`（乘以 2）\n- `x = 5`（相当于计算 1 + 4）",
        "parent": "operators",
        "version": 1
      }
    },
    "primitive-conversions-questions": {
      "type": "Task",
      "value": {
        "title": "类型转换",
        "slug": "primitive-conversions-questions",
        "githubPath": "/1-js/02-first-steps/08-operators/3-primitive-conversions-questions",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面这些表达式的结果是什么？\n\n```js no-beautify\n\"\" + 1 + 0\n\"\" - 1 + 0\ntrue + false\n6 / \"3\"\n\"2\" * \"3\"\n4 + 5 + \"px\"\n\"$\" + 4 + 5\n\"4\" - 2\n\"4px\" - 2\n\"  -9  \" + 5\n\"  -9  \" - 5\nnull + 1\nundefined + 1\n\" \\t \\n\" - 2\n```\n\n好好思考一下，把它们写下来然后和答案比较一下。",
        "solution": "```js no-beautify\n\"\" + 1 + 0 = \"10\" // (1)\n\"\" - 1 + 0 = -1 // (2)\ntrue + false = 1\n6 / \"3\" = 2\n\"2\" * \"3\" = 6\n4 + 5 + \"px\" = \"9px\"\n\"$\" + 4 + 5 = \"$45\"\n\"4\" - 2 = 2\n\"4px\" - 2 = NaN\n\"  -9  \" + 5 = \"  -9  5\" // (3)\n\"  -9  \" - 5 = -14 // (4)\nnull + 1 = 1 // (5)\nundefined + 1 = NaN // (6)\n\" \\t \\n\" - 2 = -2 // (7)\n```\n\n1. 有字符串的加法 `\"\" + 1`，首先会将数字 `1` 转换为一个字符串：`\"\" + 1 = \"1\"`，然后我们得到 `\"1\" + 0`，再次应用同样的规则得到最终的结果。\n2. 减法 `-`（像大多数数学运算一样）只能用于数字，它会使空字符串 `\"\"` 转换为 `0`。\n3. 带字符串的加法会将数字 `5` 加到字符串之后。\n4. 减法始终将字符串转换为数字，因此它会使 `\" -9  \"` 转换为数字 `-9`（忽略了字符串首尾的空格）。\n5. `null` 经过数字转换之后会变为 `0`。\n6. `undefined` 经过数字转换之后会变为 `NaN`。\n7. 字符串转换为数字时，会忽略字符串的首尾处的空格字符。在这里，整个字符串由空格字符组成，包括 `\\t`、`\\n` 以及它们之间的“常规”空格。因此，类似于空字符串，所以会变为 `0`。",
        "parent": "operators",
        "version": 1
      }
    },
    "fix-prompt": {
      "type": "Task",
      "value": {
        "title": "修正加法",
        "slug": "fix-prompt",
        "githubPath": "/1-js/02-first-steps/08-operators/4-fix-prompt",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n这里有一段代码，要求用户输入两个数字并显示它们的总和。\n\n它的运行结果不正确。下面例子中的输出是 `12`（对于默认的 prompt 的值）。\n\n为什么会这样？修正它。结果应该是 `3`。\n\n```js run\nlet a = prompt(\"First number?\", 1);\nlet b = prompt(\"Second number?\", 2);\n\nalert(a + b); // 12\n```",
        "solution": "原因是 prompt 以字符串的形式返回用户的输入。\n\n所以变量的值分别为 `\"1\"` 和 `\"2\"`。\n\n```js run\nlet a = \"1\"; // prompt(\"First number?\", 1);\nlet b = \"2\"; // prompt(\"Second number?\", 2);\n\nalert(a + b); // 12\n```\n\n我们应该做的是，在 `+` 之前将字符串转换为数字。例如，使用 `Number()` 或在 `prompt` 前加 `+`。\n\n例如，就在 `prompt` 之前加 `+`：\n\n```js run\nlet a = +prompt(\"First number?\", 1);\nlet b = +prompt(\"Second number?\", 2);\n\nalert(a + b); // 3\n```\n\n或在 `alert` 中：\n\n```js run\nlet a = prompt(\"First number?\", 1);\nlet b = prompt(\"Second number?\", 2);\n\nalert(+a + +b); // 3\n```\n\n在最新的代码中，同时使用一元和二元的 `+`。看起来很有趣，不是吗？",
        "parent": "operators",
        "version": 1
      }
    },
    "comparison": {
      "type": "Article",
      "value": {
        "title": "值的比较",
        "slug": "comparison",
        "githubPath": "/1-js/02-first-steps/09-comparison",
        "isFolder": false,
        "weight": 9,
        "content": "\n\n我们知道，在数学中有很多用于比较大小的运算符。\n\n在 JavaScript 中，它们的编写方式如下：\n\n- 大于 / 小于：<code>a &gt; b</code>，<code>a &lt; b</code>。\n- 大于等于 / 小于等于：<code>a &gt;= b</code>，<code>a &lt;= b</code>。\n- 检查两个值的相等：`a == b`，请注意双等号 `==` 表示相等性检查，而单等号 `a = b` 表示赋值。\n- 检查两个值不相等：不相等在数学中的符号是 <code>&ne;</code>，但在 JavaScript 中写成 <code>a != b</code>。\n\n在本文中，我们将进一步了解不同类型的比较，JavaScript 是如何进行比较的，包括一些重要的特殊性。\n\n在文末给出了一些秘诀，帮助你避免 “JavaScript 陷阱”相关的问题。\n\n## 比较结果为 Boolean 类型\n\n所有比较运算符均返回布尔值：\n\n- `true` —— 表示“yes（是）”，“correct（正确）”或“the truth（真）”。\n- `false` ——  表示“no（否）”，“wrong（错误）”或“not the truth（非真）”。\n\n示例：\n\n```js run\nalert( 2 > 1 );  // true（正确）\nalert( 2 == 1 ); // false（错误）\nalert( 2 != 1 ); // true（正确）\n```\n\n和其他类型的值一样，比较的结果可以被赋值给任意变量：\n\n```js run\nlet result = 5 > 4; // 把比较的结果赋值给 result\nalert( result ); // true\n```\n\n## 字符串比较\n\n在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定。\n\n换言之，字符串是按字符（母）逐个进行比较的。\n\n例如：\n\n```js run\nalert( 'Z' > 'A' ); // true\nalert( 'Glow' > 'Glee' ); // true\nalert( 'Bee' > 'Be' ); // true\n```\n\n字符串的比较算法非常简单：\n\n1. 首先比较两个字符串的首位字符大小。\n2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。\n3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。\n4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。\n5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。\n\n在上面的第一个例子中，`'Z' > 'A'` 比较在算法的第 1 步就得到了结果。\n\n在第二个例子中，字符串 `Glow` 与 `Glee` 的比较则需要更多步骤，因为需要逐个字符进行比较：\n\n1. `G` 和 `G` 相等。\n2. `l` 和 `l` 相等。\n3. `o` 比 `e` 大，算法停止，第一个字符串大于第二个。\n\n```smart header=\"非真正的字典顺序，而是 Unicode 编码顺序\"\n在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。\n\n比如说，字符串比较对字母大小写是敏感的。大写的 `\"A\"` 并不等于小写的 `\"a\"`。哪一个更大呢？实际上小写的 `\"a\"` 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。我们会在 <info:string> 这章讨论更多关于字符串的细节。\n```\n\n## 不同类型间的比较\n\n当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。\n\n例如：\n\n```js run\nalert( '2' > 1 ); // true，字符串 '2' 会被转化为数字 2\nalert( '01' == 1 ); // true，字符串 '01' 会被转化为数字 1\n```\n\n对于布尔类型值，`true` 会被转化为 `1`、`false` 转化为 `0`。\n\n例如：\n\n```js run\nalert( true == 1 ); // true\nalert( false == 0 ); // true\n```\n\n````smart header=\"一个有趣的现象\"\n有时候，以下两种情况会同时发生：\n\n- 若直接比较两个值，其结果是相等的。\n- 若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 `true`，一个是 `false`。\n\n例如：\n\n```js run\nlet a = 0;\nalert( Boolean(a) ); // false\n\nlet b = \"0\";\nalert( Boolean(b) ); // true\n\nalert(a == b); // true!\n```\n\n对于 JavaScript 而言，这种现象其实挺正常的。因为 JavaScript 会把待比较的值转化为数字后再做比较（因此 `\"0\"` 变成了 `0`）。若只是将一个变量转化为 `Boolean` 值，则会使用其他的类型转换规则。\n````\n\n## 严格相等\n\n普通的相等性检查 `==` 存在一个问题，它不能区分出 `0` 和 `false`：\n\n```js run\nalert( 0 == false ); // true\n```\n\n也同样无法区分空字符串和 `false`：\n\n```js run\nalert( '' == false ); // true\n```\n\n这是因为在比较不同类型的值时，处于相等判断符号 `==` 两侧的值会先被转化为数字。空字符串和 `false` 也是如此，转化后它们都为数字 0。\n\n如果我们需要区分 `0` 和 `false`，该怎么办？\n\n**严格相等运算符 `===` 在进行比较时不会做任何的类型转换。**\n\n换句话说，如果 `a` 和 `b` 属于不同的数据类型，那么 `a === b` 不会做任何的类型转换而立刻返回 `false`。\n\n让我们试试：\n\n```js run\nalert( 0 === false ); // false，因为被比较值的数据类型不同\n```\n\n同样的，与“不相等”符号 `!=` 类似，“严格不相等”表示为 `!==`。\n\n严格相等的运算符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性。\n\n## 对 null 和 undefined 进行比较\n\n当使用 `null` 或 `undefined` 与其他值进行比较时，其返回结果常常出乎你的意料。\n\n当使用严格相等 `===` 比较二者时 \n: 它们不相等，因为它们属于不同的类型。\n\n    ```js run\n    alert( null === undefined ); // false\n    ```\n\n当使用非严格相等 `==` 比较二者时\n: JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。\n\n    ```js run\n    alert( null == undefined ); // true\n    ```\n\n当使用数学式或其他比较方法 `< > <= >=` 时：\n: `null/undefined` 会被转化为数字：`null` 被转化为 `0`，`undefined` 被转化为 `NaN`。\n\n下面让我们看看，这些规则会带来什么有趣的现象。同时更重要的是，我们需要从中学会如何远离这些特性带来的“陷阱”。\n\n### 奇怪的结果：null vs 0\n\n通过比较 `null` 和 0 可得：\n\n```js run\nalert( null > 0 );  // (1) false\nalert( null == 0 ); // (2) false\nalert( null >= 0 ); // (3) *!*true*/!*\n```\n\n是的，上面的结果完全打破了你对数学的认识。在最后一行代码显示“`null` 大于等于 0”的情况下，前两行代码中一定会有一个是正确的，然而事实表明它们的结果都是 false。\n\n为什么会出现这种反常结果，这是因为相等性检查 `==` 和普通比较符 `> < >= <=` 的代码逻辑是相互独立的。进行值的比较时，`null` 会被转化为数字，因此它被转化为了 `0`。这就是为什么（3）中 `null >= 0` 返回值是 true，（1）中 `null > 0` 返回值是 false。\n\n另一方面，`undefined` 和 `null` 在相等性检查 `==` 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 `null == 0` 会返回 false。\n\n### 特立独行的 undefined\n\n`undefined` 不应该被与其他值进行比较：\n\n```js run\nalert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)\n```\n\n为何它看起来如此厌恶 0？返回值都是 false！\n\n原因如下：\n\n- `(1)` 和 `(2)` 都返回 `false` 是因为 `undefined` 在比较中被转换为了 `NaN`，而 `NaN` 是一个特殊的数值型值，它与任何值进行比较都会返回 `false`。\n- `(3)` 返回 `false` 是因为这是一个相等性检查，而 `undefined` 只与 `null` 相等，不会与其他值相等。\n\n### 避免问题\n\n我们为何要研究上述示例？我们需要时刻记得这些古怪的规则吗？不，其实不需要。虽然随着代码写得越来越多，我们对这些规则也都会烂熟于胸，但是我们需要更为可靠的方法来避免潜在的问题：\n\n- 除了严格相等 `===` 外，其他但凡是有 `undefined/null` 参与的比较，我们都需要格外小心。\n- 除非你非常清楚自己在做什么，否则永远不要使用 `>= > < <=` 去比较一个可能为 `null/undefined` 的变量。对于取值可能是 `null/undefined` 的变量，请按需要分别检查它的取值情况。\n\n## 总结\n\n- 比较运算符始终返回布尔值。\n- 字符串的比较，会按照“词典”顺序逐字符地比较大小。\n- 当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。\n- 在非严格相等 `==` 下，`null` 和 `undefined` 相等且各自不等于任何其他的值。\n- 在使用 `>` 或 `<` 进行比较时，需要注意变量可能为 `null/undefined` 的情况。比较好的方法是单独检查变量是否等于 `null/undefined`。",
        "libs": [],
        "children": [
          "comparison-questions"
        ],
        "parent": "first-steps",
        "updatedAt": 1634661693
      }
    },
    "comparison-questions": {
      "type": "Task",
      "value": {
        "title": "值的比较",
        "slug": "comparison-questions",
        "githubPath": "/1-js/02-first-steps/09-comparison/1-comparison-questions",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n以下表达式的执行结果是？\n\n```js no-beautify\n5 > 4\n\"apple\" > \"pineapple\"\n\"2\" > \"12\"\nundefined == null\nundefined === null\nnull == \"\\n0\\n\"\nnull === +\"\\n0\\n\"\n```",
        "solution": "```js no-beautify\n5 > 4 → true\n\"apple\" > \"pineapple\" → false\n\"2\" > \"12\" → true\nundefined == null → true\nundefined === null → false\nnull == \"\\n0\\n\" → false\nnull === +\"\\n0\\n\" → false\n```\n\n结果的原因：\n\n1. 数字间比较大小，显然得 true。\n2. 按词典顺序比较，得 false。`\"a\"` 比 `\"p\"` 小。\n3. 与第 2 题同理，首位字符 `\"2\"` 大于 `\"1\"`。\n4. `null` 只与 `undefined` 互等。\n5. 严格相等模式下，类型不同得 false。\n6. 与第 4 题同理，`null` 只与 `undefined` 相等。\n7. 不同类型严格不相等。",
        "parent": "comparison",
        "version": 1
      }
    },
    "ifelse": {
      "type": "Article",
      "value": {
        "title": "条件分支：if 和 '?'",
        "slug": "ifelse",
        "githubPath": "/1-js/02-first-steps/10-ifelse",
        "isFolder": false,
        "weight": 10,
        "content": "\n\n有时我们需要根据不同条件执行不同的操作。\n\n我们可以使用 `if` 语句和条件运算符 `?`（也称为“问号”运算符）来实现。\n\n## \"if\" 语句\n\n`if(...)` 语句计算括号里的条件表达式，如果计算结果是 `true`，就会执行对应的代码块。\n\n例如：\n\n```js run\nlet year = prompt('In which year was ECMAScript-2015 specification published?', '');\n\n*!*\nif (year == 2015) alert( 'You are right!' );\n*/!*\n```\n\n在上面这个例子中，条件是一个简单的相等性检查（`year == 2015`），但它还可以更复杂。\n\n如果有多个语句要执行，我们必须将要执行的代码块封装在大括号内：\n\n```js\nif (year == 2015) {\n  alert( \"That's correct!\" );\n  alert( \"You're so smart!\" );\n}\n```\n\n建议每次使用 if 语句都用大括号 `{}` 来包装代码块，即使只有一条语句。这样可以提高代码可读性。\n\n## 布尔转换\n\n`if (…)` 语句会计算圆括号内的表达式，并将计算结果转换为布尔型。\n\n让我们回顾一下 <info:type-conversions> 一章中的转换规则：\n\n- 数字 `0`、空字符串 `\"\"`、`null`、`undefined` 和 `NaN` 都会被转换成 `false`。因为它们被称为“假值（falsy）”。\n- 其他值被转换为 `true`，所以它们被称为“真值（truthy）”。\n\n所以，下面这个条件下的代码永远不会执行：\n\n```js\nif (0) { // 0 是假值（falsy）\n  ...\n}\n```\n\n……但下面的条件 —— 始终有效：\n\n```js\nif (1) { // 1 是真值（truthy）\n  ...\n}\n```\n\n我们也可以将预先计算的布尔值传入 `if` 语句，像这样：\n\n```js\nlet cond = (year == 2015); // 相等运算符的结果是 true 或 false\n\nif (cond) {\n  ...\n}\n```\n\n## \"else\" 语句\n\n`if` 语句有时会包含一个可选的 \"else\" 块。如果判断条件不成立，就会执行它内部的代码。\n\n例如：\n```js run\nlet year = prompt('In which year was ECMAScript-2015 specification published?', '');\n\nif (year == 2015) {\n  alert( 'You guessed it right!' );\n} else {\n  alert( 'How can you be so wrong?' ); // 2015 以外的任何值\n}\n```\n\n## 多个条件：\"else if\"\n\n有时我们需要测试一个条件的几个变体。我们可以通过使用 `else if` 子句实现。\n\n例如：\n\n```js run\nlet year = prompt('In which year was ECMAScript-2015 specification published?', '');\n\nif (year < 2015) {\n  alert( 'Too early...' );\n} else if (year > 2015) {\n  alert( 'Too late' );\n} else {\n  alert( 'Exactly!' );\n}\n```\n\n在上面的代码中，JavaScript 先检查 `year < 2015`。如果条件不符合，就会转到下一个条件 `year > 2015`。如果这个条件也不符合，则会显示最后一个 `alert`。\n\n可以有更多的 `else if` 块。结尾的 `else` 是可选的。\n\n## 条件运算符 '?'\n\n有时我们需要根据一个条件去赋值一个变量。\n\n如下所示：\n\n```js run no-beautify\nlet accessAllowed;\nlet age = prompt('How old are you?', '');\n\n*!*\nif (age > 18) {\n  accessAllowed = true;\n} else {\n  accessAllowed = false;\n}\n*/!*\n\nalert(accessAllowed);\n```\n\n所谓的“条件”或“问号”运算符让我们可以更简短地达到目的。\n\n这个运算符通过问号 `?` 表示。有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。\n\n语法：\n```js\nlet result = condition ? value1 : value2;\n```\n\n计算条件结果，如果结果为真，则返回 `value1`，否则返回 `value2`。\n\n例如：\n\n```js\nlet accessAllowed = (age > 18) ? true : false;\n```\n\n技术上讲，我们可以省略 `age > 18` 外面的括号。问号运算符的优先级较低，所以它会在比较运算符 `>` 后执行。\n\n下面这个示例会执行和前面那个示例相同的操作：\n\n```js\n// 比较运算符 \"age > 18\" 首先执行\n//（不需要将其包含在括号中）\nlet accessAllowed = age > 18 ? true : false;\n```\n\n但括号可以使代码可读性更强，所以我们建议使用它们。\n\n````smart\n在上面的例子中，你可以不使用问号运算符，因为比较本身就返回 `true/false`：\n\n```js\n// 下面代码同样可以实现\nlet accessAllowed = age > 18;\n```\n````\n\n## 多个 '?'\n\n使用一系列问号 `?` 运算符可以返回一个取决于多个条件的值。\n\n例如：\n```js run\nlet age = prompt('age?', 18);\n\nlet message = (age < 3) ? 'Hi, baby!' :\n  (age < 18) ? 'Hello!' :\n  (age < 100) ? 'Greetings!' :\n  'What an unusual age!';\n\nalert( message );\n```\n\n可能很难一下子看出发生了什么。但经过仔细观察，我们可以看到它只是一个普通的检查序列。\n\n1. 第一个问号检查 `age < 3`。\n2. 如果为真 — 返回 `'Hi, baby!'`。否则，会继续执行冒号 `\":\"` 后的表达式，检查 `age < 18`。\n3. 如果为真 — 返回 `'Hello!'`。否则，会继续执行下一个冒号 `\":\"` 后的表达式，检查 `age < 100`。\n4. 如果为真 — 返回 `'Greetings!'`。否则，会继续执行最后一个冒号 `\":\"` 后面的表达式，返回 `'What an unusual age!'`。\n\n这是使用 `if..else` 实现上面的逻辑的写法：\n\n```js\nif (age < 3) {\n  message = 'Hi, baby!';\n} else if (age < 18) {\n  message = 'Hello!';\n} else if (age < 100) {\n  message = 'Greetings!';\n} else {\n  message = 'What an unusual age!';\n}\n```\n\n## '?' 的非常规使用\n\n有时可以使用问号 `?` 来代替 `if` 语句：\n\n```js run no-beautify\nlet company = prompt('Which company created JavaScript?', '');\n\n*!*\n(company == 'Netscape') ?\n   alert('Right!') : alert('Wrong.');\n*/!*\n```\n\n根据条件 `company =='Netscape'`，要么执行 `?` 后面的第一个表达式并显示对应内容，要么执行第二个表达式并显示对应内容。\n\n在这里我们不是把结果赋值给变量。而是根据条件执行不同的代码。\n\n**不建议这样使用问号运算符。**\n\n这种写法比 `if` 语句更短，对一些程序员很有吸引力。但它的可读性差。\n\n下面是使用 `if` 语句实现相同功能的代码，进行下比较：\n\n```js run no-beautify\nlet company = prompt('Which company created JavaScript?', '');\n\n*!*\nif (company == 'Netscape') {\n  alert('Right!');\n} else {\n  alert('Wrong.');\n}\n*/!*\n```\n\n因为我们的眼睛垂直扫描代码。所以，跨越几行的代码块比长而水平的代码更易于理解。\n\n问号 `?` 的作用是根据条件返回其中一个值。请正确使用它。当需要执行不同的代码分支时，请使用 `if`。",
        "libs": [],
        "children": [
          "if-zero-string",
          "check-standard",
          "sign",
          "rewrite-if-question",
          "rewrite-if-else-question"
        ],
        "parent": "first-steps",
        "updatedAt": 1658291435
      }
    },
    "if-zero-string": {
      "type": "Task",
      "value": {
        "title": "if（值为 0 的字符串）",
        "slug": "if-zero-string",
        "githubPath": "/1-js/02-first-steps/10-ifelse/1-if-zero-string",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n`alert` 弹窗会出来吗？\n\n```js\nif (\"0\") {\n  alert( 'Hello' );\n}\n```",
        "solution": "**是的，它会**\n\n任何非空字符串（`\"0\"` 不是空字符串）的逻辑值都是 `true`。\n\n我们可以执行下面的代码来进行验证：\n\n```js run\nif (\"0\") {\n  alert( 'Hello' );\n}\n```",
        "parent": "ifelse",
        "version": 1
      }
    },
    "check-standard": {
      "type": "Task",
      "value": {
        "title": "JavaScript 的名字",
        "slug": "check-standard",
        "githubPath": "/1-js/02-first-steps/10-ifelse/2-check-standard",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\n\n使用 `if..else` 结构，实现提问 \"What's the “official” name of JavaScript?\" 的代码。\n\n如果访问者输入了 \"ECMAScript\"，输出就提示 \"Right!\"，否则 —— 输出：\"You don't know? “ECMAScript”!\"\n\n![](ifelse_task2.svg)\n\n[demo src=\"ifelse_task2\"]",
        "solution": "[html run src=\"ifelse_task2/index.html\"]",
        "parent": "ifelse",
        "version": 1
      }
    },
    "sign": {
      "type": "Task",
      "value": {
        "title": "显示符号",
        "slug": "sign",
        "githubPath": "/1-js/02-first-steps/10-ifelse/3-sign",
        "weight": 3,
        "libs": [],
        "importance": 2,
        "content": "\n\n使用 `if..else` 语句，编写代码实现通过 `prompt` 获取一个数字并用 `alert` 显示结果：\n\n- 如果这个数字大于 0，就显示 `1`，\n- 如果这个数字小于 0，就显示 `-1`，\n- 如果这个数字等于 0，就显示 `0`。\n\n在这个任务中，我们假设输入永远是一个数字。\n\n[demo src=\"if_sign\"]",
        "solution": "```js run\nlet value = prompt('Type a number', 0);\n\nif (value > 0) {\n  alert( 1 );\n} else if (value < 0) {\n  alert( -1 );\n} else {\n  alert( 0 );\n}\n```",
        "parent": "ifelse",
        "version": 1
      }
    },
    "rewrite-if-question": {
      "type": "Task",
      "value": {
        "title": "使用 '?' 重写 'if' 语句",
        "slug": "rewrite-if-question",
        "githubPath": "/1-js/02-first-steps/10-ifelse/5-rewrite-if-question",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n使用条件运算符 `'?'` 重写下面的 `if` 语句：\n\n```js\nlet result;\n\nif (a + b < 4) {\n  result = 'Below';\n} else {\n  result = 'Over';\n}\n```",
        "solution": "```js\nlet result = (a + b < 4) ? 'Below' : 'Over';\n```",
        "parent": "ifelse",
        "version": 1
      }
    },
    "rewrite-if-else-question": {
      "type": "Task",
      "value": {
        "title": "使用 '?' 重写 'if..else' 语句",
        "slug": "rewrite-if-else-question",
        "githubPath": "/1-js/02-first-steps/10-ifelse/6-rewrite-if-else-question",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n使用多个三元运算符 `'?'` 重写下面的 `if..else` 语句。\n\n为了增强代码可读性，建议将代码分成多行。\n\n```js\nlet message;\n\nif (login == 'Employee') {\n  message = 'Hello';\n} else if (login == 'Director') {\n  message = 'Greetings';\n} else if (login == '') {\n  message = 'No login';\n} else {\n  message = '';\n}\n```",
        "solution": "```js\nlet message = (login == 'Employee') ? 'Hello' :\n  (login == 'Director') ? 'Greetings' :\n  (login == '') ? 'No login' :\n  '';\n```",
        "parent": "ifelse",
        "version": 1
      }
    },
    "logical-operators": {
      "type": "Article",
      "value": {
        "title": "逻辑运算符",
        "slug": "logical-operators",
        "githubPath": "/1-js/02-first-steps/11-logical-operators",
        "isFolder": false,
        "weight": 11,
        "content": "\n\nJavaScript 中有四个逻辑运算符：`||`（或），`&&`（与），`!`（非），`??`（空值合并运算符）。本文我们先介绍前三个，在下一篇文章中再详细介绍 `??` 运算符。\n\n虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型。\n\n让我们来详细看一下。\n\n## ||（或）\n\n两个竖线符号表示“或”运算符：\n\n```js\nresult = a || b;\n```\n\n在传统的编程中，逻辑或仅能够操作布尔值。如果参与运算的任意一个参数为 `true`，返回的结果就为 `true`，否则返回 `false`。\n\n在 JavaScript 中，逻辑运算符更加灵活强大。但是，首先让我们看一下操作数是布尔值的时候发生了什么。\n\n下面是四种可能的逻辑组合：\n\n```js run\nalert( true || true );   // true\nalert( false || true );  // true\nalert( true || false );  // true\nalert( false || false ); // false\n```\n\n正如我们所见，除了两个操作数都是 `false` 的情况，结果都是 `true`。\n\n如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算。\n\n例如，数字 `1` 被作为 `true` 处理，数字 `0` 则被作为 `false`：\n\n```js run\nif (1 || 0) { // 工作原理相当于 if( true || false )\n  alert( 'truthy!' );\n}\n```\n\n大多数情况下，逻辑或 `||` 会被用在 `if` 语句中，用来测试是否有 **任何** 给定的条件为 `true`。\n\n例如：\n\n```js run\nlet hour = 9;\n\n*!*\nif (hour < 10 || hour > 18) {\n*/!*\n  alert( 'The office is closed.' );\n}\n```\n\n我们可以传入更多的条件：\n\n```js run\nlet hour = 12;\nlet isWeekend = true;\n\nif (hour < 10 || hour > 18 || isWeekend) {\n  alert( 'The office is closed.' ); // 是周末\n}\n```\n\n## 或运算寻找第一个真值 [#or-finds-the-first-truthy-value]\n\n上文提到的逻辑处理多少有些传统了。下面让我们看看 JavaScript 的“附加”特性。\n\n拓展的算法如下所示。\n\n给定多个参与或运算的值：\n\n```js\nresult = value1 || value2 || value3;\n```\n\n或运算符 `||` 做了如下的事情：\n\n- 从左到右依次计算操作数。\n- 处理每一个操作数时，都将其转化为布尔值。如果结果是 `true`，就停止计算，返回这个操作数的初始值。\n- 如果所有的操作数都被计算过（也就是，转换结果都是 `false`），则返回最后一个操作数。\n\n返回的值是操作数的初始形式，不会做布尔转换。\n\n换句话说，一个或运算 `||` 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。\n\n例如：\n\n```js run\nalert( 1 || 0 ); // 1（1 是真值）\n\nalert( null || 1 ); // 1（1 是第一个真值）\nalert( null || 0 || 1 ); // 1（第一个真值）\n\nalert( undefined || null || 0 ); // 0（都是假值，返回最后一个值）\n```\n\n与“纯粹的、传统的、仅仅处理布尔值的或运算”相比，这个规则就引起了一些很有趣的用法。\n\n1. **获取变量列表或者表达式中的第一个真值。**\n\n    例如，我们有变量 `firstName`、`lastName` 和 `nickName`，都是可选的（即可以是 undefined，也可以是假值）。\n\n    我们用或运算 `||` 来选择有数据的那一个，并显示出来（如果没有设置，则用 `\"Anonymous\"`）：\n\n    ```js run\n    let firstName = \"\";\n    let lastName = \"\";\n    let nickName = \"SuperCoder\";\n\n    *!*\n    alert( firstName || lastName || nickName || \"Anonymous\"); // SuperCoder\n    */!*\n    ```\n\n    如果所有变量的值都为假，结果就是 `\"Anonymous\"`。\n\n2. **短路求值（Short-circuit evaluation）。**\n\n    或运算符 `||` 的另一个用途是所谓的“短路求值”。\n\n    这指的是，`||` 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数。\n\n    如果操作数不仅仅是一个值，而是一个有副作用的表达式，例如变量赋值或函数调用，那么这一特性的重要性就变得显而易见了。\n\n    在下面这个例子中，只会打印第二条信息：\n\n    ```js run no-beautify\n    *!*true*/!* || alert(\"not printed\");\n    *!*false*/!* || alert(\"printed\");\n    ```\n\n    在第一行中，或运算符 `||` 在遇到 `true` 时立即停止运算，所以 `alert` 没有运行。\n\n    有时，人们利用这个特性，只在左侧的条件为假时才执行命令。\n\n## &&（与）\n\n两个 & 符号表示 `&&` 与运算符：\n\n```js\nresult = a && b;\n```\n\n在传统的编程中，当两个操作数都是真值时，与运算返回 `true`，否则返回 `false`：\n\n```js run\nalert( true && true );   // true\nalert( false && true );  // false\nalert( true && false );  // false\nalert( false && false ); // false\n```\n\n带有 `if` 语句的示例：\n\n```js run\nlet hour = 12;\nlet minute = 30;\n\nif (hour == 12 && minute == 30) {\n  alert( 'Time is 12:30' );\n}\n```\n\n就像或运算一样，与运算的操作数可以是任意类型的值：\n\n```js run\nif (1 && 0) { // 作为 true && false 来执行\n  alert( \"won't work, because the result is falsy\" );\n}\n```\n\n\n## 与运算寻找第一个假值\n\n给出多个参加与运算的值：\n\n```js\nresult = value1 && value2 && value3;\n```\n\n与运算 `&&` 做了如下的事：\n\n- 从左到右依次计算操作数。\n- 在处理每一个操作数时，都将其转化为布尔值。如果结果是 `false`，就停止计算，并返回这个操作数的初始值。\n- 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。\n\n换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值。\n\n上面的规则和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。\n\n例如：\n\n```js run\n// 如果第一个操作数是真值，\n// 与运算返回第二个操作数：\nalert( 1 && 0 ); // 0\nalert( 1 && 5 ); // 5\n\n// 如果第一个操作数是假值，\n// 与运算将直接返回它。第二个操作数会被忽略\nalert( null && 5 ); // null\nalert( 0 && \"no matter what\" ); // 0\n```\n\n我们也可以在一行代码上串联多个值。查看第一个假值是如何被返回的：\n\n```js run\nalert( 1 && 2 && null && 3 ); // null\n```\n\n如果所有的值都是真值，最后一个值将会被返回：\n\n```js run\nalert( 1 && 2 && 3 ); // 3，最后一个值\n```\n\n````smart header=\"与运算 `&&` 在或运算 `||` 之前进行\"\n与运算 `&&` 的优先级比或运算 `||` 要高。\n\n所以代码 `a && b || c && d` 跟 `&&` 表达式加了括号完全一样：`(a && b) || (c && d)`。\n````\n\n````warn header=\"不要用 `||` 或 `&&` 来取代 `if`\"\n有时候，有人会将与运算符 `&&` 作为“简化 `if`”的一种方式。\n\n例如：\n\n```js run\nlet x = 1;\n\n(x > 0) && alert( 'Greater than zero!' );\n```\n\n`&&` 右边的代码只有运算抵达到那里才能被执行。也就是，当且仅当 `(x > 0)` 为真。\n\n所以我们基本可以类似地得到：\n\n```js run\nlet x = 1;\n\nif (x > 0) alert( 'Greater than zero!' );\n```\n\n虽然使用 `&&` 写出的变体看起来更短，但 `if` 更明显，并且往往更具可读性。因此，我们建议根据每个语法结构的用途来使用：如果我们想要 `if`，就使用 `if`；如果我们想要逻辑与，就使用 `&&`。\n````\n\n\n## !（非）\n\n感叹符号 `!` 表示布尔非运算符。\n\n语法相当简单：\n\n```js\nresult = !value;\n```\n\n逻辑非运算符接受一个参数，并按如下运作：\n\n1. 将操作数转化为布尔类型：`true/false`。\n2. 返回相反的值。\n\n例如：\n\n```js run\nalert( !true ); // false\nalert( !0 ); // true\n```\n\n两个非运算 `!!` 有时候用来将某个值转化为布尔类型：\n\n```js run\nalert( !!\"non-empty string\" ); // true\nalert( !!null ); // false\n```\n\n也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。\n\n有一个略显冗长的方式也可以实现同样的效果 —— 一个内建的 `Boolean` 函数：\n\n```js run\nalert( Boolean(\"non-empty string\") ); // true\nalert( Boolean(null) ); // false\n```\n\n非运算符 `!` 的优先级在所有逻辑运算符里面最高，所以它总是在 `&&` 和 `||` 之前执行。",
        "libs": [],
        "children": [
          "alert-null-2-undefined",
          "alert-or",
          "alert-1-null-2",
          "alert-and",
          "alert-and-or",
          "check-if-in-range",
          "check-if-out-range",
          "if-question",
          "check-login"
        ],
        "parent": "first-steps",
        "updatedAt": 1666798942
      }
    },
    "alert-null-2-undefined": {
      "type": "Task",
      "value": {
        "title": "或运算的结果是什么？",
        "slug": "alert-null-2-undefined",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/1-alert-null-2-undefined",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n如下代码将会输出什么？\n\n```js\nalert( null || 2 || undefined );\n```",
        "solution": "结果是 `2`，这是第一个真值。\n\n```js run\nalert( null || 2 || undefined );\n```",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "alert-or": {
      "type": "Task",
      "value": {
        "title": "或运算和 alert 的结果是什么？",
        "slug": "alert-or",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/2-alert-or",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\n\n下面的代码将会输出什么？\n\n```js\nalert( alert(1) || 2 || alert(3) );\n```",
        "solution": "答案：首先是 `1`，然后是 `2`。\n\n```js run\nalert( alert(1) || 2 || alert(3) );\n```\n\n对 `alert` 的调用没有返回值。或者说返回的是 `undefined`。\n\n1. 第一个或运算 `||` 对它的左值 `alert(1)` 进行了计算。这就显示了第一条信息 `1`。\n2. 函数 `alert` 返回了 `undefined`，所以或运算继续检查第二个操作数以寻找真值。\n3. 第二个操作数 `2` 是真值，所以执行就中断了。`2` 被返回，并且被外层的 alert 显示。\n\n这里不会显示 `3`，因为运算没有抵达 `alert(3)`。",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "alert-1-null-2": {
      "type": "Task",
      "value": {
        "title": "与操作的结果是什么？",
        "slug": "alert-1-null-2",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/3-alert-1-null-2",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面这段代码将会显示什么？\n\n```js\nalert( 1 && null && 2 );\n```",
        "solution": "答案：`null`，因为它是列表中第一个假值。\n\n```js run\nalert(1 && null && 2);\n```",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "alert-and": {
      "type": "Task",
      "value": {
        "title": "与运算连接的 alert 的结果是什么？",
        "slug": "alert-and",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/4-alert-and",
        "weight": 4,
        "libs": [],
        "importance": 3,
        "content": "\n\n这段代码将会显示什么？\n\n```js\nalert( alert(1) && alert(2) );\n```",
        "solution": "答案：`1`，然后 `undefined`。\n\n```js run\nalert( alert(1) && alert(2) );\n```\n\n调用 `alert` 返回了 `undefined`（它只展示消息，所以没有有意义的返回值）。\n\n因此，`&&` 计算了它左边的操作数（显示 `1`），然后立即停止了，因为 `undefined` 是一个假值。`&&` 就是寻找假值然后返回它，所以运算结束。",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "alert-and-or": {
      "type": "Task",
      "value": {
        "title": "或运算、与运算、或运算串联的结果",
        "slug": "alert-and-or",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/5-alert-and-or",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n结果将会是什么？\n\n```js\nalert( null || 2 && 3 || 4 );\n```",
        "solution": "答案：`3`。\n\n```js run\nalert( null || 2 && 3 || 4 );\n```\n\n与运算 `&&` 的优先级比 `||` 高，所以它第一个被执行。\n\n结果是 `2 && 3 = 3`，所以表达式变成了：\n\n```\nnull || 3 || 4\n```\n\n现在的结果就是第一个真值：`3`。",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "check-if-in-range": {
      "type": "Task",
      "value": {
        "title": "检查值是否位于范围区间内",
        "slug": "check-if-in-range",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/6-check-if-in-range",
        "weight": 6,
        "libs": [],
        "importance": 3,
        "content": "\n\n写一个 `if` 条件句来检查 `age` 是否位于 `14` 到 `90` 的闭区间。\n\n“闭区间”意味着，`age` 的值可以取 `14` 或 `90`。",
        "solution": "```js\nif (age >= 14 && age <= 90)\n```",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "check-if-out-range": {
      "type": "Task",
      "value": {
        "title": "检查值是否位于范围之外",
        "slug": "check-if-out-range",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/7-check-if-out-range",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\n\n写一个 `if` 条件句，检查 `age` 是否不位于 `14` 到 `90` 的闭区间。\n\n创建两个表达式：第一个用非运算 `!`，第二个不用。",
        "solution": "第一个表达式：\n\n```js\nif (!(age >= 14 && age <= 90))\n```\n\n第二个表达式：\n\n```js\nif (age < 14 || age > 90)\n```",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "if-question": {
      "type": "Task",
      "value": {
        "title": "一个关于 \"if\" 的问题",
        "slug": "if-question",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/8-if-question",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面哪一个 `alert` 将会被执行？\n\n`if(...)` 语句内表达式的结果是什么？\n\n```js\nif (-1 || 0) alert( 'first' );\nif (-1 && 0) alert( 'second' );\nif (null || -1 && 1) alert( 'third' );\n```",
        "solution": "答案：第一个和第三个将会被执行。\n\n详解：\n\n```js run\n// 执行。\n// -1 || 0 的结果为 -1，真值\nif (-1 || 0) alert( 'first' );\n\n// 不执行。\n// -1 && 0 = 0，假值\nif (-1 && 0) alert( 'second' );\n\n// 执行\n// && 运算的优先级比 || 高\n// 所以 -1 && 1 先执行，给出如下运算链：\n// null || -1 && 1  ->  null || 1  ->  1\nif (null || -1 && 1) alert( 'third' );\n```",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "check-login": {
      "type": "Task",
      "value": {
        "title": "登录校验",
        "slug": "check-login",
        "githubPath": "/1-js/02-first-steps/11-logical-operators/9-check-login",
        "weight": 9,
        "libs": [],
        "importance": 3,
        "content": "\n\n实现使用 `prompt` 进行登录校验的代码。\n\n如果访问者输入 `\"Admin\"`，那么使用 `prompt` 引导获取密码，如果输入的用户名为空或者按下了 `key:Esc` 键 —— 显示 \"Canceled\"，如果是其他字符串 —— 显示 \"I don't know you\"。\n\n密码的校验规则如下：\n\n- 如果输入的是 \"TheMaster\"，显示 \"Welcome!\"，\n- 其他字符串 —— 显示 \"Wrong password\"，\n- 空字符串或取消了输入，显示 \"Canceled.\"。\n\n流程图：\n\n![](ifelse_task.svg)\n\n请使用嵌套的 `if` 块。注意代码整体的可读性。\n\n提示：将空字符串输入，prompt 会获取到一个空字符串 `''`。Prompt 运行过程中，按下 `key:ESC` 键会得到 `null`。\n\n[demo]",
        "solution": "```js run demo\nlet userName = prompt(\"Who's there?\", '');\n\nif (userName === 'Admin') {\n\n  let pass = prompt('Password?', '');\n\n  if (pass === 'TheMaster') {\n    alert( 'Welcome!' );\n  } else if (pass === '' || pass === null) {\n    alert( 'Canceled' );\n  } else {\n    alert( 'Wrong password' );\n  }\n\n} else if (userName === '' || userName === null) {\n  alert( 'Canceled' );\n} else {\n  alert( \"I don't know you\" );\n}\n```\n\n请注意 `if` 块中水平方向的缩进。技术上是非必需的，但会提升代码的可读性。",
        "parent": "logical-operators",
        "version": 1
      }
    },
    "nullish-coalescing-operator": {
      "type": "Article",
      "value": {
        "title": "空值合并运算符 '??'",
        "slug": "nullish-coalescing-operator",
        "githubPath": "/1-js/02-first-steps/12-nullish-coalescing-operator",
        "isFolder": false,
        "weight": 12,
        "content": "\n\n[recent browser=\"new\"]\n\n空值合并运算符（nullish coalescing operator）的写法为两个问号 `??`。\n\n由于它对待 `null` 和 `undefined` 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 `null` 也不是 `undefined` 时，我们将其称为“已定义的（defined）”。\n\n`a ?? b` 的结果是：\n- 如果 `a` 是已定义的，则结果为 `a`，\n- 如果 `a` 不是已定义的，则结果为 `b`。\n\n换句话说，如果第一个参数不是 `null/undefined`，则 `??` 返回第一个参数。否则，返回第二个参数。\n\n空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。\n\n我们可以使用我们已知的运算符重写 `result = a ?? b`，像这样：\n\n```js\nresult = (a !== null && a !== undefined) ? a : b;\n```\n\n现在你应该清楚了 `??` 的作用。让我们来看看它的使用场景吧。\n\n`??` 的常见使用场景是提供默认值。\n\n例如，在这里，如果 `user` 的值不为 `null/undefined` 则显示 `user`，否则显示 `匿名`：\n\n```js run\nlet user;\n\nalert(user ?? \"匿名\"); // 匿名（user 未定义）\n```\n\n在下面这个例子中，我们将一个名字赋值给了 `user`：\n\n```js run\nlet user = \"John\";\n\nalert(user ?? \"匿名\"); // John（user 已定义）\n```\n\n我们还可以使用 `??` 序列从一系列的值中选择出第一个非 `null/undefined` 的值。\n\n假设我们在变量 `firstName`、`lastName` 或 `nickName` 中存储着一个用户的数据。如果用户决定不填写相应的值，则所有这些变量的值都可能是未定义的。\n\n我们想使用这些变量之一显示用户名，如果这些变量的值都是 `null/undefined`，则显示 \"匿名\"。\n\n让我们使用 `??` 运算符来实现这一需求：\n\n```js run\nlet firstName = null;\nlet lastName = null;\nlet nickName = \"Supercoder\";\n\n// 显示第一个已定义的值：\n*!*\nalert(firstName ?? lastName ?? nickName ?? \"匿名\"); // Supercoder\n*/!*\n```\n\n## 与 || 比较\n\n或运算符 `||` 可以以与 `??` 运算符相同的方式使用。像我们在 [上一章](info:logical-operators#or-finds-the-first-truthy-value) 所讲的那样。\n\n例如，在上面的代码中，我们可以用 `||` 替换掉 `??`，也可以获得相同的结果：\n\n```js run\nlet firstName = null;\nlet lastName = null;\nlet nickName = \"Supercoder\";\n\n// 显示第一个真值：\n*!*\nalert(firstName || lastName || nickName || \"Anonymous\"); // Supercoder\n*/!*\n```\n\n纵观 JavaScript 发展史，或 `||` 运算符先于 `??` 出现。它自 JavaScript 诞生就存在了，因此开发者长期将其用于这种目的。\n\n另一方面，空值合并运算符 `??` 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 `||` 不太满意。\n\n它们之间重要的区别是：\n- `||` 返回第一个 **真** 值。\n- `??` 返回第一个 **已定义的** 值。\n\n换句话说，`||` 无法区分 `false`、`0`、空字符串 `\"\"` 和 `null/undefined`。它们都一样 —— 假值（falsy values）。如果其中任何一个是 `||` 的第一个参数，那么我们将得到第二个参数作为结果。\n\n不过在实际中，我们可能只想在变量的值为 `null/undefined` 时使用默认值。也就是说，当该值确实未知或未被设置时。\n\n例如，考虑下面这种情况：\n\n```js run\nlet height = 0;\n\nalert(height || 100); // 100\nalert(height ?? 100); // 0\n```\n\n- `height || 100` 首先会检查 `height` 是否为一个假值，它是 `0`，确实是假值。\n    - 所以，`||` 运算的结果为第二个参数，`100`。\n- `height ?? 100` 首先会检查 `height` 是否为 `null/undefined`，发现它不是。\n    - 所以，结果为 `height` 的原始值，`0`。\n\n实际上，高度 `0` 通常是一个有效值，它不应该被替换为默认值。所以 `??` 运算得到的是正确的结果。\n\n## 优先级\n\n`??` 运算符的优先级与 `||` 相同，它们的的优先级都为 `4`，详见：[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)。\n\n这意味着，就像 `||` 一样，空值合并运算符在 `=` 和 `?` 运算前计算，但在大多数其他运算（例如 `+` 和 `*`）之后计算。\n\n所以我们可能需要在这样的表达式中添加括号：\n\n```js run\nlet height = null;\nlet width = null;\n\n// 重要：使用括号\nlet area = (height ?? 100) * (width ?? 50);\n\nalert(area); // 5000\n```\n\n否则，如果我们省略了括号，则由于 `*` 的优先级比 `??` 高，它会先执行，进而导致错误的结果。\n\n```js\n// 没有括号\nlet area = height ?? 100 * width ?? 50;\n\n// ……将这样计算（不符合我们的期望）：\nlet area = height ?? (100 * width) ?? 50;\n```\n\n### ?? 与 && 或 || 一起使用\n\n出于安全原因，JavaScript 禁止将 `??` 运算符与 `&&` 和 `||` 运算符一起使用，除非使用括号明确指定了优先级。\n\n下面的代码会触发一个语法错误：\n\n```js run\nlet x = 1 && 2 ?? 3; // Syntax error\n```\n\n这个限制无疑是值得商榷的，它被添加到语言规范中是为了避免人们从 `||` 切换到 `??` 时的编程错误。\n\n可以明确地使用括号来解决这个问题：\n\n```js run\n*!*\nlet x = (1 && 2) ?? 3; // 正常工作了\n*/!*\n\nalert(x); // 2\n```\n\n## 总结\n\n- 空值合并运算符 `??` 提供了一种从列表中选择第一个“已定义的”值的简便方式。\n\n    它被用于为变量分配默认值：\n\n    ```js\n    // 当 height 的值为 null 或 undefined 时，将 height 的值设置为 100\n    height = height ?? 100;\n    ```\n\n- `??` 运算符的优先级非常低，仅略高于 `?` 和 `=`，因此在表达式中使用它时请考虑添加括号。\n- 如果没有明确添加括号，不能将其与 `||` 或 `&&` 一起使用。",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1650734977
      }
    },
    "while-for": {
      "type": "Article",
      "value": {
        "title": "循环：while 和 for",
        "slug": "while-for",
        "githubPath": "/1-js/02-first-steps/13-while-for",
        "isFolder": false,
        "weight": 13,
        "content": "\n\n我们经常需要重复执行一些操作。\n\n例如，我们需要将列表中的商品逐个输出，或者运行相同的代码将数字 1 到 10 逐个输出。\n\n**循环** 是一种重复运行同一代码的方法。\n\n```smart header=\"for..of 和 for..in 循环\"\n给进阶读者的一个小提示。\n\n本文仅涵盖了基础的循环：`while`，`do..while` 和 `for(..; ..; ..)`。\n\n如果你阅读本文是为了寻找其他类型的循环，那么：\n\n- 用于遍历对象属性的 `for..in` 循环请见：[for..in](info:object#forin)。\n- 用于遍历数组和可迭代对象的循环分别请见：[for..of](info:array#loops) 和 [iterables](info:iterable)。\n\n否则，请继续阅读。\n```\n\n## \"while\" 循环\n\n`while` 循环的语法如下：\n\n```js\nwhile (condition) {\n  // 代码\n  // 所谓的“循环体” \n}\n```\n\n当 `condition` 为真时，执行循环体的 `code`。\n\n例如，以下将循环输出当 `i < 3` 时的 `i` 值：\n\n```js run\nlet i = 0;\nwhile (i < 3) { // 依次显示 0、1 和 2\n  alert( i );\n  i++;\n}\n```\n\n循环体的单次执行叫作 **一次迭代**。上面示例中的循环进行了三次迭代。\n\n如果上述示例中没有 `i++`，那么循环（理论上）会永远重复执行下去。实际上，浏览器提供了阻止这种循环的方法，我们可以通过终止进程，来停掉服务器端的 JavaScript。\n\n任何表达式或变量都可以是循环条件，而不仅仅是比较。在 `while` 中的循环条件会被计算，计算结果会被转化为布尔值。\n\n例如，`while (i != 0)` 可简写为 `while (i)`：\n\n```js run\nlet i = 3;\n*!*\nwhile (i) { // 当 i 变成 0 时，条件为假，循环终止\n*/!*\n  alert( i );\n  i--;\n}\n```\n\n````smart header=\"单行循环体不需要大括号\"\n如果循环体只有一条语句，则可以省略大括号 `{…}`：\n\n```js run\nlet i = 3;\n*!*\nwhile (i) alert(i--);\n*/!*\n```\n````\n\n## \"do..while\" 循环\n\n使用 `do..while` 语法可以将条件检查移至循环体 **下面**：\n\n```js\ndo {\n  // 循环体\n} while (condition);\n```\n\n循环首先执行循环体，然后检查条件，当条件为真时，重复执行循环体。\n\n例如：\n\n```js run\nlet i = 0;\ndo {\n  alert( i );\n  i++;\n} while (i < 3);\n```\n\n这种形式的语法很少使用，除非你希望不管条件是否为真，循环体 **至少执行一次**。通常我们更倾向于使用另一个形式：`while(…) {…}`。\n\n## \"for\" 循环\n\n`for` 循环更加复杂，但它是最常使用的循环形式。\n\n`for` 循环看起来就像这样：\n\n```js\nfor (begin; condition; step) {\n  // ……循环体……\n}\n```\n\n我们通过示例来了解一下这三个部分的含义。下述循环从 `i` 等于 `0` 到 `3`（但不包括 `3`）运行 `alert(i)`：\n\n```js run\nfor (let i = 0; i < 3; i++) { // 结果为 0、1、2\n  alert(i);\n}\n```\n\n我们逐个部分分析 `for` 循环：\n\n| 语句段 |             |                                                                            |\n| ----- | ----------- |----------------------------------------------------------------------------|\n| begin | `let i = 0`     | 进入循环时执行一次。                                     |\n| condition | `i < 3` | 在每次循环迭代之前检查，如果为 false，停止循环。          |\n| body（循环体） | `alert(i)` | 条件为真时，重复运行。                        |\n| step | `i++`        | 在每次循环体迭代后执行。 |\n\n一般循环算法的工作原理如下：\n\n```\n开始运行\n→ (如果 condition 成立 → 运行 body 然后运行 step)\n→ (如果 condition 成立 → 运行 body 然后运行 step)\n→ (如果 condition 成立 → 运行 body 然后运行 step)\n→ ...\n```\n\n所以，`begin` 执行一次，然后进行迭代：每次检查 `condition` 后，执行 `body` 和 `step`。\n\n如果你这是第一次接触循环，那么回到这个例子，在一张纸上重现它逐步运行的过程，可能会对你有所帮助。\n\n以下是在这个示例中发生的事：\n\n```js\n// for (let i = 0; i < 3; i++) alert(i)\n\n// 开始\nlet i = 0\n// 如果条件为真，运行下一步\nif (i < 3) { alert(i); i++ }\n// 如果条件为真，运行下一步\nif (i < 3) { alert(i); i++ }\n// 如果条件为真，运行下一步\nif (i < 3) { alert(i); i++ }\n// ……结束，因为现在 i == 3\n```\n\n````smart header=\"内联变量声明\"\n这里“计数”变量 `i` 是在循环中声明的。这叫做“内联”变量声明。这样的变量只在循环中可见。\n\n```js run\nfor (*!*let*/!* i = 0; i < 3; i++) {\n  alert(i); // 0, 1, 2\n}\nalert(i); // 错误，没有这个变量。\n```\n\n除了定义一个变量，我们也可以使用现有的变量：\n\n```js run\nlet i = 0;\n\nfor (i = 0; i < 3; i++) { // 使用现有的变量\n  alert(i); // 0, 1, 2\n}\n\nalert(i); //3，可见，因为是在循环之外声明的\n```\n````\n\n### 省略语句段\n\n`for` 循环的任何语句段都可以被省略。\n\n例如，如果我们在循环开始时不需要做任何事，我们就可以省略 `begin` 语句段。\n\n就像这样：\n\n```js run\nlet i = 0; // 我们已经声明了 i 并对它进行了赋值\n\nfor (; i < 3; i++) { // 不再需要 \"begin\" 语句段\n  alert( i ); // 0, 1, 2\n}\n```\n\n我们也可以移除 `step` 语句段：\n\n```js run\nlet i = 0;\n\nfor (; i < 3;) {\n  alert( i++ );\n}\n```\n\n该循环与 `while (i < 3)` 等价。\n\n实际上我们可以删除所有内容，从而创建一个无限循环：\n\n```js\nfor (;;) {\n  // 无限循环\n}\n```\n\n请注意 `for` 的两个 `;` 必须存在，否则会出现语法错误。\n\n## 跳出循环\n\n通常条件为假时，循环会终止。\n\n但我们随时都可以使用 `break` 指令强制退出。\n\n例如，下面这个循环要求用户输入一系列数字，在输入的内容不是数字时“终止”循环。\n\n```js run\nlet sum = 0;\n\nwhile (true) {\n\n  let value = +prompt(\"Enter a number\", '');\n\n*!*\n  if (!value) break; // (*)\n*/!*\n\n  sum += value;\n\n}\nalert( 'Sum: ' + sum );\n```\n\n如果用户输入空行或取消输入，在 `(*)` 行的 `break` 指令会被激活。它立刻终止循环，将控制权传递给循环后的第一行，即，`alert`。\n\n根据需要，\"无限循环 + `break`\" 的组合非常适用于不必在循环开始/结束时检查条件，但需要在中间甚至是主体的多个位置进行条件检查的情况。\n\n## 继续下一次迭代 [#continue]\n\n`continue` 指令是 `break` 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）。\n\n如果我们完成了当前的迭代，并且希望继续执行下一次迭代，我们就可以使用它。\n\n下面这个循环使用 `continue` 来只输出奇数：\n\n```js run no-beautify\nfor (let i = 0; i < 10; i++) {\n\n  //如果为真，跳过循环体的剩余部分。\n  *!*if (i % 2 == 0) continue;*/!*\n\n  alert(i); // 1，然后 3，5，7，9\n}\n```\n\n对于偶数的 `i` 值，`continue` 指令会停止本次循环的继续执行，将控制权传递给下一次 `for` 循环的迭代（使用下一个数字）。因此 `alert` 仅被奇数值调用。\n\n````smart header=\"`continue` 指令利于减少嵌套\"\n显示奇数的循环可以像下面这样：\n\n```js run\nfor (let i = 0; i < 10; i++) {\n\n  if (i % 2) {\n    alert( i );\n  }\n\n}\n```\n\n从技术角度看，它与上一个示例完全相同。当然，我们可以将代码包装在 `if` 块而不使用 `continue`。\n\n但在副作用方面，它多创建了一层嵌套（大括号内的 `alert` 调用）。如果 `if` 中代码有多行，则可能会降低代码整体的可读性。\n````\n\n````warn header=\"禁止 `break/continue` 在 ‘?’ 的右边\"\n请注意非表达式的语法结构不能与三元运算符 `?` 一起使用。特别是 `break/continue` 这样的指令是不允许这样使用的。\n\n例如，我们使用如下代码：\n\n```js\nif (i > 5) {\n  alert(i);\n} else {\n  continue;\n}\n```\n\n……用问号重写：\n\n```js no-beautify\n(i > 5) ? alert(i) : *!*continue*/!*; // continue 不允许在这个位置\n```\n\n……代码会停止运行，并显示有语法错误。\n\n这是不（建议）使用问号 `?` 运算符替代 `if` 语句的另一个原因。\n````\n\n## break/continue 标签\n\n有时候我们需要一次从多层嵌套的循环中跳出来。\n\n例如，下述代码中我们的循环使用了 `i` 和 `j`，从 `(0,0)` 到 `(3,3)` 提示坐标 `(i, j)`：\n\n```js run no-beautify\nfor (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '');\n\n    // 如果我想从这里退出并直接执行 alert('Done!')\n  }\n}\n\nalert('Done!');\n```\n\n我们需要提供一种方法，以在用户取消输入时来停止这个过程。\n\n在 `input` 之后的普通 `break` 只会打破内部循环。这还不够 —— 标签可以实现这一功能！\n\n**标签** 是在循环之前带有冒号的标识符：\n\n```js\nlabelName: for (...) {\n  ...\n}\n```\n\n`break <labelName>` 语句跳出循环至标签处：\n\n```js run no-beautify\n*!*outer:*/!* for (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '');\n\n    // 如果是空字符串或被取消，则中断并跳出这两个循环。\n    if (!input) *!*break outer*/!*; // (*)\n\n    // 用得到的值做些事……\n  }\n}\n\nalert('Done!');\n```\n\n上述代码中，`break outer` 向上寻找名为 `outer` 的标签并跳出当前循环。\n\n因此，控制权直接从 `(*)` 转至 `alert('Done!')`。\n\n我们还可以将标签移至单独一行：\n\n```js no-beautify\nouter:\nfor (let i = 0; i < 3; i++) { ... }\n```\n\n`continue` 指令也可以与标签一起使用。在这种情况下，执行跳转到标记循环的下一次迭代。\n\n````warn header=\"标签并不允许“跳到”所有位置\"\n标签不允许我们跳到代码的任意位置。\n\n例如，这样做是不可能的：\n\n```js\nbreak label;  // 跳转至下面的 label 处（无效）\n\nlabel: for (...)\n```\n\n`break` 指令必须在代码块内。从技术上讲，任何被标记的代码块都有效，例如：\n\n```js\nlabel: {\n  // ...\n  break label; // 有效\n  // ...\n}\n```\n\n……尽管 99.9% 的情况下 `break` 都被用在循环内，就像在上面那些例子中我们看到的那样。\n\n`continue` 只有在循环内部才可行。\n````\n\n## 总结\n\n我们学习了三种循环：\n\n- `while` —— 每次迭代之前都要检查条件。\n- `do..while` —— 每次迭代后都要检查条件。\n- `for (;;)` —— 每次迭代之前都要检查条件，可以使用其他设置。\n\n通常使用 `while(true)` 来构造“无限”循环。这样的循环和其他循环一样，都可以通过 `break` 指令来终止。\n\n如果我们不想在当前迭代中做任何事，并且想要转移至下一次迭代，那么可以使用 `continue` 指令。\n\n`break/continue` 支持循环前的标签。标签是 `break/continue` 跳出嵌套循环以转到外部的唯一方法。",
        "libs": [],
        "children": [
          "loop-last-value",
          "which-value-while",
          "which-value-for",
          "for-even",
          "replace-for-while",
          "repeat-until-correct",
          "list-primes"
        ],
        "parent": "first-steps",
        "updatedAt": 1657705346
      }
    },
    "loop-last-value": {
      "type": "Task",
      "value": {
        "title": "最后一次循环的值",
        "slug": "loop-last-value",
        "githubPath": "/1-js/02-first-steps/13-while-for/1-loop-last-value",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\n\n此代码最后一次 alert 值是多少？为什么？\n\n```js\nlet i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```",
        "solution": "答案是：`1`。\n\n```js run\nlet i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\n```\n\n每次循环迭代都将 `i` 减  `1`。当检查到 `i = 0` 时，`while(i)` 循环停止。\n\n因此，此循环执行的步骤如下（“循环展开”）：\n\n```js\nlet i = 3;\n\nalert(i--); // 显示 3，i 减至 2\n\nalert(i--) // 显示 2，i 减至 1\n\nalert(i--) // 显示 1，i 减至 0\n\n// 完成，while(i) 检查循环条件并停止循环\n```",
        "parent": "while-for",
        "version": 1
      }
    },
    "which-value-while": {
      "type": "Task",
      "value": {
        "title": "while 循环显示哪些值？",
        "slug": "which-value-while",
        "githubPath": "/1-js/02-first-steps/13-while-for/2-which-value-while",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n对于每次循环，写出你认为会显示的值，然后与答案进行比较。\n\n以下两个循环的 `alert` 值是否相同？\n\n1. 前缀形式 `++i`:\n\n    ```js\n    let i = 0;\n    while (++i < 5) alert( i );\n    ```\n2. 后缀形式 `i++`\n\n    ```js\n    let i = 0;\n    while (i++ < 5) alert( i );\n    ```",
        "solution": "这个题目展现了 i++/++i 两种形式在比较中导致的不同结果。\n\n1. **从 1 到 4**\n\n    ```js run\n    let i = 0;\n    while (++i < 5) alert( i );\n    ```\n\n    第一个值是 `i = 1`，因为 `++i` 首先递增 `i` 然后返回新值。因此先比较 `1 < 5` 然后通过 `alert` 显示 `1`。\n\n    然后按照 `2, 3, 4…` —— 数值一个接着一个被显示出来。在比较中使用的都是递增后的值，因为 `++` 在变量前。\n\n    最终，`i = 4` 时，在 `++i < 5` 的比较中，`i` 值递增至 `5`，所以 `while(5 < 5)` 不符合循环条件，循环停止。所以没有显示 `5`。\n\n2. **从 1 到 5**\n\n    ```js run\n    let i = 0;\n    while (i++ < 5) alert( i );\n    ```\n\n    第一个值也是 `i = 1`。后缀形式 `i++` 递增 `i` 然后返回 **旧** 值，因此比较 `i++ < 5` 将使用 `i = 0`（与 `++i < 5` 不同）。\n\n    但 `alert` 调用是独立的。这是在递增和比较之后执行的另一条语句。因此它得到了当前的 `i = 1`。\n\n    接下来是 `2, 3,4…`\n\n    我们在 `i = 4` 时暂停，前缀形式 `++i` 会递增 `i` 并在比较中使用新值 `5`。但我们这里是后缀形式 `i++`。因此，它将 `i` 递增到 `5`，但返回旧值。因此实际比较的是 `while(4 < 5)` —— true，程序继续执行 `alert`。\n\n    `i = 5` 是最后一个值，因为下一步比较 `while(5 < 5)` 为 false。",
        "parent": "while-for",
        "version": 1
      }
    },
    "which-value-for": {
      "type": "Task",
      "value": {
        "title": "\"for\" 循环显示哪些值？",
        "slug": "which-value-for",
        "githubPath": "/1-js/02-first-steps/13-while-for/3-which-value-for",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\n\n对于每次循环，写下它将显示的值。然后与答案进行比较。\n\n两次循环 `alert` 值是否相同？\n\n1. 后缀形式：\n\n    ```js\n    for (let i = 0; i < 5; i++) alert( i );\n    ```\n2. 前缀形式：\n\n    ```js\n    for (let i = 0; i < 5; ++i) alert( i );\n    ```",
        "solution": "**答案：在这两种情况下都是从 `0` 到 `4`。**\n\n```js run\nfor (let i = 0; i < 5; ++i) alert( i );\n\nfor (let i = 0; i < 5; i++) alert( i );\n```\n\n这可以很容易地从 `for` 算法中推导出：\n\n1. 在一切开始之前执行 `i = 0`。\n2. 检查 `i < 5` 条件\n3. 如果 `true` —— 执行循环体并 `alert(i)`，然后进行 `i++`\n\n递增 `i++` 与检查条件（2）分开。这只是另一种写法。\n\n在这没使用返回的递增值，因此 `i++` 和 `++i`之间没有区别。",
        "parent": "while-for",
        "version": 1
      }
    },
    "for-even": {
      "type": "Task",
      "value": {
        "title": "使用 for 循环输出偶数",
        "slug": "for-even",
        "githubPath": "/1-js/02-first-steps/13-while-for/4-for-even",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n使用 `for` 循环输出从 `2` 到 `10` 的偶数。\n\n[demo]",
        "solution": "```js run demo\nfor (let i = 2; i <= 10; i++) {\n  if (i % 2 == 0) {\n    alert( i );\n  }\n}\n```\n\n我们使用 \"modulo\" 运算符 `%` 来获取余数，并检查奇偶性。",
        "parent": "while-for",
        "version": 1
      }
    },
    "replace-for-while": {
      "type": "Task",
      "value": {
        "title": "用 \"while\" 替换 \"for\"",
        "slug": "replace-for-while",
        "githubPath": "/1-js/02-first-steps/13-while-for/5-replace-for-while",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n重写代码，在保证不改变其行为的情况下，将 `for` 循环更改为 `while`（输出应保持不变）。\n\n```js run\nfor (let i = 0; i < 3; i++) {\n  alert( `number ${i}!` );\n}\n```",
        "solution": "```js run\nlet i = 0;\nwhile (i < 3) {\n  alert( `number ${i}!` );\n  i++;\n}\n```",
        "parent": "while-for",
        "version": 1
      }
    },
    "repeat-until-correct": {
      "type": "Task",
      "value": {
        "title": "重复输入，直到正确为止",
        "slug": "repeat-until-correct",
        "githubPath": "/1-js/02-first-steps/13-while-for/6-repeat-until-correct",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写一个提示用户输入大于 `100` 的数字的循环。如果用户输入其他数值 —— 请他重新输入。\n\n循环一直在请求一个数字，直到用户输入了一个大于 `100` 的数字、取消输入或输入了一个空行为止。\n\n在这我们假设用户只会输入数字。在本题目中，不需要对非数值输入进行特殊处理。\n\n[demo]",
        "solution": "```js run demo\nlet num;\n\ndo {\n  num = prompt(\"Enter a number greater than 100?\", 0);\n} while (num <= 100 && num);\n```\n\n两个检查都为真时，继续执行 `do..while` 循环：\n\n1. 检查 `num <= 100` —— 即输入值仍然不大于 `100`。\n2. 当 `num` 为 `null` 或空字符串时，`&& num` 的结果为 false。那么 `while` 循环也会停止。\n\nP.S. 如果 `num` 为 `null`，那么 `num <= 100` 为 `true`。因此用户单击取消，如果没有第二次检查，循环就不会停止。两次检查都是必须的。",
        "parent": "while-for",
        "version": 1
      }
    },
    "list-primes": {
      "type": "Task",
      "value": {
        "title": "输出素数（prime）",
        "slug": "list-primes",
        "githubPath": "/1-js/02-first-steps/13-while-for/7-list-primes",
        "weight": 7,
        "libs": [],
        "importance": 3,
        "content": "\n\n大于 `1` 且不能被除了 `1` 和它本身以外的任何数整除的整数叫做[素数](https://en.wikipedia.org/wiki/Prime_number)。\n\n换句话说，`n > 1` 且不能被 `1` 和 `n` 以外的任何数整除的整数，被称为素数。\n\n例如，`5` 是素数，因为它不能被 `2`、`3` 和 `4` 整除，会产生余数。\n\n**写一个可以输出 `2` 到 `n` 之间的所有素数的代码。**\n\n当 `n = 10`，结果输出 `2、3、5、7`。\n\nP.S. 代码应适用于任何 `n`，而不是对任何固定值进行硬性调整。",
        "solution": "这个题目有很多解法。\n\n我们使用一个嵌套循环：\n\n```js\n对于间隔中的每个 i {\n  检查在 1~i 之间，是否有 i 的除数\n  如果有 => 这个 i 不是素数\n  如果没有 => 这个 i 是素数，输出出来\n}\n```\n\n使用标签的代码：\n\n```js run\nlet n = 10;\n\nnextPrime:\nfor (let i = 2; i <= n; i++) { // 对每个自然数 i\n\n  for (let j = 2; j < i; j++) { // 寻找一个除数……\n    if (i % j == 0) continue nextPrime; // 不是素数，则继续检查下一个\n  }\n\n  alert( i ); // 输出素数\n}\n```\n\n这段代码有很大的优化空间。例如，我们可以从 `2` 到 `i` 的平方根之间的数中寻找除数。无论怎样，如果我们想要在很大的数字范围内实现高效率，我们需要改变实现方法，依赖高等数学和复杂算法，如[二次筛选法（Quadratic sieve）](https://en.wikipedia.org/wiki/Quadratic_sieve)，[普通数域筛选法（General number field sieve）](https://en.wikipedia.org/wiki/General_number_field_sieve)等。\n\n译注：素数也称为质数，对本答案的代码进一步优化，其实就是一道 LeetCode 算法题，感兴趣的可以点击链接查看如何通过 [埃拉托斯特尼筛法筛选素数](https://dingxuewen.com/leetcode-js-leviding/easy/204.count-primes/204.count-primes.html)。",
        "parent": "while-for",
        "version": 1
      }
    },
    "switch": {
      "type": "Article",
      "value": {
        "title": "\"switch\" 语句",
        "slug": "switch",
        "githubPath": "/1-js/02-first-steps/14-switch",
        "isFolder": false,
        "weight": 14,
        "content": "\n\n`switch` 语句可以替代多个 `if` 判断。\n\n`switch` 语句为多分支选择的情况提供了一个更具描述性的方式。\n\n## 语法\n\n`switch` 语句有至少一个 `case` 代码块和一个可选的 `default` 代码块。\n\n就像这样：\n\n```js no-beautify\nswitch(x) {\n  case 'value1':  // if (x === 'value1')\n    ...\n    [break]\n\n  case 'value2':  // if (x === 'value2')\n    ...\n    [break]\n\n  default:\n    ...\n    [break]\n}\n```\n\n- 比较 `x` 值与第一个 `case`（也就是 `value1`）是否严格相等，然后比较第二个 `case`（`value2`）以此类推。\n- 如果相等，`switch` 语句就执行相应 `case` 下的代码块，直到遇到最靠近的 `break` 语句（或者直到 `switch` 语句末尾）。\n- 如果没有符合的 case，则执行 `default` 代码块（如果 `default` 存在）。\n\n## 举个例子\n\n`switch` 的例子（高亮的部分是执行的 `case` 部分）：\n\n```js run\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Too small' );\n    break;\n*!*\n  case 4:\n    alert( 'Exactly!' );\n    break;\n*/!*\n  case 5:\n    alert( 'Too big' );\n    break;\n  default:\n    alert( \"I don't know such values\" );\n}\n```\n\n这里的 `switch` 从第一个 `case` 分支开始将 `a` 的值与 `case` 后的值进行比较，第一个 `case` 后的值为 `3` 匹配失败。\n\n然后比较 `4`。匹配，所以从 `case 4` 开始执行直到遇到最近的 `break`。\n\n**如果没有 `break`，程序将不经过任何检查就会继续执行下一个 `case`。**\n\n无 `break` 的例子：\n\n```js run\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Too small' );\n*!*\n  case 4:\n    alert( 'Exactly!' );\n  case 5:\n    alert( 'Too big' );\n  default:\n    alert( \"I don't know such values\" );\n*/!*\n}\n```\n\n在上面的例子中我们会看到连续执行的三个 `alert`：\n\n```js\nalert( 'Exactly!' );\nalert( 'Too big' );\nalert( \"I don't know such values\" );\n```\n\n````smart header=\"任何表达式都可以成为 `switch/case` 的参数\"\n`switch` 和 `case` 都允许任意表达式。\n\n比如：\n\n```js run\nlet a = \"1\";\nlet b = 0;\n\nswitch (+a) {\n*!*\n  case b + 1:\n    alert(\"this runs, because +a is 1, exactly equals b+1\");\n    break;\n*/!*\n\n  default:\n    alert(\"this doesn't run\");\n}\n```\n这里 `+a` 返回 `1`，这个值跟 `case` 中 `b + 1` 相比较，然后执行对应的代码。\n````\n\n## \"case\" 分组\n\n共享同一段代码的几个 `case` 分支可以被分为一组：\n\n比如，如果我们想让 `case 3` 和 `case 5` 执行同样的代码：\n\n```js run no-beautify\nlet a = 3;\n\nswitch (a) {\n  case 4:\n    alert('Right!');\n    break;\n\n*!*\n  case 3: // (*) 下面这两个 case 被分在一组\n  case 5:\n    alert('Wrong!');\n    alert(\"Why don't you take a math class?\");\n    break;\n*/!*\n\n  default:\n    alert('The result is strange. Really.');\n}\n```\n\n现在 `3` 和 `5` 都显示相同的信息。\n\n`switch/case` 有通过 case 进行“分组”的能力，其实是 switch 语句没有 `break` 时的副作用。因为没有 `break`，`case 3` 会从 `(*)` 行执行到 `case 5`。\n\n## 类型很关键\n\n强调一下，这里的相等是严格相等。被比较的值必须是相同的类型才能进行匹配。\n\n比如，我们来看下面的代码：\n\n```js run\nlet arg = prompt(\"Enter a value?\")\nswitch (arg) {\n  case '0':\n  case '1':\n    alert( 'One or zero' );\n    break;\n\n  case '2':\n    alert( 'Two' );\n    break;\n\n  case 3:\n    alert( 'Never executes!' );\n    break;\n  default:\n    alert( 'An unknown value' )\n}\n```\n\n1. 在 `prompt` 对话框输入 `0`、`1`，第一个 `alert` 弹出。\n2. 输入 `2`，第二个 `alert` 弹出。 \n3. 但是输入 `3`，因为 `prompt` 的结果是字符串类型的 `\"3\"`，不严格相等 `===` 于数字类型的 `3`，所以 `case 3` 不会执行！因此 `case 3` 部分是一段无效代码。所以会执行 `default` 分支。",
        "libs": [],
        "children": [
          "rewrite-switch-if-else",
          "rewrite-if-switch"
        ],
        "parent": "first-steps",
        "updatedAt": 1628412622
      }
    },
    "rewrite-switch-if-else": {
      "type": "Task",
      "value": {
        "title": "将 \"switch\" 结构重写为 \"if\" 结构",
        "slug": "rewrite-switch-if-else",
        "githubPath": "/1-js/02-first-steps/14-switch/1-rewrite-switch-if-else",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n将下面 `switch` 结构的代码写成 `if..else` 结构：\n\n```js\nswitch (browser) {\n  case 'Edge':\n    alert( \"You've got the Edge!\" );\n    break;\n\n  case 'Chrome':\n  case 'Firefox':\n  case 'Safari':\n  case 'Opera':\n    alert( 'Okay we support these browsers too' );\n    break;\n\n  default:\n    alert( 'We hope that this page looks ok!' );\n}\n```",
        "solution": "为了精确实现 `switch` 的功能，`if` 必须使用严格相等 `'==='`。\n\n对于给定的字符串，一个简单的 `'=='` 也可以。\n\n```js no-beautify\nif(browser == 'Edge') {\n  alert(\"You've got the Edge!\");\n} else if (browser == 'Chrome'\n || browser == 'Firefox'\n || browser == 'Safari'\n || browser == 'Opera') {\n  alert( 'Okay we support these browsers too' );\n} else {\n  alert( 'We hope that this page looks ok!' );\n}\n```\n\n请注意：将 `browser == 'Chrome' || browser == 'Firefox' …` 结构分成多行可读性更高。\n\n但 `switch` 结构更清晰明了。",
        "parent": "switch",
        "version": 1
      }
    },
    "rewrite-if-switch": {
      "type": "Task",
      "value": {
        "title": "将 \"if\" 结构重写为 \"switch\" 结构",
        "slug": "rewrite-if-switch",
        "githubPath": "/1-js/02-first-steps/14-switch/2-rewrite-if-switch",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n用 `switch` 重写以下代码：\n\n```js run\nlet a = +prompt('a?', '');\n\nif (a == 0) {\n  alert( 0 );\n}\nif (a == 1) {\n  alert( 1 );\n}\n\nif (a == 2 || a == 3) {\n  alert( '2,3' );\n}\n```",
        "solution": "前两个检查为前两个 `case`，第三个检查分为两种情况：\n\n```js run\nlet a = +prompt('a?', '');\n\nswitch (a) {\n  case 0:\n    alert( 0 );\n    break;\n\n  case 1:\n    alert( 1 );\n    break;\n\n  case 2:\n  case 3:\n    alert( '2,3' );\n*!*\n    break;\n*/!*\n}\n```\n\n请注意：最后的 `break` 不是必须的。但是为了让代码可扩展我们要把它加上。\n\n有可能之后我们想要再添加一个 `case`，例如 `case 4`。如果我们忘记在它之前添加一个 break，那么在 case 3 执行结束后可能会出现错误。所以这是一种自我保险。",
        "parent": "switch",
        "version": 1
      }
    },
    "function-basics": {
      "type": "Article",
      "value": {
        "title": "函数",
        "slug": "function-basics",
        "githubPath": "/1-js/02-first-steps/15-function-basics",
        "isFolder": false,
        "weight": 15,
        "content": "\n\n我们经常需要在脚本的许多地方执行很相似的操作。\n\n例如，当访问者登录、注销或者在其他地方时，我们需要显示一条好看的信息。\n\n函数是程序的主要“构建模块”。函数使该段代码可以被调用很多次，而不需要写重复的代码。\n\n我们已经看到了内建函数的示例，如 `alert(message)`、`prompt(message, default)` 和 `confirm(question)`。但我们也可以创建自己的函数。\n\n## 函数声明\n\n使用 **函数声明** 创建函数。\n\n看起来就像这样：\n\n```js\nfunction showMessage() {\n  alert( 'Hello everyone!' );\n}\n```\n\n`function` 关键字首先出现，然后是 **函数名**，然后是括号之间的 **参数** 列表（用逗号分隔，在上述示例中为空，我们将在接下来的示例中看到），最后是花括号之间的代码（即“函数体”）。\n\n```js\nfunction name(parameter1, parameter2, ... parameterN) {\n  ...body...\n}\n```\n\n我们的新函数可以通过名称调用：`showMessage()`。\n\n例如：\n\n```js run\nfunction showMessage() {\n  alert( 'Hello everyone!' );\n}\n\n*!*\nshowMessage();\nshowMessage();\n*/!*\n```\n\n调用 `showMessage()` 执行函数的代码。这里我们会看到显示两次消息。\n\n这个例子清楚地演示了函数的主要目的之一：避免代码重复。\n\n如果我们需要更改消息或其显示方式，只需在一个地方修改代码：输出它的函数。\n\n## 局部变量\n\n在函数中声明的变量只在该函数内部可见。\n\n例如：\n\n```js run\nfunction showMessage() {\n*!*\n  let message = \"Hello, I'm JavaScript!\"; // 局部变量\n*/!*\n\n  alert( message );\n}\n\nshowMessage(); // Hello, I'm JavaScript!\n\nalert( message ); // <-- 错误！变量是函数的局部变量\n```\n\n## 外部变量\n\n函数也可以访问外部变量，例如：\n\n```js run no-beautify\nlet *!*userName*/!* = 'John';\n\nfunction showMessage() {\n  let message = 'Hello, ' + *!*userName*/!*;\n  alert(message);\n}\n\nshowMessage(); // Hello, John\n```\n\n函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。\n\n例如：\n\n```js run\nlet *!*userName*/!* = 'John';\n\nfunction showMessage() {\n  *!*userName*/!* = \"Bob\"; // (1) 改变外部变量\n\n  let message = 'Hello, ' + *!*userName*/!*;\n  alert(message);\n}\n\nalert( userName ); // *!*John*/!* 在函数调用之前\n\nshowMessage();\n\nalert( userName ); // *!*Bob*/!*，值被函数修改了\n```\n\n只有在没有局部变量的情况下才会使用外部变量。\n\n如果在函数内部声明了同名变量，那么函数会 **遮蔽** 外部变量。例如，在下面的代码中，函数使用局部的 `userName`，而外部变量被忽略：\n\n```js run\nlet userName = 'John';\n\nfunction showMessage() {\n*!*\n  let userName = \"Bob\"; // 声明一个局部变量\n*/!*\n\n  let message = 'Hello, ' + userName; // *!*Bob*/!*\n  alert(message);\n}\n\n// 函数会创建并使用它自己的 userName\nshowMessage();\n\nalert( userName ); // *!*John*/!*，未被更改，函数没有访问外部变量。\n```\n\n```smart header=\"全局变量\"\n任何函数之外声明的变量，例如上述代码中的外部变量 `userName`，都被称为 **全局** 变量。\n\n全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。\n\n减少全局变量的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。\n```\n\n## 参数\n\n我们可以通过参数将任意数据传递给函数。\n\n在如下示例中，函数有两个参数：`from` 和 `text`。\n\n```js run\nfunction showMessage(*!*from, text*/!*) { // 参数：from 和 text\n  alert(from + ': ' + text);\n}\n\n*!*showMessage('Ann', 'Hello!');*/!* // Ann: Hello! (*)\n*!*showMessage('Ann', \"What's up?\");*/!* // Ann: What's up? (**)\n```\n\n当函数在 `(*)` 和 `(**)` 行中被调用时，给定值被复制到了局部变量 `from` 和 `text`。然后函数使用它们进行计算。\n\n这里还有一个例子：我们有一个变量 `from`，并将它传递给函数。请注意：函数会修改 `from`，但在函数外部看不到更改，因为函数修改的是复制的变量值副本：\n\n```js run\nfunction showMessage(from, text) {\n\n*!*\n  from = '*' + from + '*'; // 让 \"from\" 看起来更优雅\n*/!*\n\n  alert( from + ': ' + text );\n}\n\nlet from = \"Ann\";\n\nshowMessage(from, \"Hello\"); // *Ann*: Hello\n\n// \"from\" 值相同，函数修改了一个局部的副本。\nalert( from ); // Ann\n```\n\n当一个值被作为函数参数（parameter）传递时，它也被称为 **参数（argument）**。\n\n换一种方式，我们把这些术语搞清楚：\n\n- 参数（parameter）是函数声明中括号内列出的变量（它是函数声明时的术语）。\n- 参数（argument）是调用函数时传递给函数的值（它是函数调用时的术语）。\n\n我们声明函数时列出它们的参数（parameters），然后调用它们传递参数（arguments）。\n\n在上面的例子中，我们可以说：“函数 `showMessage` 被声明，并且带有两个参数（parameters），随后它被调用，两个参数（arguments）分别为 `from` 和 `\"Hello\"`”。\n\n\n## 默认值\n\n如果一个函数被调用，但有参数（argument）未被提供，那么相应的值就会变成 `undefined`。\n\n例如，之前提到的函数 `showMessage(from, text)` 可以只使用一个参数（argument）调用：\n\n```js\nshowMessage(\"Ann\");\n```\n\n那不是错误，这样调用将输出 `\"*Ann*: undefined\"`。因为参数 `text` 的值未被传递，所以变成了 `undefined`。\n\n我们可以使用 `=` 为函数声明中的参数指定所谓的“默认”（如果对应参数的值未被传递则使用）值：\n\n```js run\nfunction showMessage(from, *!*text = \"no text given\"*/!*) {\n  alert( from + \": \" + text );\n}\n\nshowMessage(\"Ann\"); // Ann: no text given\n```\n\n现在如果 `text` 参数未被传递，它将会得到值 `\"no text given\"`。\n\n这里 `\"no text given\"` 是一个字符串，但它可以是更复杂的表达式，并且只会在缺少参数时才会被计算和分配。所以，这也是可能的：\n\n```js run\nfunction showMessage(from, text = anotherFunction()) {\n  // anotherFunction() 仅在没有给定 text 时执行\n  // 其运行结果将成为 text 的值 \n}\n```\n\n```smart header=\"默认参数的计算\"\n在 JavaScript 中，每次函数在没带个别参数的情况下被调用，默认参数会被计算出来。\n\n在上面的例子中，如果传递了参数 `text`，那么 `anotherFunction()` 就不会被调用。\n\n如果没传递参数 `text`，那么 `anotherFunction()` 就会被调用。\n```\n\n````smart header=\"在 JavaScript 老代码中的默认参数\"\n几年前，JavaScript 不支持默认参数的语法。所以人们使用其他方式来设置默认参数。\n\n如今，我们会在旧代码中看到它们。\n\n例如，显式地检查 `undefined`：\n\n```js\nfunction showMessage(from, text) {\n*!*\n  if (text === undefined) {\n    text = 'no text given';\n  }\n*/!*\n\n  alert( from + \": \" + text );\n}\n```\n\n……或者使用 `||` 运算符：\n\n```js\nfunction showMessage(from, text) {\n  // 如果 text 的值为假值，则分配默认值\n  // 这样赋值 text == \"\" 与 text 无值相同\n  text = text || 'no text given';\n  ...\n}\n```\n````\n\n\n### 后备的默认参数\n\n有些时候，将参数默认值的设置放在函数执行（相较更后期）而不是函数声明时，也行得通。\n\n我们可以通过将参数与 `undefined` 进行比较，来检查该参数是否在函数执行期间被传递进来：\n\n```js run\nfunction showMessage(text) {\n  // ...\n\n*!*\n  if (text === undefined) { // 如果参数未被传递进来\n    text = 'empty message';\n  }\n*/!*\n\n  alert(text);\n}\n\nshowMessage(); // empty message\n```\n\n……或者我们可以使用 `||` 运算符：\n\n```js\nfunction showMessage(text) {\n  // 如果 text 为 undefined 或者为假值，那么将其赋值为 'empty'\n  text = text || 'empty';\n  ...\n}\n```\n\n现代 JavaScript 引擎支持 [空值合并运算符](info:nullish-coalescing-operator) `??`，它在大多数假值（例如 `0`）应该被视为“正常值”时更具优势：\n\n```js run\nfunction showCount(count) {\n  // 如果 count 为 undefined 或 null，则提示 \"unknown\"\n  alert(count ?? \"unknown\");\n}\n\nshowCount(0); // 0\nshowCount(null); // unknown\nshowCount(); // unknown\n```\n\n## 返回值\n\n函数可以将一个值返回到调用代码中作为结果。\n\n最简单的例子是将两个值相加的函数：\n\n```js run no-beautify\nfunction sum(a, b) {\n  *!*return*/!* a + b;\n}\n\nlet result = sum(1, 2);\nalert( result ); // 3\n```\n\n指令 `return` 可以在函数的任意位置。当执行到达时，函数停止，并将值返回给调用代码（分配给上述代码中的 `result`）。\n\n在一个函数中可能会出现很多次 `return`。例如：\n\n```js run\nfunction checkAge(age) {\n  if (age >= 18) {\n*!*\n    return true;\n*/!*\n  } else {\n*!*\n    return confirm('Got a permission from the parents?');\n*/!*\n  }\n}\n\nlet age = prompt('How old are you?', 18);\n\nif ( checkAge(age) ) {\n  alert( 'Access granted' );\n} else {\n  alert( 'Access denied' );\n}\n```\n\n只使用 `return` 但没有返回值也是可行的。但这会导致函数立即退出。\n\n例如：\n\n```js\nfunction showMovie(age) {\n  if ( !checkAge(age) ) {\n*!*\n    return;\n*/!*\n  }\n\n  alert( \"Showing you the movie\" ); // (*)\n  // ...\n}\n```\n\n在上述代码中，如果 `checkAge(age)` 返回 `false`，那么 `showMovie` 将不会运行到 `alert`。\n\n````smart header=\"空值的 `return` 或没有 `return` 的函数返回值为 `undefined`\"\n如果函数无返回值，它就会像返回 `undefined` 一样：\n\n```js run\nfunction doNothing() { /* 没有代码 */ }\n\nalert( doNothing() === undefined ); // true\n```\n\n空值的 `return` 和 `return undefined` 等效：\n\n```js run\nfunction doNothing() {\n  return;\n}\n\nalert( doNothing() === undefined ); // true\n```\n````\n\n````warn header=\"不要在 `return` 与返回值之间添加新行\"\n对于 `return` 的长表达式，可能你会很想将其放在单独一行，如下所示：\n\n```js\nreturn\n (some + long + expression + or + whatever * f(a) + f(b))\n```\n但这不行，因为 JavaScript 默认会在 `return` 之后加上分号。上面这段代码和下面这段代码运行流程相同：\n\n```js\nreturn*!*;*/!*\n (some + long + expression + or + whatever * f(a) + f(b))\n```\n\n因此，实际上它的返回值变成了空值。\n\n如果我们想要将返回的表达式写成跨多行的形式，那么应该在 `return` 的同一行开始写此表达式。或者至少按照如下的方式放上左括号：\n\n```js\nreturn (\n  some + long + expression\n  + or +\n  whatever * f(a) + f(b)\n  )\n```\n然后它就能像我们预想的那样正常运行了。\n````\n\n## 函数命名 [#function-naming]\n\n函数就是行为（action）。所以它们的名字通常是动词。它应该简短且尽可能准确地描述函数的作用。这样读代码的人就能清楚地知道这个函数的功能。\n\n一种普遍的做法是用动词前缀来开始一个函数，这个前缀模糊地描述了这个行为。团队内部必须就前缀的含义达成一致。\n\n例如，以 `\"show\"` 开头的函数通常会显示某些内容。\n\n函数以 XX 开始……\n\n- `\"get…\"` —— 返回一个值，\n- `\"calc…\"` —— 计算某些内容，\n- `\"create…\"` —— 创建某些内容，\n- `\"check…\"` —— 检查某些内容并返回 boolean 值，等。\n\n这类名字的示例：\n\n```js no-beautify\nshowMessage(..)     // 显示信息\ngetAge(..)          // 返回 age（gets it somehow）\ncalcSum(..)         // 计算求和并返回结果\ncreateForm(..)      // 创建表单（通常会返回它）\ncheckPermission(..) // 检查权限并返回 true/false\n```\n\n有了前缀，只需瞥一眼函数名，就可以了解它的功能是什么，返回什么样的值。\n\n```smart header=\"一个函数 —— 一个行为\"\n一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。\n\n两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。\n\n有几个违反这一规则的例子：\n\n- `getAge` —— 如果它通过 `alert` 将 age 显示出来，那就有问题了（只应该是获取）。\n- `createForm` —— 如果它包含修改文档的操作，例如向文档添加一个表单，那就有问题了（只应该创建表单并返回）。\n- `checkPermission` —— 如果它显示 `access granted/denied` 消息，那就有问题了（只应执行检查并返回结果）。\n\n这些例子假设函数名前缀具有通用的含义。你和你的团队可以自定义这些函数名前缀的含义，但是通常都没有太大的不同。无论怎样，你都应该对函数名前缀的含义、带特定前缀的函数可以做什么以及不可以做什么有深刻的了解。所有相同前缀的函数都应该遵守相同的规则。并且，团队成员应该形成共识。\n```\n\n```smart header=\"非常短的函数命名\"\n常用的函数有时会有**非常短**的名字。\n\n例如，[jQuery](http://jquery.com) 框架用 `$` 定义一个函数。[LoDash](http://lodash.com/) 库的核心函数用 `_` 命名。\n\n这些都是例外，一般而言，函数名应简明扼要且具有描述性。\n```\n\n## 函数 == 注释\n\n函数应该简短且只有一个功能。如果这个函数功能复杂，那么把该函数拆分成几个小的函数是值得的。有时候遵循这个规则并不是那么容易，但这绝对是件好事。\n\n一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！\n\n例如，比较如下两个函数 `showPrimes(n)`。它们的功能都是输出到 `n` 的 [素数](https://en.wikipedia.org/wiki/Prime_number)。\n\n第一个变体使用了一个标签：\n\n```js\nfunction showPrimes(n) {\n  nextPrime: for (let i = 2; i < n; i++) {\n\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // 一个素数\n  }\n}\n```\n\n第二个变体使用附加函数 `isPrime(n)` 来检验素数：\n\n```js\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    *!*if (!isPrime(i)) continue;*/!*\n\n    alert(i);  // 一个素数\n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}\n```\n\n第二个变体更容易理解，不是吗？我们通过函数名（`isPrime`）就可以看出函数的行为，而不需要通过代码。人们通常把这样的代码称为 **自描述**。\n\n因此，即使我们不打算重用它们，也可以创建函数。函数可以让代码结构更清晰，可读性更强。\n\n## 总结\n\n函数声明方式如下所示：\n\n```js\nfunction name(parameters, delimited, by, comma) {\n  /* code */\n}\n```\n\n- 作为参数传递给函数的值，会被复制到函数的局部变量。\n- 函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。\n- 函数可以返回值。如果没有返回值，则其返回的结果是 `undefined`。\n\n为了使代码简洁易懂，建议在函数中主要使用局部变量和参数，而不是外部变量。\n\n与不获取参数但将修改外部变量作为副作用的函数相比，获取参数、使用参数并返回结果的函数更容易理解。\n\n函数命名：\n\n- 函数名应该清楚地描述函数的功能。当我们在代码中看到一个函数调用时，一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。\n- 一个函数是一个行为，所以函数名通常是动词。\n- 目前有许多优秀的函数名前缀，如 `create…`、`show…`、`get…`、`check…` 等等。使用它们来提示函数的作用吧。\n\n函数是脚本的主要构建块。现在我们已经介绍了基本知识，现在我们就可以开始创建和使用函数了。但这只是学习和使用函数的开始。我们将继续学习更多函数的相关知识，更深入地研究它们的先进特征。",
        "libs": [],
        "children": [
          "if-else-required",
          "rewrite-function-question-or",
          "min",
          "pow"
        ],
        "parent": "first-steps",
        "updatedAt": 1650818129
      }
    },
    "if-else-required": {
      "type": "Task",
      "value": {
        "title": "是否需要 “else”？",
        "slug": "if-else-required",
        "githubPath": "/1-js/02-first-steps/15-function-basics/1-if-else-required",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\n\n如果参数 `age` 大于 `18`，那么下面的函数将返回 `true`。\n\n否则它将会要求进行确认，并返回确认结果：\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n*!*\n  } else {\n    // ...\n    return confirm('父母允许吗？');\n  }\n*/!*\n}\n```\n\n如果 `else` 被删除，函数的工作方式会不同吗？\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  }\n*!*\n  // ...\n  return confirm('父母允许吗？');\n*/!*\n}\n```\n\n这两个变体的行为是否有区别？",
        "solution": "没有区别。\n\n在这两种情况下，`return confirm('父母允许吗？')` 均只会在 `if` 条件为假时执行。",
        "parent": "function-basics",
        "version": 1
      }
    },
    "rewrite-function-question-or": {
      "type": "Task",
      "value": {
        "title": "使用 '?' 或者 '||' 重写函数",
        "slug": "rewrite-function-question-or",
        "githubPath": "/1-js/02-first-steps/15-function-basics/2-rewrite-function-question-or",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n如果参数 `age` 大于 `18`，那么下面的函数返回 `true`。\n\n否则它将会要求进行确认，并返回确认结果：\n\n```js\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  } else {\n    return confirm('Do you have your parents permission to access this page?');\n  }\n}\n```\n\n重写这个函数并保证效果相同，不使用 `if`，且只需一行代码。\n\n编写 `checkAge` 的两个变体：\n\n1. 使用问号运算符 `?`\n2. 使用或运算符 `||`",
        "solution": "使用问号运算符 `'?'`：\n\n```js\nfunction checkAge(age) {\n  return (age > 18) ? true : confirm('Did parents allow you?');\n}\n```\n\n使用或运算符 `||`（最短的变体）：\n\n```js\nfunction checkAge(age) {\n  return (age > 18) || confirm('Did parents allow you?');\n}\n```\n\n请注意此处不需要 `age > 18` 左右的括号。写上括号是为了提高可读性。",
        "parent": "function-basics",
        "version": 1
      }
    },
    "min": {
      "type": "Task",
      "value": {
        "title": "函数 min(a, b)",
        "slug": "min",
        "githubPath": "/1-js/02-first-steps/15-function-basics/3-min",
        "weight": 3,
        "libs": [],
        "importance": 1,
        "content": "\n\n写一个返回数字 `a` 和 `b` 中较小的那个数字的函数 `min(a,b)`。\n\n例如：\n\n```js\nmin(2, 5) == 2\nmin(3, -1) == -1\nmin(1, 1) == 1\n```",
        "solution": "使用 `if` 的解决方案：\n\n```js\nfunction min(a, b) {\n  if (a < b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n```\n\n使用问号运算符 `'?'` 的解决方案：\n\n```js\nfunction min(a, b) {\n  return a < b ? a : b;\n}\n```\n\nP.S. 在 `a == b` 的情况下，返回什么都无关紧要。",
        "parent": "function-basics",
        "version": 1
      }
    },
    "pow": {
      "type": "Task",
      "value": {
        "title": "函数 pow(x,n)",
        "slug": "pow",
        "githubPath": "/1-js/02-first-steps/15-function-basics/4-pow",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n\n写一个函数 `pow(x,n)`，返回 `x` 的 `n` 次方。换句话说，将 `x` 与自身相乘 `n` 次，返回最终结果。\n\n```js\npow(3, 2) = 3 * 3 = 9\npow(3, 3) = 3 * 3 * 3 = 27\npow(1, 100) = 1 * 1 * ...*1 = 1\n```\n\n创建一个 web  页面，提示输入 `x` 和 `n`，然后返回 `pow(x,n)` 的运算结果。\n\n[demo]\n\nP.S. 在这个任务中，函数应该只支持自然数 `n`：从 `1` 开始的整数。",
        "solution": "```js run demo\nfunction pow(x, n) {\n  let result = x;\n\n  for (let i = 1; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", '');\nlet n = prompt(\"n?\", '');\n\nif (n < 1) {\n  alert(`Power ${n} is not supported, use a positive integer`);\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "function-basics",
        "version": 1
      }
    },
    "function-expressions": {
      "type": "Article",
      "value": {
        "title": "函数表达式",
        "slug": "function-expressions",
        "githubPath": "/1-js/02-first-steps/16-function-expressions",
        "isFolder": false,
        "weight": 16,
        "content": "\n\n在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值。\n\n我们在前面章节使用的语法称为 **函数声明**：\n\n```js\nfunction sayHi() {\n  alert( \"Hello\" );\n}\n```\n\n另一种创建函数的语法称为 **函数表达式**。\n\n它允许我们在任何表达式的中间创建一个新函数。\n\n例如：\n\n```js\nlet sayHi = function() {\n  alert( \"Hello\" );\n};\n```\n\n在这里我们可以看到变量 `sayHi` 得到了一个值，新函数 `function() { alert(\"Hello\"); }`。\n\n由于函数创建发生在赋值表达式的上下文中（在 `=` 的右侧），因此这是一个 **函数表达式**。\n\n请注意，`function` 关键字后面没有函数名。函数表达式允许省略函数名。\n\n这里我们立即将它赋值给变量，所以上面的两个代码示例的含义是一样的：“创建一个函数并将其放入变量 `sayHi` 中”。\n\n在更多更高阶的情况下，稍后我们会遇到，可以创建一个函数并立即调用，或者安排稍后执行，而不是存储在任何地方，因此保持匿名。\n\n## 函数是一个值\n\n重申一次：无论函数是如何创建的，函数都是一个值。上面的两个示例都在 `sayHi` 变量中存储了一个函数。\n\n我们还可以用 `alert` 显示这个变量的值：\n\n```js run\nfunction sayHi() {\n  alert( \"Hello\" );\n}\n\n*!*\nalert( sayHi ); // 显示函数代码\n*/!*\n```\n\n注意，最后一行代码并不会运行函数，因为 `sayHi` 后没有括号。在某些编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。\n\n在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码。\n\n的确，在某种意义上说一个函数是一个特殊值，我们可以像 `sayHi()` 这样调用它。\n\n但它依然是一个值，所以我们可以像使用其他类型的值一样使用它。\n\n我们可以复制函数到其他变量：\n\n```js run no-beautify\nfunction sayHi() {   // (1) 创建\n  alert( \"Hello\" );\n}\n\nlet func = sayHi;    // (2) 复制\n\nfunc(); // Hello     // (3) 运行复制的值（正常运行）！\nsayHi(); // Hello    //     这里也能运行（为什么不行呢）\n```\n\n解释一下上段代码发生的细节：\n\n1. `(1)` 行声明创建了函数，并把它放入到变量 `sayHi`。\n2. `(2)` 行将 `sayHi` 复制到了变量 `func`。请注意：`sayHi` 后面没有括号。如果有括号，`func = sayHi()` 会把 `sayHi()` 的调用结果写进`func`，而不是 `sayHi` **函数** 本身。\n3. 现在函数可以通过 `sayHi()` 和 `func()` 两种方式进行调用。\n\n我们也可以在第一行中使用函数表达式来声明 `sayHi`：\n\n```js\nlet sayHi = function() { // (1) 创建\n  alert( \"Hello\" );\n};\n\nlet func = sayHi;\n// ...\n```\n\n这两种声明的函数是一样的。\n\n\n````smart header=\"为什么这里末尾会有个分号？\"\n你可能想知道，为什么函数表达式结尾有一个分号 `;`，而函数声明没有：\n\n```js\nfunction sayHi() {\n  // ...\n}\n\nlet sayHi = function() {\n  // ...\n}*!*;*/!*\n```\n\n答案很简单：这里函数表达式是在赋值语句 `let sayHi = ...;` 中以 `function(…) {…}` 的形式创建的。建议在语句末尾加上分号 `;`，它不是函数语法的一部分。\n\n分号用于更简单的赋值，例如 `let sayHi = 5;`，它也用于函数赋值。\n````\n\n## 回调函数\n\n让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。\n\n我们写一个包含三个参数的函数 `ask(question, yes, no)`：\n\n`question`\n: 关于问题的文本\n\n`yes`\n: 当回答为 \"Yes\" 时，要运行的脚本\n\n`no`\n: 当回答为 \"No\" 时，要运行的脚本\n\n函数需要提出 `question`（问题），并根据用户的回答，调用 `yes()` 或 `no()`：\n\n```js run\n*!*\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n*/!*\n\nfunction showOk() {\n  alert( \"You agreed.\" );\n}\n\nfunction showCancel() {\n  alert( \"You canceled the execution.\" );\n}\n\n// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask\nask(\"Do you agree?\", showOk, showCancel);\n```\n\n在实际开发中，这样的函数是非常有用的。实际开发与上述示例最大的区别是，实际开发中的函数会通过更加复杂的方式与用户进行交互，而不是通过简单的 `confirm`。在浏览器中，这样的函数通常会绘制一个漂亮的提问窗口。但这是另外一件事了。\n\n`ask` 的两个参数值 `showOk` 和 `showCancel` 可以被称为 **回调函数** 或简称 **回调**。\n\n主要思想是我们传递一个函数，并期望在稍后必要时将其“回调”。在我们的例子中，`showOk` 是回答 \"yes\" 的回调，`showCancel` 是回答 \"no\" 的回调。\n\n我们可以使用函数表达式来编写一个等价的、更简洁的函数：\n\n```js run no-beautify\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\n*!*\nask(\n  \"Do you agree?\",\n  function() { alert(\"You agreed.\"); },\n  function() { alert(\"You canceled the execution.\"); }\n);\n*/!*\n```\n\n这里直接在 `ask(...)` 调用内进行函数声明。这两个函数没有名字，所以叫 **匿名函数**。这样的函数在 `ask` 外无法访问（因为没有对它们分配变量），不过这正是我们想要的。\n\n这样的代码在我们的脚本中非常常见，这正符合 JavaScript 语言的思想。\n\n```smart header=\"一个函数是表示一个“行为”的值\"\n字符串或数字等常规值代表 **数据**。\n\n函数可以被视为一个 **行为（action）**。\n\n我们可以在变量之间传递它们，并在需要时运行。\n```\n\n\n## 函数表达式 vs 函数声明\n\n让我们来总结一下函数声明和函数表达式之间的主要区别。\n\n首先是语法：如何通过代码对它们进行区分。\n\n- **函数声明**：在主代码流中声明为单独的语句的函数：\n\n    ```js\n    // 函数声明\n    function sum(a, b) {\n      return a + b;\n    }\n    ```\n- **函数表达式**：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 `=` 右侧创建的：\n    \n    ```js\n    // 函数表达式\n    let sum = function(a, b) {\n      return a + b;\n    };\n    ```\n\n更细微的差别是，JavaScript 引擎会在 **什么时候** 创建函数。\n\n**函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。**\n\n一旦代码执行到赋值表达式 `let sum = function…` 的右侧，此时就会开始创建该函数，并且可以从现在开始使用（分配，调用等）。\n\n函数声明则不同。\n\n**在函数声明被定义之前，它就可以被调用。**\n\n例如，一个全局函数声明对整个脚本来说都是可见的，无论它被写在这个脚本的哪个位置。\n\n这是内部算法的缘故。当 JavaScript **准备** 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。我们可以将其视为“初始化阶段”。\n\n在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。\n\n例如下面的代码会正常工作：\n\n```js run refresh untrusted\n*!*\nsayHi(\"John\"); // Hello, John\n*/!*\n\nfunction sayHi(name) {\n  alert( `Hello, ${name}` );\n}\n```\n\n函数声明 `sayHi` 是在 JavaScript 准备运行脚本时被创建的，在这个脚本的任何位置都可见。\n\n……如果它是一个函数表达式，它就不会工作：\n\n```js run refresh untrusted\n*!*\nsayHi(\"John\"); // error!\n*/!*\n\nlet sayHi = function(name) {  // (*) no magic any more\n  alert( `Hello, ${name}` );\n};\n```\n\n函数表达式在代码执行到它时才会被创建。只会发生在 `(*)` 行。为时已晚。\n\n函数声明的另外一个特殊的功能是它们的块级作用域。\n\n**严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。**\n\n例如，想象一下我们需要依赖于在代码运行过程中获得的变量 `age` 声明一个函数 `welcome()`。并且我们计划在之后的某个时间使用它。\n\n如果我们使用函数声明，则以下代码无法像预期那样工作：\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\n// 有条件地声明一个函数\nif (age < 18) {\n\n  function welcome() {\n    alert(\"Hello!\");\n  }\n\n} else {\n\n  function welcome() {\n    alert(\"Greetings!\");\n  }\n\n}\n\n// ……稍后使用\n*!*\nwelcome(); // Error: welcome is not defined\n*/!*\n```\n\n这是因为函数声明只在它所在的代码块中可见。\n\n下面是另一个例子：\n\n```js run\nlet age = 16; // 拿 16 作为例子\n\nif (age < 18) {\n*!*\n  welcome();               // \\   (运行)\n*/!*\n                           //  |\n  function welcome() {     //  |\n    alert(\"Hello!\");       //  |  函数声明在声明它的代码块内任意位置都可用\n  }                        //  |  \n                           //  |\n*!*\n  welcome();               // /   (运行)\n*/!*\n\n} else {\n\n  function welcome() {\n    alert(\"Greetings!\");\n  }\n}\n\n// 在这里，我们在花括号外部调用函数，我们看不到它们内部的函数声明。\n\n\n*!*\nwelcome(); // Error: welcome is not defined\n*/!*\n```\n\n我们怎么才能让 `welcome` 在 `if` 外可见呢？\n\n正确的做法是使用函数表达式，并将 `welcome` 赋值给在 `if` 外声明的变量，并具有正确的可见性。\n\n下面的代码可以如愿运行：\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome;\n\nif (age < 18) {\n\n  welcome = function() {\n    alert(\"Hello!\");\n  };\n\n} else {\n\n  welcome = function() {\n    alert(\"Greetings!\");\n  };\n\n}\n\n*!*\nwelcome(); // 现在可以了\n*/!*\n```\n\n或者我们可以使用问号运算符 `?` 来进一步对代码进行简化：\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome = (age < 18) ?\n  function() { alert(\"Hello!\"); } :\n  function() { alert(\"Greetings!\"); };\n\n*!*\nwelcome(); // 现在可以了\n*/!*\n```\n\n\n```smart header=\"什么时候选择函数声明与函数表达式？\"\n根据经验，当我们需要声明一个函数时，首先考虑函数声明语法。它能够为组织代码提供更多的灵活性。因为我们可以在声明这些函数之前调用这些函数。\n\n这对代码可读性也更好，因为在代码中查找 `function f(…) {…}` 比 `let f = function(…) {…}` 更容易。函数声明更“醒目”。\n\n……但是，如果由于某种原因而导致函数声明不适合我们（我们刚刚看过上面的例子），那么应该使用函数表达式。\n```\n\n## 总结\n\n- 函数是值。它们可以在代码的任何地方被分配，复制或声明。\n- 如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。\n- 如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。\n- 在执行代码块之前，内部算法会先处理函数声明。所以函数声明在其被声明的代码块内的任何位置都是可见的。\n- 函数表达式在执行流程到达时创建。\n\n在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。\n\n所以，仅当函数声明不适合对应的任务时，才应使用函数表达式。在本章中，我们已经看到了几个例子，以后还会看到更多的例子。",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1672928680
      }
    },
    "arrow-functions-basics": {
      "type": "Article",
      "value": {
        "title": "箭头函数，基础知识",
        "slug": "arrow-functions-basics",
        "githubPath": "/1-js/02-first-steps/17-arrow-functions-basics",
        "isFolder": false,
        "weight": 17,
        "content": "\n\n创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。\n\n它被称为“箭头函数”，因为它看起来像这样：\n\n```js\nlet func = (arg1, arg2, ..., argN) => expression;\n```\n\n这里创建了一个函数 `func`，它接受参数 `arg1..argN`，然后使用参数对右侧的 `expression` 求值并返回其结果。\n\n换句话说，它是下面这段代码的更短的版本：\n\n```js\nlet func = function(arg1, arg2, ..., argN) {\n  return expression;\n};\n```\n\n让我们来看一个具体的例子：\n\n```js run\nlet sum = (a, b) => a + b;\n\n/* 这个箭头函数是下面这个函数的更短的版本：\n\nlet sum = function(a, b) {\n  return a + b;\n};\n*/\n\nalert( sum(1, 2) ); // 3\n```\n\n可以看到 `(a, b) => a + b` 表示一个函数接受两个名为 `a` 和 `b` 的参数。在执行时，它将对表达式 `a + b` 求值，并返回计算结果。\n\n- 如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。\n\n    例如：\n\n    ```js run\n    *!*\n    let double = n => n * 2;\n    // 差不多等同于：let double = function(n) { return n * 2 }\n    */!*\n\n    alert( double(3) ); // 6\n    ```\n\n- 如果没有参数，括号则是空的（但括号必须保留）：\n\n    ```js run\n    let sayHi = () => alert(\"Hello!\");\n\n    sayHi();\n    ```\n\n箭头函数可以像函数表达式一样使用。\n\n例如，动态创建一个函数：\n\n```js run\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome = (age < 18) ?\n  () => alert('Hello!') :\n  () => alert(\"Greetings!\");\n\nwelcome();\n```\n\n一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。\n\n箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。\n\n## 多行的箭头函数\n\n到目前为止，我们看到的箭头函数非常简单。它们从 `=>` 的左侧获取参数，计算并返回右侧表达式的计算结果。\n\n有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 `return` 才能返回值（就像常规函数一样）。\n\n就像这样：\n\n```js run\nlet sum = (a, b) => {  // 花括号表示开始一个多行函数\n  let result = a + b;\n*!*\n  return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return”\n*/!*\n};\n\nalert( sum(1, 2) ); // 3\n```\n\n```smart header=\"更多内容\"\n在这里，我们赞扬了箭头函数的简洁性。但还不止这些！\n\n箭头函数还有其他有趣的特性。\n\n为了更深入地学习它们，我们首先需要了解一些 JavaScript 其他方面的知识，因此我们将在后面的 <info:arrow-functions> 一章中再继续研究箭头函数。\n\n现在，我们已经可以用箭头函数进行单行行为和回调了。\n```\n\n## 总结\n\n箭头函数对于简单的操作很方便，特别是对于单行的函数。它具体有两种形式：\n\n1. 不带花括号：`(...args) => expression` —— 右侧是一个表达式：函数计算表达式并返回其结果。如果只有一个参数，则可以省略括号，例如 `n => n*2`。\n2. 带花括号：`(...args) => { body }` —— 花括号允许我们在函数中编写多个语句，但是我们需要显式地 `return` 来返回一些内容。",
        "libs": [],
        "children": [
          "rewrite-arrow"
        ],
        "parent": "first-steps",
        "updatedAt": 1652676820
      }
    },
    "rewrite-arrow": {
      "type": "Task",
      "value": {
        "title": "用箭头函数重写",
        "slug": "rewrite-arrow",
        "githubPath": "/1-js/02-first-steps/17-arrow-functions-basics/1-rewrite-arrow",
        "weight": 1,
        "libs": [],
        "content": "\n\n用箭头函数重写下面的函数表达式：\n\n```js run\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes();\n  else no();\n}\n\nask(\n  \"Do you agree?\",\n  function() { alert(\"You agreed.\"); },\n  function() { alert(\"You canceled the execution.\"); }\n);\n```",
        "solution": "```js run\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes();\n  else no();\n}\n\nask(\n  \"Do you agree?\",\n*!*\n  () => alert(\"You agreed.\"),\n  () => alert(\"You canceled the execution.\")\n*/!*\n);\n```\n\n是不是看起来精简多了？",
        "parent": "arrow-functions-basics",
        "version": 1
      }
    },
    "javascript-specials": {
      "type": "Article",
      "value": {
        "title": "JavaScript 特性",
        "slug": "javascript-specials",
        "githubPath": "/1-js/02-first-steps/18-javascript-specials",
        "isFolder": false,
        "weight": 18,
        "content": "\n\n本章简要回顾我们到现在为止学到的 JavaScript 特性，并特别注意了一些细节。\n\n## 代码结构\n\n语句用分号分隔：\n\n```js run no-beautify\nalert('Hello'); alert('World');\n```\n\n通常，换行符也被视为分隔符，因此下面的例子也能正常运行：\n\n```js run no-beautify\nalert('Hello')\nalert('World')\n```\n\n这就是所谓的「自动分号插入」。但有时它不起作用，例如：\n\n```js run\nalert(\"There will be an error after this message\")\n\n[1, 2].forEach(alert)\n```\n\n大多数代码风格指南都认为我们应该在每个语句后面都加上分号。\n\n在代码块 `{...}` 后以及有代码块的语法结构（例如循环）后不需要加分号：\n\n```js\nfunction f() {\n  // 函数声明后不需要加分号\n}\n\nfor(;;) {\n  // 循环语句后不需要加分号\n}\n```\n\n……但即使我们在某处添加了「额外的」分号，这也不是错误。分号会被忽略的。\n\n更多内容：<info:structure>。\n\n## 严格模式\n\n为了完全启用现代 JavaScript 的所有特性，我们应该在脚本顶部写上 `\"use strict\"` 指令。\n\n```js\n'use strict';\n\n...\n```\n\n该指令必须位于 JavaScript 脚本的顶部或函数体的开头。\n\n如果没有 `\"use strict\"`，所有东西仍可以正常工作，但某些功能将以老式的“兼容”方式运行。我们通常更喜欢现代的方式。\n\n语言的一些现代特征（比如我们将来要学习的类）会隐式地启用严格模式。\n\n更多内容：<info:strict-mode>。\n\n## 变量\n\n可以使用以下方式声明变量：\n\n- `let`\n- `const`（不变的，不能被改变）\n- `var`（旧式的，稍后会看到）\n\n一个变量名可以由以下组成：\n- 字母和数字，但是第一个字符不能是数字。\n- 字符 `$` 和 `_` 是允许的，用法同字母。\n- 非拉丁字母和象形文字也是允许的，但通常不会使用。\n\n变量是动态类型的，它们可以存储任何值：\n\n```js\nlet x = 5;\nx = \"John\";\n```\n\n有 8 种数据类型：\n\n- `number` — 可以是浮点数，也可以是整数，\n- `bigint` — 用于任意长度的整数，\n- `string` — 字符串类型，\n- `boolean` — 逻辑值：`true/false`，\n- `null` — 具有单个值 `null` 的类型，表示“空”或“不存在”，\n- `undefined` — 具有单个值 `undefined` 的类型，表示“未分配（未定义）”，\n- `object` 和 `symbol` — 对于复杂的数据结构和唯一标识符，我们目前还没学习这个类型。\n\n`typeof` 运算符返回值的类型，但有两个例外：\n```js\ntypeof null == \"object\" // JavaScript 编程语言的设计错误\ntypeof function(){} == \"function\" // 函数被特殊对待\n```\n\n更多内容：<info:variables> 和 <info:types>。\n\n## 交互\n\n我们使用浏览器作为工作环境，所以基本的 UI 功能将是：\n\n[`prompt(question[, default])`](mdn:api/Window/prompt)\n: 提出一个问题 `question`，并返回访问者输入的内容，如果他按下「取消」则返回 `null`。\n\n[`confirm(question)`](mdn:api/Window/confirm)\n: 提出一个问题 `question`，并建议用户在“确定”和“取消”之间进行选择。选择结果以 `true/false` 形式返回。\n\n[`alert(message)`](mdn:api/Window/alert)\n: 输出一个消息 `message`。\n\n这些函数都会产生 **模态框**，它们会暂停代码执行并阻止访问者与页面的其他部分进行交互，直到用户做出回答为止。\n\n举个例子：\n\n```js run\nlet userName = prompt(\"Your name?\", \"Alice\");\nlet isTeaWanted = confirm(\"Do you want some tea?\");\n\nalert( \"Visitor: \" + userName ); // Alice\nalert( \"Tea wanted: \" + isTeaWanted ); // true\n```\n\n更多内容：<info:alert-prompt-confirm>。\n\n## 运算符\n\nJavaScript 支持以下运算符：\n\n算数运算符\n: 常规的：`+ - * /`（加减乘除），取余运算符 `%` 和幂运算符 `**`。\n\n    二进制加号 `+` 可以连接字符串。如果任何一个操作数是一个字符串，那么另一个操作数也将被转换为字符串：\n\n    ```js run\n    alert( '1' + 2 ); // '12'，字符串\n    alert( 1 + '2' ); // '12'，字符串\n    ```\n\n赋值\n: 简单的赋值：`a = b` 和合并了其他操作的赋值：`a *= 2`。\n\n按位运算符\n: 按位运算符在最低位级上操作 32 位的整数：详见 [文档](mdn:/JavaScript/Guide/Expressions_and_Operators#bitwise_operators)。\n\n三元运算符\n: 唯一具有三个参数的操作：`cond ? resultA : resultB`。如果 `cond` 为真，则返回 `resultA`，否则返回 `resultB`。\n\n逻辑运算符\n: 逻辑与 `&&` 和或 `||` 执行短路运算，然后返回运算停止处的值（`true`/`false` 不是必须的）。逻辑非 `!` 将操作数转换为布尔值并返回其相反的值。\n\n空值合并运算符\n: `??` 运算符从一列变量中，选取值为已定义的值（defined value）的变量。`a ?? b` 的结果是 `a`，除非 `a` 为 `null/undefined`，这时结果是 `b`。\n\n比较运算符\n: 对不同类型的值进行相等检查时，运算符 `==` 会将不同类型的值转换为数字（除了 `null` 和 `undefined`，它们彼此相等而没有其他情况），所以下面的例子是相等的：\n\n    ```js run\n    alert( 0 == false ); // true\n    alert( 0 == '' ); // true\n    ```\n\n    其他比较也将转换为数字。\n\n    严格相等运算符 `===` 不会进行转换：不同的类型总是指不同的值。\n\n    值 `null` 和 `undefined` 是特殊的：它们只在 `==` 下相等，且不相等于其他任何值。\n\n    大于/小于比较，在比较字符串时，会按照字符顺序逐个字符地进行比较。其他类型则被转换为数字。\n\n其他运算符\n: 还有很少一部分其他运算符，如逗号运算符。\n\n更多内容：<info:operators>，<info:comparison>，<info:logical-operators>，<info:nullish-coalescing-operator>。\n\n## 循环\n\n- 我们涵盖了 3 种类型的循环：\n\n    ```js\n    // 1\n    while (condition) {\n      ...\n    }\n\n    // 2\n    do {\n      ...\n    } while (condition);\n\n    // 3\n    for(let i = 0; i < 10; i++) {\n      ...\n    }\n    ```\n\n- 在 `for(let...)` 循环内部声明的变量，只在该循环内可见。但我们也可以省略 `let` 并重用已有的变量。\n- 指令 `break/continue` 允许退出整个循环/当前迭代。使用标签来打破嵌套循环。\n\n更多内容：<info:while-for>。\n\n稍后我们将学习更多类型的循环来处理对象。\n\n## \"switch\" 结构\n\n\"switch\" 结构可以替代多个 `if` 检查。它内部使用 `===`（严格相等）进行比较。\n\n例如：\n\n```js run\nlet age = prompt('Your age?', 18);\n\nswitch (age) {\n  case 18:\n    alert(\"Won't work\"); // prompt 的结果是一个字符串，而不是数字\n    break;\n\n  case \"18\":\n    alert(\"This works!\");\n    break;\n\n  default:\n    alert(\"Any value not equal to one above\");\n}\n```\n\n详情请见：<info:switch>。\n\n## 函数\n\n我们介绍了三种在 JavaScript 中创建函数的方式：\n\n1. 函数声明：主代码流中的函数\n\n    ```js\n    function sum(a, b) {\n      let result = a + b;\n\n      return result;\n    }\n    ```\n\n2. 函数表达式：表达式上下文中的函数\n\n    ```js\n    let sum = function(a, b) {\n      let result = a + b;\n\n      return result;\n    }\n    ```\n\n3. 箭头函数：\n\n    ```js\n    // 表达式在右侧\n    let sum = (a, b) => a + b;\n\n    // 或带 {...} 的多行语法，此处需要 return：\n    let sum = (a, b) => {\n      // ...\n      return a + b;\n    }\n\n    // 没有参数\n    let sayHi = () => alert(\"Hello\");\n\n    // 有一个参数\n    let double = n => n * 2;\n    ```\n\n\n- 函数可能具有局部变量：在函数内部声明的变量，或在其参数列表中。这类变量只在函数内部可见。\n- 参数可以有默认值：`function sum(a = 1, b = 2) {...}`。\n- 函数总是返回一些东西。如果没有 `return` 语句，那么返回的结果是 `undefined`。\n\n详细内容：请见 <info:function-basics>，<info:arrow-functions-basics>。\n\n## 更多内容\n\n这些是 JavaScript 特性的简要概述。截至目前，我们仅仅学习了基础知识。随着教程的深入，你会发现 JavaScript 的更多特性和高级特性。",
        "libs": [],
        "children": [],
        "parent": "first-steps",
        "updatedAt": 1670644433
      }
    },
    "code-quality": {
      "type": "Article",
      "value": {
        "title": "代码质量",
        "slug": "code-quality",
        "githubPath": "/1-js/03-code-quality",
        "isFolder": true,
        "weight": 3,
        "content": "\n\n本章介绍了我们将在开发中进一步使用的编码实践。",
        "libs": [],
        "children": [
          "debugging-chrome",
          "coding-style",
          "comments",
          "ninja-code",
          "testing-mocha",
          "polyfills"
        ],
        "parent": "js"
      }
    },
    "debugging-chrome": {
      "type": "Article",
      "value": {
        "title": "在浏览器中调试",
        "slug": "debugging-chrome",
        "githubPath": "/1-js/03-code-quality/01-debugging-chrome",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n在编写更复杂的代码前，让我们先来聊聊调试吧。\n\n[调试](https://en.wikipedia.org/wiki/Debugging) 是指在一个脚本中找出并修复错误的过程。所有的现代浏览器和大多数其他环境都支持调试工具 —— 开发者工具中的一个令调试更加容易的特殊用户界面。它也可以让我们一步步地跟踪代码以查看当前实际运行情况。\n\n在这里我们将会使用 Chrome（谷歌浏览器），因为它拥有足够多的功能，其他大部分浏览器的功能也与之类似。\n\n## “资源（Sources）”面板\n\n你的 Chrome 版本可能看起来有一点不同，但是它应该还是处于很明显的位置。\n\n- 在 Chrome 中打开 [示例页面](debugging/index.html)。\n- 使用快捷键 `key:F12`（Mac：`key:Cmd+Opt+I`）打开开发者工具。\n- 选择 `Sources（资源）` 面板。\n\n如果你是第一次这么做，那你应该会看到下面这个样子：\n\n![](chrome-open-sources.svg)\n\n切换按钮 <span class=\"devtools\" style=\"background-position:-172px -98px\"></span> 会打开文件列表的选项卡。\n\n让我们在预览树中点击和选择 `hello.js`。这里应该会如下图所示：\n\n![](chrome-tabs.svg)\n\n资源（Sources）面板包含三个部分：\n\n1. **文件导航（File Navigator）** 区域列出了 HTML、JavaScript、CSS 和包括图片在内的其他依附于此页面的文件。Chrome 扩展程序也会显示在这。\n2. **代码编辑（Code Editor）** 区域展示源码。\n3. **JavaScript 调试（JavaScript Debugging）** 区域是用于调试的，我们很快就会来探索它。\n\n现在你可以再次点击切换按钮 <span class=\"devtools\" style=\"background-position:-172px -122px\"></span> 隐藏资源列表来给代码腾出一些空间。\n\n## 控制台（Console）\n\n如果我们按下 `key:Esc`，下面会出现一个控制台，我们可以输入一些命令然后按下 `key:Enter` 来执行。\n\n语句执行完毕之后，其执行结果会显示在下面。\n\n例如，`1+2` 将会返回 `3`，而 `hello(\"debugger\")` 函数调用什么也没返回，所以结果是 `undefined`：\n\n![](chrome-sources-console.svg)\n\n## 断点（Breakpoints）\n\n我们来看看 [示例页面](debugging/index.html) 发生了什么。在 `hello.js` 中，点击第 `4` 行。是的，就点击数字 `\"4\"` 上，不是点击代码。\n\n恭喜你！你已经设置了一个断点。现在，请在第 `8` 行的数字上也点击一下。\n\n看起来应该是这样的（蓝色是你应该点击的地方）：\n\n![](chrome-sources-breakpoint.svg)\n\n**断点** 是调试器会自动暂停 JavaScript 执行的地方。\n\n当代码被暂停时，我们可以检查当前的变量，在控制台执行命令等等。换句话说，我们可以调试它。\n\n我们总是可以在右侧的面板中找到断点的列表。当我们在数个文件中有许多断点时，这是非常有用的。它允许我们：\n- 快速跳转至代码中的断点（通过点击右侧面板中的对应的断点）。\n- 通过取消选中断点来临时禁用对应的断点。\n- 通过右键单击并选择移除来删除一个断点。\n- ……等等。\n\n```smart header=\"条件断点\"\n在行号上 **右键单击** 允许你创建一个 **条件** 断点。只有当给定的表达式（你创建条件断点时提供的表达式）为真时才会被触发。\n\n当我们需要在特定的变量值或参数的情况下暂停程序执行时，这种调试方法就很有用了。\n```\n\n## \"debugger\" 命令\n\n我们也可以使用 `debugger` 命令来暂停代码，像这样：\n\n```js\nfunction hello(name) {\n  let phrase = `Hello, ${name}!`;\n\n*!*\n  debugger;  // <-- 调试器会在这停止\n*/!*\n\n  say(phrase);\n}\n```\n\n这样的命令只有在开发者工具打开时才有效，否则浏览器会忽略它。\n\n## 暂停并查看\n\n在我们的例子中，`hello()` 函数在页面加载期间被调用，因此激活调试器的最简单的方法（在我们已经设置了断点后）就是 —— 重新加载页面。因此让我们按下 `key:F5`（Windows，Linux）或 `key:Cmd+R`（Mac）吧。\n\n设置断点之后，程序会在第 4 行暂停执行：\n\n![](chrome-sources-debugger-pause.svg)\n\n请打开右侧的信息下拉列表（箭头指示出的地方）。这里允许你查看当前的代码状态：\n\n1. **`察看（Watch）` —— 显示任意表达式的当前值。**\n\n    你可以点击加号 `+` 然后输入一个表达式。调试器将显示它的值，并在执行过程中自动重新计算该表达式。\n\n2. **`调用栈（Call Stack）` —— 显示嵌套的调用链。**\n\n    此时，调试器正在 `hello()` 的调用链中，被 `index.html` 中的一个脚本调用（这里没有函数，因此显示 \"anonymous\"）\n\n    如果你点击了一个堆栈项，调试器将跳到对应的代码处，并且还可以查看其所有变量。\n3. **`作用域（Scope）` —— 显示当前的变量。**\n\n    `Local` 显示当前函数中的变量，你还可以在源代码中看到它们的值高亮显示了出来。\n\n    `Global` 显示全局变量（不在任何函数中）。\n\n    这里还有一个 `this` 关键字，目前我们还没有学到它，不过我们很快就会学习它了。\n\n## 跟踪执行\n\n现在是 **跟踪** 脚本的时候了。\n\n在右侧面板的顶部是一些关于跟踪脚本的按钮。让我们来使用它们吧。\n<!-- https://github.com/ChromeDevTools/devtools-frontend/blob/master/front_end/Images/src/largeIcons.svg -->\n<span class=\"devtools\" style=\"background-position:-146px -168px\"></span> —— “恢复（Resume）”：继续执行，快捷键 `key:F8`。\n: 继续执行。如果没有其他的断点，那么程序就会继续执行，并且调试器不会再控制程序。\n\n    我们点击它一下之后，我们会看到这样的情况：\n\n    ![](chrome-sources-debugger-trace-1.svg)\n\n    执行恢复了，执行到 `say()` 函数中的另外一个断点后暂停在了那里。看一下右边的 \"Call stack\"。它已经增加了一个调用信息。我们现在在 `say()` 里面。\n\n<span class=\"devtools\" style=\"background-position:-200px -190px\"></span> —— “下一步（Step）”：运行下一条（即当前行）指令，快捷键 `key:F9`。\n: 运行下一条语句。如果我们现在点击它，`alert` 会被显示出来。\n\n    一次接一次地点击此按钮，整个脚本的所有语句会被逐个执行。\n\n<span class=\"devtools\" style=\"background-position:-62px -192px\"></span> —— “跨步（Step over）”：运行下一条（即当前行）指令，但 **不会进入到一个函数中**，快捷键 `key:F10`。\n: 跟上一条命令“下一步（Step）”类似，但如果下一条语句是函数调用则表现不同。这里的函数指的是：不是内建的如 `alert` 函数等，而是我们自己写的函数。\n\n    如果我们对比一下，“下一步（Step）”命令会进入嵌套函数调用并在其第一行暂停执行，而“跨步（Step over）”对我们不可见地执行嵌套函数调用，跳过了函数内部。\n\n    执行会在该函数调用后立即暂停。\n\n    如果我们对该函数的内部执行不感兴趣，这命令会很有用。\n\n<span class=\"devtools\" style=\"background-position:-4px -194px\"></span> —— “步入（Step into）”，快捷键 `key:F11`。\n: 和“下一步（Step）”类似，但在异步函数调用情况下表现不同。如果你刚刚才开始学 JavaScript，那么你可以先忽略此差异，因为我们还没有用到异步调用。\n\n    至于之后，只需要记住“下一步（Step）”命令会忽略异步行为，例如 `setTimeout`（计划的函数调用），它会过一段时间再执行。而“步入（Step into）”会进入到代码中并等待（如果需要）。详见 [DevTools 手册](https://developers.google.com/web/updates/2018/01/devtools#async)。\n\n<span class=\"devtools\" style=\"background-position:-32px -194px\"></span> —— “步出（Step out）”：继续执行到当前函数的末尾，快捷键 `key:Shift+F11`。\n: 继续执行当前函数内的剩余代码，并暂停在调用当前函数的下一行代码处。当我们使用 <span class=\"devtools\" style=\"background-position:-200px -190px\"></span> 偶然地进入到一个嵌套调用，但是我们又对这个函数不感兴趣时，我们想要尽可能的继续执行到最后的时候是非常方便的。\n\n<span class=\"devtools\" style=\"background-position:-61px -74px\"></span> —— 启用/禁用所有的断点。\n: 这个按钮不会影响程序的执行。只是一个批量操作断点的开/关。\n\n<span class=\"devtools\" style=\"background-position:-90px -146px\"></span> —— 启用/禁用出现错误时自动暂停脚本执行。\n: 当启动此功能，如果开发者工具是打开着的时候，任何脚本执行错误都会导致该脚本执行自动暂停。然后我们可以在调试器中分析变量来看一下什么出错了。因此如果我们的脚本因为错误挂掉的时候，我们可以打开调试器，启用这个选项然后重载页面，查看一下哪里导致它挂掉了和当时的上下文是什么。\n\n```smart header=\"Continue to here\"\n在代码中的某一行上右键，在显示的关联菜单（context menu）中点击一个非常有用的名为 \"Continue to here\" 的选项。\n\n当你想要向前移动很多步到某一行为止，但是又懒得设置一个断点时非常的方便。\n```\n\n## 日志记录\n\n想要输出一些东西到控制台上？`console.log` 函数可以满足你。\n\n例如：将从 `0` 到 `4` 的值输出到控制台上：\n\n```js run\n// 打开控制台来查看\nfor (let i = 0; i < 5; i++) {\n  console.log(\"value\", i);\n}\n```\n\n普通用户看不到这个输出，它是在控制台里面的。要想看到它 —— 要么打开开发者工具中的 Console（控制台）选项卡，要么在一个其他的选项卡中按下 `key:Esc`：这会在下方打开一个控制台。\n\n如果我们在代码中有足够的日志记录，那么我们可以从记录中看到刚刚发生了什么，而不需要借助调试器。\n\n## 总结\n\n我们可以看到，这里有 3 种方式来暂停一个脚本：\n1. 断点。\n2. `debugger` 语句。\n3. error（如果开发者工具是打开状态，并且按钮 <span class=\"devtools\" style=\"background-position:-90px -146px\"></span> 是开启的状态）。\n\n当脚本执行暂停时，我们就可以进行调试：检查变量，跟踪代码来查看执行出错的位置。\n\n开发人员工具中的选项比本文介绍的多得多。完整的手册请点击这个链接查看：<https://developers.google.com/web/tools/chrome-devtools>。\n\n本章节的内容足够让你上手代码调试了，但是之后，尤其是你做了大量关于浏览器的东西后，推荐你查看上面那个链接中讲的开发者工具更高级的功能。\n\n对了，你也可以点击开发者工具中的其他地方来看一下会显示什么。这可能是你学习开发者工具最快的方式了。不要忘了还有右键单击和关联菜单哟。",
        "libs": [],
        "children": [],
        "headHtml": "<style>\nspan.devtools {\n  display: inline-block;\n  background-image: url(/article/debugging-chrome/largeIcons.svg);\n  height:18px;\n  width:18px;\n}\n</style>\n",
        "parent": "code-quality",
        "updatedAt": 1670931120
      }
    },
    "coding-style": {
      "type": "Article",
      "value": {
        "title": "代码风格",
        "slug": "coding-style",
        "githubPath": "/1-js/03-code-quality/02-coding-style",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n我们的代码必须尽可能的清晰和易读。\n\n这实际上是一种编程艺术 —— 以一种正确并且人们易读的方式编码来完成一个复杂的任务。一个良好的代码风格大大有助于实现这一点。\n\n## 语法\n\n下面是一个备忘单，其中列出了一些建议的规则（详情请参阅下文）：\n\n![](code-style.svg)\n<!--\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", \"\");\nlet n = prompt(\"n?\", \"\");\n\nif (n < 0) {\n  alert(`Power ${n} is not supported,\n    please enter a non-negative integer number`);\n} else {\n  alert( pow(x, n) );\n}\n```\n\n-->\n\n现在，让我们详细讨论一下这些规则和它们的原因吧。\n\n```warn header=\"没有什么规则是“必须”的\"\n没有什么规则是“刻在石头上”的。这些是风格偏好，而不是宗教教条。\n```\n\n### 花括号\n\n在大多数的 JavaScript 项目中，花括号以 \"Egyptian\" 风格（译注：\"egyptian\" 风格又称 K&R 风格 —— 代码段的开括号位于一行的末尾，而不是另起一行的风格）书写，左花括号与相应的关键词在同一行上 —— 而不是新起一行。左括号前还应该有一个空格，如下所示：\n\n```js\nif (condition) {\n  // do this\n  // ...and that\n  // ...and that\n}\n```\n\n单行构造（如 `if (condition) doSomething()`）也是一个重要的用例。我们是否应该使用花括号？如果是，那么在哪里？\n\n下面是这几种情况的注释，你可以自己判断一下它们的可读性：\n\n1. 😠 初学者常这样写。非常不好！这里不需要花括号：\n    ```js\n    if (n < 0) *!*{*/!*alert(`Power ${n} is not supported`);*!*}*/!*\n    ```\n2. 😠 拆分为单独的行，不带花括号。永远不要这样做，添加新行很容易出错：\n    ```js\n    if (n < 0)\n      alert(`Power ${n} is not supported`);\n    ```\n3. 😏 写成一行，不带花括号 —— 如果短的话，也是可以的：\n    ```js\n    if (n < 0) alert(`Power ${n} is not supported`);\n    ```\n4. 😃 最好的方式：\n    ```js\n    if (n < 0) {\n      alert(`Power ${n} is not supported`);\n    }\n    ```\n\n对于很短的代码，写成一行是可以接受的：例如 `if (cond) return null`。但是代码块（最后一个示例）通常更具可读性。\n\n### 行的长度\n\n没有人喜欢读一长串代码，最好将代码分割一下。\n\n例如：\n```js\n// 回勾引号 ` 允许将字符串拆分为多行\nlet str = `\n  ECMA International's TC39 is a group of JavaScript developers,\n  implementers, academics, and more, collaborating with the community\n  to maintain and evolve the definition of JavaScript.\n`;\n```\n\n对于 `if` 语句：\n\n```js\nif (\n  id === 123 &&\n  moonPhase === 'Waning Gibbous' &&\n  zodiacSign === 'Libra'\n) {\n  letTheSorceryBegin();\n}\n```\n\n一行代码的最大长度应该在团队层面上达成一致。通常是 80 或 120 个字符。\n\n### 缩进\n\n有两种类型的缩进：\n\n- **水平方向上的缩进：2 或 4 个空格。**\n\n    一个水平缩进通常由 2 或 4 个空格或者 \"Tab\" 制表符（`key:Tab` 键）构成。选择哪一个方式是一场古老的圣战。如今空格更普遍一点。\n\n    选择空格而不是 tabs 的优点之一是，这允许你做出比 “Tab” 制表符更加灵活的缩进配置。\n\n    例如，我们可以将参数与左括号对齐，像下面这样：\n\n    ```js no-beautify\n    show(parameters,\n         aligned, // 左边有 5 个空格\n         one,\n         after,\n         another\n      ) {\n      // ...\n    }\n    ```\n\n- **垂直方向上的缩进：用于将代码拆分成逻辑块的空行。**\n\n    即使是单个函数通常也被分割为数个逻辑块。在下面的示例中，初始化的变量、主循环结构和返回值都被垂直分割了：\n\n    ```js\n    function pow(x, n) {\n      let result = 1;\n      //              <--\n      for (let i = 0; i < n; i++) {\n        result *= x;\n      }\n      //              <--\n      return result;\n    }\n    ```\n\n    插入一个额外的空行有助于使代码更具可读性。写代码时，不应该出现连续超过 9 行都没有被垂直分割的代码。\n\n### 分号\n\n每一个语句后面都应该有一个分号。即使它可以被跳过。\n\n有一些编程语言的分号确实是可选的，那些语言中也很少使用分号。但是在 JavaScript 中，极少数情况下，换行符有时不会被解释为分号，这时代码就容易出错。更多内容请参阅 <info:structure#semicolon> 一章的内容。\n\n如果你是一个有经验的 JavaScript 程序员，你可以选择像 [StandardJS](https://standardjs.com/) 这样的无分号的代码风格。否则，最好使用分号以避免可能出现的陷阱。大多数开发人员都应该使用分号。\n\n### 嵌套的层级\n\n尽量避免代码嵌套层级过深。\n\n例如，在循环中，有时候使用 [`continue`](info:while-for#continue) 指令以避免额外的嵌套是一个好主意。\n\n例如，不应该像下面这样添加嵌套的 `if` 条件：\n\n```js\nfor (let i = 0; i < 10; i++) {\n  if (cond) {\n    ... // <- 又一层嵌套\n  }\n}\n```\n\n我们可以这样写：\n\n```js\nfor (let i = 0; i < 10; i++) {\n  if (!cond) *!*continue*/!*;\n  ...  // <- 没有额外的嵌套\n}\n```\n\n使用 `if/else` 和 `return` 也可以做类似的事情。\n\n例如，下面的两个结构是相同的。\n\n第一个：\n\n```js\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n  } else {\n    let result = 1;\n\n    for (let i = 0; i < n; i++) {\n      result *= x;\n    }\n\n    return result;\n  }\n}\n```\n\n第二个：\n\n```js\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n    return;\n  }\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\n但是第二个更具可读性，因为 `n < 0` 这个“特殊情况”在一开始就被处理了。一旦条件通过检查，代码执行就可以进入到“主”代码流，而不需要额外的嵌套。\n\n## 函数位置\n\n如果你正在写几个“辅助”函数和一些使用它们的代码，那么有三种方式来组织这些函数。\n\n1. 在调用这些函数的代码的 **上方** 声明这些函数：\n\n    ```js\n    // *!*函数声明*/!*\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n\n    // *!*调用函数的代码*/!*\n    let elem = createElement();\n    setHandler(elem);\n    walkAround();\n    ```\n2. 先写调用代码，再写函数\n\n    ```js\n    // *!*调用函数的代码*/!*\n    let elem = createElement();\n    setHandler(elem);\n    walkAround();\n\n    // --- *!*辅助函数*/!* ---\n    function createElement() {\n      ...\n    }\n\n    function setHandler(elem) {\n      ...\n    }\n\n    function walkAround() {\n      ...\n    }\n    ```\n3. 混合：在第一次使用一个函数时，对该函数进行声明。\n\n大多数情况下，第二种方式更好。\n\n这是因为阅读代码时，我们首先想要知道的是“它做了什么”。如果代码先行，那么在整个程序的最开始就展示出了这些信息。之后，可能我们就不需要阅读这些函数了，尤其是它们的名字清晰地展示出了它们的功能的时候。\n\n## 风格指南\n\n风格指南包含了“如何编写”代码的通用规则，例如：使用哪个引号、用多少空格来缩进、一行代码最大长度等非常多的细节。\n\n当团队中的所有成员都使用相同的风格指南时，代码看起来将是统一的。无论是团队中谁写的，都是一样的风格。\n\n当然，一个团队可以制定他们自己的风格指南，但是没必要这样做。现在已经有了很多制定好的代码风格指南可供选择。\n\n一些受欢迎的选择：\n\n- [Google JavaScript 风格指南](https://google.github.io/styleguide/jsguide.html)\n- [Airbnb JavaScript 风格指南](https://github.com/airbnb/javascript)\n- [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js)\n- [StandardJS](https://standardjs.com/)\n- 还有很多……\n\n如果你是一个初学者，你可以从本章中上面的内容开始。然后你可以浏览其他风格指南，并选择一个你最喜欢的。\n\n## 自动检查器\n\n检查器（Linters）是可以自动检查代码样式，并提出改进建议的工具。\n\n它们的妙处在于进行代码风格检查时，还可以发现一些代码错误，例如变量或函数名中的错别字。因此，即使你不想坚持某一种特定的代码风格，我也建议你安装一个检查器。\n\n下面是一些最出名的代码检查工具：\n\n- [JSLint](https://www.jslint.com/) —— 第一批检查器之一。\n- [JSHint](https://www.jshint.com/) —— 比 JSLint 多了更多设置。\n- [ESLint](https://eslint.org/) —— 应该是最新的一个。\n\n它们都能够做好代码检查。我使用的是 [ESLint](https://eslint.org/)。\n\n大多数检查器都可以与编辑器集成在一起：只需在编辑器中启用插件并配置代码风格即可。\n\n例如，要使用 ESLint 你应该这样做：\n\n1. 安装 [Node.JS](https://nodejs.org/)。\n2. 使用 `npm install -g eslint` 命令（npm 是一个 JavaScript 包安装工具）安装 ESLint。\n3. 在你的 JavaScript 项目的根目录（包含该项目的所有文件的那个文件夹）创建一个名为 `.eslintrc` 的配置文件。\n4. 在集成了 ESLint 的编辑器中安装/启用插件。大多数编辑器都有这个选项。\n\n下面是一个 `.eslintrc` 文件的例子：\n\n```js\n{\n  \"extends\": \"eslint:recommended\",\n  \"env\": {\n    \"browser\": true,\n    \"node\": true,\n    \"es6\": true\n  },\n  \"rules\": {\n    \"no-console\": 0,\n    \"indent\": 2\n  }\n}\n```\n\n这里的 `\"extends\"` 指令表示我们是基于 \"eslint:recommended\" 的设置项而进行设置的。之后，我们制定我们自己的规则。\n\n你也可以从网上下载风格规则集并进行扩展。有关安装的更多详细信息，请参见 <https://eslint.org/docs/user-guide/getting-started>。\n\n此外，某些 IDE 有内建的检查器，这非常方便，但是不像 ESLint 那样可自定义。\n\n## 总结\n\n本章描述的（和提到的代码风格指南中的）所有语法规则，都旨在帮助你提高代码可读性。它们都是值得商榷的。\n\n当我们思考如何写“更好”的代码的时候，我们应该问自己的问题是：“什么可以让代码可读性更高，更容易被理解？”和“什么可以帮助我们避免错误？”这些是我们讨论和选择代码风格时要牢记的主要原则。\n\n阅读流行的代码风格指南，可以帮助你了解有关代码风格的变化趋势和最佳实践的最新想法。",
        "libs": [],
        "children": [
          "style-errors"
        ],
        "parent": "code-quality",
        "updatedAt": 1657782904
      }
    },
    "style-errors": {
      "type": "Task",
      "value": {
        "title": "不好的风格",
        "slug": "style-errors",
        "githubPath": "/1-js/03-code-quality/02-coding-style/1-style-errors",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\n\n下面的代码风格有什么问题？\n\n```js no-beautify\nfunction pow(x,n)\n{\n  let result=1;\n  for(let i=0;i<n;i++) {result*=x;}\n  return result;\n}\n\nlet x=prompt(\"x?\",''), n=prompt(\"n?\",'')\nif (n<=0)\n{\n  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);\n}\nelse\n{\n  alert(pow(x,n))\n}\n```\n\n修复它。",
        "solution": "你可以注意到以下几点：\n\n```js no-beautify\nfunction pow(x,n)  // <- 参数之间没有空格\n{  // <- 花括号独占了一行\n  let result=1;   // <- = 号两边没有空格\n  for(let i=0;i<n;i++) {result*=x;}   // <- 没有空格\n  // { ... } 里面的内容应该在新的一行上\n  return result;\n}\n\nlet x=prompt(\"x?\",''), n=prompt(\"n?\",'') // <-- 从技术的角度来看是可以的，\n// 但是拆分成 2 行会更好，并且这里也缺了空格和分号 ;\nif (n<=0)  // <- (n <= 0) 里面没有空格，并且应该在本行上面加一个空行\n{   // <- 花括号独占了一行\n  // 下面的一行代码太长了，可以将其拆分成 2 行以提高可读性\n  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);\n}\nelse // <- 可以像 \"} else {\" 这样写在一行上\n{\n  alert(pow(x,n))  // 缺失了空格和分号 ;\n}\n```\n\n修改后的版本：\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nlet x = prompt(\"x?\", \"\");\nlet n = prompt(\"n?\", \"\");\n\nif (n <= 0) {\n  alert(`Power ${n} is not supported,\n    please enter an integer number greater than zero`);\n} else {\n  alert( pow(x, n) );\n}\n```",
        "parent": "coding-style",
        "version": 1
      }
    },
    "comments": {
      "type": "Article",
      "value": {
        "title": "注释",
        "slug": "comments",
        "githubPath": "/1-js/03-code-quality/03-comments",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n正如我们在 <info:structure> 一章所了解到的那样，注释可以是以 `//` 开始的单行注释，也可以是 `/* ... */` 结构的多行注释。\n\n我们通常通过注释来描述代码怎样工作和为什么这样工作。\n\n乍一看，写注释可能很简单，但初学者在编程的时候，经常错误地使用注释。\n\n## 糟糕的注释\n\n新手倾向于使用注释来解释“代码中发生了什么”。就像这样：\n\n```js\n// 这里的代码会先做这件事（……）然后做那件事（……）\n// ……谁知道还有什么……\nvery;\ncomplex;\ncode;\n```\n\n但在好的代码中，这种“解释性”注释的数量应该是最少的。严格地说，就算没有它们，代码也应该很容易理解。\n\n关于这一点有一个很棒的原则：“如果代码不够清晰以至于需要一个注释，那么或许它应该被重写。”\n\n### 配方：分解函数\n\n有时候，用一个函数来代替一个代码片段是更好的，就像这样：\n\n```js\nfunction showPrimes(n) {\n  nextPrime:\n  for (let i = 2; i < n; i++) {\n\n*!*\n    // 检测 i 是否是一个质数（素数）\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n*/!*\n\n    alert(i);\n  }\n}\n```\n\n更好的变体，使用一个分解出来的函数 `isPrime`：\n\n\n```js\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    *!*if (!isPrime(i)) continue;*/!*\n\n    alert(i);  \n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if (n % i == 0) return false;\n  }\n\n  return true;\n}\n```\n\n现在我们可以很容易地理解代码了。函数自己就变成了一个注释。这种代码被称为 **自描述型** 代码。\n\n### 配方：创建函数\n\n如果我们有一个像下面这样很长的代码块：\n\n```js\n// 在这里我们添加威士忌（译注：国外的一种酒）\nfor(let i = 0; i < 10; i++) {\n  let drop = getWhiskey();\n  smell(drop);\n  add(drop, glass);\n}\n\n// 在这里我们添加果汁\nfor(let t = 0; t < 3; t++) {\n  let tomato = getTomato();\n  examine(tomato);\n  let juice = press(tomato);\n  add(juice, glass);\n}\n\n// ...\n```\n\n我们像下面这样，将上面的代码重构为函数，可能会是一个更好的变体：\n\n```js\naddWhiskey(glass);\naddJuice(glass);\n\nfunction addWhiskey(container) {\n  for(let i = 0; i < 10; i++) {\n    let drop = getWhiskey();\n    //...\n  }\n}\n\nfunction addJuice(container) {\n  for(let t = 0; t < 3; t++) {\n    let tomato = getTomato();\n    //...\n  }\n}\n```\n\n同样，函数本身就可以告诉我们发生了什么。没有什么地方需要注释。并且分割之后代码的结构也更好了。每一个函数做什么、需要什么和返回什么都非常地清晰。\n\n实际上，我们不能完全避免“解释型”注释。例如在一些复杂的算法中，会有一些出于优化的目的而做的一些巧妙的“调整”。但是通常情况下，我们应该尽可能地保持代码的简单和“自我描述”性。\n\n## 好的注释\n\n所以，解释性注释通常来说都是不好的。那么哪一种注释才是好的呢？\n\n描述架构\n: 对组件进行高层次的整体概括，它们如何相互作用、各种情况下的控制流程是什么样的……简而言之 —— 代码的鸟瞰图。有一个专门用于构建代码的高层次架构图，以对代码进行解释的特殊编程语言 [UML](http://wikipedia.org/wiki/Unified_Modeling_Language)。绝对值得学习。\n\n记录函数的参数和用法\n: 有一个专门用于记录函数的语法 [JSDoc](http://en.wikipedia.org/wiki/JSDoc)：用法、参数和返回值。\n\n例如：\n```js\n/**\n * 返回 x 的 n 次幂的值。\n *\n * @param {number} x 要改变的值。\n * @param {number} n 幂数，必须是一个自然数。\n * @return {number} x 的 n 次幂的值。\n */\nfunction pow(x, n) {\n  ...\n}\n```\n\n这种注释可以帮助我们理解函数的目的，并且不需要研究其内部的实现代码，就可以直接正确地使用它。\n\n顺便说一句，很多诸如 [WebStorm](https://www.jetbrains.com/webstorm/) 这样的编辑器，都可以很好地理解和使用这些注释，来提供自动补全和一些自动化代码检查工作。\n\n当然，也有一些像 [JSDoc 3](https://github.com/jsdoc/jsdoc) 这样的工具，可以通过注释直接生成 HTML 文档。你可以在 <https://jsdoc.app> 阅读更多关于 JSDoc 的信息。\n\n为什么任务以这种方式解决？\n: 写了什么代码很重要。但是为什么 **不** 那样写可能对于理解正在发生什么更重要。为什么任务是通过这种方式解决的？代码并没有给出答案。\n\n    如果有很多种方法都可以解决这个问题，为什么偏偏是这一种？尤其当它不是最显而易见的那一种的时候。\n\n    没有这样的注释的话，就可能会发生下面的情况：\n    1. 你（或者你的同事）打开了前一段时间写的代码，看到它不是最理想的实现方式。\n    2. 你会想：“我当时是有多蠢啊，现在我真是太聪明了”，然后用“更显而易见且正确的”方式重写了一遍。\n    3. ……重写的这股冲动劲是好的。但是在重写的过程中你发现“更显而易见”的解决方案实际上是有缺陷的。你甚至依稀地想起了为什么会这样，因为你很久之前就已经尝试过这样做了。于是你又还原了那个正确的实现，但是时间已经浪费了。\n\n    解决方案的注释非常的重要。它们可以帮助你以正确的方式继续开发。\n\n代码有哪些巧妙的特性？它们被用在了什么地方？\n: 如果代码存在任何巧妙和不显而易见的方法，那绝对需要注释。\n\n## 总结\n\n一个好的开发者的标志之一就是他的注释：它们的存在甚至它们的缺席（译注：在该注释的地方注释，在不需要注释的地方则不注释，甚至写得好的自描述函数本身就是一种注释）。\n\n好的注释可以使我们更好地维护代码，一段时间之后依然可以更高效地回到代码高效开发。\n\n**注释这些内容：**\n\n- 整体架构，高层次的观点。\n- 函数的用法。\n- 重要的解决方案，特别是在不是很明显时。\n\n**避免注释：**\n\n- 描述“代码如何工作”和“代码做了什么”。\n- 避免在代码已经足够简单或代码有很好的自描述性而不需要注释的情况下，还写些没必要的注释。\n\n注释也被用于一些如 JSDoc3 等文档自动生成工具：它们读取注释然后生成 HTML 文档（或者其他格式的文档）。",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1657705346
      }
    },
    "ninja-code": {
      "type": "Article",
      "value": {
        "title": "忍者代码",
        "slug": "ninja-code",
        "githubPath": "/1-js/03-code-quality/04-ninja-code",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n\n```quote author=\"孔子《论语》\"\n学而不思则罔，思而不学则殆。\n```\n\n过去的程序员忍者使用这些技巧，来使代码维护者的头脑更加敏锐。\n\n代码审查大师在测试任务中寻找它们。\n\n一些新入门的开发者有时候甚至比忍者程序员能够更好地使用它们。\n\n仔细阅读本文，找出你是谁 —— 一个忍者、一个新手、或者一个代码审查者？\n\n\n```warn header=\"检测到讽刺意味\"\n许多人试图追随忍者的脚步。只有极少数成功了。\n```\n\n\n## 简洁是智慧的灵魂\n\n把代码尽可能写得短。展示出你是多么的聪明啊。\n\n在编程中，多使用一些巧妙的编程语言特性。\n\n例如，看一下这个三元运算符 `'?'`：\n\n```js\n// 从一个著名的 JavaScript 库中截取的代码\ni = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n```\n\n很酷，对吗？如果你这样写了，那些看到这一行代码并尝试去理解 `i` 的值是什么的开发者们，就会有一个“快活的”的时光了。然后会来找你寻求答案。\n\n告诉他短一点总是更好的。引导他进入忍者之路。\n\n## 一个字母的变量\n\n```quote author=\"老子（道德经）\"\n道隐无名。夫唯道善贷且成。\n```\n\n\n另一个缩减代码量的方法是，到处使用单字母的变量名。例如 `a`、`b` 或 `c`。\n\n短变量就像森林中真正的忍者一样，一下就找不到了。没有人能够通过编辑器的“搜索”功能找到它。即使有人做到了，他也不能“破译”出变量名 `a` 或 `b` 到底是什么意思。\n\n……但是有一个例外情况。一个真正的忍者绝不会在 `\"for\"` 循环中使用 `i` 作为计数器。在任何地方都可以，但是这里不会用。你随便一找，就能找到很多不寻常的字母。例如 `x` 或 `y`。\n\n使用一个不寻常的变量多酷啊，尤其是在长达 1-2 页（如果可以的话，你可以写得更长）的循环体中使用的时候。如果某人要研究循环内部实现的时候，他就很难很快地找出变量 `x` 其实是循环计数器啦。\n\n## 使用缩写\n\n如果团队规则中禁止使用一个字母和模糊的命名 — 那就缩短命名，使用缩写吧。\n\n像这样：\n\n- `list` -> `lst`\n- `userAgent` -> `ua`\n- `browser` -> `brsr`\n- ……等\n\n只有具有真正良好直觉的人，才能够理解这样的命名。尽可能缩短一切。只有真正有价值的人，才能够维护这种代码的开发。\n\n## Soar high，抽象化。\n\n```quote author=\"老子（道德经）\"\n大方无隅，<br>\n大器晚成，<br>\n大音希声，<br>\n大象无形。\n```\n\n当选择一个名字时，尽可能尝试使用最抽象的词语。例如 `obj`、`data`、`value`、`item` 和 `elem` 等。\n\n- **一个变量的理想名称是 `data`。** 在任何能用的地方都使用它。的确，每个变量都持有 **数据（data）**，对吧？\n\n    ……但是 `data` 已经用过了怎么办？可以尝试一下 `value`，它也很普遍。毕竟，一个变量总会有一个 **值（value）**，对吧？\n\n- **根据变量的类型为变量命名：`str`、`num`……**\n\n    尝试一下吧。新手可能会诧异 — 这些名字对于忍者来说真的有用吗？事实上，有用的！\n\n    一方面，变量名仍然有着一些含义。它说明了变量内是什么：一个字符串、一个数字或是其他的东西。但是当一个局外人试图理解代码时，他会惊讶地发现实际上没有任何有效信息！最终就无法修改你精心思考过的代码。\n\n    我们可以通过代码调试，很容易地看出值的类型。但是变量名的含义呢？它存了哪一个字符串或数字？\n\n    如果思考的深度不够，是没有办法搞明白的。\n\n- **……但是如果找不到更多这样的名字呢？** 可以加一个数字：`data1, item2, elem5`……\n\n## 注意测试\n\n只有一个真正细心的程序员才能理解你的代码。但是怎么检验呢？\n\n**方式之一 —— 使用相似的变量名，像 `date` 和 `data`。**\n\n尽你所能地将它们混合在一起。\n\n想快速阅读这种代码是不可能的。并且如果有一个错别字时……额……我们卡在这儿好长时间了，到饭点了 (⊙v⊙)。\n\n\n## 智能同义词\n\n```quote author=\"老子《道德经》\"\n道，可道，非常道。名，可名，非常名。\n```\n\n对 **同一个** 东西使用 **类似** 的命名，可以使生活更有趣，并且能够展现你的创造力。\n\n例如，函数前缀。如果一个函数的功能是在屏幕上展示一个消息 — 名称可以以 `display…` 开头，例如 `displayMessage`。如果另一个函数展示别的东西，比如一个用户名，名称可以以 `show…` 开始（例如 `showName`）。\n\n暗示这些函数之间有微妙的差异，实际上并没有。\n\n与团队中的其他忍者们达成一个协议：如果张三在他的代码中以 `display...` 来开始一个“显示”函数，那么李四可以用 `render..`，王二可以使用 `paint...`。你可以发现代码变得多么地有趣多样呀。\n\n……现在是帽子戏法！\n\n对于有非常重要的差异的两个函数 — 使用相同的前缀。\n\n例如，`printPage(page)` 函数会使用一个打印机（printer）。`printText(text)` 函数会将文字显示到屏幕上。让一个不熟悉的读者来思考一下：“名字为 `printMessage(message)` 的函数会将消息放到哪里呢？打印机还是屏幕上？”。为了让代码真正耀眼，`printMessage(message)` 应该将消息输出到新窗口中！\n\n## 重用名字\n\n```quote author=\"老子（道德经）\"\n始制有名，<br>\n名亦既有，<br>\n夫亦将知止，<br>\n知止可以不殆。\n```\n\n仅在绝对必要时才添加新变量。\n\n否则，重用已经存在的名字。直接把新值写进变量即可。\n\n在一个函数中，尝试仅使用作为参数传递的变量。\n\n这样就很难确定这个变量的值现在是什么了。也不知道它是从哪里来的。目的是提高阅读代码的人的直觉和记忆力。一个直觉较弱的人必须逐行分析代码，跟踪每个代码分支中的更改。\n\n**这个方法的一个进阶方案是，在循环或函数中偷偷地替换掉它的值。**\n\n例如：\n\n```js\nfunction ninjaFunction(elem) {\n  // 基于变量 elem 进行工作的 20 行代码\n\n  elem = clone(elem);\n\n  // 又 20 行代码，现在使用的是 clone 后的 elem 变量。\n}\n```\n\n想要在后半部分中使用 `elem` 的程序员会感到很诧异……只有在调试期间，检查代码之后，他才会发现他正在使用克隆过的变量！\n\n经常看到这样的代码，即使对经验丰富的忍者来说也是致命的。\n\n## 下划线的乐趣\n\n在变量名前加上下划线 `_` 和 `__`。例如 `_name` 和 `__value`。如果只有你知道它们的含义，那就非常棒了。或者，加这些下划线只是为了好玩儿，没有任何含义，那就更棒了！\n\n加下划线可谓是一箭双雕。首先，代码变得更长，可读性更低；并且，你的开发者小伙伴可能会花费很长时间，来弄清楚下划线是什么意思。\n\n聪明的忍者会在代码的一个地方使用下划线，然后在其他地方刻意避免使用它们。这会使代码变得更加脆弱，并提高了代码未来出现错误的可能性。\n\n## 展示你的爱\n\n向大家展现一下你那丰富的情感！像 `superElement`、`megaFrame` 和 `niceItem` 这样的名字一定会启发读者。\n\n事实上，从一方面来说，看似写了一些东西：`super..`、`mega..`、`nice..`。但从另一方面来说 — 并没有提供任何细节。阅读代码的人可能需要耗费一到两个小时的带薪工作时间，冥思苦想来寻找一个隐藏的含义。\n\n\n## 重叠外部变量\n\n```quote author=\"关尹子\"\n处明者不见暗中一物，<br>\n处暗者能见明中区事。\n```\n\n对函数内部和外部的变量，使用相同的名称。很简单，不用费劲想新的名称。\n\n```js\nlet *!*user*/!* = authenticateUser();\n\nfunction render() {\n  let *!*user*/!* = anotherValue();\n  ...\n  ...许多行代码...\n  ...\n  ... // <-- 某个程序员想要在这里使用 user 变量……\n  ...\n}\n```\n\n在研究 `render` 内部代码的程序员可能不会注意到，有一个内部变量 `user` 屏蔽了外部的 `user` 变量。\n\n然后他会假设 `user` 仍然是外部的变量然后使用它，`authenticateUser()` 的结果……陷阱出来啦！你好呀，调试器……\n\n\n## 无处不在的副作用！\n\n有些函数看起来它们不会改变任何东西。例如 `isReady()`，`checkPermission()`，`findTags()`……它们被假定用于执行计算、查找和返回数据，而不会更改任何它们自身之外的数据。这被称为“无副作用”。\n\n**一个非常惊喜的技巧就是，除了主要任务之外，给它们添加一个“有用的”行为。**\n\n当你的同事看到被命名为 `is..`、`check..` 或 `find...` 的函数改变了某些东西的时候，他脸上肯定是一脸懵逼的表情 — 这会扩大你的理性界限。\n\n**另一个惊喜的方式是，返回非标准的结果。**\n\n展示你原来的想法！让调用 `checkPermission` 时的返回值不是 `true/false`，而是一个包含检查结果的复杂对象。\n\n那些尝试写 `if (checkPermission(..))` 的开发者，会很疑惑为什么它不能工作。告诉他们：“去读文档吧”。然后给出这篇文章。\n\n\n## 强大的函数！\n\n```quote author=\"老子（道德经）\"\n大道泛兮，<br>\n其左可右。\n```\n\n不要让函数受限于名字中写的内容。拓宽一些。\n\n例如，函数 `validateEmail(email)` 可以（除了检查邮件的正确性之外）显示一个错误消息并要求重新输入邮件。\n\n额外的行为在函数名称中不应该很明显。一个真正的忍者会使它们在代码中也不明显。\n\n**将多个行为合并到一起，可以保护你的代码不被重用。**\n\n想象一下，另一个开发者只想检查邮箱而不想输出任何信息。你的函数 `validateEmail(email)` 对他而言就不合适啦。所以他不会找你问关于这些函数的任何事而打断你的思考。\n\n## 总结\n\n上面的所有“建议”都是从真实的代码中提炼而来的……有时候，这些代码是由有经验的开发者写的。也许比你更有经验 ;）\n\n- 遵从其中的一丢丢，你的代码就会变得充满惊喜。\n- 遵从其中的一大部分，你的代码将真正成为你的代码，没有人会想改变它。\n- 遵从所有，你的代码将成为寻求启发的年轻开发者的宝贵案例。",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1602853739
      }
    },
    "testing-mocha": {
      "type": "Article",
      "value": {
        "title": "使用 Mocha 进行自动化测试",
        "slug": "testing-mocha",
        "githubPath": "/1-js/03-code-quality/05-testing-mocha",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n自动化测试将被用于进一步的任务中，并且还将被广泛应用在实际项目中。\n\n## 我们为什么需要测试？\n\n当我们在写一个函数时，我们通常可以想象出它应该做什么：哪些参数会给出哪些结果。\n\n在开发期间，我们可以通过运行程序来检查它并将结果与预期进行比较。例如，我们可以在控制台中这么做。\n\n如果出了问题 —— 那么我们会修复代码，然后再一次运行并检查结果 —— 直到它工作为止。\n\n但这样的手动“重新运行”是不完美的。\n\n**当通过手动重新运行来测试代码时，很容易漏掉一些东西。**\n\n例如，我们要创建一个函数 `f`。写一些代码，然后测试：`f(1)` 可以执行，但是 `f(2)` 不执行。我们修复了一下代码，现在 `f(2)` 可以执行了。看起来已经搞定了？但是我们忘了重新测试 `f(1)`。这样有可能会导致出现错误。\n\n这是非常典型的。当我们在开发一些东西时，我们会保留很多可能需要的用例。但是不要想着程序员在每一次代码修改后都去检查所有的案例。所以这就很容易造成修复了一个问题却造成另一个问题的情况。\n\n**自动化测试意味着测试是独立于代码的。它们以各种方式运行我们的函数，并将结果与预期结果进行比较。**\n\n## 行为驱动开发（BDD）\n\n我们来使用一种名为 [行为驱动开发](http://en.wikipedia.org/wiki/Behavior-driven_development) 或简言为 BDD 的技术。\n\n**BDD 包含了三部分内容：测试、文档和示例。**\n\n为了理解 BDD，我们将研究一个实际的开发案例。\n\n## 开发 “pow”：规范\n\n我们想要创建一个函数 `pow(x, n)` 来计算 `x` 的 `n` 次幂（`n` 为整数）。我们假设 `n≥0`。\n\n这个任务只是一个例子：JavaScript 中有一个 `**` 运算符可以用于幂运算。但是在这里我们专注于可以应用于更复杂任务的开发流程上。\n\n在创建函数 `pow` 的代码之前，我们可以想象函数应该做什么并且描述出来。\n\n这样的描述被称作 **规范（specification, spec）**，包含用例的描述以及针对它们的测试，如下所示：\n\n```js\ndescribe(\"pow\", function() {\n\n  it(\"raises to n-th power\", function() {\n    assert.equal(pow(2, 3), 8);\n  });\n\n});\n```\n\n正如你所看到的，一个规范包含三个主要的模块：\n\n`describe(\"title\", function() { ... })`\n: 表示我们正在描述的功能是什么。在我们的例子中我们正在描述函数 `pow`。用于组织“工人（workers）” —— `it` 代码块。\n\n`it(\"use case description\", function() { ... })`\n: `it` 里面的描述部分，我们以一种 **易于理解** 的方式描述特定的用例，第二个参数是用于对其进行测试的函数。\n\n`assert.equal(value1, value2)`\n: `it` 块中的代码，如果实现是正确的，它应该在执行的时候不产生任何错误。\n\n    `assert.*` 函数用于检查 `pow` 函数是否按照预期工作。在这里我们使用了其中之一 —— `assert.equal`，它会对参数进行比较，如果它们不相等则会抛出一个错误。这里它检查了 `pow(2, 3)` 的值是否等于 `8`。还有其他类型的比较和检查，我们将在后面介绍到。\n\n规范可以被执行，它将运行在 `it` 块中指定的测试。我们稍后会看到。\n\n## 开发流程\n\n开发流程通常看起来像这样：\n\n1. 编写初始规范，测试最基本的功能。\n2. 创建一个最初始的实现。\n3. 检查它是否工作，我们运行测试框架 [Mocha](http://mochajs.org/)（很快会有更多细节）来运行测试。当功能未完成时，将显示错误。我们持续修正直到一切都能工作。\n4. 现在我们有一个带有测试的能工作的初步实现。\n5. 我们增加更多的用例到规范中，或许目前的程序实现还不支持。无法通过测试。\n6. 回到第 3 步，更新程序直到测试不会抛出错误。\n7. 重复第 3 步到第 6 步，直到功能完善。\n\n如此来看，开发就是不断地 **迭代**。我们写规范，实现它，确保测试通过，然后写更多的测试，确保它们工作等等。最后，我们有了一个能工作的实现和针对它的测试。\n\n让我们在我们的开发案例中看看这个开发流程吧。\n\n在我们的案例中，第一步已经完成了：我们有一个针对 `pow` 的初始规范。因此让我们来实现它吧。但在此之前，让我们用一些 JavaScript 库来运行测试，就是看看测试是通过了还是失败了。\n\n## 行为规范\n\n在本教程中，我们将使用以下 JavaScript 库进行测试：\n\n- [Mocha](http://mochajs.org/) —— 核心框架：提供了包括通用型测试函数 `describe` 和 `it`，以及用于运行测试的主函数。\n- [Chai](http://chaijs.com) —— 提供很多断言（assertion）支持的库。它提供了很多不同的断言，现在我们只需要用 `assert.equal`。\n- [Sinon](http://sinonjs.org/) —— 用于监视函数、模拟内建函数和其他函数的库，我们在后面才会用到它。\n\n这些库都既适用于浏览器端，也适用于服务器端。这里我们将使用浏览器端的变体。\n\n包含这些框架和 `pow` 规范的完整的 HTML 页面：\n\n```html src=\"index.html\"\n```\n\n该页面可分为五个部分：\n\n1. `<head>` —— 添加用于测试的第三方库和样式文件。\n2. `<script>` 包含测试函数，在我们的例子中 —— 和 `pow` 相关的代码。\n3. 测试代码 —— 在我们的案例中是名为 `test.js` 的脚本，它包含上面 `describe(\"pow\", ...)` 的那些代码。\n4. HTML 元素 `<div id=\"mocha\">` 将被 Mocha 用来输出结果。\n5. 可以使用 `mocha.run()` 命令来开始测试。\n\n结果：\n\n[iframe height=250 src=\"pow-1\" border=1 edit]\n\n到目前为止，测试失败了，出现了一个错误。这是合乎逻辑的：我们的 `pow` 是一个空函数，因此 `pow(2,3)` 返回了 `undefined` 而不是 `8`。\n\n未来，我们会注意到有更高级的测试工具，像是 [karma](https://karma-runner.github.io/) 或其他的，使自动运行许多不同的测试变得更容易。\n\n## 初始实现\n\n为了可以通过测试，让我们写一个 `pow` 的简单实现：\n\n```js\nfunction pow() {\n  return 8; // :) 我们作弊啦！\n}\n```\n\n哇哦，现在它可以工作了。\n\n[iframe height=250 src=\"pow-min\" border=1 edit]\n\n## 改进规范\n\n我们所做的这些绝对是作弊。函数是不起作用的：尝试计算 `pow(3,4)` 的话就会得到一个不正确的结果，但是测试却通过了。\n\n……但是这种情况却是在实际中相当典型例子。测试通过了，但是函数却是错误的。我们的规范是不完善的。我们需要给它添加更多的测试用例。\n\n这里我们又添加了一个测试来检查 `pow(3, 4) = 81`。\n\n我们可以选择两种方式中的任意一种来组织测试代码：\n\n1. 第一种 —— 在同一个 `it` 中再添加一个 `assert`：\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"raises to n-th power\", function() {\n        assert.equal(pow(2, 3), 8);\n    *!*\n        assert.equal(pow(3, 4), 81);\n    */!*\n      });\n\n    });\n    ```\n2. 第二种 —— 写两个测试：\n\n    ```js\n    describe(\"pow\", function() {\n\n      it(\"2 raised to power 3 is 8\", function() {\n        assert.equal(pow(2, 3), 8);\n      });\n\n      it(\"3 raised to power 4 is 81\", function() {\n        assert.equal(pow(3, 4), 81);\n      });\n\n    });\n    ```\n\n主要的区别是，当 `assert` 触发一个错误时，`it` 代码块会立即终止。因此，在第一种方式中，如果第一个 `assert` 失败了，我们将永远不会看到第二个 `assert` 的结果。\n\n保持测试之间独立，有助于我们获知代码中正在发生什么，因此第二种方式更好一点。\n\n除此之外，还有一个规范值得遵循。\n\n**一个测试检查一个东西。**\n\n如果我们在看测试代码的时候，发现在其中有两个相互独立的检查 —— 最好将它拆分成两个更简单的检查。\n\n因此让我们继续使用第二种方式。\n\n结果：\n\n[iframe height=250 src=\"pow-2\" edit border=\"1\"]\n\n正如我们可以想到的，第二条测试失败了。当然啦，我们的函数总会返回 `8`，而 `assert` 期望的是 `81`。\n\n## 改进实现\n\n让我们写一些更加实际的代码来通过测试吧：\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\n为了确保函数可以很好地工作，我们来使用更多值测试它吧。除了手动地编写 `it` 代码块，我们可以使用 `for` 循环来生成它们：\n\n```js\ndescribe(\"pow\", function() {\n\n  function makeTest(x) {\n    let expected = x * x * x;\n    it(`${x} in the power 3 is ${expected}`, function() {\n      assert.equal(pow(x, 3), expected);\n    });\n  }\n\n  for (let x = 1; x <= 5; x++) {\n    makeTest(x);\n  }\n\n});\n```\n\n结果：\n\n[iframe height=250 src=\"pow-3\" edit border=\"1\"]\n\n## 嵌套描述\n\n我们继续添加更多的测试。但在此之前，我们需要注意到辅助函数 `makeTest` 和 `for` 应该被组合到一起。我们在其他测试中不需要 `makeTest`，只有在 `for` 循环中需要它：它们共同的任务就是检查 `pow` 是如何自乘至给定的幂次方。\n\n使用嵌套的 `describe` 来进行分组：\n\n```js\ndescribe(\"pow\", function() {\n\n*!*\n  describe(\"raises x to power 3\", function() {\n*/!*\n\n    function makeTest(x) {\n      let expected = x * x * x;\n      it(`${x} in the power 3 is ${expected}`, function() {\n        assert.equal(pow(x, 3), expected);\n      });\n    }\n\n    for (let x = 1; x <= 5; x++) {\n      makeTest(x);\n    }\n\n*!*\n  });\n*/!*\n\n  // ……可以在这里写更多的测试代码，describe 和 it 都可以添加在这。\n});\n```\n\n嵌套的 `describe` 定义了一个新的 \"subgroup\" 测试。在输出中我们可以看到带有标题的缩进：\n\n[iframe height=250 src=\"pow-4\" edit border=\"1\"]\n\n将来，我们可以在顶级域中使用 `it` 和 `describe` 的辅助函数添加更多的 `it` 和 `describe`，它们不会看到 `makeTest`。\n\n````smart header=\"`before/after` 和 `beforeEach/afterEach`\"\n我们可以设置 `before/after` 函数来在运行测试之前/之后执行。也可以使用 `beforeEach/afterEach` 函数来设置在执行 **每一个** `it` 之前/之后执行。\n\n例如：\n\n```js no-beautify\ndescribe(\"test\", function() {\n\n  before(() => alert(\"Testing started – before all tests\"));\n  after(() => alert(\"Testing finished – after all tests\"));\n\n  beforeEach(() => alert(\"Before a test – enter a test\"));\n  afterEach(() => alert(\"After a test – exit a test\"));\n\n  it('test 1', () => alert(1));\n  it('test 2', () => alert(2));\n\n});\n```\n\n运行顺序将为：\n\n```\nTesting started – before all tests (before)\nBefore a test – enter a test (beforeEach)\n1\nAfter a test – exit a test   (afterEach)\nBefore a test – enter a test (beforeEach)\n2\nAfter a test – exit a test   (afterEach)\nTesting finished – after all tests (after)\n```\n\n[edit src=\"beforeafter\" title=\"Open the example in the sandbox.\"]\n\n通常，`beforeEach/afterEach` 和 `before/after` 被用于执行初始化，清零计数器或做一些介于每个测试（或测试组）之间的事情。\n````\n\n## 延伸规范\n\n`pow` 的基础功能已经完成了。第一次迭代开发完成啦。当我们庆祝和喝完香槟之后，让我们继续改进它吧。\n\n正如前面所说，函数 `pow(x, n)` 适用于正整数 `n`。\n\nJavaScript 函数通常会返回 `NaN` 以表示一个数学错误。接下来我们对无效的 `n` 值执行相同的操作。\n\n让我们首先将这个行为加到规范中(!)：\n\n```js\ndescribe(\"pow\", function() {\n\n  // ...\n\n  it(\"for negative n the result is NaN\", function() {\n*!*\n    assert.isNaN(pow(2, -1));\n*/!*\n  });\n\n  it(\"for non-integer n the result is NaN\", function() {\n*!*\n    assert.isNaN(pow(2, 1.5));    \n*/!*\n  });\n\n});\n```\n\n新测试的结果：\n\n[iframe height=530 src=\"pow-nan\" edit border=\"1\"]\n\n新加的测试失败了，因为我们的实现方式是不支持它们的。这就是 BDD 的做法：我们首先写一些暂时无法通过的测试，然后去实现它们。\n\n```smart header=\"Other assertions\"\n请注意断言语句 `assert.isNaN`：它用来检查 `NaN`。\n\n在 [Chai](http://chaijs.com) 中也有其他的断言，例如：\n\n- `assert.equal(value1, value2)` —— 检查相等 `value1 == value2`。\n- `assert.strictEqual(value1, value2)` —— 检查严格相等 `value1 === value2`。\n- `assert.notEqual`，`assert.notStrictEqual` —— 执行和上面相反的检查。\n- `assert.isTrue(value)` —— 检查 `value === true`。\n- `assert.isFalse(value)` —— 检查 `value === false`。\n- ……完整的列表请见 [docs](http://chaijs.com/api/assert/)\n```\n\n因此我们应该给 `pow` 再加几行：\n\n```js\nfunction pow(x, n) {\n*!*\n  if (n < 0) return NaN;\n  if (Math.round(n) != n) return NaN;\n*/!*\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\n现在它可以工作了，所有的测试也都通过了：\n\n[iframe height=300 src=\"pow-full\" edit border=\"1\"]\n\n[edit src=\"pow-full\" title=\"Open the full final example in the sandbox.\"]\n\n## 总结\n\n在 BDD 中，规范先行，实现在后。最后我们同时拥有了规范和代码。\n\n规范有三种使用方式：\n\n1. 作为 **测试** —— 保证代码正确工作。\n2. 作为 **文档** —— `describe` 和 `it` 的标题告诉我们函数做了什么。\n3. 作为 **案例** —— 测试实际工作的例子展示了一个函数可以被怎样使用。\n\n有了规范，我们可以安全地改进、修改甚至重写函数，并确保它仍然正确地工作。\n\n这在一个函数会被用在多个地方的大型项目中尤其重要。当我们改变这样一个函数时，没有办法手动检查每个使用它们的地方是否仍旧正确。\n\n如果没有测试，一般有两个办法：\n\n1. 展示修改，无论修改了什么。然后我们的用户遇到了 bug，这应该是我们没有手动完成某些检查。\n2. 如果对出错的惩罚比较严重，并且没有测试，那么大家会很害怕修改这样的函数，然后这些代码就会越来越陈旧，没有人会想接触它。这很不利于发展。\n\n**自动化测试则有助于避免这样的问题！**\n\n如果这个项目被测试代码覆盖了，就不会出现这种问题。在任何修改之后，我们都可以运行测试，并在几秒钟内看到大量的检查。\n\n**另外，一个经过良好测试的代码通常都有更好的架构。**\n\n当然，这是因为覆盖了自动化测试的代码更容易修改和改进。但还有另一个原因。\n\n要编写测试，代码的组织方式应确保每个函数都有一个清晰描述的任务、定义良好的输入和输出。这意味着从一开始就有一个好的架构。\n\n在实际开发中有时候可能并不容易，有时很难在写实际代码之前编写规范，因为还不清楚它应该如何表现。但一般来说，编写测试使得开发更快更稳定。\n\n在本教程的后面部分，你将遇到许多包含了测试的任务。所以你会看到更多的实际例子。\n\n编写测试需要良好的 JavaScript 知识。但我们刚刚开始学习它。因此，为了解决所有问题，到目前为止，你不需要编写测试，但是你应该已经能够阅读测试了，即使它们比本章中的内容稍微复杂一些。",
        "libs": [],
        "children": [
          "pow-test-wrong"
        ],
        "parent": "code-quality",
        "updatedAt": 1638611567
      }
    },
    "pow-test-wrong": {
      "type": "Task",
      "value": {
        "title": "测试代码中有什么错误？",
        "slug": "pow-test-wrong",
        "githubPath": "/1-js/03-code-quality/05-testing-mocha/3-pow-test-wrong",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面这个 `pow` 的测试代码有什么错误？\n\n```js\nit(\"Raises x to the power n\", function() {\n  let x = 5;\n\n  let result = x;\n  assert.equal(pow(x, 1), result);\n\n  result *= x;\n  assert.equal(pow(x, 2), result);\n\n  result *= x;\n  assert.equal(pow(x, 3), result);\n});\n```\n\n附：从语法上来说这些测试代码是正确且通过的。",
        "solution": "这些测试代码展示了开发人员在编写测试代码时遇到的一些疑惑。\n\n我们这里实际上有三条测试，但是用了一个函数来放置 3 个断言语句。\n\n有时用这种方式编写会更容易，但是如果发生错误，那么到底什么出错了就很不明显。\n\n如果错误发生在一个复杂的执行流的中间，那么我们就必须找出那个点的数据。我们必须 **调试测试**。\n\n将测试分成多个具有明确输入和输出的 `it` 代码块会更好。\n\n像是这样：\n```js\ndescribe(\"Raises x to power n\", function() {\n  it(\"5 in the power of 1 equals 5\", function() {\n    assert.equal(pow(5, 1), 5);\n  });\n\n  it(\"5 in the power of 2 equals 25\", function() {\n    assert.equal(pow(5, 2), 25);\n  });\n\n  it(\"5 in the power of 3 equals 125\", function() {\n    assert.equal(pow(5, 3), 125);\n  });\n});\n```\n\n我们使用 `describe` 和一组 `it` 代码块替换掉了单个的 `it`。现在，如果某个测试失败了，我们可以清楚地看到数据是什么。\n\n此外，我们可以通过编写 `it.only` 而不是 `it` 来隔离单个测试，并以独立模式运行它：\n\n\n```js\ndescribe(\"Raises x to power n\", function() {\n  it(\"5 in the power of 1 equals 5\", function() {\n    assert.equal(pow(5, 1), 5);\n  });\n\n*!*\n  // Mocha 将只运行这个代码块\n  it.only(\"5 in the power of 2 equals 25\", function() {\n    assert.equal(pow(5, 2), 25);\n  });\n*/!*\n\n  it(\"5 in the power of 3 equals 125\", function() {\n    assert.equal(pow(5, 3), 125);\n  });\n});\n```",
        "parent": "testing-mocha",
        "version": 1
      }
    },
    "polyfills": {
      "type": "Article",
      "value": {
        "title": "Polyfill 和转译器",
        "slug": "polyfills",
        "githubPath": "/1-js/03-code-quality/06-polyfills",
        "isFolder": false,
        "weight": 6,
        "content": "\n\nJavaScript 语言在稳步发展。也会定期出现一些对语言的新提议，它们会被分析讨论，如果认为有价值，就会被加入到 <https://tc39.github.io/ecma262/> 的列表中，然后被加到 [规范](http://www.ecma-international.org/publications/standards/Ecma-262.htm) 中。\n\nJavaScript 引擎背后的团队关于首先要实现什么有着他们自己想法。他们可能会决定执行草案中的建议，并推迟已经在规范中的内容，因为它们不太有趣或者难以实现。\n\n因此，一个 JavaScript 引擎只能实现标准中的一部分是很常见的情况。\n\n查看语言特性的当前支持状态的一个很好的页面是 <https://kangax.github.io/compat-table/es6/>（它很大，我们现在还有很多东西要学）。\n\n作为程序员，我们希望使用最新的特性。好东西越多越好！\n\n另一方面，如何让我们现代的代码在还不支持最新特性的旧引擎上工作？\n\n有两个工作可以做到这一点：\n\n1. 转译器（Transpilers）。\n2. 垫片（Polyfills）。\n\n通过本文，我们一起了解它们的工作原理以及它们在 Web 开发中的位置。\n\n## 转译器（Transpilers）\n\n[转译器](https://en.wikipedia.org/wiki/Source-to-source_compiler) 是一种可以将源码转译成另一种源码的特殊的软件。它可以解析（“阅读和理解”）现代代码，并使用旧的语法结构对其进行重写，进而使其也可以在旧的引擎中工作。\n\n例如，在 ES2020 之前没有“空值合并运算符” `??`。所以，如果访问者使用过时了的浏览器访问我们的网页，那么该浏览器可能就不明白 `height = height ?? 100` 这段代码的含义。\n\n转译器会分析我们的代码，并将 `height ?? 100` 重写为 `(height !== undefined && height !== null) ? height : 100`。\n\n```js\n// 在运行转译器之前\nheight = height ?? 100;\n\n// 在运行转译器之后\nheight = (height !== undefined && height !== null) ? height : 100;\n```\n\n现在，重写了的代码适用于更旧版本的 JavaScript 引擎。\n\n通常，开发者会在自己的计算机上运行转译器，然后将转译后的代码部署到服务器。\n\n说到名字，[Babel](https://babeljs.io) 是最著名的转译器之一。\n\n现代项目构建系统，例如 [webpack](https://webpack.js.org/)，提供了在每次代码更改时自动运行转译器的方法，因此很容易将代码转译集成到开发过程中。\n\n## 垫片（Polyfills）\n\n新的语言特性可能不仅包括语法结构和运算符，还可能包括内建函数。\n\n例如，`Math.trunc(n)` 是一个“截断”数字小数部分的函数，例如 `Math.trunc(1.23)` 返回 `1`。\n\n在一些（非常过时的）JavaScript 引擎中没有 `Math.trunc` 函数，所以这样的代码会执行失败。\n\n由于我们谈论的是新函数，而不是语法更改，因此无需在此处转译任何内容。我们只需要声明缺失的函数。\n\n更新/添加新函数的脚本被称为“polyfill”。它“填补”了空白并添加了缺失的实现。\n\n对于这种特殊情况，`Math.trunc` 的 polyfill 是一个实现它的脚本，如下所示：\n\n```js\nif (!Math.trunc) { // 如果没有这个函数\n  // 实现它\n  Math.trunc = function(number) {\n    // Math.ceil 和 Math.floor 甚至存在于上古年代的 JavaScript 引擎中\n    // 在本教程的后续章节中会讲到它们\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n  };\n}\n```\n\nJavaScript 是一种高度动态的语言。脚本可以添加/修改任何函数，甚至包括内建函数。\n\n两个有趣的 polyfill 库：\n- [core js](https://github.com/zloirock/core-js) 支持了很多特性，允许只包含需要的特性。\n- [polyfill.io](http://polyfill.io) 提供带有 polyfill 的脚本的服务，具体取决于特性和用户的浏览器。\n\n\n## 总结\n\n在本章中，我们希望激励你学习现代甚至“前沿”的语言特性，即使 JavaScript 引擎还没有很好地支持它们。\n\n只是不要忘记使用转译器（如果使用现代语法或运算符）和 polyfill（添加可能缺少的特性）。它们将确保代码能正常工作。\n\n例如，以后熟悉了 JavaScript，你就可以搭建一个基于 [webpack](https://webpack.js.org/) 和 [babel-loader](https://github.com/babel/babel-loader) 插件的代码构建系统。\n\n展示对各种特征的当前支持情况的工具：\n- <https://kangax.github.io/compat-table/es6/> —— 对于原生 JavaScript。\n- <https://caniuse.com/> —— 对于浏览器相关的函数。\n\nP.S. 谷歌的 Chrome 浏览器通常是对最新的语言特性的支持情况最好的浏览器，如果教程的示例运行失败，请尝试使用 Chrome 浏览器。不过，教程中的大多数示例都适用于任意的现代浏览器。",
        "libs": [],
        "children": [],
        "parent": "code-quality",
        "updatedAt": 1657705346
      }
    },
    "object-basics": {
      "type": "Article",
      "value": {
        "title": "Object（对象）：基础知识",
        "slug": "object-basics",
        "githubPath": "/1-js/04-object-basics",
        "isFolder": true,
        "weight": 4,
        "content": "",
        "libs": [],
        "children": [
          "object",
          "object-copy",
          "garbage-collection",
          "object-methods",
          "constructor-new",
          "optional-chaining",
          "symbol",
          "object-toprimitive"
        ],
        "parent": "js"
      }
    },
    "object": {
      "type": "Article",
      "value": {
        "title": "对象",
        "slug": "object",
        "githubPath": "/1-js/04-object-basics/01-object",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n正如我们在 <info:types> 一章学到的，JavaScript 中有八种数据类型。有七种原始类型，因为它们的值只包含一种东西（字符串，数字或者其他）。\n\n相反，对象则用来存储键值对和更复杂的实体。在 JavaScript 中，对象几乎渗透到了这门编程语言的方方面面。所以，在我们深入理解这门语言之前，必须先理解对象。\n\n我们可以通过使用带有可选 **属性列表** 的花括号 `{…}` 来创建对象。一个属性就是一个键值对（\"key: value\"），其中键（`key`）是一个字符串（也叫做属性名），值（`value`）可以是任何值。\n\n我们可以把对象想象成一个带有签名文件的文件柜。每一条数据都基于键（`key`）存储在文件中。这样我们就可以很容易根据文件名（也就是“键”）查找文件或添加/删除文件了。\n\n![](object.svg)\n\n我们可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：\n\n```js\nlet user = new Object(); // “构造函数” 的语法\nlet user = {};  // “字面量” 的语法\n```\n\n![](object-user-empty.svg)\n\n通常，我们用花括号。这种方式我们叫做 **字面量**。\n\n## 文本和属性\n\n我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 `{...}` 中。\n\n```js\nlet user = {     // 一个对象\n  name: \"John\",  // 键 \"name\"，值 \"John\"\n  age: 30        // 键 \"age\"，值 30\n};\n```\n\n属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 `\":\"` 的前面，值在冒号的右边。\n\n在 `user` 对象中，有两个属性：\n\n1. 第一个的键是 `\"name\"`，值是 `\"John\"`。\n2. 第二个的键是 `\"age\"`，值是 `30`。\n\n生成的 `user` 对象可以被想象为一个放置着两个标记有 \"name\" 和 \"age\" 的文件的柜子。\n\n![user object](object-user.svg)\n\n我们可以随时添加、删除和读取文件。\n\n可以使用点符号访问属性值：\n\n```js\n// 读取文件的属性：\nalert( user.name ); // John\nalert( user.age ); // 30\n```\n\n属性的值可以是任意类型，让我们加个布尔类型：\n\n```js\nuser.isAdmin = true;\n```\n\n![user object 2](object-user-isadmin.svg)\n\n我们可以用 `delete` 操作符移除属性：\n\n```js\ndelete user.age;\n```\n\n![user object 3](object-user-delete.svg)\n\n我们也可以用多字词语来作为属性名，但必须给它们加上引号：\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30,\n  \"likes birds\": true  // 多词属性名必须加引号\n};\n```\n\n![](object-user-props.svg)\n\n\n列表中的最后一个属性应以逗号结尾：\n```js\nlet user = {\n  name: \"John\",\n  age: 30*!*,*/!*\n}\n```\n这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。\n\n## 方括号\n\n对于多词属性，点操作就不能用了：\n\n```js run\n// 这将提示有语法错误\nuser.likes birds = true\n```\n\nJavaScript 理解不了。它认为我们在处理 `user.likes`，然后在遇到意外的 `birds` 时给出了语法错误。\n\n点符号要求 `key` 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 `$` 和 `_`）。\n\n有另一种方法，就是使用方括号，可用于任何字符串：\n\n```js run\nlet user = {};\n\n// 设置\nuser[\"likes birds\"] = true;\n\n// 读取\nalert(user[\"likes birds\"]); // true\n\n// 删除\ndelete user[\"likes birds\"];\n```\n\n现在一切都可行了。请注意方括号中的字符串要放在引号中，单引号或双引号都可以。\n\n方括号同样提供了一种可以通过任意表达式来获取属性名的方式 —— 与文本字符串不同 —— 例如下面的变量：\n\n```js\nlet key = \"likes birds\";\n\n// 跟 user[\"likes birds\"] = true; 一样\nuser[key] = true;\n```\n\n在这里，变量 `key` 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。\n\n例如：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet key = prompt(\"What do you want to know about the user?\", \"name\");\n\n// 访问变量\nalert( user[key] ); // John（如果输入 \"name\"）\n```\n\n点符号不能以类似的方式使用：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet key = \"name\";\nalert( user.key ) // undefined\n```\n\n### 计算属性\n\n当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 **计算属性**。\n\n例如：\n\n```js run\nlet fruit = prompt(\"Which fruit to buy?\", \"apple\");\n\nlet bag = {\n*!*\n  [fruit]: 5, // 属性名是从 fruit 变量中得到的\n*/!*\n};\n\nalert( bag.apple ); // 5 如果 fruit=\"apple\"\n```\n\n计算属性的含义很简单：`[fruit]` 含义是属性名应该从 `fruit` 变量中获取。\n\n所以，如果一个用户输入 `\"apple\"`，`bag` 将变为 `{apple: 5}`。\n\n本质上，这跟下面的语法效果相同：\n```js run\nlet fruit = prompt(\"Which fruit to buy?\", \"apple\");\nlet bag = {};\n\n// 从 fruit 变量中获取值\nbag[fruit] = 5;\n```\n\n……但是看起来更好。\n\n我们可以在方括号中使用更复杂的表达式：\n\n```js\nlet fruit = 'apple';\nlet bag = {\n  [fruit + 'Computers']: 5 // bag.appleComputers = 5\n};\n```\n\n方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。\n\n所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。\n\n## 属性值简写\n\n在实际开发中，我们通常用已存在的变量当做属性名。\n\n例如：\n\n```js run\nfunction makeUser(name, age) {\n  return {\n    name: name,\n    age: age,\n    // ……其他的属性\n  };\n}\n\nlet user = makeUser(\"John\", 30);\nalert(user.name); // John\n```\n\n在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 **属性值缩写** 方法，使属性名变得更短。\n\n可以用 `name` 来代替 `name:name` 像下面那样：\n\n```js\nfunction makeUser(name, age) {\n*!*\n  return {\n    name, // 与 name: name 相同\n    age,  // 与 age: age 相同\n    // ...\n  };\n*/!*\n}\n```\n\n我们可以把属性名简写方式和正常方式混用：\n\n```js\nlet user = {\n  name,  // 与 name:name 相同\n  age: 30\n};\n```\n\n\n## 属性名称限制\n\n我们已经知道，变量名不能是编程语言的某个保留字，如 \"for\"、\"let\"、\"return\" 等……\n\n但对象的属性名并不受此限制：\n\n```js run\n// 这些属性都没问题\nlet obj = {\n  for: 1,\n  let: 2,\n  return: 3\n};\n\nalert( obj.for + obj.let + obj.return );  // 6\n```\n\n简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。\n\n其他类型会被自动地转换为字符串。\n\n例如，当数字 `0` 被用作对象的属性的键时，会被转换为字符串 `\"0\"`：\n\n```js run\nlet obj = {\n  0: \"test\" // 等同于 \"0\": \"test\"\n};\n\n// 都会输出相同的属性（数字 0 被转为字符串 \"0\"）\nalert( obj[\"0\"] ); // test\nalert( obj[0] ); // test (相同的属性)\n```\n\n这里有个小陷阱：一个名为 `__proto__` 的属性。我们不能将它设置为一个非对象的值：\n\n```js run\nlet obj = {};\nobj.__proto__ = 5; // 分配一个数字\nalert(obj.__proto__); // [object Object] —— 值为对象，与预期结果不同\n```\n\n我们从代码中可以看出来，把它赋值为 `5` 的操作被忽略了。\n\n我们将在 [后续章节](info:prototype-inheritance) 中学习 `__proto__` 的特殊性质，并给出了 [解决此问题的方法](info:prototype-methods)。\n\n## 属性存在性测试，\"in\" 操作符\n\n相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！\n\n读取不存在的属性只会得到 `undefined`。所以我们可以很容易地判断一个属性是否存在：\n\n```js run\nlet user = {};\n\nalert( user.noSuchProperty === undefined ); // true 意思是没有这个属性\n```\n\n这里还有一个特别的，检查属性是否存在的操作符 `\"in\"`。\n\n语法是：\n```js\n\"key\" in object\n```\n\n例如：\n\n```js run\nlet user = { name: \"John\", age: 30 };\n\nalert( \"age\" in user ); // true，user.age 存在\nalert( \"blabla\" in user ); // false，user.blabla 不存在。\n```\n\n请注意，`in` 的左边必须是 **属性名**。通常是一个带引号的字符串。\n\n如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：\n\n```js run\nlet user = { age: 30 };\n\nlet key = \"age\";\nalert( *!*key*/!* in user ); // true，属性 \"age\" 存在\n```\n\n为何会有 `in` 运算符呢？与 `undefined` 进行比较来判断还不够吗？\n\n确实，大部分情况下与 `undefined` 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 `in` 运算符的判断结果仍是对的。\n\n那就是属性存在，但存储的值是 `undefined` 的时候：\n\n```js run\nlet obj = {\n  test: undefined\n};\n\nalert( obj.test ); // 显示 undefined，所以属性不存在？\n\nalert( \"test\" in obj ); // true，属性存在！\n```\n\n在上面的代码中，属性 `obj.test` 事实上是存在的，所以 `in` 操作符检查通过。\n\n这种情况很少发生，因为通常情况下不应该给对象赋值 `undefined`。我们通常会用 `null` 来表示未知的或者空的值。因此，`in` 运算符是代码中的特殊来宾。\n\n\n## \"for..in\" 循环 [#forin]\n\n为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：`for..in`。这跟我们在前面学到的 `for(;;)` 循环是完全不一样的东西。\n\n语法：\n\n```js\nfor (key in object) {\n  // 对此对象属性中的每个键执行的代码\n}\n```\n\n例如，让我们列出 `user` 所有的属性：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n  isAdmin: true\n};\n\nfor (let key in user) {\n  // keys\n  alert( key );  // name, age, isAdmin\n  // 属性键的值\n  alert( user[key] ); // John, 30, true\n}\n```\n\n注意，所有的 \"for\" 结构体都允许我们在循环中定义变量，像这里的 `let key`。\n\n同样，我们可以用其他属性名来替代 `key`。例如 `\"for(let prop in obj)\"` 也很常用。\n\n### 像对象一样排序\n\n对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？\n\n简短的回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。详情如下：\n\n例如，让我们考虑一个带有电话号码的对象：\n\n```js run\nlet codes = {\n  \"49\": \"Germany\",\n  \"41\": \"Switzerland\",\n  \"44\": \"Great Britain\",\n  // ..,\n  \"1\": \"USA\"\n};\n\n*!*\nfor(let code in codes) {\n  alert(code); // 1, 41, 44, 49\n}\n*/!*\n```\n\n对象可用于面向用户的建议选项列表。如果我们的网站主要面向德国观众，那么我们可能希望 `49` 排在第一。\n\n但如果我们执行代码，会看到完全不同的现象：\n\n- USA (1) 排在了最前面\n- 然后是 Switzerland (41) 及其它。\n\n因为这些电话号码是整数，所以它们以升序排列。所以我们看到的是 `1, 41, 44, 49`。\n\n````smart header=\"整数属性？那是什么？\"\n这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。\n\n所以，`\"49\"` 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样的。但是 \"+49\" 和 \"1.2\" 就不行了：\n\n```js run\n// Number(...) 显式转换为数字\n// Math.trunc 是内建的去除小数部分的方法。\nalert( String(Math.trunc(Number(\"49\"))) ); // \"49\"，相同，整数属性\nalert( String(Math.trunc(Number(\"+49\"))) ); // \"49\"，不同于 \"+49\" ⇒ 不是整数属性\nalert( String(Math.trunc(Number(\"1.2\"))) ); // \"1\"，不同于 \"1.2\" ⇒ 不是整数属性\n```\n````\n\n……此外，如果属性名不是整数，那它们就按照创建时的顺序来排序，例如：\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\nuser.age = 25; // 增加一个\n\n*!*\n// 非整数属性是按照创建的顺序来排列的\n*/!*\nfor (let prop in user) {\n  alert( prop ); // name, surname, age\n}\n```\n\n所以，为了解决电话号码的问题，我们可以使用非整数属性名来 **欺骗** 程序。只需要给每个键名加一个加号 `\"+\"` 前缀就行了。\n\n像这样：\n\n```js run\nlet codes = {\n  \"+49\": \"Germany\",\n  \"+41\": \"Switzerland\",\n  \"+44\": \"Great Britain\",\n  // ..,\n  \"+1\": \"USA\"\n};\n\nfor (let code in codes) {\n  alert( +code ); // 49, 41, 44, 1\n}\n```\n\n现在跟预想的一样了。\n\n## 总结\n\n对象是具有一些特殊特性的关联数组。\n\n它们存储属性（键值对），其中：\n- 属性的键必须是字符串或者 symbol（通常是字符串）。\n- 值可以是任何类型。\n\n我们可以用下面的方法访问属性：\n- 点符号: `obj.property`。\n- 方括号 `obj[\"property\"]`，方括号允许从变量中获取键，例如 `obj[varWithKey]`。\n\n其他操作：\n- 删除属性：`delete obj.prop`。\n- 检查是否存在给定键的属性：`\"key\" in obj`。\n- 遍历对象：`for(let key in obj)` 循环。\n\n我们在这一章学习的叫做“普通对象（plain object）”，或者就叫对象。\n\nJavaScript 中还有很多其他类型的对象：\n\n- `Array` 用于存储有序数据集合，\n- `Date` 用于存储时间日期，\n- `Error` 用于存储错误信息。\n- ……等等。\n\n它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 \"object\"。它们以不同的方式对 \"object\" 做了一些扩展。\n\nJavaScript 中的对象非常强大。这里我们只接触了其冰山一角。在后面的章节中，我们将频繁使用对象进行编程，并学习更多关于对象的知识。",
        "libs": [],
        "children": [
          "hello-object",
          "is-empty",
          "sum-object",
          "multiply-numeric"
        ],
        "parent": "object-basics",
        "updatedAt": 1657784929
      }
    },
    "hello-object": {
      "type": "Task",
      "value": {
        "title": "你好，对象",
        "slug": "hello-object",
        "githubPath": "/1-js/04-object-basics/01-object/2-hello-object",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n按下面的要求写代码，一条对应一行代码：\n\n1. 创建一个空的对象 `user`。\n2. 为这个对象增加一个属性，键是 `name`，值是 `John`。\n3. 再增加一个属性，键是 `surname`，值是 `Smith`。\n4. 把键为 `name` 的属性的值改成 `Pete`。\n5. 删除这个对象中键为 `name` 的属性。",
        "solution": "```js\nlet user = {};\nuser.name = \"John\";\nuser.surname = \"Smith\";\nuser.name = \"Pete\";\ndelete user.name;\n```",
        "parent": "object",
        "version": 1
      }
    },
    "is-empty": {
      "type": "Task",
      "value": {
        "title": "检查空对象",
        "slug": "is-empty",
        "githubPath": "/1-js/04-object-basics/01-object/3-is-empty",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n写一个 `isEmpty(obj)` 函数，当对象没有属性的时候返回 `true`，否则返回 `false`。\n\n应该像这样：\n\n```js\nlet schedule = {};\n\nalert( isEmpty(schedule) ); // true\n\nschedule[\"8:30\"] = \"get up\";\n\nalert( isEmpty(schedule) ); // false\n```",
        "solution": "只需要遍历这个对象，如果对象存在任何属性则 `return false`。",
        "solutionJs": "function isEmpty(obj) {\n  for (let key in obj) {\n    // 如果进到循环里面，说明有属性。\n    return false;\n  }\n  return true;\n}",
        "parent": "object",
        "version": 1
      }
    },
    "sum-object": {
      "type": "Task",
      "value": {
        "title": "对象属性求和",
        "slug": "sum-object",
        "githubPath": "/1-js/04-object-basics/01-object/5-sum-object",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有一个保存着团队成员工资的对象：\n\n```js\nlet salaries = {\n  John: 100,\n  Ann: 160,\n  Pete: 130\n}\n```\n\n写一段代码求出我们的工资总和，将计算结果保存到变量 `sum`。从所给的信息来看，结果应该是 `390`。\n\n如果 `salaries` 是一个空对象，那结果就为 `0`。",
        "solution": "```js run\nlet salaries = {\n  John: 100,\n  Ann: 160,\n  Pete: 130\n};\n\nlet sum = 0;\nfor (let key in salaries) {\n  sum += salaries[key];\n}\n\nalert(sum); // 390\n```",
        "parent": "object",
        "version": 1
      }
    },
    "multiply-numeric": {
      "type": "Task",
      "value": {
        "title": "将数值属性值都乘以 2",
        "slug": "multiply-numeric",
        "githubPath": "/1-js/04-object-basics/01-object/8-multiply-numeric",
        "weight": 8,
        "libs": [],
        "importance": 3,
        "content": "\n\n创建一个 `multiplyNumeric(obj)` 函数，把 `obj` 所有的数值属性值都乘以 `2`。\n\n例如：\n\n```js\n// 在调用之前\nlet menu = {\n  width: 200,\n  height: 300,\n  title: \"My menu\"\n};\n\nmultiplyNumeric(menu);\n\n// 调用函数之后\nmenu = {\n  width: 400,\n  height: 600,\n  title: \"My menu\"\n};\n```\n\n注意 `multiplyNumeric` 函数不需要返回任何值，它应该就地修改对象。\n\nP.S. 用 `typeof` 检查值类型。",
        "solution": "",
        "solutionJs": "function multiplyNumeric(obj) {\n  for (let key in obj) {\n    if (typeof obj[key] == 'number') {\n      obj[key] *= 2;\n    }\n  }\n}",
        "parent": "object",
        "version": 1
      }
    },
    "object-copy": {
      "type": "Article",
      "value": {
        "title": "对象引用和复制",
        "slug": "object-copy",
        "githubPath": "/1-js/04-object-basics/02-object-copy",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等 —— 总是“作为一个整体”复制。\n\n如果我们深入了解复制值时会发生什么，就很容易理解了。\n\n让我们从原始类型开始，例如一个字符串。\n\n这里我们将 `message` 复制到 `phrase`：\n\n```js\nlet message = \"Hello!\";\nlet phrase = message;\n```\n\n结果我们就有了两个独立的变量，每个都存储着字符串 `\"Hello!\"`。\n\n![](variable-copy-value.svg)\n\n显而易见的结果，对吧？\n\n但是，对象不是这样的。\n\n**赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。**\n\n让我们看一个这样的变量的例子：\n\n```js\nlet user = {\n  name: \"John\"\n};\n```\n\n这是它实际存储在内存中的方式：\n\n![](variable-contains-reference.svg)\n\n该对象被存储在内存中的某个位置（在图片的右侧），而变量 `user`（在左侧）保存的是对其的“引用”。\n\n我们可以将一个对象变量（例如 `user`）想象成一张写有对象的地址的纸。\n\n当我们对对象执行操作时，例如获取一个属性 `user.name`，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。\n\n现在，这就是为什么它很重要。\n\n**当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。**\n\n例如：\n\n```js no-beautify\nlet user = { name: \"John\" };\n\nlet admin = user; // 复制引用\n```\n\n现在我们有了两个变量，它们保存的都是对同一个对象的引用：\n\n![](variable-copy-reference.svg)\n\n正如你所看到的，这里仍然只有一个对象，但现在有两个引用它的变量。\n\n我们可以通过其中任意一个变量来访问该对象并修改它的内容：\n\n```js run\nlet user = { name: 'John' };\n\nlet admin = user;\n\n*!*\nadmin.name = 'Pete'; // 通过 \"admin\" 引用来修改\n*/!*\n\nalert(*!*user.name*/!*); // 'Pete'，修改能通过 \"user\" 引用看到\n```\n\n这就像我们有一个带有两把钥匙的柜子，使用其中一把钥匙（`admin`）打开柜子并更改了里面的东西。那么，如果我们稍后用另一把钥匙（`user`），我们仍然可以打开同一个柜子并且可以访问更改的内容。\n\n## 通过引用来比较\n\n仅当两个对象为同一对象时，两者才相等。\n\n例如，这里 `a` 和 `b` 两个变量都引用同一个对象，所以它们相等：\n\n```js run\nlet a = {};\nlet b = a; // 复制引用\n\nalert( a == b ); // true，都引用同一对象\nalert( a === b ); // true\n```\n\n而这里两个独立的对象则并不相等，即使它们看起来很像（都为空）：\n\n```js run\nlet a = {};\nlet b = {}; // 两个独立的对象\n\nalert( a == b ); // false\n```\n\n对于类似 `obj1 > obj2` 的比较，或者跟一个原始类型值的比较 `obj == 5`，对象都会被转换为原始值。我们很快就会学到对象是如何转换的，但是说实话，很少需要进行这样的比较 —— 通常是在编程错误的时候才会出现这种情况。\n\n## 克隆与合并，Object.assign [#cloning-and-merging-object-assign]\n\n那么，拷贝一个对象变量会又创建一个对相同对象的引用。\n\n但是，如果我们想要复制一个对象，那该怎么做呢？\n\n我们可以创建一个新对象，通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。\n\n就像这样：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nlet clone = {}; // 新的空对象\n\n// 将 user 中所有的属性拷贝到其中\nfor (let key in user) {\n  clone[key] = user[key];\n}\n*/!*\n\n// 现在 clone 是带有相同内容的完全独立的对象\nclone.name = \"Pete\"; // 改变了其中的数据\n\nalert( user.name ); // 原来的对象中的 name 属性依然是 John\n```\n\n我们也可以使用 [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 方法来达成同样的效果。\n\n语法是：\n\n```js\nObject.assign(dest, [src1, src2, src3...])\n```\n\n- 第一个参数 `dest` 是指目标对象。\n- 更后面的参数 `src1, ..., srcN`（可按需传递多个参数）是源对象。\n- 该方法将所有源对象的属性拷贝到目标对象 `dest` 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。\n- 调用结果返回 `dest`。\n\n例如，我们可以用它来合并多个对象：\n```js\nlet user = { name: \"John\" };\n\nlet permissions1 = { canView: true };\nlet permissions2 = { canEdit: true };\n\n*!*\n// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中\nObject.assign(user, permissions1, permissions2);\n*/!*\n\n// 现在 user = { name: \"John\", canView: true, canEdit: true }\n```\n\n如果被拷贝的属性的属性名已经存在，那么它会被覆盖：\n\n```js run\nlet user = { name: \"John\" };\n\nObject.assign(user, { name: \"Pete\" });\n\nalert(user.name); // 现在 user = { name: \"Pete\" }\n```\n\n我们也可以用 `Object.assign` 代替 `for..in` 循环来进行简单克隆：\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nlet clone = Object.assign({}, user);\n*/!*\n```\n\n它将 `user` 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。\n\n还有其他克隆对象的方法，例如使用 [spread 语法](info:rest-parameters-spread) `clone = {...user}`，在后面的章节中我们会讲到。\n\n## 深层克隆\n\n到现在为止，我们都假设 `user` 的所有属性均为原始类型。但属性可以是对其他对象的引用。\n\n例如：\n```js run\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nalert( user.sizes.height ); // 182\n```\n\n现在这样拷贝 `clone.sizes = user.sizes` 已经不足够了，因为 `user.sizes` 是个对象，它会以引用形式被拷贝。因此 `clone` 和 `user` 会共用一个 sizes：\n\n```js run\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nlet clone = Object.assign({}, user);\n\nalert( user.sizes === clone.sizes ); // true，同一个对象\n\n// user 和 clone 分享同一个 sizes\nuser.sizes.width++;       // 通过其中一个改变属性值\nalert(clone.sizes.width); // 51，能从另外一个获取到变更后的结果\n```\n\n为了解决这个问题，并让 `user` 和 `clone` 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 `user[key]` 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。\n\n我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 [lodash](https://lodash.com) 库的 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)。\n\n````smart header=\"使用 const 声明的对象也是可以被修改的\"\n通过引用对对象进行存储的一个重要的副作用是声明为 `const` 的对象 **可以** 被修改。\n\n例如：\n\n```js run\nconst user = {\n  name: \"John\"\n};\n\n*!*\nuser.name = \"Pete\"; // (*)\n*/!*\n\nalert(user.name); // Pete\n```\n\n看起来 `(*)` 行的代码会触发一个错误，但实际并没有。`user` 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改。\n\n换句话说，只有当我们尝试将 `user=...` 作为一个整体进行赋值时，`const user` 才会报错。\n\n也就是说，如果我们真的需要创建常量对象属性，也是可以的，但使用的是完全不同的方法。我们将在 <info:property-descriptors> 一章中学习它。\n````\n\n## 总结\n\n对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。\n\n所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。\n\n为了创建“真正的拷贝”（一个克隆），我们可以使用 `Object.assign` 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)。",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1657705346
      }
    },
    "garbage-collection": {
      "type": "Article",
      "value": {
        "title": "垃圾回收",
        "slug": "garbage-collection",
        "githubPath": "/1-js/04-object-basics/03-garbage-collection",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。\n\n当我们不再需要某个东西时会发生什么？JavaScript 引擎如何发现它并清理它？\n\n## 可达性（Reachability）\n\nJavaScript 中主要的内存管理概念是 **可达性**。\n\n简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。\n\n1. 这里列出固有的可达值的基本集合，这些值明显不能被释放。\n\n    比方说：\n\n    - 当前执行的函数，它的局部变量和参数。\n    - 当前嵌套调用链上的其他函数、它们的局部变量和参数。\n    - 全局变量。\n    - （还有一些内部的）\n\n    这些值被称作 **根（roots）**。\n\n2. 如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的。\n\n    比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 **该** 对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。\n\n在 JavaScript 引擎中有一个被称作 [垃圾回收器](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)) 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。\n\n## 一个简单的例子\n\n这里是一个最简单的例子：\n\n```js\n// user 具有对这个对象的引用\nlet user = {\n  name: \"John\"\n};\n```\n\n![](memory-user-john.svg)\n\n这里的箭头描述了一个对象引用。全局变量 `\"user\"` 引用了对象 `{name：\"John\"}`（为简洁起见，我们称它为 John）。John 的 `\"name\"` 属性存储一个原始值，所以它被写在对象内部。\n\n如果 `user` 的值被重写了，这个引用就没了：\n\n```js\nuser = null;\n```\n\n![](memory-user-john-lost.svg)\n\n现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。\n\n## 两个引用\n\n现在让我们想象下，我们把 `user` 的引用复制给 `admin`：\n\n```js\n// user 具有对这个对象的引用\nlet user = {\n  name: \"John\"\n};\n\n*!*\nlet admin = user;\n*/!*\n```\n\n![](memory-user-john-admin.svg)\n\n现在如果执行刚刚的那个操作：\n\n```js\nuser = null;\n```\n\n……然后对象仍然可以被通过 `admin` 这个全局变量访问到，因此它必须被保留在内存中。如果我们又重写了 `admin`，对象就会被删除。\n\n## 相互关联的对象\n\n现在来看一个更复杂的例子。这是个家庭：\n\n```js\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nlet family = marry({\n  name: \"John\"\n}, {\n  name: \"Ann\"\n});\n```\n\n`marry` 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。\n\n由此产生的内存结构：\n\n![](family.svg)\n\n到目前为止，所有对象都是可达的。\n\n现在让我们移除两个引用：\n\n```js\ndelete family.father;\ndelete family.mother.husband;\n```\n\n![](family-delete-refs.svg)\n\n仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。\n\n但是，如果我们把这两个都删除，那么我们可以看到再也没有对 John 的引用了：\n\n![](family-no-father.svg)\n\n对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达。\n\n经过垃圾回收：\n\n![](family-no-father-2.svg)\n\n## 无法到达的岛屿\n\n几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。\n\n源对象与上面相同。然后：\n\n```js\nfamily = null;\n```\n\n内存内部状态将变成：\n\n![](family-no-family.svg)\n\n这个例子展示了可达性概念的重要性。\n\n显而易见，John 和 Ann 仍然连着，都有传入的引用。但是，这样还不够。\n\n前面说的 `\"family\"` 对象已经不再与根相连，没有了外部对其的引用，所以它变成了一座“孤岛”，并且将被从内存中删除。\n\n## 内部算法\n\n垃圾回收的基本算法被称为 \"mark-and-sweep\"。\n\n定期执行以下“垃圾回收”步骤：\n\n- 垃圾收集器找到所有的根，并“标记”（记住）它们。\n- 然后它遍历并“标记”来自它们的所有引用。\n- 然后它遍历标记的对象并标记 **它们的** 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。\n- ……如此操作，直到所有可达的（从根部）引用都被访问到。\n- 没有被标记的对象都会被删除。\n\n例如，使我们的对象有如下的结构：\n\n![](garbage-collection-1.svg)\n\n我们可以清楚地看到右侧有一个“无法到达的岛屿”。现在我们来看看“标记和清除”垃圾收集器如何处理它。\n\n第一步标记所有的根：\n\n![](garbage-collection-2.svg)\n\n然后，我们跟随它们的引用标记它们所引用的对象：\n\n![](garbage-collection-3.svg)\n\n……如果还有引用的话，继续标记：\n\n![](garbage-collection-4.svg)\n\n现在，无法通过这个过程访问到的对象被认为是不可达的，并且会被删除。\n\n![](garbage-collection-5.svg)\n\n我们还可以将这个过程想象成从根溢出一大桶油漆，它流经所有引用并标记所有可到达的对象。然后移除未标记的。\n\n这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。\n\n一些优化建议：\n\n- **分代收集（Generational collection）**—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。\n- **增量收集（Incremental collection）**—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。\n- **闲时收集（Idle-time collection）**—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。\n\n还有其他垃圾回收算法的优化和风格。尽管我想在这里描述它们，但我必须打住了，因为不同的引擎会有不同的调整和技巧。而且，更重要的是，随着引擎的发展，情况会发生变化，所以在没有真实需求的时候，“提前”学习这些内容是不值得的。当然，除非你纯粹是出于兴趣。我在下面给你提供了一些相关链接。\n\n## 总结\n\n主要需要掌握的内容：\n\n- 垃圾回收是自动完成的，我们不能强制执行或是阻止执行。\n- 当对象是可达状态时，它一定是存在于内存中的。\n- 被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达，正如我们在上面的例子中看到的那样。\n\n现代引擎实现了垃圾回收的高级算法。\n\n《The Garbage Collection Handbook: The Art of Automatic Memory Management》（R. Jones 等人著）这本书涵盖了其中一些内容。\n\n如果你熟悉底层（low-level）编程，关于 V8 引擎垃圾回收器的更详细信息请参阅文章 [V8 之旅：垃圾回收](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)。\n\n[V8 博客](http://v8project.blogspot.com/) 还不时发布关于内存管理变化的文章。当然，为了学习更多垃圾收集的相关内容，你最好通过学习 V8 引擎内部知识来进行准备，并阅读一个名为 [Vyacheslav Egorov](http://mrale.ph) 的 V8 引擎工程师的博客。我之所以说 “V8”，因为网上关于它的文章最丰富的。对于其他引擎，许多方法是相似的，但在垃圾收集上许多方面有所不同。\n\n当你需要底层的优化时，对引擎有深入了解将很有帮助。在熟悉了这门编程语言之后，把熟悉引擎作为下一步计划是明智之选。",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1657790927
      }
    },
    "object-methods": {
      "type": "Article",
      "value": {
        "title": "对象方法，\"this\"",
        "slug": "object-methods",
        "githubPath": "/1-js/04-object-basics/04-object-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n通常创建对象来表示真实世界中的实体，如用户和订单等：\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n```\n\n并且，在现实世界中，用户可以进行 **操作**：从购物车中挑选某物、登录和注销等。\n\n在 JavaScript 中，行为（action）由属性中的函数来表示。\n\n## 方法示例\n\n刚开始，我们来教 `user` 说 hello：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nuser.sayHi = function() {\n  alert(\"Hello!\");\n};\n*/!*\n\nuser.sayHi(); // Hello!\n```\n\n这里我们使用函数表达式创建了一个函数，并将其指定给对象的 `user.sayHi` 属性。\n\n随后我们像这样 `user.sayHi()` 调用它。用户现在可以说话了！\n\n作为对象属性的函数被称为 **方法**。\n\n所以，在这我们得到了 `user` 对象的 `sayHi` 方法。\n\n当然，我们也可以使用预先声明的函数作为方法，就像这样：\n\n```js run\nlet user = {\n  // ...\n};\n\n*!*\n// 首先，声明函数\nfunction sayHi() {\n  alert(\"Hello!\");\n}\n\n// 然后将其作为一个方法添加\nuser.sayHi = sayHi;\n*/!*\n\nuser.sayHi(); // Hello!\n```\n\n```smart header=\"面向对象编程\"\n当我们在代码中用对象表示实体时，就是所谓的 [面向对象编程](https://en.wikipedia.org/wiki/Object-oriented_programming)，简称为 \"OOP\"。\n\nOOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。\n```\n### 方法简写\n\n在对象字面量中，有一种更短的（声明）方法的语法：\n\n```js\n// 这些对象作用一样\n\nuser = {\n  sayHi: function() {\n    alert(\"Hello\");\n  }\n};\n\n// 方法简写看起来更好，对吧？\nlet user = {\n*!*\n  sayHi() { // 与 \"sayHi: function(){...}\" 一样\n*/!*\n    alert(\"Hello\");\n  }\n};\n```\n\n如上所示，我们可以省略 `\"function\"`，只写 `sayHi()`。\n\n说实话，这种表示法还是有些不同。在对象继承方面有一些细微的差别（稍后将会介绍），但目前它们并不重要。在几乎所有的情况下，更短的语法是首选的。\n\n## 方法中的 \"this\"\n\n通常，对象方法需要访问对象中存储的信息才能完成其工作。\n\n例如，`user.sayHi()` 中的代码可能需要用到 `user` 的 name 属性。\n\n**为了访问该对象，方法中可以使用 `this` 关键字。**\n\n`this` 的值就是在点之前的这个对象，即调用该方法的对象。\n\n举个例子：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n*!*\n    // \"this\" 指的是“当前的对象”\n    alert(this.name);\n*/!*\n  }\n\n};\n\nuser.sayHi(); // John\n```\n\n在这里 `user.sayHi()` 执行过程中，`this` 的值是 `user`。\n\n技术上讲，也可以在不使用 `this` 的情况下，通过外部变量名来引用它：\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert(user.name); // \"user\" 替代 \"this\"\n*/!*\n  }\n\n};\n```\n\n……但这样的代码是不可靠的。如果我们决定将 `user` 复制给另一个变量，例如 `admin = user`，并赋另外的值给 `user`，那么它将访问到错误的对象。\n\n下面这个示例证实了这一点：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n*!*\n    alert( user.name ); // 导致错误\n*/!*\n  }\n\n};\n\n\nlet admin = user;\nuser = null; // 重写让其更明显\n\n*!*\nadmin.sayHi(); // TypeError: Cannot read property 'name' of null\n*/!*\n```\n\n如果我们在 `alert` 中以 `this.name` 替换 `user.name`，那么代码就会正常运行。\n\n## \"this\" 不受限制\n\n在 JavaScript 中，`this` 关键字与其他大多数编程语言中的不同。JavaScript 中的 `this` 可以用于任何函数，即使它不是对象的方法。\n\n下面这样的代码没有语法错误：\n\n```js\nfunction sayHi() {\n  alert( *!*this*/!*.name );\n}\n```\n\n`this` 的值是在代码运行时计算出来的，它取决于代码上下文。\n\n例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 \"this\" 值：\n\n```js run\nlet user = { name: \"John\" };\nlet admin = { name: \"Admin\" };\n\nfunction sayHi() {\n  alert( this.name );\n}\n\n*!*\n// 在两个对象中使用相同的函数\nuser.f = sayHi;\nadmin.f = sayHi;\n*/!*\n\n// 这两个调用有不同的 this 值\n// 函数内部的 \"this\" 是“点符号前面”的那个对象\nuser.f(); // John（this == user）\nadmin.f(); // Admin（this == admin）\n\nadmin['f'](); // Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）\n```\n\n这个规则很简单：如果 `obj.f()` 被调用了，则 `this` 在 `f` 函数调用期间是 `obj`。所以在上面的例子中 this 先是 `user`，之后是 `admin`。\n\n````smart header=\"在没有对象的情况下调用：`this == undefined`\"\n我们甚至可以在没有对象的情况下调用函数：\n\n```js run\nfunction sayHi() {\n  alert(this);\n}\n\nsayHi(); // undefined\n```\n\n在这种情况下，严格模式下的 `this` 值为 `undefined`。如果我们尝试访问 `this.name`，将会报错。\n\n在非严格模式的情况下，`this` 将会是 **全局对象**（浏览器中的 `window`，我们稍后会在 [](info:global-object) 一章中学习它）。这是一个历史行为，`\"use strict\"` 已经将其修复了。\n\n通常这种调用是程序出错了。如果在一个函数内部有 `this`，那么通常意味着它是在对象上下文环境中被调用的。\n````\n\n```smart header=\"解除 `this` 绑定的后果\"\n如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 `this`”的概念，即在对象中定义的方法总是有指向该对象的 `this`。\n\n在 JavaScript 中，`this` 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。\n\n在运行时对 `this` 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。\n\n这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。\n```\n\n## 箭头函数没有自己的 \"this\"\n\n箭头函数有些特别：它们没有自己的 `this`。如果我们在这样的函数中引用 `this`，`this` 值取决于外部“正常的”函数。\n\n举个例子，这里的 `arrow()` 使用的 `this` 来自于外部的 `user.sayHi()` 方法：\n\n```js run\nlet user = {\n  firstName: \"Ilya\",\n  sayHi() {\n    let arrow = () => alert(this.firstName);\n    arrow();\n  }\n};\n\nuser.sayHi(); // Ilya\n```\n\n这是箭头函数的一个特性，当我们并不想要一个独立的 `this`，反而想从外部上下文中获取时，它很有用。在后面的 <info:arrow-functions> 一章中，我们将深入介绍箭头函数。\n\n\n## 总结\n\n- 存储在对象属性中的函数被称为“方法”。\n- 方法允许对象进行像 `object.doSomething()` 这样的“操作”。\n- 方法可以将对象引用为 `this`。\n\n`this` 的值是在程序运行时得到的。\n- 一个函数在声明时，可能就使用了 `this`，但是这个 `this` 只有在函数被调用时才会有值。\n- 可以在对象之间复制函数。\n- 以“方法”的语法调用函数时：`object.method()`，调用过程中的 `this` 值是 `object`。\n\n请注意箭头函数有些特别：它们没有 `this`。在箭头函数内部访问到的 `this` 都是从外部获取的。",
        "libs": [],
        "children": [
          "object-property-this",
          "calculator",
          "chain-calls"
        ],
        "parent": "object-basics",
        "updatedAt": 1657705346
      }
    },
    "object-property-this": {
      "type": "Task",
      "value": {
        "title": "在对象字面量中使用 \"this\"",
        "slug": "object-property-this",
        "githubPath": "/1-js/04-object-basics/04-object-methods/4-object-property-this",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n这里 `makeUser` 函数返回了一个对象。\n\n访问 `ref` 的结果是什么？为什么？\n\n```js\nfunction makeUser() {\n  return {\n    name: \"John\",\n    ref: this\n  };\n}\n\nlet user = makeUser();\n\nalert( user.ref.name ); // 结果是什么？\n```",
        "solution": "**答案：一个错误。**\n\n试一下：\n```js run\nfunction makeUser() {\n  return {\n    name: \"John\",\n    ref: this\n  };\n}\n\nlet user = makeUser();\n\nalert( user.ref.name ); // Error: Cannot read property 'name' of undefined\n```\n\n这是因为设置 `this` 的规则不考虑对象定义。只有调用那一刻才重要。\n\n这里 `makeUser()` 中的 `this` 的值是 `undefined`，因为它是被作为函数调用的，而不是通过点符号被作为方法调用。\n\n`this` 的值是对于整个函数的，代码段和对象字面量对它都没有影响。\n\n所以 `ref: this` 实际上取的是当前函数的 `this`。\n\n我们可以重写这个函数，并返回和上面相同的值为 `undefined` 的 `this`：\n\n```js run\nfunction makeUser(){\n  return this; // 这次这里没有对象字面量\n}\n\nalert( makeUser().name ); // Error: Cannot read property 'name' of undefined\n```\n我们可以看到 `alert( makeUser().name )` 的结果和前面那个例子中 `alert( user.ref.name )` 的结果相同。\n\n这里有个反例：\n\n```js run\nfunction makeUser() {\n  return {\n    name: \"John\",\n*!*\n    ref() {\n      return this;\n    }\n*/!*\n  };\n}\n\nlet user = makeUser();\n\nalert( user.ref().name ); // John\n```\n\n现在正常了，因为 `user.ref()` 是一个方法。`this` 的值为点符号 `.` 前的这个对象。",
        "parent": "object-methods",
        "version": 1
      }
    },
    "calculator": {
      "type": "Task",
      "value": {
        "title": "创建一个计算器",
        "slug": "calculator",
        "githubPath": "/1-js/04-object-basics/04-object-methods/7-calculator",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个有三个方法的 `calculator` 对象：\n\n- `read()` 提示输入两个值，并将其保存为对象属性，属性名分别为 `a` 和 `b`。\n- `sum()` 返回保存的值的和。\n- `mul()` 将保存的值相乘并返回计算结果。\n\n```js\nlet calculator = {\n  // ……你的代码……\n};\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo solution\nlet calculator = {\n  sum() {\n    return this.a + this.b;\n  },\n\n  mul() {\n    return this.a * this.b;\n  },\n\n  read() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n};\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n```",
        "solutionJs": "let calculator = {\n  sum() {\n    return this.a + this.b;\n  },\n\n  mul() {\n    return this.a * this.b;\n  },\n\n  read() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  }\n};",
        "parent": "object-methods",
        "version": 1
      }
    },
    "chain-calls": {
      "type": "Task",
      "value": {
        "title": "链式（调用）",
        "slug": "chain-calls",
        "githubPath": "/1-js/04-object-basics/04-object-methods/8-chain-calls",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\n\n有一个可以上下移动的 `ladder` 对象：\n\n```js\nlet ladder = {\n  step: 0,\n  up() { \n    this.step++;\n  },\n  down() { \n    this.step--;\n  },\n  showStep: function() { // 显示当前的 step\n    alert( this.step );\n  }\n};\n```\n\n现在，如果我们要按顺序执行几次调用，可以这样做：\n\n```js\nladder.up();\nladder.up();\nladder.down();\nladder.showStep(); // 1\nladder.down();\nladder.showStep(); // 0\n```\n\n修改 `up`，`down` 和 `showStep` 的代码，让调用可以链接，就像这样：\n\n```js\nladder.up().up().down().showStep().down().showStep(); // 展示 1，然后 0\n```\n\n这种方法在 JavaScript 库中被广泛使用。",
        "solution": "解决方案就是在每次调用后返回这个对象本身。\n\n```js run demo\nlet ladder = {\n  step: 0,\n  up() {\n    this.step++;\n*!*\n    return this;\n*/!*\n  },\n  down() {\n    this.step--;\n*!*\n    return this;\n*/!*\n  },\n  showStep() {\n    alert( this.step );\n*!*\n    return this;\n*/!*\n  }\n};\n\nladder.up().up().down().showStep().down().showStep(); // 展示 1，然后 0\n```\n\n我们也可以每行一个调用。对于长链接它更具可读性：\n\n```js \nladder\n  .up()\n  .up()\n  .down()\n  .showStep() // 1\n  .down()\n  .showStep(); // 0\n```",
        "solutionJs": "\nlet ladder = {\n  step: 0,\n  up: function() { \n    this.step++;\n    return this;\n  },\n  down: function() { \n    this.step--;\n    return this;\n  },\n  showStep: function() { \n    alert(this.step);\n    return this;\n  }\n};",
        "parent": "object-methods",
        "version": 1
      }
    },
    "constructor-new": {
      "type": "Article",
      "value": {
        "title": "构造器和操作符 \"new\"",
        "slug": "constructor-new",
        "githubPath": "/1-js/04-object-basics/06-constructor-new",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n常规的 `{...}` 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。\n\n这可以使用构造函数和 `\"new\"` 操作符来实现。\n\n## 构造函数\n\n构造函数在技术上是常规函数。不过有两个约定：\n\n1. 它们的命名以大写字母开头。\n2. 它们只能由 `\"new\"` 操作符来执行。\n\n例如：\n\n```js run\nfunction User(name) {\n  this.name = name;\n  this.isAdmin = false;\n}\n\n*!*\nlet user = new User(\"Jack\");\n*/!*\n\nalert(user.name); // Jack\nalert(user.isAdmin); // false\n```\n\n当一个函数被使用 `new` 操作符执行时，它按照以下步骤：\n\n1. 一个新的空对象被创建并分配给 `this`。\n2. 函数体执行。通常它会修改 `this`，为其添加新的属性。\n3. 返回 `this` 的值。\n\n换句话说，`new User(...)` 做的就是类似的事情：\n\n```js\nfunction User(name) {\n*!*\n  // this = {};（隐式创建）\n*/!*\n\n  // 添加属性到 this\n  this.name = name;\n  this.isAdmin = false;\n\n*!*\n  // return this;（隐式返回）\n*/!*\n}\n```\n\n所以 `new User(\"Jack\")` 的结果是相同的对象：\n\n```js\nlet user = {\n  name: \"Jack\",\n  isAdmin: false\n};\n```\n\n现在，如果我们想创建其他用户，我们可以调用 `new User(\"Ann\")`，`new User(\"Alice\")` 等。比每次都使用字面量创建要短得多，而且更易于阅读。\n\n这是构造器的主要目的 —— 实现可重用的对象创建代码。\n\n让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 `this`）都可以用作构造器。即可以通过 `new` 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 `new` 来运行。\n\n````smart header=\"new function() { ... }\"\n如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：\n\n```js\n// 创建一个函数并立即使用 new 调用它\nlet user = new function() {\n  this.name = \"John\";\n  this.isAdmin = false;\n\n  // ……用于用户创建的其他代码\n  // 也许是复杂的逻辑和语句\n  // 局部变量等\n};\n```\n\n这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。\n````\n\n## 构造器模式测试：new.target\n\n```smart header=\"进阶内容\"\n本节涉及的语法内容很少使用，除非你想了解所有内容，否则你可以直接跳过该语法。\n```\n\n在一个函数内部，我们可以使用 `new.target` 属性来检查它是否被使用 `new` 进行调用了。\n\n对于常规调用，它为 undefined，对于使用 `new` 的调用，则等于该函数：\n\n```js run\nfunction User() {\n  alert(new.target);\n}\n\n// 不带 \"new\"：\n*!*\nUser(); // undefined\n*/!*\n\n// 带 \"new\"：\n*!*\nnew User(); // function User { ... }\n*/!*\n```\n\n它可以被用在函数内部，来判断该函数是被通过 `new` 调用的“构造器模式”，还是没被通过 `new` 调用的“常规模式”。\n\n我们也可以让 `new` 调用和常规调用做相同的工作，像这样：\n\n```js run\nfunction User(name) {\n  if (!new.target) { // 如果你没有通过 new 运行我\n    return new User(name); // ……我会给你添加 new\n  }\n\n  this.name = name;\n}\n\nlet john = User(\"John\"); // 将调用重定向到新用户\nalert(john.name); // John\n```\n\n这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 `new`，程序都能工作。\n\n不过，到处都使用它并不是一件好事，因为省略了 `new` 使得很难观察到代码中正在发生什么。而通过 `new` 我们都可以知道这创建了一个新对象。\n\n## 构造器的 return\n\n通常，构造器没有 `return` 语句。它们的任务是将所有必要的东西写入 `this`，并自动转换为结果。\n\n但是，如果这有一个 `return` 语句，那么规则就简单了：\n\n- 如果 `return` 返回的是一个对象，则返回这个对象，而不是 `this`。\n- 如果 `return` 返回的是一个原始类型，则忽略。\n\n换句话说，带有对象的 `return` 返回该对象，在所有其他情况下返回 `this`。\n\n例如，这里 `return` 通过返回一个对象覆盖 `this`：\n\n```js run\nfunction BigUser() {\n\n  this.name = \"John\";\n\n  return { name: \"Godzilla\" };  // <-- 返回这个对象\n}\n\nalert( new BigUser().name );  // Godzilla，得到了那个对象\n```\n\n这里有一个 `return` 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：\n\n```js run\nfunction SmallUser() {\n\n  this.name = \"John\";\n\n  return; // <-- 返回 this\n}\n\nalert( new SmallUser().name );  // John\n```\n\n通常构造器没有 `return` 语句。这里我们主要为了完整性而提及返回对象的特殊行为。\n\n````smart header=\"省略括号\"\n顺便说一下，如果没有参数，我们可以省略 `new` 后的括号：\n\n```js\nlet user = new User; // <-- 没有参数\n// 等同于\nlet user = new User();\n```\n\n这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。\n````\n\n## 构造器中的方法\n\n使用构造函数来创建对象会带来很大的灵活性。构造函数可能有一些参数，这些参数定义了如何构造对象以及要放入什么。\n\n当然，我们不仅可以将属性添加到 `this` 中，还可以添加方法。\n\n例如，下面的 `new User(name)` 用给定的 `name` 和方法 `sayHi` 创建了一个对象：\n\n```js run\nfunction User(name) {\n  this.name = name;\n\n  this.sayHi = function() {\n    alert( \"My name is: \" + this.name );\n  };\n}\n\n*!*\nlet john = new User(\"John\");\n\njohn.sayHi(); // My name is: John\n*/!*\n\n/*\njohn = {\n   name: \"John\",\n   sayHi: function() { ... }\n}\n*/\n```\n\n[类](info:classes) 是用于创建复杂对象的一个更高级的语法，我们稍后会讲到。\n\n## 总结\n\n- 构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。\n- 构造函数只能使用 `new` 来调用。这样的调用意味着在开始时创建了空的 `this`，并在最后返回填充了值的 `this`。\n\n我们可以使用构造函数来创建多个类似的对象。\n\nJavaScript 为许多内建的对象提供了构造函数：比如日期 `Date`、集合 `Set` 以及其他我们计划学习的内容。\n\n```smart header=\"对象，我们还会回来哒！\"\n在本章中，我们只介绍了关于对象和构造器的基础知识。它们对于我们在下一章中，学习更多关于数据类型和函数的相关知识非常重要。\n\n在我们学习了那些之后，我们将回到对象，在 <info:prototypes> 和 <info:classes> 章节中深入介绍它们。\n```",
        "libs": [],
        "children": [
          "two-functions-one-object",
          "calculator-constructor",
          "accumulator"
        ],
        "parent": "object-basics",
        "updatedAt": 1657873591
      }
    },
    "two-functions-one-object": {
      "type": "Task",
      "value": {
        "title": "两个函数 —— 一个对象",
        "slug": "two-functions-one-object",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/1-two-functions-one-object",
        "weight": 1,
        "libs": [],
        "importance": 2,
        "content": "\n\n是否可以创建像 `new A() == new B()` 这样的函数 `A` 和 `B`？\n\n```js no-beautify\nfunction A() { ... }\nfunction B() { ... }\n\nlet a = new A;\nlet b = new B;\n\nalert( a == b ); // true\n```\n\n如果可以，请提供一个它们的代码示例。",
        "solution": "是的，这是可以的。\n\n如果一个函数返回一个对象，那么 `new` 返回那个对象而不是 `this`。\n\n所以它们可以，例如，返回相同的外部定义的对象 `obj`：\n\n```js run no-beautify\nlet obj = {};\n\nfunction A() { return obj; }\nfunction B() { return obj; }\n\nalert( new A() == new B() ); // true\n```",
        "parent": "constructor-new",
        "version": 1
      }
    },
    "calculator-constructor": {
      "type": "Task",
      "value": {
        "title": "创建 new Calculator",
        "slug": "calculator-constructor",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/2-calculator-constructor",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个构造函数 `Calculator`，它创建的对象中有三个方法：\n\n- `read()` 使用 `prompt` 请求两个值并把它们记录在对象的属性中。\n- `sum()` 返回这些属性的总和。\n- `mul()` 返回这些属性的乘积。\n\n例如：\n\n```js\nlet calculator = new Calculator();\ncalculator.read();\n\nalert( \"Sum=\" + calculator.sum() );\nalert( \"Mul=\" + calculator.mul() );\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}\n\nlet calculator = new Calculator();\ncalculator.read();\n\nalert( \"Sum=\" + calculator.sum() );\nalert( \"Mul=\" + calculator.mul() );\n```",
        "solutionJs": "function Calculator() {\n\n  this.read = function() {\n    this.a = +prompt('a?', 0);\n    this.b = +prompt('b?', 0);\n  };\n\n  this.sum = function() {\n    return this.a + this.b;\n  };\n\n  this.mul = function() {\n    return this.a * this.b;\n  };\n}",
        "parent": "constructor-new",
        "version": 1
      }
    },
    "accumulator": {
      "type": "Task",
      "value": {
        "title": "创建 new Accumulator",
        "slug": "accumulator",
        "githubPath": "/1-js/04-object-basics/06-constructor-new/3-accumulator",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个构造函数 `Accumulator(startingValue)`。\n\n它创建的对象应该：\n\n- 将“当前 value”存储在属性 `value` 中。起始值被设置到构造器 `startingValue` 的参数。\n- `read()` 方法应该使用 `prompt` 来读取一个新的数字，并将其添加到 `value` 中。\n\n换句话说，`value` 属性是所有用户输入值与初始值 `startingValue` 的总和。\n\n下面是示例代码：\n\n```js\nlet accumulator = new Accumulator(1); // 初始值 1\n\naccumulator.read(); // 添加用户输入的 value\naccumulator.read(); // 添加用户输入的 value\n\nalert(accumulator.value); // 显示这些值的总和\n```\n\n[demo]",
        "solution": "```js run demo\nfunction Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('How much to add?', 0);\n  };\n\n}\n\nlet accumulator = new Accumulator(1);\naccumulator.read();\naccumulator.read();\nalert(accumulator.value);\n```",
        "solutionJs": "function Accumulator(startingValue) {\n  this.value = startingValue;\n\n  this.read = function() {\n    this.value += +prompt('How much to add?', 0);\n  };\n\n}\n",
        "parent": "constructor-new",
        "version": 1
      }
    },
    "optional-chaining": {
      "type": "Article",
      "value": {
        "title": "可选链 \"?.\"",
        "slug": "optional-chaining",
        "githubPath": "/1-js/04-object-basics/07-optional-chaining",
        "isFolder": false,
        "weight": 7,
        "content": "\n\n[recent browser=\"new\"]\n\n可选链 `?.` 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。\n\n## “不存在的属性”的问题\n\n如果你才刚开始读此教程并学习 JavaScript，那可能还没接触到这个问题，但它却相当常见。\n\n举个例子，假设我们有很多个 `user` 对象，其中存储了我们的用户数据。\n\n我们大多数用户的地址都存储在 `user.address` 中，街道地址存储在 `user.address.street` 中，但有些用户没有提供这些信息。\n\n在这种情况下，当我们尝试获取 `user.address.street`，而该用户恰好没提供地址信息，我们则会收到一个错误：\n\n```js run\nlet user = {}; // 一个没有 \"address\" 属性的 user 对象\n\nalert(user.address.street); // Error!\n```\n\n这是预期的结果。JavaScript 的工作原理就是这样的。因为 `user.address` 为 `undefined`，尝试读取 `user.address.street` 会失败，并收到一个错误。\n\n但是在很多实际场景中，我们更希望得到的是 `undefined`（表示没有 `street` 属性）而不是一个错误。\n\n……还有另一个例子。在 Web 开发中，我们可以使用特殊的方法调用（例如 `document.querySelector('.elem')`）以对象的形式获取一个网页元素，如果没有这种对象，则返回 `null`。\n\n```js run\n// 如果 document.querySelector('.elem') 的结果为 null，则这里不存在这个元素\nlet html = document.querySelector('.elem').innerHTML; // 如果 document.querySelector('.elem') 的结果为 null，则会出现错误\n```\n\n同样，如果该元素不存在，则访问 `null` 的 `.innerHTML` 属性时会报错。在某些情况下，当元素的缺失是没问题的时候，我们希望避免出现这种错误，而是接受 `html = null` 作为结果。\n\n我们如何实现这一点呢？\n\n可能最先想到的方案是在访问该值的属性之前，使用 `if` 或条件运算符 `?` 对该值进行检查，像这样：\n\n```js\nlet user = {};\n\nalert(user.address ? user.address.street : undefined);\n```\n\n这样可以，这里就不会出现错误了……但是不够优雅。就像你所看到的，`\"user.address\"` 在代码中出现了两次。\n\n我们看一个以相同方式获取 `document.querySelector` 的例子：\n\n```js run\nlet html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;\n```\n\n我们可以看到用于进行元素搜索的 `document.querySelector('.elem')` 在这里实际上被调用了两次。这样不优雅。\n\n对于嵌套层次更深的属性，代码会变得更丑，因为需要更多的重复。\n\n例如，让我们以相同的方式尝试获取 `user.address.street.name`。\n\n```js\nlet user = {}; // user 没有 address 属性\n\nalert(user.address ? user.address.street ? user.address.street.name : null : null);\n```\n\n这样就太扯淡了，并且这可能导致写出来的代码很难让别人理解。\n\n这里有一种更好的实现方式，就是使用 `&&` 运算符：\n\n```js run\nlet user = {}; // user 没有 address 属性\n\nalert( user.address && user.address.street && user.address.street.name ); // undefined（不报错）\n```\n\n依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的（如果不存在，则停止计算），但仍然不够优雅。\n\n就像你所看到的，在代码中我们仍然重复写了好几遍对象属性名。例如在上面的代码中，`user.address` 被重复写了三遍。\n\n这就是为什么可选链 `?.` 被加入到了 JavaScript 这门编程语言中。那就是彻底地解决以上所有问题！\n\n## 可选链\n\n如果可选链 `?.` 前面的值为 `undefined` 或者 `null`，它会停止运算并返回 `undefined`。\n\n**为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 `null` 也不是 `undefined`，那么它就“存在”。**\n\n换句话说，例如 `value?.prop`：\n- 如果 `value` 存在，则结果与 `value.prop` 相同，\n- 否则（当 `value` 为 `undefined/null` 时）则返回 `undefined`。\n\n下面这是一种使用 `?.` 安全地访问 `user.address.street` 的方式：\n\n```js run\nlet user = {}; // user 没有 address 属性\n\nalert( user?.address?.street ); // undefined（不报错）\n```\n\n代码简洁明了，也不用重复写好几遍属性名。\n\n这里是一个结合 `document.querySelector` 使用的示例：\n\n```js run\nlet html = document.querySelector('.elem')?.innerHTML; // 如果没有符合的元素，则为 undefined\n```\n\n即使 对象 `user` 不存在，使用 `user?.address` 来读取地址也没问题：\n\n```js run\nlet user = null;\n\nalert( user?.address ); // undefined\nalert( user?.address.street ); // undefined\n```\n\n请注意：`?.` 语法使其前面的值成为可选值，但不会对其后面的起作用。\n\n例如，在 `user?.address.street.name` 中，`?.` 允许 `user` 为 `null/undefined`（在这种情况下会返回 `undefined`）也不会报错，但这仅对于 `user`。更深层次的属性是通过常规方式访问的。如果我们希望它们中的一些也是可选的，那么我们需要使用更多的 `?.` 来替换 `.`。\n\n```warn header=\"不要过度使用可选链\"\n我们应该只将 `?.` 使用在一些东西可以不存在的地方。\n\n例如，如果根据我们的代码逻辑，`user` 对象必须存在，但 `address` 是可选的，那么我们应该这样写 `user.address?.street`，而不是这样 `user?.address?.street`。\n\n那么，如果 `user` 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 `?.`，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。\n```\n\n````warn header=\"`?.` 前的变量必须已声明\"\n如果未声明变量 `user`，那么 `user?.anything` 会触发一个错误：\n\n```js run\n// ReferenceError: user is not defined\nuser?.address;\n```\n`?.` 前的变量必须已声明（例如 `let/const/var user` 或作为一个函数参数）。可选链仅适用于已声明的变量。\n````\n\n## 短路效应\n\n正如前面所说的，如果 `?.` 左边部分不存在，就会立即停止运算（“短路效应”）。\n\n因此，如果在 `?.` 的右侧有任何进一步的函数调用或操作，它们均不会执行。\n\n例如：\n\n```js run\nlet user = null;\nlet x = 0;\n\nuser?.sayHi(x++); // 没有 \"user\"，因此代码执行没有到达 sayHi 调用和 x++\n\nalert(x); // 0，值没有增加\n```\n\n## 其它变体：?.()，?.[]\n\n可选链 `?.` 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。\n\n例如，将 `?.()` 用于调用一个可能不存在的函数。\n\n在下面这段代码中，有些用户具有 `admin` 方法，而有些没有：\n\n```js run\nlet userAdmin = {\n  admin() {\n    alert(\"I am admin\");\n  }\n};\n\nlet userGuest = {};\n\n*!*\nuserAdmin.admin?.(); // I am admin\n*/!*\n\n*!*\nuserGuest.admin?.(); // 啥都没发生（没有这样的方法）\n*/!*\n```\n\n在这两行代码中，我们首先使用点符号（`userAdmin.admin`）来获取 `admin` 属性，因为我们假定对象 `userAdmin` 存在，因此可以安全地读取它。\n\n然后 `?.()` 会检查它左边的部分：如果 `admin` 函数存在，那么就调用运行它（对于 `userAdmin`）。否则（对于 `userGuest`）运算停止，没有报错。\n\n如果我们想使用方括号 `[]` 而不是点符号 `.` 来访问属性，语法 `?.[]` 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。\n\n```js run\nlet key = \"firstName\";\n\nlet user1 = {\n  firstName: \"John\"\n};\n\nlet user2 = null;\n\nalert( user1?.[key] ); // John\nalert( user2?.[key] ); // undefined\n```\n\n此外，我们还可以将 `?.` 跟 `delete` 一起使用：\n\n```js run\ndelete user?.name; // 如果 user 存在，则删除 user.name\n```\n\n````warn header=\"我们可以使用 `?.` 来安全地读取或删除，但不能写入\"\n可选链 `?.` 不能用在赋值语句的左侧。\n\n例如：\n```js run\nlet user = null;\n\nuser?.name = \"John\"; // Error，不起作用\n// 因为它在计算的是：undefined = \"John\"\n```\n\n````\n\n## 总结\n\n可选链 `?.` 语法有三种形式：\n\n1. `obj?.prop` —— 如果 `obj` 存在则返回 `obj.prop`，否则返回 `undefined`。\n2. `obj?.[prop]` —— 如果 `obj` 存在则返回 `obj[prop]`，否则返回 `undefined`。\n3. `obj.method?.()` —— 如果 `obj.method` 存在则调用 `obj.method()`，否则返回 `undefined`。\n\n正如我们所看到的，这些语法形式用起来都很简单直接。`?.` 检查左边部分是否为 `null/undefined`，如果不是则继续运算。\n\n`?.` 链使我们能够安全地访问嵌套属性。\n\n但是，我们应该谨慎地使用 `?.`，根据我们的代码逻辑，仅在当左侧部分不存在也可接受的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏。",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1656646333
      }
    },
    "symbol": {
      "type": "Article",
      "value": {
        "title": "symbol 类型",
        "slug": "symbol",
        "githubPath": "/1-js/04-object-basics/08-symbol",
        "isFolder": false,
        "weight": 8,
        "content": "\n\n根据规范，只有两种原始类型可以用作对象属性键：\n\n- 字符串类型\n- symbol 类型\n\n否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。所以 `obj[1]` 与 `obj[\"1\"]` 相同，而 `obj[true]` 与 `obj[\"true\"]` 相同。\n\n到目前为止，我们一直只使用字符串。\n\n现在我们来看看 symbol 能给我们带来什么。\n\n## symbol\n\n\"symbol\" 值表示唯一的标识符。\n\n可以使用 `Symbol()` 来创建这种类型的值：\n\n```js\nlet id = Symbol();\n```\n\n创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用：\n\n```js\n// id 是描述为 \"id\" 的 symbol\nlet id = Symbol(\"id\");\n```\n\nsymbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。\n\n例如，这里有两个描述相同的 symbol —— 它们不相等：\n\n```js run\nlet id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\n*!*\nalert(id1 == id2); // false\n*/!*\n```\n\n如果你熟悉 Ruby 或者其他有 \"symbol\" 的语言 —— 别被误导。JavaScript 的 symbol 是不同的。\n\n所以，总而言之，symbol 是带有可选描述的“原始唯一值”。让我们看看我们可以在哪里使用它们。\n\n````warn header=\"symbol 不会被自动转换为字符串\"\nJavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 `alert` 任何值，都可以生效。symbol 比较特殊，它不会被自动转换。\n\n例如，这个 `alert` 将会提示出错：\n\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id); // 类型错误：无法将 symbol 值转换为字符串。\n*/!*\n```\n\n这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。\n\n如果我们真的想显示一个 symbol，我们需要在它上面调用 `.toString()`，如下所示：\n\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id.toString()); // Symbol(id)，现在它有效了\n*/!*\n```\n\n或者获取 `symbol.description` 属性，只显示描述（description）：\n\n```js run\nlet id = Symbol(\"id\");\n*!*\nalert(id.description); // id\n*/!*\n```\n\n````\n\n## “隐藏”属性\n\n\nsymbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。\n\n例如，如果我们使用的是属于第三方代码的 `user` 对象，我们想要给它们添加一些标识符。\n\n我们可以给它们使用 symbol 键：\n\n```js run\nlet user = { // 属于另一个代码\n  name: \"John\"\n};\n\nlet id = Symbol(\"id\");\n\nuser[id] = 1;\n\nalert( user[id] ); // 我们可以使用 symbol 作为键来访问数据\n```\n\n使用 `Symbol(\"id\")` 作为键，比起用字符串 `\"id\"` 来有什么好处呢？\n\n由于 `user` 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 `user` 对象是安全的。\n\n另外，假设另一个脚本希望在 `user` 中有自己的标识符，以实现自己的目的。\n\n那么，该脚本可以创建自己的 `Symbol(\"id\")`，像这样：\n\n```js\n// ...\nlet id = Symbol(\"id\");\n\nuser[id] = \"Their id value\";\n```\n\n我们的标识符和它们的标识符之间不会有冲突，因为 symbol 总是不同的，即使它们有相同的名字。\n\n……但如果我们处于同样的目的，使用字符串 `\"id\"` 而不是用 symbol，那么 **就会** 出现冲突：\n\n```js\nlet user = { name: \"John\" };\n\n// 我们的脚本使用了 \"id\" 属性。\nuser.id = \"Our id value\";\n\n// ……另一个脚本也想将 \"id\" 用于它的目的……     \n\nuser.id = \"Their id value\"\n// 砰！无意中被另一个脚本重写了 id！\n```\n\n### 对象字面量中的 symbol\n\n如果我们要在对象字面量 `{...}` 中使用 symbol，则需要使用方括号把它括起来。\n\n就像这样：\n\n```js\nlet id = Symbol(\"id\");\n\nlet user = {\n  name: \"John\",\n*!*\n  [id]: 123 // 而不是 \"id\"：123\n*/!*\n};\n```\n这是因为我们需要变量 `id` 的值作为键，而不是字符串 \"id\"。\n\n### symbol 在 for..in 中会被跳过\n\nsymbol 属性不参与 `for..in` 循环。\n\n例如：\n\n```js run\nlet id = Symbol(\"id\");\nlet user = {\n  name: \"John\",\n  age: 30,\n  [id]: 123\n};\n\n*!*\nfor (let key in user) alert(key); // name, age（没有 symbol）\n*/!*\n\n// 使用 symbol 任务直接访问\nalert(\"Direct: \" + user[id]); // Direct: 123\n```\n\n[Object.keys(user)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。\n\n相反，[Object.assign](mdn:js/Object/assign) 会同时复制字符串和 symbol 属性：\n\n```js run\nlet id = Symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = Object.assign({}, user);\n\nalert( clone[id] ); // 123\n```\n\n这里并不矛盾，就是这样设计的。这里的想法是当我们克隆或者合并一个 object 时，通常希望 **所有** 属性被复制（包括像 `id` 这样的 symbol）。\n\n## 全局 symbol\n\n正如我们所看到的，通常所有的 symbol 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 symbol `\"id\"` 指的是完全相同的属性。\n\n为了实现这一点，这里有一个 **全局 symbol 注册表**。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。\n\n要从注册表中读取（不存在则创建）symbol，请使用 `Symbol.for(key)`。\n\n该调用会检查全局注册表，如果有一个描述为 `key` 的 symbol，则返回该 symbol，否则将创建一个新 symbol（`Symbol(key)`），并通过给定的 `key` 将其存储在注册表中。\n\n例如：\n\n```js run\n// 从全局注册表中读取\nlet id = Symbol.for(\"id\"); // 如果该 symbol 不存在，则创建它\n\n// 再次读取（可能是在代码中的另一个位置）\nlet idAgain = Symbol.for(\"id\");\n\n// 相同的 symbol\nalert( id === idAgain ); // true\n```\n\n注册表内的 symbol 被称为 **全局 symbol**。如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 —— 这就是它们的用途。\n\n```smart header=\"这听起来像 Ruby\"\n在一些编程语言中，例如 Ruby，每个名字都有一个 symbol。\n\n正如我们所看到的，在 JavaScript 中，全局 symbol 也是这样的。\n```\n\n### Symbol.keyFor\n\n我们已经看到，对于全局 symbol，`Symbol.for(key)` 按名字返回一个 symbol。相反，通过全局 symbol 返回一个名字，我们可以使用 `Symbol.keyFor(sym)`：\n\n例如：\n\n```js run\n// 通过 name 获取 symbol\nlet sym = Symbol.for(\"name\");\nlet sym2 = Symbol.for(\"id\");\n\n// 通过 symbol 获取 name\nalert( Symbol.keyFor(sym) ); // name\nalert( Symbol.keyFor(sym2) ); // id\n```\n\n`Symbol.keyFor` 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 `undefined`。\n\n也就是说，所有 symbol 都具有 `description` 属性。\n\n例如：\n\n```js run\nlet globalSymbol = Symbol.for(\"name\");\nlet localSymbol = Symbol(\"name\");\n\nalert( Symbol.keyFor(globalSymbol) ); // name，全局 symbol\nalert( Symbol.keyFor(localSymbol) ); // undefined，非全局\n\nalert( localSymbol.description ); // name\n```\n\n## 系统 symbol\n\nJavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面。 \n\n它们都被列在了 [众所周知的 symbol](https://tc39.github.io/ecma262/#sec-well-known-symbols) 表的规范中：\n\n- `Symbol.hasInstance`\n- `Symbol.isConcatSpreadable`\n- `Symbol.iterator`\n- `Symbol.toPrimitive`\n- ……等等。\n\n例如，`Symbol.toPrimitive` 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。\n\n当我们研究相应的语言特征时，我们对其他的 symbol 也会慢慢熟悉起来。\n\n## 总结\n\n`symbol` 是唯一标识符的基本类型\n\nsymbol 是使用带有可选描述（name）的 `Symbol()` 调用创建的。\n\nsymbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：`Symbol.for(key)` 返回（如果需要的话则创建）一个以 `key` 作为名字的全局 symbol。使用 `Symbol.for` 多次调用 `key` 相同的 symbol 时，返回的就是同一个 symbol。\n\nsymbol 有两个主要的使用场景：\n\n1. “隐藏” 对象属性。\n\n    如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 `for..in` 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。\n\n    因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。\n\n2. JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 `Symbol.*` 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 `Symbol.iterator` 来进行 [迭代](info:iterable) 操作，使用 `Symbol.toPrimitive` 来设置 [对象原始值的转换](info:object-toprimitive) 等等。\n\n从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols) 允许我们获取所有的 symbol。还有一个名为 [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) 的方法可以返回一个对象的 **所有** 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1657705346
      }
    },
    "object-toprimitive": {
      "type": "Article",
      "value": {
        "title": "对象 —— 原始值转换",
        "slug": "object-toprimitive",
        "githubPath": "/1-js/04-object-basics/09-object-toprimitive",
        "isFolder": false,
        "weight": 9,
        "content": "\n\n当对象相加 `obj1 + obj2`，相减 `obj1 - obj2`，或者使用 `alert(obj)` 打印时会发生什么？\n\nJavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（Ruby，C++）不同，我们无法实现特殊的对象处理方法来处理加法（或其他运算）。\n\n在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。\n\n这是一个重要的限制：因为 `obj1 + obj2`（或者其他数学运算）的结果不能是另一个对象！\n\n例如，我们无法使用对象来表示向量或矩阵（或成就或其他），把它们相加并期望得到一个“总和”向量作为结果。这样的想法是行不通的。\n\n因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。\n\n本文将介绍对象是如何转换为原始值的，以及如何对其进行自定义。\n\n我们有两个目的：\n\n1. 让我们在遇到类似的对对象进行数学运算的编程错误时，能够更加理解到底发生了什么。\n2. 也有例外，这些操作也可以是可行的。例如日期相减或比较（`Date` 对象）。我们稍后会遇到它们。\n\n## 转换规则\n\n在 <info:type-conversions> 一章中，我们已经看到了数字、字符串和布尔转换的规则。但是我们没有讲对象的转换规则。现在我们已经掌握了方法（method）和 symbol 的相关知识，可以开始学习对象原始值转换了。\n\n1. 没有转换为布尔值。所有的对象在布尔上下文（context）中均为 `true`，就这么简单。只有字符串和数字转换。\n2. 数字转换发生在对象相减或应用数学函数时。例如，`Date` 对象（将在 <info:date> 一章中介绍）可以相减，`date1 - date2` 的结果是两个日期之间的差值。\n3. 至于字符串转换 —— 通常发生在我们像 `alert(obj)` 这样输出一个对象和类似的上下文中。\n\n我们可以使用特殊的对象方法，自己实现字符串和数字的转换。\n\n现在让我们一起探究技术细节，因为这是深入讨论该主题的唯一方式。\n\n## hint\n\nJavaScript 是如何决定应用哪种转换的？\n\n类型转换在各种情况下有三种变体。它们被称为 \"hint\"，在 [规范](https://tc39.github.io/ecma262/#sec-toprimitive) 所述：\n\n`\"string\"`\n: 对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 \"alert\"：\n\n    ```js\n    // 输出\n    alert(obj);\n\n    // 将对象作为属性键\n    anotherObj[obj] = 123;\n    ```\n\n`\"number\"`\n: 对象到数字的转换，例如当我们进行数学运算时：\n\n    ```js\n    // 显式转换\n    let num = Number(obj);\n\n    // 数学运算（除了二元加法）\n    let n = +obj; // 一元加法\n    let delta = date1 - date2;\n\n    // 小于/大于的比较\n    let greater = user1 > user2;\n    ```\n\n    大多数内建的数学函数也包括这种转换。\n\n`\"default\"`\n: 在少数情况下发生，当运算符“不确定”期望值的类型时。\n\n    例如，二元加法 `+` 可用于字符串（连接），也可以用于数字（相加）。因此，当二元加法得到对象类型的参数时，它将依据 `\"default\"` hint 来对其进行转换。\n\n    此外，如果对象被用于与字符串、数字或 symbol 进行 `==` 比较，这时到底应该进行哪种转换也不是很明确，因此使用 `\"default\"` hint。\n\n    ```js\n    // 二元加法使用默认 hint\n    let total = obj1 + obj2;\n\n    // obj == number 使用默认 hint\n    if (user == 1) { ... };\n    ```\n\n    像 `<` 和 `>` 这样的小于/大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 \"number\" hint，而不是 \"default\"。这是历史原因。\n\n上面这些规则看起来比较复杂，但在实践中其实挺简单的。\n\n除了一种情况（`Date` 对象，我们稍后会讲到）之外，所有内建对象都以和 `\"number\"` 相同的方式实现 `\"default\"` 转换。我们也可以这样做。\n\n尽管如此，了解上述的 3 个 hint 还是很重要的，很快你就会明白为什么这样说。\n\n**为了进行转换，JavaScript 尝试查找并调用三个对象方法：**\n\n1. 调用 `obj[Symbol.toPrimitive](hint)` —— 带有 symbol 键 `Symbol.toPrimitive`（系统 symbol）的方法，如果这个方法存在的话，\n2. 否则，如果 hint 是 `\"string\"`\n   —— 尝试调用 `obj.toString()` 或 `obj.valueOf()`，无论哪个存在。\n3. 否则，如果 hint 是 `\"number\"` 或 `\"default\"`\n   —— 尝试调用 `obj.valueOf()` 或 `obj.toString()`，无论哪个存在。\n\n## Symbol.toPrimitive\n\n我们从第一个方法开始。有一个名为 `Symbol.toPrimitive` 的内建 symbol，它被用来给转换方法命名，像这样：\n\n```js\nobj[Symbol.toPrimitive] = function(hint) {\n  // 这里是将此对象转换为原始值的代码\n  // 它必须返回一个原始值\n  // hint = \"string\"、\"number\" 或 \"default\" 中的一个\n}\n```\n\n如果 `Symbol.toPrimitive` 方法存在，则它会被用于所有 hint，无需更多其他方法。\n\n例如，这里 `user` 对象实现了它：\n\n```js run\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  [Symbol.toPrimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == \"string\" ? `{name: \"${this.name}\"}` : this.money;\n  }\n};\n\n// 转换演示：\nalert(user); // hint: string -> {name: \"John\"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n```\n\n从代码中我们可以看到，根据转换的不同，`user` 变成一个自描述字符串或者一个金额。`user[Symbol.toPrimitive]` 方法处理了所有的转换情况。\n\n## toString/valueOf\n\n如果没有 `Symbol.toPrimitive`，那么 JavaScript 将尝试寻找 `toString` 和 `valueOf` 方法：\n\n- 对于 `\"string\"` hint：调用 `toString` 方法，如果它不存在，则调用 `valueOf` 方法（因此，对于字符串转换，优先调用 `toString`）。\n- 对于其他 hint：调用 `valueOf` 方法，如果它不存在，则调用 `toString` 方法（因此，对于数学运算，优先调用 `valueOf` 方法）。\n\n`toString` 和 `valueOf` 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。\n\n这些方法必须返回一个原始值。如果 `toString` 或 `valueOf` 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。\n\n默认情况下，普通对象具有 `toString` 和 `valueOf` 方法：\n\n- `toString` 方法返回一个字符串 `\"[object Object]\"`。\n- `valueOf` 方法返回对象自身。\n\n下面是一个示例：\n\n```js run\nlet user = {name: \"John\"};\n\nalert(user); // [object Object]\nalert(user.valueOf() === user); // true\n```\n\n所以，如果我们尝试将一个对象当做字符串来使用，例如在 `alert` 中，那么在默认情况下我们会看到 `[object Object]`。\n\n这里提到的默认的 `valueOf` 只是为了完整起见，以避免混淆。正如你看到的，它返回对象本身，因此被忽略。别问我为什么，这是历史原因。所以我们可以假设它根本就不存在。\n\n让我们实现一下这些方法来自定义转换。\n\n例如，这里的 `user` 执行和前面提到的那个 `user` 一样的操作，使用 `toString` 和 `valueOf` 的组合（而不是 `Symbol.toPrimitive`）：\n\n```js run\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  // 对于 hint=\"string\"\n  toString() {\n    return `{name: \"${this.name}\"}`;\n  },\n\n  // 对于 hint=\"number\" 或 \"default\"\n  valueOf() {\n    return this.money;\n  }\n\n};\n\nalert(user); // toString -> {name: \"John\"}\nalert(+user); // valueOf -> 1000\nalert(user + 500); // valueOf -> 1500\n```\n\n我们可以看到，执行的动作和前面使用 `Symbol.toPrimitive` 的那个例子相同。\n\n通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 `toString`，就像这样：\n\n```js run\nlet user = {\n  name: \"John\",\n\n  toString() {\n    return this.name;\n  }\n};\n\nalert(user); // toString -> John\nalert(user + 500); // toString -> John500\n```\n\n如果没有 `Symbol.toPrimitive` 和 `valueOf`，`toString` 将处理所有原始转换。\n\n### 转换可以返回任何原始类型\n\n关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 \"hint\" 的原始值。\n\n没有限制 `toString()` 是否返回字符串，或 `Symbol.toPrimitive` 方法是否为 `\"number\"` hint 返回数字。\n\n唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。\n\n```smart header=\"历史原因\"\n由于历史原因，如果 `toString` 或 `valueOf` 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 \"error\" 的概念。\n\n相反，`Symbol.toPrimitive` 更严格，它 **必须** 返回一个原始值，否则就会出现 error。\n```\n\n## 进一步的转换\n\n我们已经知道，许多运算符和函数执行类型转换，例如乘法 `*` 将操作数转换为数字。\n\n如果我们将对象作为参数传递，则会出现两个运算阶段：\n1. 对象被转换为原始值（通过前面我们描述的规则）。\n2. 如果还需要进一步计算，则生成的原始值会被进一步转换。\n\n例如：\n\n```js run\nlet obj = {\n  // toString 在没有其他方法的情况下处理所有转换\n  toString() {\n    return \"2\";\n  }\n};\n\nalert(obj * 2); // 4，对象被转换为原始值字符串 \"2\"，之后它被乘法转换为数字 2。\n```\n\n1. 乘法 `obj * 2` 首先将对象转换为原始值（字符串 \"2\"）。\n2. 之后 `\"2\" * 2` 变为 `2 * 2`（字符串被转换为数字）。\n\n二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：\n\n```js run\nlet obj = {\n  toString() {\n    return \"2\";\n  }\n};\n\nalert(obj + 2); // 22（\"2\" + 2）被转换为原始值字符串 => 级联\n```\n\n## 总结\n\n对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。\n\n这里有三种类型（hint）：\n- `\"string\"`（对于 `alert` 和其他需要字符串的操作）\n- `\"number\"`（对于数学运算）\n- `\"default\"`（少数运算符，通常对象以和 `\"number\"` 相同的方式实现 `\"default\"` 转换）\n\n规范明确描述了哪个运算符使用哪个 hint。\n\n转换算法是：\n\n1. 调用 `obj[Symbol.toPrimitive](hint)` 如果这个方法存在，\n2. 否则，如果 hint 是 `\"string\"`\n    - 尝试调用 `obj.toString()` 或 `obj.valueOf()`，无论哪个存在。\n3. 否则，如果 hint 是 `\"number\"` 或者 `\"default\"`\n    - 尝试调用 `obj.valueOf()` 或 `obj.toString()`，无论哪个存在。\n\n所有这些方法都必须返回一个原始值才能工作（如果已定义）。\n\n在实际使用中，通常只实现 `obj.toString()` 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。",
        "libs": [],
        "children": [],
        "parent": "object-basics",
        "updatedAt": 1657885250
      }
    },
    "data-types": {
      "type": "Article",
      "value": {
        "title": "数据类型",
        "slug": "data-types",
        "githubPath": "/1-js/05-data-types",
        "isFolder": true,
        "weight": 5,
        "content": "\n\n更多的数据结构和更深入的类型研究。",
        "libs": [],
        "children": [
          "primitives-methods",
          "number",
          "string",
          "array",
          "array-methods",
          "iterable",
          "map-set",
          "weakmap-weakset",
          "keys-values-entries",
          "destructuring-assignment",
          "date",
          "json"
        ],
        "parent": "js"
      }
    },
    "primitives-methods": {
      "type": "Article",
      "value": {
        "title": "原始类型的方法",
        "slug": "primitives-methods",
        "githubPath": "/1-js/05-data-types/01-primitives-methods",
        "isFolder": false,
        "weight": 1,
        "content": "\n\nJavaScript 允许我们像使用对象一样使用原始类型（字符串，数字等）。JavaScript 还提供了这样的调用方法。我们很快就会学习它们，但是首先我们将了解它的工作原理，毕竟原始类型不是对象（在这里我们会分析地更加清楚）。\n\n我们来看看原始类型和对象之间的关键区别。\n\n一个原始值：\n\n- 是原始类型中的一种值。\n- 在 JavaScript 中有 7 种原始类型：`string`，`number`，`bigint`，`boolean`，`symbol`，`null` 和 `undefined`。\n\n一个对象：\n\n- 能够存储多个值作为属性。\n- 可以使用大括号 `{}` 创建对象，例如：`{name: \"John\", age: 30}`。JavaScript 中还有其他种类的对象，例如函数就是对象。\n\n关于对象的最好的事儿之一是，我们可以把一个函数作为对象的属性存储到对象中。\n\n```js run\nlet john = {\n  name: \"John\",\n  sayHi: function() {\n    alert(\"Hi buddy!\");\n  }\n};\n\njohn.sayHi(); // Hi buddy!\n```\n\n所以我们在这里创建了一个包含 `sayHi` 方法的对象 `john`。\n\n许多内建对象已经存在，例如那些处理日期、错误、HTML 元素等的内建对象。它们具有不同的属性和方法。\n\n但是，这些特性（feature）都是有成本的！\n\n对象比原始类型“更重”。它们需要额外的资源来支持运作。\n\n## 当作对象的原始类型\n\n以下是 JavaScript 创建者面临的悖论：\n\n- 人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好使用方法来访问它们。\n- 原始类型必须尽可能的简单轻量。\n\n而解决方案看起来多少有点尴尬，如下：\n\n1. 原始类型仍然是原始的。与预期相同，提供单个值\n2. JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。\n3. 为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。\n\n“对象包装器”对于每种原始类型都是不同的，它们被称为 `String`、`Number`、`Boolean`、`Symbol` 和 `BigInt`。因此，它们提供了不同的方法。\n\n例如，字符串方法 [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) 返回一个大写化处理的字符串。\n\n用法演示如下：\n\n```js run\nlet str = \"Hello\";\n\nalert( str.toUpperCase() ); // HELLO\n```\n\n很简单，对吧？以下是 `str.toUpperCase()` 中实际发生的情况：\n\n1. 字符串 `str` 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有可用的方法，例如 `toUpperCase()`。\n2. 该方法运行并返回一个新的字符串（由 `alert` 显示）。\n3. 特殊对象被销毁，只留下原始值 `str`。\n\n所以原始类型可以提供方法，但它们依然是轻量级的。\n\nJavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。\n\n数字有其自己的方法，例如，[toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 将数字舍入到给定的精度：\n\n```js run\nlet n = 1.23456;\n\nalert( n.toFixed(2) ); // 1.23\n```\n\n我们将在后面 <info:number> 和 <info:string> 章节中看到更多具体的方法。\n\n\n````warn header=\"构造器 `String/Number/Boolean` 仅供内部使用\"\n像 Java 这样的一些语言允许我们使用 `new Number(1)` 或 `new Boolean(false)` 等语法，明确地为原始类型创建“对象包装器”。\n\n在 JavaScript 中，由于历史原因，这也是可以的，但极其 **不推荐**。因为这样会出问题。\n\n例如：\n\n```js run\nalert( typeof 0 ); // \"number\"\n\nalert( typeof new Number(0) ); // \"object\"!\n```\n\n对象在 `if` 中始终为真，所以此处的 alert 将显示：\n\n```js run\nlet zero = new Number(0);\n\nif (zero) { // zero 为 true，因为它是一个对象\n  alert( \"zero is truthy?!?\" );\n}\n```\n\n另一方面，调用不带 `new`（关键字）的 `String/Number/Boolean` 函数是可以的且有效的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。\n\n例如，下面完全是有效的：\n\n```js\nlet num = Number(\"123\"); // 将字符串转成数字\n```\n````\n\n\n````warn header=\"null/undefined 没有任何方法\"\n特殊的原始类型 `null` 和 `undefined` 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。\n\n尝试访问这种值的属性会导致错误：\n\n```js run\nalert(null.test); // error\n````\n\n## 总结\n\n- 除 `null` 和 `undefined` 以外的原始类型都提供了许多有用的方法。我们后面的章节中学习这些内容。\n- 从形式上讲，这些方法通过临时对象工作，但 JavaScript 引擎可以很好地调整，以在内部对其进行优化，因此调用它们并不需要太高的成本。",
        "libs": [],
        "children": [
          "string-new-property"
        ],
        "parent": "data-types",
        "updatedAt": 1657799105
      }
    },
    "string-new-property": {
      "type": "Task",
      "value": {
        "title": "我能为字符串添加一个属性吗？",
        "slug": "string-new-property",
        "githubPath": "/1-js/05-data-types/01-primitives-methods/1-string-new-property",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n\n思考下面的代码：\n\n```js\nlet str = \"Hello\";\n\nstr.test = 5;\n\nalert(str.test);\n```\n\n你怎么想的呢，它会工作吗？会得到什么样的结果？",
        "solution": "试试运行一下：\n\n```js run\nlet str = \"Hello\";\n\nstr.test = 5; // (*)\n\nalert(str.test); \n```\n\n根据你是否开启了严格模式 `use strict`，会得到如下结果：\n1. `undefined`（非严格模式）\n2. 报错（严格模式）。\n\n为什么？让我们看看在 `(*)` 那一行到底发生了什么：\n\n1. 当访问 `str` 的属性时，一个“对象包装器”被创建了。\n2. 在严格模式下，向其写入内容会报错。\n3. 否则，将继续执行带有属性的操作，该对象将获得 `test` 属性，但是此后，“对象包装器”将消失，因此在最后一行，`str` 并没有该属性的踪迹。\n\n**这个例子清楚地表明，原始类型不是对象。**\n\n它们不能存储额外的数据。",
        "parent": "primitives-methods",
        "version": 1
      }
    },
    "number": {
      "type": "Article",
      "value": {
        "title": "数字类型",
        "slug": "number",
        "githubPath": "/1-js/05-data-types/02-number",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n在现代 JavaScript 中，数字（number）有两种类型：\n\n1. JavaScript 中的常规数字以 64 位的格式 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754) 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。\n\n2. BigInt 用于表示任意长度的整数。有时会需要它们，因为正如我们在前面的章节 <info:types> 中提到的，常规整数不能安全地超过 <code>(2<sup>53</sup>-1)</code> 或小于 <code>-(2<sup>53</sup>-1)</code>。由于仅在少数特殊领域才会用到 BigInt，因此我们在特殊的章节 <info:bigint> 中对其进行了介绍。\n\n所以，在这里我们将讨论常规数字类型。现在让我们开始学习吧。\n\n## 编写数字的更多方法\n\n假如我们需要表示 10 亿。显然，我们可以这样写：\n\n```js\nlet billion = 1000000000;\n```\n\n我们也可以使用下划线 `_` 作为分隔符：\n\n```js\nlet billion = 1_000_000_000;\n```\n\n这里的下划线 `_` 扮演了“[语法糖](https://en.wikipedia.org/wiki/Syntactic_sugar)”的角色，使得数字具有更强的可读性。JavaScript 引擎会直接忽略数字之间的 `_`，所以 上面两个例子其实是一样的。\n\n但在现实生活中，我们通常会尽量避免写带一长串零的数。因为我们比较懒……我们会尝试将 10 亿写成 `\"1bn\"`，或将 73 亿写成 `\"7.3bn\"`。对于大多数大的数字来说都是如此。\n\n在 JavaScript 中，我们可以通过在数字后面附加字母 `\"e\"` 并指定零的个数来缩短数字：\n\n```js run\nlet billion = 1e9;  // 10 亿，字面意思：数字 1 后面跟 9 个 0\n\nalert( 7.3e9 );  // 73 亿（与 7300000000 和 7_300_000_000 相同）\n```\n\n换句话说，`e` 把数字乘以 `1` 后面跟着给定数量的 0 的数字。\n\n```js\n1e3 === 1 * 1000; // e3 表示 *1000\n1.23e6 === 1.23 * 1000000; // e6 表示 *1000000\n```\n\n现在让我们写一些非常小的数字。例如，1 微秒（百万分之一秒）：\n\n```js\nlet mcs = 0.000001;\n```\n\n就像以前一样，可以使用 `\"e\"` 来完成。如果我们想避免显式地写零，我们可以这样写：\n\n```js\nlet mcs = 1e-6; // 1 的左边有 6 个 0\n```\n\n如果我们数一下 `0.000001` 中的 0 的个数，是 6 个。所以自然是 `1e-6`。\n\n换句话说，`e` 后面的负数表示除以 1 后面跟着给定数量的 0 的数字：\n\n```js\n// -3 除以 1 后面跟着 3 个 0 的数字\n1e-3 === 1 / 1000; // 0.001\n\n// -6 除以 1 后面跟着 6 个 0 的数字\n1.23e-6 === 1.23 / 1000000; // 0.00000123\n\n// 一个更大一点的数字的示例\n1234e-2 === 1234 / 100; // 12.34，小数点移动两次\n```\n\n### 十六进制，二进制和八进制数字\n\n[十六进制](https://en.wikipedia.org/wiki/Hexadecimal) 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：`0x`，然后是数字。\n\n例如：\n\n```js run\nalert( 0xff ); // 255\nalert( 0xFF ); // 255（一样，大小写没影响）\n```\n\n二进制和八进制数字系统很少使用，但也支持使用 `0b` 和 `0o` 前缀：\n\n\n```js run\nlet a = 0b11111111; // 二进制形式的 255\nlet b = 0o377; // 八进制形式的 255\n\nalert( a == b ); // true，两边是相同的数字，都是 255\n```\n\n只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 `parseInt`（我们将在本章后面看到）。\n\n## toString(base)\n\n方法 `num.toString(base)` 返回在给定 `base` 进制数字系统中 `num` 的字符串表示形式。\n\n举个例子：\n```js run\nlet num = 255;\n\nalert( num.toString(16) );  // ff\nalert( num.toString(2) );   // 11111111\n```\n\n`base` 的范围可以从 `2` 到 `36`。默认情况下是 `10`。\n\n常见的用例如下：\n\n- **base=16** 用于十六进制颜色，字符编码等，数字可以是 `0..9` 或 `A..F`。\n- **base=2** 主要用于调试按位操作，数字可以是 `0` 或 `1`。\n- **base=36** 是最大进制，数字可以是 `0..9` 或 `A..Z`。所有拉丁字母都被用于了表示数字。对于 `36` 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 `36` 的数字系统表示：\n\n    ```js run\n    alert( 123456..toString(36) ); // 2n9c\n    ```\n\n```warn header=\"使用两个点来调用一个方法\"\n请注意 `123456..toString(36)` 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 `toString`，那么我们需要在它后面放置两个点 `..`。\n\n如果我们放置一个点：`123456.toString(36)`，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。\n\n也可以写成 `(123456).toString(36)`。\n\n```\n\n## 舍入\n\n舍入（rounding）是使用数字时最常用的操作之一。\n\n这里有几个对数字进行舍入的内建函数：\n\n`Math.floor`\n: 向下舍入：`3.1` 变成 `3`，`-1.1` 变成 `-2`。\n\n`Math.ceil`\n: 向上舍入：`3.1` 变成 `4`，`-1.1` 变成 `-1`。\n\n`Math.round`\n: 向最近的整数舍入：`3.1` 变成 `3`，`3.6` 变成 `4`，中间值 `3.5` 变成 `4`。\n\n`Math.trunc`（IE 浏览器不支持这个方法）\n: 移除小数点后的所有内容而没有舍入：`3.1` 变成 `3`，`-1.1` 变成 `-1`。\n\n这个是总结它们之间差异的表格：\n\n|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |\n|---|---------|--------|---------|---------|\n|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |\n|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |\n|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |\n|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |\n\n\n这些函数涵盖了处理数字小数部分的所有可能方法。但是，如果我们想将数字舍入到小数点后 `n` 位，该怎么办？\n\n例如，我们有 `1.2345`，并且想把它舍入到小数点后两位，仅得到 `1.23`。\n\n有两种方式可以实现这个需求：\n\n1. 乘除法\n\n    例如，要将数字舍入到小数点后两位，我们可以将数字乘以 `100`，调用舍入函数，然后再将其除回。\n    ```js run\n    let num = 1.23456;\n\n    alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23\n    ```\n\n2. 函数 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 将数字舍入到小数点后 `n` 位，并以字符串形式返回结果。\n        \n    ```js run\n    let num = 12.34;\n    alert( num.toFixed(1) ); // \"12.3\"\n    ```\n\n    这会向上或向下舍入到最接近的值，类似于 `Math.round`：\n\n    ```js run\n    let num = 12.36;\n    alert( num.toFixed(1) ); // \"12.4\"\n    ```\n\n    请注意 `toFixed` 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：\n\n    ```js run\n    let num = 12.34;\n    alert( num.toFixed(5) ); // \"12.34000\"，在结尾添加了 0，以达到小数点后五位\n    ```\n\n    我们可以使用一元加号或 `Number()` 调用，将其转换为数字，例如 `+ num.toFixed(5)`。\n\n## 不精确的计算\n\n在内部，数字是以 64 位格式 [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754) 表示的，所以正好有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置，而 1 位用于符号。\n\n如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 `Infinity`：\n\n```js run\nalert( 1e500 ); // Infinity\n```\n\n这可能不那么明显，但经常会发生的是，精度的损失。\n\n考虑下这个（falsy!）相等性测试：\n\n```js run\nalert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*\n```\n\n没错，如果我们检查 `0.1` 和 `0.2` 的总和是否为 `0.3`，我们会得到 `false`。\n\n奇了怪了！如果不是 `0.3`，那能是啥？\n\n```js run\nalert( 0.1 + 0.2 ); // 0.30000000000000004\n```\n\n我擦！想象一下，你创建了一个电子购物网站，如果访问者将价格为 `¥ 0.10` 和 `¥ 0.20` 的商品放入了他的购物车。订单总额将是 `¥ 0.30000000000000004`。这会让任何人感到惊讶。\n\n但为什么会这样呢？\n\n一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 `0.1`，`0.2` 这样的小数，实际上在二进制形式中是无限循环小数。\n\n什么是 `0.1`？`0.1` 就是 `1` 除以 `10`，`1/10`，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：`1/3`。三分之一变成了无限循环小数 `0.33333(3)`。\n\n在十进制数字系统中，可以保证以 `10` 的整数次幂作为除数能够正常工作，但是以 `3` 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 `2` 的整数次幂作为除数时能够正常工作，但 `1/10` 就变成了一个无限循环的二进制小数。\n\n使用二进制数字系统无法 **精确** 存储 *0.1* 或 *0.2*，就像没有办法将三分之一存储为十进制小数一样。\n\nIEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。\n\n我们可以看到：\n```js run\nalert( 0.1.toFixed(20) ); // 0.10000000000000000555\n```\n\n当我们对两个数字进行求和时，它们的“精度损失”会叠加起来。\n\n这就是为什么 `0.1 + 0.2` 不等于 `0.3`。\n\n```smart header=\"不仅仅是 JavaScript\"\n许多其他编程语言也存在同样的问题。\n\nPHP，Java，C，Perl，Ruby 给出的也是完全相同的结果，因为它们基于的是相同的数字格式。\n```\n\n我们能解决这个问题吗？当然，最可靠的方法是借助方法 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 对结果进行舍入：\n\n```js run\nlet sum = 0.1 + 0.2;\nalert( sum.toFixed(2) ); // 0.30\n```\n\n请注意，`toFixed` 总是返回一个字符串。它确保小数点后有 2 位数字。如果我们有一个电子购物网站，并需要显示 `¥ 0.30`，这实际上很方便。对于其他情况，我们可以使用一元加号将其强制转换为一个数字：\n\n```js run\nlet sum = 0.1 + 0.2;\nalert( +sum.toFixed(2) ); // \"0.30\"\n```\n\n我们可以将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。当我们使用整数进行数学运算时，误差会有所减少，但仍然可以在除法中得到：\n\n```js run\nalert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3\nalert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001\n```\n\n因此，乘/除法可以减少误差，但不能完全消除误差。\n\n有时候我们可以尝试完全避免小数。例如，我们正在创建一个电子购物网站，那么我们可以用角而不是元来存储价格。但是，如果我们要打 30% 的折扣呢？实际上，完全避免小数处理几乎是不可能的。只需要在必要时剪掉其“尾巴”来对其进行舍入即可。\n\n````smart header=\"有趣的事儿\"\n尝试运行下面这段代码：\n\n```js run\n// Hello！我是一个会自我增加的数字！\nalert( 9999999999999999 ); // 显示 10000000000000000\n```\n\n出现了同样的问题：精度损失。有 64 位来表示该数字，其中 52 位可用于存储数字，但这还不够。所以最不重要的数字就消失了。\n\nJavaScript 不会在此类事件中触发 error。它会尽最大努力使数字符合所需的格式，但不幸的是，这种格式不够大到满足需求。\n````\n\n```smart header=\"两个零\"\n数字内部表示的另一个有趣结果是存在两个零：`0` 和 `-0`。\n\n这是因为在存储时，使用一位来存储符号，因此对于包括零在内的任何数字，可以设置这一位或者不设置。\n\n在大多数情况下，这种区别并不明显，因为运算符将它们视为相同的值。\n```\n\n## 测试：isFinite 和 isNaN\n\n还记得这两个特殊的数值吗？\n\n- `Infinity`（和 `-Infinity`）是一个特殊的数值，比任何数值都大（小）。\n- `NaN` 代表一个 error。\n\n它们属于 `number` 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数：\n\n\n- `isNaN(value)` 将其参数转换为数字，然后测试它是否为 `NaN`：\n\n    ```js run\n    alert( isNaN(NaN) ); // true\n    alert( isNaN(\"str\") ); // true\n    ```\n\n    但是我们需要这个函数吗？我们不能只使用 `=== NaN` 比较吗？很不幸，这不行。值 \"NaN\" 是独一无二的，它不等于任何东西，包括它自身：\n\n    ```js run\n    alert( NaN === NaN ); // false\n    ```\n\n- `isFinite(value)` 将其参数转换为数字，如果是常规数字而不是 `NaN/Infinity/-Infinity`，则返回 `true`：\n\n    ```js run\n    alert( isFinite(\"15\") ); // true\n    alert( isFinite(\"str\") ); // false，因为是一个特殊的值：NaN\n    alert( isFinite(Infinity) ); // false，因为是一个特殊的值：Infinity\n    ```\n\n有时 `isFinite` 被用于验证字符串值是否为常规数字：\n\n\n```js run\nlet num = +prompt(\"Enter a number\", '');\n\n// 结果会是 true，除非你输入的是 Infinity、-Infinity 或不是数字\nalert( isFinite(num) );\n```\n\n请注意，在所有数字函数中，包括 `isFinite`，空字符串或仅有空格的字符串均被视为 `0`。\n\n```smart header=\"与 `Object.is` 进行比较\"\n有一个特殊的内建方法 `Object.is`，它类似于 `===` 一样对值进行比较，但它对于两种边缘情况更可靠：\n\n1. 它适用于 `NaN`：`Object.is(NaN, NaN) === true`，这是件好事。\n2. 值 `0` 和 `-0` 是不同的：`Object.is(0, -0) === false`，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。\n\n在所有其他情况下，`Object.is(a, b)` 与 `a === b` 相同。\n\n这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 `Object.is`（内部称为 [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)）。\n```\n\n\n## parseInt 和 parseFloat\n\n使用加号 `+` 或 `Number()` 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：\n\n```js run\nalert( +\"100px\" ); // NaN\n```\n\n唯一的例外是字符串开头或结尾的空格，因为它们会被忽略。\n\n但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 `\"100px\"` 或 `\"12pt\"`。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 `\"19€\"`，并希望从中提取出一个数值。\n\n这就是 `parseInt` 和 `parseFloat` 的作用。\n\n它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 `parseInt` 返回一个整数，而 `parseFloat` 返回一个浮点数：\n\n```js run\nalert( parseInt('100px') ); // 100\nalert( parseFloat('12.5em') ); // 12.5\n\nalert( parseInt('12.3') ); // 12，只有整数部分被返回了\nalert( parseFloat('12.3.4') ); // 12.3，在第二个点出停止了读取\n```\n\n某些情况下，`parseInt/parseFloat` 会返回 `NaN`。当没有数字可读时会发生这种情况：\n\n```js run\nalert( parseInt('a123') ); // NaN，第一个符号停止了读取\n```\n\n````smart header=\"parseInt(str, radix) 的第二个参数\"\n`parseInt()` 函数具有可选的第二个参数。它指定了数字系统的基数，因此 `parseInt` 还可以解析十六进制数字、二进制数字等的字符串：\n\n```js run\nalert( parseInt('0xff', 16) ); // 255\nalert( parseInt('ff', 16) ); // 255，没有 0x 仍然有效\n\nalert( parseInt('2n9c', 36) ); // 123456\n```\n````\n\n## 其他数学函数\n\nJavaScript 有一个内建的 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象，它包含了一个小型的数学函数和常量库。\n\n几个例子：\n\n`Math.random()`\n: 返回一个从 0 到 1 的随机数（不包括 1）。\n\n    ```js run\n    alert( Math.random() ); // 0.1234567894322\n    alert( Math.random() ); // 0.5435252343232\n    alert( Math.random() ); // ... (任何随机数)\n    ```\n\n`Math.max(a, b, c...)` 和 `Math.min(a, b, c...)`\n: 从任意数量的参数中返回最大值和最小值。\n\n    ```js run\n    alert( Math.max(3, 5, -10, 0, 1) ); // 5\n    alert( Math.min(1, 2) ); // 1\n    ```\n\n`Math.pow(n, power)`\n: 返回 `n` 的给定（power）次幂。\n\n    ```js run\n    alert( Math.pow(2, 10) ); // 2 的 10 次幂 = 1024\n    ```\n\n`Math` 对象中还有更多函数和常量，包括三角函数，你可以在 [Math 对象文档](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 中找到这些内容。\n\n## 总结\n\n要写有很多零的数字：\n\n- 将 `\"e\"` 和 0 的数量附加到数字后。就像：`123e6` 与 `123` 后面接 6 个 0 相同。\n- `\"e\"` 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 `123e-6` 表示 `0.000123`（`123` 的百万分之一）。\n\n对于不同的数字系统：\n\n- 可以直接在十六进制（`0x`），八进制（`0o`）和二进制（`0b`）系统中写入数字。\n- `parseInt(str, base)` 将字符串 `str` 解析为在给定的 `base` 数字系统中的整数，`2 ≤ base ≤ 36`。\n- `num.toString(base)` 将数字转换为在给定的 `base` 数字系统中的字符串。\n\n对于常规数字检测：\n\n- `isNaN(value)` 将其参数转换为数字，然后检测它是否为 `NaN`\n- `isFinite(value)` 将其参数转换为数字，如果它是常规数字，则返回 `true`，而不是 `NaN/Infinity/-Infinity`\n\n要将 `12pt` 和 `100px` 之类的值转换为数字：\n\n- 使用 `parseInt/parseFloat` 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。\n\n小数：\n\n- 使用 `Math.floor`，`Math.ceil`，`Math.trunc`，`Math.round` 或 `num.toFixed(precision)` 进行舍入。\n- 请确保记住使用小数时会损失精度。\n\n更多数学函数：\n\n- 需要时请查看 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象。这个库很小，但是可以满足基本的需求。",
        "libs": [],
        "children": [
          "sum-interface",
          "why-rounded-down",
          "repeat-until-number",
          "endless-loop-error",
          "random-min-max",
          "random-int-min-max"
        ],
        "parent": "data-types",
        "updatedAt": 1665942617
      }
    },
    "sum-interface": {
      "type": "Task",
      "value": {
        "title": "来自访问者的数字的总和",
        "slug": "sum-interface",
        "githubPath": "/1-js/05-data-types/02-number/1-sum-interface",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个脚本，提示访问者输入两个数字，然后显示它们的总和。\n\n[demo]\n\nP.S. 有一个类型陷阱。",
        "solution": "```js run demo\nlet a = +prompt(\"The first number?\", \"\");\nlet b = +prompt(\"The second number?\", \"\");\n\nalert( a + b );\n```\n\n注意在 `prompt` 前面的一元加号 `+`。它将立即把值转换成数字。\n\n否则，`a` 和 `b` 将会是字符串，它们的总和将是它们的连接，即：`\"1\" + \"2\" = \"12\"`。",
        "parent": "number",
        "version": 1
      }
    },
    "why-rounded-down": {
      "type": "Task",
      "value": {
        "title": "为什么 6.35.toFixed(1) == 6.3？",
        "slug": "why-rounded-down",
        "githubPath": "/1-js/05-data-types/02-number/2-why-rounded-down",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n根据文档，`Math.round` 和 `toFixed` 都将数字舍入到最接近的数字：`0..4` 会被舍去，而 `5..9` 会进一位。\n\n例如：\n\n```js run\nalert( 1.35.toFixed(1) ); // 1.4\n```\n\n在下面这个类似的示例中，为什么 `6.35` 被舍入为 `6.3` 而不是 `6.4`？\n\n```js run\nalert( 6.35.toFixed(1) ); // 6.3\n```\n\n如何以正确的方式来对 `6.35` 进行舍入？",
        "solution": "在内部，`6.35` 的小数部分是一个无限的二进制。在这种情况下，它的存储会造成精度损失。\n\n让我们来看看：\n\n```js run\nalert( 6.35.toFixed(20) ); // 6.34999999999999964473\n```\n\n精度损失可能会导致数字的增加和减小。在这种特殊的情况下，数字变小了一点，这就是它向下舍入的原因。\n\n那么 `1.35` 会怎样呢？\n\n```js run\nalert( 1.35.toFixed(20) ); // 1.35000000000000008882\n```\n\n在这里，精度损失使得这个数字稍微大了一些，因此其向上舍入。\n\n**如果我们希望以正确的方式进行舍入，我们应该如何解决 `6.35` 的舍入问题呢？**\n\n在进行舍入前，我们应该使其更接近整数：\n\n```js run\nalert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000\n```\n\n请注意，`63.5` 完全没有精度损失。这是因为小数部分 `0.5` 实际上是 `1/2`。以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，现在我们可以对它进行舍入：\n\n\n```js run\nalert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4\n```",
        "parent": "number",
        "version": 1
      }
    },
    "repeat-until-number": {
      "type": "Task",
      "value": {
        "title": "重复，直到输入的是一个数字",
        "slug": "repeat-until-number",
        "githubPath": "/1-js/05-data-types/02-number/3-repeat-until-number",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个函数 `readNumber`，它提示输入一个数字，直到访问者输入一个有效的数字为止。\n\n结果值必须以数字形式返回。\n\n访问者也可以通过输入空行或点击“取消”来停止该过程。在这种情况下，函数应该返回 `null`。\n\n[demo]",
        "solution": "```js run demo\nfunction readNumber() {\n  let num;\n\n  do {\n    num = prompt(\"Enter a number please?\", 0);\n  } while ( !isFinite(num) );\n\n  if (num === null || num === '') return null;\n  \n  return +num;\n}\n\nalert(`Read: ${readNumber()}`);\n```\n\n该解决方案有点复杂，因为我们需要处理 `null` 和空行。\n\n所以，我们实际上接受输入，直到输入的是一个“常规数字”。`null`（取消）和空行都符合该条件，因为在数字形式中它们是 `0`。\n\n在我们停止之后，我们需要专门处理 `null` 和空行（返回 `null`），因为将它们转换为数字将返回 `0`。",
        "solutionJs": "\nfunction readNumber() {\n  let num;\n\n  do {\n    num = prompt(\"Enter a number please?\", 0);\n  } while ( !isFinite(num) );\n\n  if (num === null || num === '') return null;\n  \n  return +num;\n}",
        "parent": "number",
        "version": 1
      }
    },
    "endless-loop-error": {
      "type": "Task",
      "value": {
        "title": "一个偶发的无限循环",
        "slug": "endless-loop-error",
        "githubPath": "/1-js/05-data-types/02-number/4-endless-loop-error",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n\n这是一个无限循环。它永远不会结束。为什么？\n\n```js\nlet i = 0;\nwhile (i != 10) {\n  i += 0.2;\n}\n```",
        "solution": "那是因为 `i` 永远不会等于 `10`。\n\n运行下面这段代码来查看 `i` 的 **实际** 值：\n\n```js run\nlet i = 0;\nwhile (i < 11) {\n  i += 0.2;\n  if (i > 9.8 && i < 10.2) alert( i );\n}\n```\n\n它们中没有一个恰好是 `10`。\n\n之所以发生这种情况，是因为对 `0.2` 这样的小数时进行加法运算时出现了精度损失。\n\n结论：在处理小数时避免相等性检查。",
        "parent": "number",
        "version": 1
      }
    },
    "random-min-max": {
      "type": "Task",
      "value": {
        "title": "从 min 到 max 的随机数",
        "slug": "random-min-max",
        "githubPath": "/1-js/05-data-types/02-number/8-random-min-max",
        "weight": 8,
        "libs": [],
        "importance": 2,
        "content": "\n\n内建函数 `Math.random()` 会创建一个在 `0` 到 `1` 之间（不包括 `1`）的随机数。\n\n编写一个 `random(min, max)` 函数，用以生成一个在 `min` 到 `max` 之间的随机浮点数（不包括 `max`)）。\n\n运行示例：\n\n```js\nalert( random(1, 5) ); // 1.2345623452\nalert( random(1, 5) ); // 3.7894332423\nalert( random(1, 5) ); // 4.3435234525\n```",
        "solution": "我们需要将区间 0..1 中的所有值“映射”为范围在 `min` 到 `max` 中的值。\n\n这可以分两个阶段完成：\n\n1. 如果我们将 0..1 的随机数乘以 `max-min`，则随机数的范围将从 0..1 增加到 `0..max-min`。\n2. 现在，如果我们将随机数与 `min` 相加，则随机数的范围将为 `min` 到 `max`。\n\n函数实现：\n\n```js run\nfunction random(min, max) {\n  return min + Math.random() * (max - min);\n}\n\nalert( random(1, 5) ); \nalert( random(1, 5) ); \nalert( random(1, 5) ); \n```",
        "parent": "number",
        "version": 1
      }
    },
    "random-int-min-max": {
      "type": "Task",
      "value": {
        "title": "从 min 到 max 的随机整数",
        "slug": "random-int-min-max",
        "githubPath": "/1-js/05-data-types/02-number/9-random-int-min-max",
        "weight": 9,
        "libs": [],
        "importance": 2,
        "content": "\n\n创建一个函数 `randomInteger(min, max)`，该函数会生成一个范围在 `min` 到 `max` 中的随机整数，包括 `min` 和 `max`。\n\n在 `min..max` 范围中的所有数字的出现概率必须相同。\n\n\n运行示例：\n\n```js\nalert( randomInteger(1, 5) ); // 1\nalert( randomInteger(1, 5) ); // 3\nalert( randomInteger(1, 5) ); // 5\n```\n\n你可以使用 [上一个任务](info:task/random-min-max) 的解决方案作为基础。",
        "solution": "# 简单但错误的解决方案\n\n最简单但错误的解决方案是生成一个范围在 `min` 到 `max` 的值，并取对其进行四舍五入后的值：\n\n```js run\nfunction randomInteger(min, max) {\n  let rand = min + Math.random() * (max - min); \n  return Math.round(rand);\n}\n\nalert( randomInteger(1, 3) );\n```\n\n这个函数是能起作用的，但不正确。获得边缘值 `min` 和 `max` 的概率比其他值低两倍。\n\n如果你将上面这个例子运行多次，你会很容易看到 `2` 出现的频率最高。\n\n发生这种情况是因为 `Math.round()` 从范围 `1..3` 中获得随机数，并按如下所示进行四舍五入：\n\n```js no-beautify\nvalues from 1    ... to 1.4999999999  become 1\nvalues from 1.5  ... to 2.4999999999  become 2\nvalues from 2.5  ... to 2.9999999999  become 3\n```\n\n现在我们可以清楚地看到 `1` 的值比 `2` 少两倍。和 `3` 一样。\n\n# 正确的解决方案\n\n这个题目有很多正确的解决方案。其中之一是调整取值范围的边界。为了确保相同的取值范围，我们可以生成从 0.5 到 3.5 的值，从而将所需的概率添加到取值范围的边界：\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n  // 现在范围是从  (min-0.5) 到 (max+0.5)\n  let rand = min - 0.5 + Math.random() * (max - min + 1);\n  return Math.round(rand);\n}\n*/!*\n\nalert( randomInteger(1, 3) );\n```\n\n另一种方法是使用 `Math.floor` 来取范围从 `min` 到 `max+1` 的随机数：\n\n```js run\n*!*\nfunction randomInteger(min, max) {\n  // here rand is from min to (max+1)\n  let rand = min + Math.random() * (max + 1 - min);\n  return Math.floor(rand);\n}\n*/!*\n\nalert( randomInteger(1, 3) );\n```\n\n现在所有间隔都以这种方式映射：\n\n```js no-beautify\nvalues from 1  ... to 1.9999999999  become 1\nvalues from 2  ... to 2.9999999999  become 2\nvalues from 3  ... to 3.9999999999  become 3\n```\n\n所有间隔的长度相同，从而使最终能够均匀分配。",
        "parent": "number",
        "version": 1
      }
    },
    "string": {
      "type": "Article",
      "value": {
        "title": "字符串",
        "slug": "string",
        "githubPath": "/1-js/05-data-types/03-string",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。\n\n字符串的内部格式始终是 [UTF-16](https://en.wikipedia.org/wiki/UTF-16)，它不依赖于页面编码。\n\n## 引号（Quotes）\n\n让我们回忆一下引号的种类。\n\n字符串可以包含在单引号、双引号或反引号中：\n\n```js\nlet single = 'single-quoted';\nlet double = \"double-quoted\";\n\nlet backticks = `backticks`;\n```\n\n单引号和双引号基本相同。但是，反引号允许我们通过 `${…}` 将任何表达式嵌入到字符串中：\n\n```js run\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n```\n\n使用反引号的另一个优点是它们允许字符串跨行：\n\n```js run\nlet guestList = `Guests:\n * John\n * Pete\n * Mary\n`;\n\nalert(guestList); // 客人清单，多行\n```\n\n看起来很自然，不是吗？但是单引号和双引号可不能这样做。\n\n如果我们使用单引号或双引号来实现字符串跨行的话，则会出现错误：\n\n```js run\nlet guestList = \"Guests: // Error: Unexpected token ILLEGAL\n  * John\";\n```\n\n单引号和双引号来自语言创建的的古老时代，当时没有考虑到多行字符串的需要。反引号出现较晚，因此更通用。\n\n反引号还允许我们在第一个反引号之前指定一个“模版函数”。语法是：<code>func&#96;string&#96;</code>。函数 `func` 被自动调用，接收字符串和嵌入式表达式，并处理它们。你可以在 [docs](mdn:/JavaScript/Reference/Template_literals#Tagged_template_literals) 中阅读更多关于它们的信息。这叫做 \"tagged templates\"。此功能可以更轻松地将字符串包装到自定义模版或其他函数中，但这很少使用。\n\n## 特殊字符\n\n我们仍然可以通过使用“换行符（newline character）”，以支持使用单引号和双引号来创建跨行字符串。换行符写作 `\\n`，用来表示换行：\n\n```js run\nlet guestList = \"Guests:\\n * John\\n * Pete\\n * Mary\";\n\nalert(guestList); // 一个多行的客人列表\n```\n\n例如，这两行描述的是一样的，只是书写方式不同：\n\n```js run\nlet str1 = \"Hello\\nWorld\"; // 使用“换行符”创建的两行字符串\n\n// 使用反引号和普通的换行创建的两行字符串\nlet str2 = `Hello\nWorld`;\n\nalert(str1 == str2); // true\n```\n\n还有其他不常见的“特殊”字符。\n\n这是完整列表：\n\n| 字符 | 描述 |\n|-----------|-------------|\n|`\\n`|换行|\n|`\\r`|在 Windows 文本文件中，两个字符 `\\r\\n` 的组合代表一个换行。而在非 Windows 操作系统上，它就是 `\\n`。这是历史原因造成的，大多数的 Windows 软件也理解 `\\n`。|\n|`\\'`, `\\\"`|引号|\n|`\\\\`|反斜线|\n|`\\t`|制表符|\n|`\\b`, `\\f`, `\\v`| 退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。 |\n|`\\xXX`|具有给定十六进制 Unicode `XX` 的 Unicode 字符，例如：`'\\x7A'` 和 `'z'` 相同。|\n|`\\uXXXX`|以 UTF-16 编码的十六进制代码 `XXXX` 的 Unicode 字符，例如 `\\u00A9` —— 是版权符号 `©` 的 Unicode。它必须正好是 4 个十六进制数字。|\n|`\\u{X…XXXXXX}`（1 到 6 个十六进制字符）|具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。|\n\nUnicode 示例：\n\n```js run\nalert( \"\\u00A9\" ); // ©\nalert( \"\\u{20331}\" ); // 佫，罕见的中国象形文字（长 Unicode）\nalert( \"\\u{1F60D}\" ); // 😍，笑脸符号（另一个长 Unicode）\n```\n\n所有的特殊字符都以反斜杠字符 `\\` 开始。它也被称为“转义字符”。\n\n如果我们想要在字符串中插入一个引号，我们也会使用它。\n\n例如：\n\n```js run\nalert( 'I*!*\\'*/!*m the Walrus!' ); // *!*I'm*/!* the Walrus!\n```\n\n正如你所看到的，我们必须在内部引号前加上反斜杠 `\\'`，否则它将表示字符串结束。\n\n当然，只有与外部闭合引号相同的引号才需要转义。因此，作为一个更优雅的解决方案，我们可以改用双引号或者反引号：\n\n```js run\nalert( `I'm the Walrus!` ); // I'm the Walrus!\n```\n\n注意反斜杠 `\\` 在 JavaScript 中用于正确读取字符串，然后消失。内存中的字符串没有 `\\`。你从上述示例中的 `alert` 可以清楚地看到这一点。\n\n但是如果我们需要在字符串中显示一个实际的反斜杠 `\\` 应该怎么做？\n\n我们可以这样做，只需要将其书写两次 `\\\\`：\n\n```js run\nalert( `The backslash: \\\\` ); // The backslash: \\\n```\n\n## 字符串长度\n\n`length` 属性表示字符串长度：\n\n```js run\nalert( `My\\n`.length ); // 3\n```\n\n注意 `\\n` 是一个单独的“特殊”字符，所以长度确实是 `3`。\n\n```warn header=\"`length` 是一个属性\"\n掌握其他编程语言的人，有时会错误地调用 `str.length()` 而不是 `str.length`。这是行不通的。\n\n请注意 `str.length` 是一个数字属性，而不是函数。后面不需要添加括号。\n```\n\n## 访问字符\n\n要获取在 `pos` 位置的一个字符，可以使用方括号 `[pos]` 或者调用 [str.charAt(pos)](mdn:js/String/charAt) 方法。第一个字符从零位置开始：\n\n```js run\nlet str = `Hello`;\n\n// 第一个字符\nalert( str[0] ); // H\nalert( str.charAt(0) ); // H\n\n// 最后一个字符\nalert( str[str.length - 1] ); // o\n```\n\n方括号是获取字符的一种现代化方法，而 `charAt` 是历史原因才存在的。\n\n它们之间的唯一区别是，如果没有找到字符，`[]` 返回 `undefined`，而 `charAt` 返回一个空字符串：\n\n```js run\nlet str = `Hello`;\n\nalert( str[1000] ); // undefined\nalert( str.charAt(1000) ); // ''（空字符串）\n```\n\n我们也可以使用 `for..of` 遍历字符：\n\n```js run\nfor (let char of \"Hello\") {\n  alert(char); // H,e,l,l,o（char 变为 \"H\"，然后是 \"e\"，然后是 \"l\" 等）\n}\n```\n\n## 字符串是不可变的\n\n在 JavaScript 中，字符串不可更改。改变字符是不可能的。\n\n我们证明一下为什么不可能：\n\n```js run\nlet str = 'Hi';\n\nstr[0] = 'h'; // error\nalert( str[0] ); // 无法运行\n```\n\n通常的解决方法是创建一个新的字符串，并将其分配给 `str` 而不是以前的字符串。\n\n例如：\n\n```js run\nlet str = 'Hi';\n\nstr = 'h' + str[1];  // 替换字符串\n\nalert( str ); // hi\n```\n\n在接下来的章节，我们将看到更多相关示例。\n\n## 改变大小写\n\n[toLowerCase()](mdn:js/String/toLowerCase) 和 [toUpperCase()](mdn:js/String/toUpperCase) 方法可以改变大小写：\n\n```js run\nalert( 'Interface'.toUpperCase() ); // INTERFACE\nalert( 'Interface'.toLowerCase() ); // interface\n```\n\n或者我们想要使一个字符变成小写：\n\n```js run\nalert( 'Interface'[0].toLowerCase() ); // 'i'\n```\n\n## 查找子字符串\n\n在字符串中查找子字符串有很多种方法。\n\n### str.indexOf\n\n第一个方法是 [str.indexOf(substr, pos)](mdn:js/String/indexOf)。\n\n它从给定位置 `pos` 开始，在 `str` 中查找 `substr`，如果没有找到，则返回 `-1`，否则返回匹配成功的位置。\n\n例如：\n\n```js run\nlet str = 'Widget with id';\n\nalert( str.indexOf('Widget') ); // 0，因为 'Widget' 一开始就被找到\nalert( str.indexOf('widget') ); // -1，没有找到，检索是大小写敏感的\n\nalert( str.indexOf(\"id\") ); // 1，\"id\" 在位置 1 处（……idget 和 id）\n```\n\n可选的第二个参数允许我们从一个给定的位置开始检索。\n\n例如，`\"id\"` 第一次出现的位置是 `1`。查询下一个存在位置时，我们从 `2` 开始检索：\n\n```js run\nlet str = 'Widget with id';\n\nalert( str.indexOf('id', 2) ) // 12\n```\n\n如果我们对所有存在位置都感兴趣，可以在一个循环中使用 `indexOf`。每一次新的调用都发生在上一匹配位置之后：\n\n```js run\nlet str = 'As sly as a fox, as strong as an ox';\n\nlet target = 'as'; // 这是我们要查找的目标\n\nlet pos = 0;\nwhile (true) {\n  let foundPos = str.indexOf(target, pos);\n  if (foundPos == -1) break;\n\n  alert( `Found at ${foundPos}` );\n  pos = foundPos + 1; // 继续从下一个位置查找\n}\n```\n\n相同的算法可以简写：\n\n```js run\nlet str = \"As sly as a fox, as strong as an ox\";\nlet target = \"as\";\n\n*!*\nlet pos = -1;\nwhile ((pos = str.indexOf(target, pos + 1)) != -1) {\n  alert( pos );\n}\n*/!*\n```\n\n```smart header=\"`str.lastIndexOf(substr, pos)`\"\n还有一个类似的方法 [str.lastIndexOf(substr, position)](mdn:js/String/lastIndexOf)，它从字符串的末尾开始搜索到开头。\n\n它会以相反的顺序列出这些事件。\n```\n\n在 `if` 测试中 `indexOf` 有一点不方便。我们不能像这样把它放在 `if` 中：\n\n```js run\nlet str = \"Widget with id\";\n\nif (str.indexOf(\"Widget\")) {\n    alert(\"We found it\"); // 不工作！\n}\n```\n\n上述示例中的 `alert` 不会显示，因为 `str.indexOf(\"Widget\")` 返回 `0`（意思是它在起始位置就查找到了匹配项）。是的，但是 `if` 认为 `0` 表示 `false`。\n\n因此我们应该检查 `-1`，像这样：\n\n```js run\nlet str = \"Widget with id\";\n\n*!*\nif (str.indexOf(\"Widget\") != -1) {\n*/!*\n    alert(\"We found it\"); // 现在工作了！\n}\n```\n\n#### 按位（bitwise）NOT 技巧\n\n这里使用的一个老技巧是 [bitwise NOT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT) `~` 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。\n\n实际上，这意味着一件很简单的事儿：对于 32-bit 整数，`~n` 等于 `-(n+1)`。\n\n例如：\n\n```js run\nalert( ~2 ); // -3，和 -(2+1) 相同\nalert( ~1 ); // -2，和 -(1+1) 相同\nalert( ~0 ); // -1，和 -(0+1) 相同\n*!*\nalert( ~-1 ); // 0，和 -(-1+1) 相同\n*/!*\n```\n\n正如我们看到这样，只有当 `n == -1` 时，`~n` 才为零（适用于任何 32-bit 带符号的整数 `n`）。\n\n因此，仅当 `indexOf` 的结果不是 `-1` 时，检查 `if ( ~str.indexOf(\"...\") )` 才为真。换句话说，当有匹配时。\n\n人们用它来简写 `indexOf` 检查：\n\n```js run\nlet str = \"Widget\";\n\nif (~str.indexOf(\"Widget\")) {\n  alert( 'Found it!' ); // 正常运行\n}\n```\n\n通常不建议以非显而易见的方式使用语言特性，但这种特殊技巧在旧代码中仍被广泛使用，所以我们应该理解它。\n\n只要记住：`if (~str.indexOf(...))` 读作 \"if found\"。\n\n确切地说，由于 `~` 运算符将大数字截断为 32 位，因此存在给出 `0` 的其他数字，最小的数字是 `~4294967295=0`。这使得这种检查只有在字符串没有那么长的情况下才是正确的。\n\n现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 `.includes` 方法（见下文）。\n\n### includes，startsWith，endsWith\n\n更现代的方法 [str.includes(substr, pos)](mdn:js/String/includes) 根据 `str` 中是否包含 `substr` 来返回 `true/false`。\n\n如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择：\n\n```js run\nalert( \"Widget with id\".includes(\"Widget\") ); // true\n\nalert( \"Hello\".includes(\"Bye\") ); // false\n```\n\n`str.includes` 的第二个可选参数是开始搜索的起始位置：\n\n```js run\nalert( \"Widget\".includes(\"id\") ); // true\nalert( \"Widget\".includes(\"id\", 3) ); // false, 从位置 3 开始没有 \"id\"\n```\n\n方法 [str.startsWith](mdn:js/String/startsWith) 和 [str.endsWith](mdn:js/String/endsWith) 的功能与其名称所表示的意思相同：\n\n```js run\nalert( \"*!*Wid*/!*get\".startsWith(\"Wid\") ); // true，\"Widget\" 以 \"Wid\" 开始\nalert( \"Wid*!*get*/!*\".endsWith(\"get\") ); // true，\"Widget\" 以 \"get\" 结束\n```\n\n## 获取子字符串\n\nJavaScript 中有三种获取字符串的方法：`substring`、`substr` 和 `slice`。\n\n`str.slice(start [, end])`\n: 返回字符串从 `start` 到（但不包括）`end` 的部分。\n\n    例如：\n\n    ```js run\n    let str = \"stringify\";\n    alert( str.slice(0, 5) ); // 'strin'，从 0 到 5 的子字符串（不包括 5）\n    alert( str.slice(0, 1) ); // 's'，从 0 到 1，但不包括 1，所以只有在 0 处的字符\n    ```\n\n    如果没有第二个参数，`slice` 会一直运行到字符串末尾：\n\n    ```js run\n    let str = \"st*!*ringify*/!*\";\n    alert( str.slice(2) ); // 从第二个位置直到结束\n    ```\n\n    `start/end` 也有可能是负值。它们的意思是起始位置从字符串结尾计算：\n\n    ```js run\n    let str = \"strin*!*gif*/!*y\";\n\n    // 从右边的第四个位置开始，在右边的第一个位置结束\n    alert( str.slice(-4, -1) ); // 'gif'\n    ```\n\n`str.substring(start [, end])`\n: 返回字符串从 `start` 到（但不包括）`end` 的部分。\n\n    这与 `slice` 几乎相同，但它允许 `start` 大于 `end`。\n\n    例如：\n\n    ```js run\n    let str = \"st*!*ring*/!*ify\";\n\n    // 这些对于 substring 是相同的\n    alert( str.substring(2, 6) ); // \"ring\"\n    alert( str.substring(6, 2) ); // \"ring\"\n\n    // ……但对 slice 是不同的：\n    alert( str.slice(2, 6) ); // \"ring\"（一样）\n    alert( str.slice(6, 2) ); // \"\"（空字符串）\n\n    ```\n\n    不支持负参数（不像 slice），它们被视为 `0`。\n\n`str.substr(start [, length])`\n: 返回字符串从 `start` 开始的给定 `length` 的部分。\n\n    与以前的方法相比，这个允许我们指定 `length` 而不是结束位置：\n\n    ```js run\n    let str = \"st*!*ring*/!*ify\";\n    alert( str.substr(2, 4) ); // 'ring'，从位置 2 开始，获取 4 个字符\n    ```\n\n    第一个参数可能是负数，从结尾算起：\n\n    ```js run\n    let str = \"strin*!*gi*/!*fy\";\n    alert( str.substr(-4, 2) ); // 'gi'，从第 4 位获取 2 个字符\n    ```\n\n我们回顾一下这些方法，以免混淆：\n\n| 方法 | 选择方式…… | 负值参数 |\n|--------|-----------|-----------|\n| `slice(start, end)` | 从 `start` 到 `end`（不含 `end`）| 允许 |\n| `substring(start, end)` | 从 `start` 到 `end`（不含 `end`） | 负值被视为 `0` |\n| `substr(start, length)` | 从 `start` 开始获取长为 `length` 的字符串 | 允许 `start` 为负数 |\n\n```smart header=\"使用哪一个？\"\n它们都可用于获取子字符串。正式一点来讲，`substr` 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中。附录 B 的内容主要是描述因历史原因而遗留下来的仅浏览器特性。因此，理论上非浏览器环境可能无法支持 `substr`，但实际上它在别的地方也都能用。\n\n相较于其他两个变体，`slice` 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 `slice` 就足够了。\n```\n\n## 比较字符串\n\n正如我们从 <info:comparison> 一章中了解到的，字符串按字母顺序逐字比较。\n\n不过，也有一些奇怪的地方。\n\n1. 小写字母总是大于大写字母：\n\n    ```js run\n    alert( 'a' > 'Z' ); // true\n    ```\n\n2. 带变音符号的字母存在“乱序”的情况：\n\n    ```js run\n    alert( 'Österreich' > 'Zealand' ); // true\n    ```\n\n    如果我们对这些国家名进行排序，可能会导致奇怪的结果。通常，人们会期望 `Zealand` 在名单中的 `Österreich` 之后出现。\n\n为了明白发生了什么，我们回顾一下在 JavaScript 中字符串的内部表示。\n\n所有的字符串都使用 [UTF-16](https://en.wikipedia.org/wiki/UTF-16) 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。\n\n`str.codePointAt(pos)`\n: 返回在 `pos` 位置的字符代码 :\n\n    ```js run\n    // 不同的字母有不同的代码\n    alert( \"z\".codePointAt(0) ); // 122\n    alert( \"Z\".codePointAt(0) ); // 90\n    ```\n\n`String.fromCodePoint(code)`\n: 通过数字 `code` 创建字符\n\n    ```js run\n    alert( String.fromCodePoint(90) ); // Z\n    ```\n\n    我们还可以用 `\\u` 后跟十六进制代码，通过这些代码添加 Unicode 字符：\n\n    ```js run\n    // 在十六进制系统中 90 为 5a\n    alert( '\\u005a' ); // Z\n    ```\n\n现在我们看一下代码为 `65..220` 的字符（拉丁字母和一些额外的字符），方法是创建一个字符串：\n\n```js run\nlet str = '';\n\nfor (let i = 65; i <= 220; i++) {\n  str += String.fromCodePoint(i);\n}\nalert( str );\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ\n```\n\n看到没？先是大写字符，然后是一些特殊字符，然后是小写字符，而 `Ö` 几乎是最后输出。\n\n现在很明显为什么 `a > Z`。\n\n字符通过数字代码进行比较。越大的代码意味着字符越大。`a`（97）的代码大于 `Z`（90）的代码。\n\n- 所有小写字母追随在大写字母之后，因为它们的代码更大。\n- 一些像 `Ö` 的字母与主要字母表不同。这里，它的代码比任何从 `a` 到 `z` 的代码都要大。\n\n### 正确的比较 [#正确的比较]\n\n执行字符串比较的“正确”算法比看起来更复杂，因为不同语言的字母都不相同。\n\n因此浏览器需要知道要比较的语言。\n\n幸运的是，所有现代浏览器（IE10- 需要额外的库 [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) 都支持国际化标准 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)。\n\n它提供了一种特殊的方法来比较不同语言的字符串，遵循它们的规则。\n\n调用 [str.localeCompare(str2)](mdn:js/String/localeCompare) 会根据语言规则返回一个整数，这个整数能指示字符串 `str` 在排序顺序中排在字符串 `str2` 前面、后面、还是相同：\n\n- 如果 `str` 排在 `str2` 前面，则返回负数。\n- 如果 `str` 排在 `str2` 后面，则返回正数。\n- 如果它们在相同位置，则返回 `0`。\n\n例如：\n\n```js run\nalert( 'Österreich'.localeCompare('Zealand') ); // -1\n```\n\n这个方法实际上在 [文档](mdn:js/String/localeCompare) 中指定了两个额外的参数，这两个参数允许它指定语言（默认语言从环境中获取，字符顺序视语言不同而不同）并设置诸如区分大小写，或应该将 `\"a\"` 和 `\"á\"` 作相同处理等附加的规则。\n\n## 内部，Unicode\n\n```warn header=\"进阶内容\"\n这部分会深入字符串内部。如果你计划处理 emoji、罕见的数学或象形文字或其他罕见的符号，这些知识会对你有用。\n\n如果你不打算支持它们，你可以跳过这一部分。\n```\n\n### 代理对\n\n所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。\n\n但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。\n\n这些符号的长度是 `2`：\n\n```js run\nalert( '𝒳'.length ); // 2，大写数学符号 X\nalert( '😂'.length ); // 2，笑哭表情\nalert( '𩷶'.length ); // 2，罕见的中国象形文字\n```\n\n注意，代理对在 JavaScript 被创建时并不存在，因此无法被编程语言正确处理！\n\n我们实际上在上面的每个字符串中都有一个符号，但 `length` 显示长度为 `2`。\n\n`String.fromCodePoint` 和 `str.codePointAt` 是几种处理代理对的少数方法。它们最近才出现在编程语言中。在它们之前，只有 [String.fromCharCode](mdn:js/String/fromCharCode) 和 [str.charCodeAt](mdn:js/String/charCodeAt)。这些方法实际上与 `fromCodePoint/codePointAt` 相同，但是不适用于代理对。\n\n获取符号可能会非常麻烦，因为代理对被认为是两个字符：\n\n```js run\nalert( '𝒳'[0] ); // 奇怪的符号……\nalert( '𝒳'[1] ); // ……代理对的一块\n```\n\n请注意，代理对的各部分没有任何意义。因此，上述示例中的 alert 显示的实际上是垃圾信息。\n\n技术角度来说，代理对也是可以通过它们的代码检测到的：如果一个字符的代码在 `0xd800..0xdbff` 范围内，那么它是代理对的第一部分。下一个字符（第二部分）必须在 `0xdc00..0xdfff` 范围中。这些范围是按照标准专门为代理对保留的。\n\n在上述示例中：\n\n```js run\n// charCodeAt 不理解代理对，所以它给出了代理对的代码\n\nalert( '𝒳'.charCodeAt(0).toString(16) ); // d835，在 0xd800 和 0xdbff 之间\nalert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3, 在 0xdc00 和 0xdfff 之间\n```\n\n本章节后面的 <info:iterable> 章节中，你可以找到更多处理代理对的方法。可能有专门的库，这里没有什么足够好的建议了。\n\n### 变音符号与规范化\n\n在许多语言中，都有一些由基本字符组成的符号，在其上方/下方有一个标记。\n\n例如，字母 `a` 可以是 `àáâäãåā` 的基本字符。最常见的“复合”字符在 UTF-16 表中都有自己的代码。但不是全部，因为可能的组合太多。\n\n为了支持任意组合，UTF-16 允许我们使用多个 Unicode 字符：基本字符紧跟“装饰”它的一个或多个“标记”字符。\n\n例如，如果我们 `S` 后跟有特殊的 \"dot above\" 字符（代码 `\\u0307`），则显示 Ṡ。\n\n```js run\nalert( 'S\\u0307' ); // Ṡ\n```\n\n如果我们需要在字母上方（或下方）添加额外的标记 —— 没问题，只需要添加必要的标记字符即可。\n\n例如，如果我们追加一个字符 \"dot below\"（代码 `\\u0323`），那么我们将得到“S 上面和下面都有点”的字符：`Ṩ`。\n\n例如：\n\n```js run\nalert( 'S\\u0307\\u0323' ); // Ṩ\n```\n\n这在提供良好灵活性的同时，也存在一个有趣的问题：两个视觉上看起来相同的字符，可以用不同的 Unicode 组合表示。\n\n例如：\n\n```js run\nlet s1 = 'S\\u0307\\u0323'; // Ṩ，S + 上点 + 下点\nlet s2 = 'S\\u0323\\u0307'; // Ṩ，S + 下点 + 上点\n\nalert( `s1: ${s1}, s2: ${s2}` );\n\nalert( s1 == s2 ); // false，尽管字符看起来相同（?!）\n```\n\n为了解决这个问题，有一个 “Unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。\n\n它由 [str.normalize()](mdn:js/String/normalize) 实现。\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize() == \"S\\u0323\\u0307\".normalize() ); // true\n```\n\n有趣的是，在实际情况下，`normalize()` 实际上将一个由 3 个字符组成的序列合并为一个：`\\u1e68`（S 有两个点）。\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize().length ); // 1\n\nalert( \"S\\u0307\\u0323\".normalize() == \"\\u1e68\" ); // true\n```\n\n事实上，情况并非总是如此，因为符号 `Ṩ` 是“常用”的，所以 UTF-16 创建者把它包含在主表中并给它了对应的代码。\n\n如果你想了解更多关于规范化规则和变体的信息 —— 它们在 Unicode 标准附录中有详细描述：[Unicode 规范化形式](http://www.unicode.org/reports/tr15/)，但对于大多数实际目的来说，本文的内容就已经足够了。\n\n## 总结\n\n- 有 3 种类型的引号。反引号允许字符串跨越多行并可以使用 `${…}` 在字符串中嵌入表达式。\n- JavaScript 中的字符串使用的是 UTF-16 编码。\n- 我们可以使用像 `\\n` 这样的特殊字符或通过使用 `\\u...` 来操作它们的 Unicode 进行字符插入。 \n- 获取字符时，使用 `[]`。\n- 获取子字符串，使用 `slice` 或 `substring`。\n- 字符串的大/小写转换，使用：`toLowerCase/toUpperCase`。\n- 查找子字符串时，使用 `indexOf` 或 `includes/startsWith/endsWith` 进行简单检查。\n- 根据语言比较字符串时使用 `localeCompare`，否则将按字符代码进行比较。\n\n还有其他几种有用的字符串方法：\n\n- `str.trim()` —— 删除字符串前后的空格 (\"trims\")。\n- `str.repeat(n)` —— 重复字符串 `n` 次。\n- ……更多内容细节请参见 [手册](mdn:js/String)。\n\n字符串还具有使用正则表达式进行搜索/替换的方法。但这个话题很大，因此我们将在本教程中单独的 <info:regular-expressions> 章节中进行讨论。",
        "libs": [],
        "children": [
          "ucfirst",
          "check-spam",
          "truncate",
          "extract-currency"
        ],
        "parent": "data-types",
        "updatedAt": 1657896857
      }
    },
    "ucfirst": {
      "type": "Task",
      "value": {
        "title": "首字母大写",
        "slug": "ucfirst",
        "githubPath": "/1-js/05-data-types/03-string/1-ucfirst",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n写一个函数 `ucFirst(str)`，并返回首字母大写的字符串 `str`，例如：\n\n```js\nucFirst(\"john\") == \"John\";\n```",
        "solution": "我们不能“替换”第一个字符，因为在 JavaScript 中字符串是不可变的。\n\n但是我们可以根据已有字符串创建一个首字母大写的新字符串：\n\n```js\nlet newStr = str[0].toUpperCase() + str.slice(1);\n```\n\n这里存在一个小问题。如果 `str` 是空的，那么 `str[0]` 就是 `undefined`，但由于 `undefined` 并没有 `toUpperCase()` 方法，因此我们会得到一个错误。\n\n存在如下两种变体：\n\n1. 使用 `str.charAt(0)`，因为它总是会返回一个字符串（可能为空）。\n2. 为空字符添加测试。\n\n这是第二种变体：\n\n```js run demo\nfunction ucFirst(str) {\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nalert( ucFirst(\"john\") ); // John\n```",
        "solutionJs": "function ucFirst(str) {\n  if (!str) return str;\n\n  return str[0].toUpperCase() + str.slice(1);\n}",
        "parent": "string",
        "version": 1
      }
    },
    "check-spam": {
      "type": "Task",
      "value": {
        "title": "检查 spam",
        "slug": "check-spam",
        "githubPath": "/1-js/05-data-types/03-string/2-check-spam",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n写一个函数 `checkSpam(str)`，如果 `str` 包含 `viagra` 或 `XXX` 就返回 `true`，否则返回 `false`。\n\n函数必须不区分大小写：\n\n```js\ncheckSpam('buy ViAgRA now') == true\ncheckSpam('free xxxxx') == true\ncheckSpam(\"innocent rabbit\") == false\n```",
        "solution": "为了使搜索不区分大小写，我们将字符串改为小写，然后搜索：\n\n```js run demo\nfunction checkSpam(str) {\n  let lowerStr = str.toLowerCase();\n\n  return lowerStr.includes('viagra') || lowerStr.includes('xxx');\n}\n\nalert( checkSpam('buy ViAgRA now') );\nalert( checkSpam('free xxxxx') );\nalert( checkSpam(\"innocent rabbit\") );\n```",
        "solutionJs": "function checkSpam(str) {\n  let lowerStr = str.toLowerCase();\n\n  return lowerStr.includes('viagra') || lowerStr.includes('xxx');\n}",
        "parent": "string",
        "version": 1
      }
    },
    "truncate": {
      "type": "Task",
      "value": {
        "title": "截断文本",
        "slug": "truncate",
        "githubPath": "/1-js/05-data-types/03-string/3-truncate",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建函数 `truncate(str, maxlength)` 来检查 `str` 的长度，如果超过 `maxlength` —— 应使用 `\"…\"` 来代替 `str` 的结尾部分，长度仍然等于 `maxlength`。\n\n函数的结果应该是截断后的文本（如果需要的话）。\n\n例如：\n\n```js\ntruncate(\"What I'd like to tell on this topic is:\", 20) = \"What I'd like to te…\"\n\ntruncate(\"Hi everyone!\", 20) = \"Hi everyone!\"\n```",
        "solution": "最大长度必须是 `maxlength`，因此为了给省略号留空间我们需要缩短它。\n\n请注意，省略号实际上有一个单独的 Unicode 字符，而不是三个点。\n\n```js run demo\nfunction truncate(str, maxlength) {\n  return (str.length > maxlength) ?\n    str.slice(0, maxlength - 1) + '…' : str;\n}\n```",
        "solutionJs": "function truncate(str, maxlength) {\n  return (str.length > maxlength) ? \n    str.slice(0, maxlength - 1) + '…' : str;\n}",
        "parent": "string",
        "version": 1
      }
    },
    "extract-currency": {
      "type": "Task",
      "value": {
        "title": "提取货币",
        "slug": "extract-currency",
        "githubPath": "/1-js/05-data-types/03-string/4-extract-currency",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n\n我们有以 `\"$120\"` 这样的格式表示的花销。意味着：先是美元符号，然后才是数值。\n\n创建函数 `extractCurrencyValue(str)` 从字符串中提取数值并返回。\n\n例如：\n\n```js\nalert( extractCurrencyValue('$120') === 120 ); // true\n```",
        "solution": "",
        "solutionJs": "function extractCurrencyValue(str) {\n  return +str.slice(1);\n}",
        "parent": "string",
        "version": 1
      }
    },
    "array": {
      "type": "Article",
      "value": {
        "title": "数组",
        "slug": "array",
        "githubPath": "/1-js/05-data-types/04-array",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n对象允许存储键值集合，这很好。\n \n但很多时候我们发现还需要 **有序集合**，里面的元素都是按顺序排列的。例如，我们可能需要存储一些列表，比如用户、商品以及 HTML 元素等。\n\n这里使用对象就不是很方便了，因为对象不能提供能够管理元素顺序的方法。我们不能在已有的元素“之间”插入一个新的属性。这种场景下对象就不太适用了。\n\n这时一个特殊的数据结构数组（`Array`）就派上用场了，它能存储有序的集合。\n\n## 声明\n\n创建一个空数组有两种语法：\n\n```js\nlet arr = new Array();\nlet arr = [];\n```\n\n绝大多数情况下使用的都是第二种语法。我们可以在方括号中添加初始元素：\n\n```js\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n```\n\n数组元素从 0 开始编号。\n\n我们可以通过方括号中的数字获取元素：\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits[0] ); // Apple\nalert( fruits[1] ); // Orange\nalert( fruits[2] ); // Plum\n```\n\n可以替换元素：\n\n```js\nfruits[2] = 'Pear'; // 现在变成了 [\"Apple\", \"Orange\", \"Pear\"]\n```\n\n……或者向数组新加一个元素：\n\n```js\nfruits[3] = 'Lemon'; // 现在变成 [\"Apple\", \"Orange\", \"Pear\", \"Lemon\"]\n```\n\n`length` 属性的值是数组中元素的总个数：\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits.length ); // 3\n```\n\n也可以用 `alert` 来显示整个数组。\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits ); // Apple,Orange,Plum\n```\n\n数组可以存储任何类型的元素。\n\n例如:\n\n```js run no-beautify\n// 混合值\nlet arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];\n\n// 获取索引为 1 的对象然后显示它的 name\nalert( arr[1].name ); // John\n\n// 获取索引为 3 的函数并执行\narr[3](); // hello\n```\n\n\n````smart header=\"以逗号结尾\"\n数组就像对象一样，可以以逗号结尾：\n```js \nlet fruits = [\n  \"Apple\", \n  \"Orange\", \n  \"Plum\"*!*,*/!*\n];\n```\n\n因为每一行都是相似的，所以这种以“逗号结尾”的方式使得插入/移除项变得更加简单。\n````\n\n## 使用 \"at\" 获取最后一个元素\n\n[recent browser=\"new\"]\n\n假设我们想要数组的最后一个元素。\n\n一些编程语言允许我们使用负数索引来实现这一点，例如 `fruits[-1]`。\n\n但在 JavaScript 中这行不通。结果将是 `undefined`，因为方括号中的索引是被按照其字面意思处理的。\n\n我们可以显式地计算最后一个元素的索引，然后访问它：`fruits[fruits.length - 1]`。\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits[fruits.length-1] ); // Plum\n```\n\n有点麻烦，不是吗？我们需要写两次变量名。\n\n幸运的是，这里有一个更简短的语法 `fruits.at(-1)`：\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// 与 fruits[fruits.length-1] 相同\nalert( fruits.at(-1) ); // Plum\n```\n\n换句话说，`arr.at(i)`：\n- 如果 `i >= 0`，则与 `arr[i]` 完全相同。\n- 对于 `i` 为负数的情况，它则从数组的尾部向前数。\n\n## pop/push, shift/unshift 方法\n\n[队列（queue）](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))是最常见的使用数组的方法之一。在计算机科学中，这表示支持两个操作的一个有序元素的集合：\n\n- `push` 在末端添加一个元素.\n- `shift` 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。\n\n![](queue.svg)\n\n这两种操作数组都支持。\n\n队列的应用在实践中经常会碰到。例如需要在屏幕上显示消息队列。\n\n数组还有另一个用例，就是数据结构 [栈](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))。\n\n它支持两种操作：\n\n- `push` 在末端添加一个元素.\n- `pop` 从末端取出一个元素.\n\n所以新元素的添加和取出都是从“末端”开始的。\n\n栈通常被被形容成一叠卡片：要么在最上面添加卡片，要么从最上面拿走卡片：\n\n![](stack.svg)\n\n对于栈来说，最后放进去的内容是最先接收的，也叫做 LIFO（Last-In-First-Out），即后进先出法则。而与队列相对应的叫做 FIFO（First-In-First-Out），即先进先出。\n\nJavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。\n\n这在计算机科学中，允许这样的操作的数据结构被称为 [双端队列（deque）](https://en.wikipedia.org/wiki/Double-ended_queue)。\n\n**作用于数组末端的方法：**\n\n`pop`\n: 取出并返回数组的最后一个元素：\n\n    ```js run\n    let fruits = [\"Apple\", \"Orange\", \"Pear\"];\n\n    alert( fruits.pop() ); // 移除 \"Pear\" 然后 alert 显示出来\n\n    alert( fruits ); // Apple, Orange\n    ```\n\n    `fruits.pop()` 和 `fruits.at(-1)` 都返回数组的最后一个元素，但 `fruits.pop()` 同时也删除了数组的最后一个元素，进而修改了原数组。\n\n`push`\n: 在数组末端添加元素：\n\n    ```js run\n    let fruits = [\"Apple\", \"Orange\"];\n\n    fruits.push(\"Pear\");\n\n    alert( fruits ); // Apple, Orange, Pear\n    ```\n\n    调用 `fruits.push(...)` 与 `fruits[fruits.length] = ...` 是一样的。\n\n**作用于数组首端的方法：**\n\n`shift`\n: 取出数组的第一个元素并返回它：\n\n    ```js run\n    let fruits = [\"Apple\", \"Orange\", \"Pear\"];\n\n    alert( fruits.shift() ); // 移除 Apple 然后 alert 显示出来\n\n    alert( fruits ); // Orange, Pear\n    ```\n\n`unshift`\n: 在数组的首端添加元素：\n\n    ```js run\n    let fruits = [\"Orange\", \"Pear\"];\n\n    fruits.unshift('Apple');\n\n    alert( fruits ); // Apple, Orange, Pear\n    ```\n\n`push` 和 `unshift` 方法都可以一次添加多个元素：\n\n```js run\nlet fruits = [\"Apple\"];\n\nfruits.push(\"Orange\", \"Peach\");\nfruits.unshift(\"Pineapple\", \"Lemon\");\n\n// [\"Pineapple\", \"Lemon\", \"Apple\", \"Orange\", \"Peach\"]\nalert( fruits );\n```\n\n## 内部\n\n数组是一种特殊的对象。使用方括号来访问属性 `arr[0]` 实际上是来自于对象的语法。它其实与 `obj[key]` 相同，其中 `arr` 是对象，而数字用作键（key）。\n\n它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 `length` 属性。但从本质上讲，它仍然是一个对象。\n\n记住，在 JavaScript 中只有 8 种基本的数据类型（详见 [数据类型](info:types) 一章）。数组是一个对象，因此其行为也像一个对象。\n\n例如，它是通过引用来复制的：\n\n```js run\nlet fruits = [\"Banana\"]\n\nlet arr = fruits; // 通过引用复制 (两个变量引用的是相同的数组)\n\nalert( arr === fruits ); // true\n\narr.push(\"Pear\"); // 通过引用修改数组\n\nalert( fruits ); // Banana, Pear — 现在有 2 项了\n```\n\n……但是数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。\n\n但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。\n\n例如，从技术上讲，我们可以这样做:\n\n```js\nlet fruits = []; // 创建一个数组\n\nfruits[99999] = 5; // 分配索引远大于数组长度的属性\n\nfruits.age = 25; // 创建一个具有任意名称的属性\n```\n\n这是可以的，因为数组是基于对象的。我们可以给它们添加任何属性。\n\n但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。\n\n数组误用的几种方式:\n\n- 添加一个非数字的属性，比如 `arr.test = 5`。\n- 制造空洞，比如：添加 `arr[0]`，然后添加 `arr[1000]` (它们中间什么都没有)。\n- 以倒序填充数组，比如 `arr[1000]`，`arr[999]` 等等。\n\n请将数组视为作用于 **有序数据** 的特殊结构。它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 `{}`。\n\n## 性能\n\n`push/pop` 方法运行的比较快，而 `shift/unshift` 比较慢。\n\n![](array-speed.svg)\n\n为什么作用于数组的末端会比首端快呢？让我们看看在执行期间都发生了什么：\n\n```js\nfruits.shift(); // 从首端取出一个元素\n```\n\n只获取并移除索引 `0` 对应的元素是不够的。其它元素也需要被重新编号。\n\n`shift` 操作必须做三件事:\n\n1. 移除索引为 `0` 的元素。\n2. 把所有的元素向左移动，把索引 `1` 改成 `0`，`2` 改成 `1` 以此类推，对其重新编号。\n3. 更新 `length` 属性。\n\n![](array-shift.svg)\n\n**数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。**\n\n`unshift` 也是一样：为了在数组的首端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。\n\n那 `push/pop` 是什么样的呢？它们不需要移动任何东西。如果从末端移除一个元素，`pop` 方法只需要清理索引值并缩短 `length` 就可以了。\n\n`pop` 操作的行为：\n\n```js\nfruits.pop(); // 从末端取走一个元素\n```\n\n![](array-pop.svg)\n\n**`pop` 方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 `pop` 会特别快。**\n\n`push` 方法也是一样的。\n\n## 循环\n\n遍历数组最古老的方式就是 `for` 循环：\n\n```js run\nlet arr = [\"Apple\", \"Orange\", \"Pear\"];\n\n*!*\nfor (let i = 0; i < arr.length; i++) {\n*/!*\n  alert( arr[i] );\n}\n```\n\n但对于数组来说还有另一种循环方式，`for..of`：\n\n```js run\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// 遍历数组元素\nfor (let fruit of fruits) {\n  alert( fruit ); \n}\n```\n\n`for..of` 不能获取当前元素的索引，只是获取元素值，但大多数情况是够用的。而且这样写更短。\n\n技术上来讲，因为数组也是对象，所以使用 `for..in` 也是可以的：\n\n```js run\nlet arr = [\"Apple\", \"Orange\", \"Pear\"];\n\n*!*\nfor (let key in arr) {\n*/!*\n  alert( arr[key] ); // Apple, Orange, Pear\n}\n```\n\n但这其实是一个很不好的想法。会有一些潜在问题存在：\n\n1. `for..in` 循环会遍历 **所有属性**，不仅仅是这些数字属性。\n\n    在浏览器和其它环境中有一种称为“类数组”的对象，它们 **看似是数组**。也就是说，它们有 `length` 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。`for..in` 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。\n\n2. `for..in` 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。\n\n通常来说，我们不应该用 `for..in` 来处理数组。\n\n\n## 关于 \"length\"\n\n当我们修改数组的时候，`length` 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。\n\n例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 `length` 也会很大：\n\n```js run\nlet fruits = [];\nfruits[123] = \"Apple\";\n\nalert( fruits.length ); // 124\n```\n\n要知道的是我们通常不会这样使用数组。\n\n`length` 属性的另一个有意思的点是它是可写的。\n\n如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，下面是例子：\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // 截断到只剩 2 个元素\nalert( arr ); // [1, 2]\n\narr.length = 5; // 又把 length 加回来\nalert( arr[3] ); // undefined：被截断的那些数值并没有回来\n```\n\n所以，清空数组最简单的方法就是：`arr.length = 0;`。\n\n\n## new Array() [#new-array]\n\n这是创建数组的另一种语法：\n\n```js\nlet arr = *!*new Array*/!*(\"Apple\", \"Pear\", \"etc\");\n```\n\n它很少被使用，因为方括号 `[]` 更短更简洁。而且，这种语法还有一个棘手的特性。\n\n如果使用单个参数（即数字）调用 `new Array`，那么它会创建一个 **指定了长度，却没有任何项** 的数组。\n\n让我们看看如何搬起石头砸自己的脚:\n\n```js run\nlet arr = new Array(2); // 会创建一个 [2] 的数组吗？\n\nalert( arr[0] ); // undefined！没有元素。\n\nalert( arr.length ); // length 2\n```\n\n为了避免这种意外情况，我们通常使用方括号，除非我们真的知道自己在做什么。\n\n## 多维数组\n\n数组里的项也可以是数组。我们可以将其用于多维数组，例如存储矩阵：\n\n```js run\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] ); // 最中间的那个数\n```\n\n## toString\n\n数组有自己的 `toString` 方法的实现，会返回以逗号隔开的元素列表。\n\n例如：\n\n\n```js run\nlet arr = [1, 2, 3];\n\nalert( arr ); // 1,2,3\nalert( String(arr) === '1,2,3' ); // true\n```\n\n此外，我们试试运行一下这个：\n\n```js run\nalert( [] + 1 ); // \"1\"\nalert( [1] + 1 ); // \"11\"\nalert( [1,2] + 1 ); // \"1,21\"\n```\n\n数组没有 `Symbol.toPrimitive`，也没有 `valueOf`，它们只能执行 `toString` 进行转换，所以这里 `[]` 就变成了一个空字符串，`[1]` 变成了 `\"1\"`，`[1,2]` 变成了 `\"1,2\"`。\n\n当 `\"+\"` 运算符把一些项加到字符串后面时，加号后面的项也会被转换成字符串，所以下一步就会是这样：\n\n```js run\nalert( \"\" + 1 ); // \"1\"\nalert( \"1\" + 1 ); // \"11\"\nalert( \"1,2\" + 1 ); // \"1,21\"\n```\n\n## 不要使用 == 比较数组\n\nJavaScript 中的数组与其它一些编程语言的不同，不应该使用 `==` 运算符比较 JavaScript 中的数组。\n\n该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。\n\n让我们回顾一下规则：\n\n- 仅当两个对象引用的是同一个对象时，它们才相等 `==`。\n- 如果 `==` 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型，转换规则如 <info:object-toprimitive> 一章所述。\n- ……`null` 和 `undefined` 相等 `==`，且各自不等于任何其他的值。\n\n严格比较 `===` 更简单，因为它不会进行类型转换。\n\n所以，如果我们使用 `==` 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。\n\n例如：\n```js run\nalert( [] == [] ); // false\nalert( [0] == [0] ); // false\n```\n\n从技术上讲，这些数组是不同的对象。所以它们不相等。`==` 运算符不会进行逐项比较。\n\n与原始类型的比较也可能会产生看似很奇怪的结果：\n\n```js run\nalert( 0 == [] ); // true\n\nalert('0' == [] ); // false\n```\n\n在这里的两个例子中，我们将原始类型和数组对象进行比较。因此，数组 `[]` 被转换为原始类型以进行比较，被转换成了一个空字符串 `''`。\n\n然后，接下来的比较就是原始类型之间的比较，如 <info:type-conversions> 一章所述：\n\n```js run\n// 在 [] 被转换为 '' 后\nalert( 0 == '' ); // true，因为 '' 被转换成了数字 0\n\nalert('0' == '' ); // false，没有进一步的类型转换，是不同的字符串\n```\n\n那么，我们应该如何对数组进行比较呢？\n\n很简单，不要使用 `==` 运算符。而是，可以在循环中或者使用下一章中我们将介绍的迭代方法逐项地比较它们。\n\n## 总结\n\n数组是一种特殊的对象，适用于存储和管理有序的数据项。\n\n声明：\n\n```js\n// 方括号 (常见用法)\nlet arr = [item1, item2...];\n\n// new Array (极其少见)\nlet arr = new Array(item1, item2...);\n```\n\n调用 `new Array(number)` 会创建一个给定长度的数组，但不含有任何项。\n\n- `length` 属性是数组的长度，准确地说，它是数组最后一个数字索引值加一。它由数组方法自动调整。\n- 如果我们手动缩短 `length`，那么数组就会被截断。\n\n获取元素：\n\n- 你可以通过元素的索引获取元素，例如 `arr[0]`\n- 我们也可以使用允许负索引的 `at(i)` 方法。对于负值的 `i`，它会从数组的末尾往回数。如果 `i >= 0`，它的工作方式与 `arr[i]` 相同。\n\n我们可以通过下列操作以双端队列的方式使用数组：\n\n- `push(...items)` 在末端添加 `items` 项。\n- `pop()` 从末端移除并返回该元素。\n- `shift()` 从首端移除并返回该元素。\n- `unshift(...items)` 从首端添加 `items` 项。\n\n遍历数组的元素：\n  - `for (let i=0; i<arr.length; i++)` — 运行得最快，可兼容旧版本浏览器。\n  - `for (let item of arr)` — 现代语法，只能访问 items。\n  - `for (let i in arr)` — 永远不要用这个。\n\n比较数组时，不要使用 `==` 运算符（当然也不要使用 `>` 和 `<` 等运算符），因为它们不会对数组进行特殊处理。它们通常会像处理任意对象那样处理数组，这通常不是我们想要的。\n\n但是，我们可以使用 `for..of` 循环来逐项比较数组。\n\n在下一章 <info:array-methods> 中，我们将继续学习数组，学习更多添加、移除、提取元素和数组排序的方法。",
        "libs": [],
        "children": [
          "item-value",
          "create-array",
          "call-array-this",
          "array-input-sum",
          "maximal-subarray"
        ],
        "parent": "data-types",
        "updatedAt": 1657705346
      }
    },
    "item-value": {
      "type": "Task",
      "value": {
        "title": "数组被拷贝了吗?",
        "slug": "item-value",
        "githubPath": "/1-js/05-data-types/04-array/1-item-value",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\n\n下面的代码将会显示什么？\n\n```js\nlet fruits = [\"Apples\", \"Pear\", \"Orange\"];\n\n// 在“副本”里 push 了一个新的值\nlet shoppingCart = fruits;\nshoppingCart.push(\"Banana\");\n\n// fruits 里面是什么？\nalert( fruits.length ); // ?\n```",
        "solution": "结果是 `4`:\n\n\n```js run\nlet fruits = [\"Apples\", \"Pear\", \"Orange\"];\n\nlet shoppingCart = fruits;\n\nshoppingCart.push(\"Banana\");\n\n*!*\nalert( fruits.length ); // 4\n*/!*\n```\n\n这是因为数组是对象。所以 `shoppingCart` 和 `fruits` 是同一数组的引用。",
        "parent": "array",
        "version": 1
      }
    },
    "maximal-subarray": {
      "type": "Task",
      "value": {
        "title": "最大子数组",
        "slug": "maximal-subarray",
        "githubPath": "/1-js/05-data-types/04-array/10-maximal-subarray",
        "weight": 10,
        "libs": [],
        "importance": 2,
        "content": "\n\n输入是以数字组成的数组，例如 `arr = [1, -2, 3, 4, -9, 6]`.\n\n任务是：找出所有项的和最大的 `arr` 数组的连续子数组。\n\n写出函数 `getMaxSubSum(arr)`，用其找出并返回最大和。\n\n例如：\n\n```js\ngetMaxSubSum([-1, *!*2, 3*/!*, -9]) == 5（高亮项的加和）\ngetMaxSubSum([*!*2, -1, 2, 3*/!*, -9]) == 6\ngetMaxSubSum([-1, 2, 3, -9, *!*11*/!*]) == 11\ngetMaxSubSum([-2, -1, *!*1, 2*/!*]) == 3\ngetMaxSubSum([*!*100*/!*, -9, 2, -3, 5]) == 100\ngetMaxSubSum([*!*1, 2, 3*/!*]) == 6（所有项的和）\n```\n\n如果所有项都是负数，那就一个项也不取（子数组是空的），所以返回的是 0：\n\n```js\ngetMaxSubSum([-1, -2, -3]) = 0\n```\n\n请尝试想出一个快速的解决方案：复杂度可以是 [O(n<sup>2</sup>)](https://en.wikipedia.org/wiki/Big_O_notation)，有能力达到 O(n) 则更好。",
        "solution": "# 慢的解决方案\n\n我们可以计算所有可能的子集的和。\n\n最简单的方法就是获取每个元素然后计算从它开始所有子数组的和。\n\n以 `[-1, 2, 3, -9, 11]` 为例：\n\n```js no-beautify\n// 从 -1 开始：\n-1\n-1 + 2\n-1 + 2 + 3\n-1 + 2 + 3 + (-9)\n-1 + 2 + 3 + (-9) + 11\n\n// 从 2 开始：\n2\n2 + 3\n2 + 3 + (-9)\n2 + 3 + (-9) + 11\n\n// 从 3 开始：\n3\n3 + (-9)\n3 + (-9) + 11\n\n// 从 -9 开始：\n-9\n-9 + 11\n\n// 从 11 开始：\n11\n```\n\n这样写出来的代码实际上是一个嵌套循环：外部循环遍历数组所有元素，内部循环计算从当前元素开始的所有子数组各自的和。\n\n```js run\nfunction getMaxSubSum(arr) {\n  let maxSum = 0; // 如果没有取到任何元素，就返回 0\n\n  for (let i = 0; i < arr.length; i++) {\n    let sumFixedStart = 0;\n    for (let j = i; j < arr.length; j++) {\n      sumFixedStart += arr[j];\n      maxSum = Math.max(maxSum, sumFixedStart);\n    }\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\n```\n\n该方案的时间复杂度是 [O(n<sup>2</sup>)](https://en.wikipedia.org/wiki/Big_O_notation)。也就是说，如果我们把数组大小增加 2 倍，那么算法的运行时间将会延长4倍。\n\n对于大型数组（1000，10000 或者更多项）这种算法会导致严重的时间消耗。\n\n# 快的解决方案\n\n让我们遍历数组，将当前局部元素的和保存在变量 `s` 中。如果 `s` 在某一点变成负数了，就重新分配 `s=0`。所有 `s` 中的最大值就是答案。\n\n如果文字描述不太好理解，就直接看下面的代码吧，真的很短：\n\n```js run\nfunction getMaxSubSum(arr) {\n  let maxSum = 0;\n  let partialSum = 0;\n\n  for (let item of arr) { // arr 中的每个 item\n    partialSum += item; // 将其加到 partialSum\n    maxSum = Math.max(maxSum, partialSum); // 记住最大值\n    if (partialSum < 0) partialSum = 0; // 如果是负数就置为 0\n  }\n\n  return maxSum;\n}\n\nalert( getMaxSubSum([-1, 2, 3, -9]) ); // 5\nalert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11\nalert( getMaxSubSum([-2, -1, 1, 2]) ); // 3\nalert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100\nalert( getMaxSubSum([1, 2, 3]) ); // 6\nalert( getMaxSubSum([-1, -2, -3]) ); // 0\n```\n\n该算法只需要遍历 1 轮数组，所以时间复杂度是 O(n)。\n\n你也可以在这获取更多该算法的细节信息：[最大子数组问题](http://en.wikipedia.org/wiki/Maximum_subarray_problem)。如果还是不明白，那就调试上面的例子，观察它是怎样工作的，说得再多也没有自己去调试好使。",
        "solutionJs": "function getMaxSubSum(arr) {\n  let maxSum = 0;\n  let partialSum = 0;\n\n  for (let item of arr) {\n    partialSum += item;\n    maxSum = Math.max(maxSum, partialSum);\n    if (partialSum < 0) partialSum = 0;\n  }\n  return maxSum;\n}",
        "parent": "array",
        "version": 1
      }
    },
    "create-array": {
      "type": "Task",
      "value": {
        "title": "数组操作。",
        "slug": "create-array",
        "githubPath": "/1-js/05-data-types/04-array/2-create-array",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们试试下面的 5 个数组操作。\n\n1. 创建一个数组 `styles`，里面存储有 \"Jazz\" 和 \"Blues\"。\n2. 将 \"Rock-n-Roll\" 从数组末端添加进去。\n3. 用 \"Classics\" 替换掉数组最中间的元素。查找数组最中间的元素的代码应该适用于任何奇数长度的数组。\n4. 去掉数组的第一个值并显示它。\n5. 在数组前面添加 `Rap` 和 `Reggae`。\n\n过程中的数组：\n\n```js no-beautify\nJazz, Blues\nJazz, Blues, Rock-n-Roll\nJazz, Classics, Rock-n-Roll\nClassics, Rock-n-Roll\nRap, Reggae, Classics, Rock-n-Roll\n```",
        "solution": "```js run\nlet styles = [\"Jazz\", \"Blues\"];\nstyles.push(\"Rock-n-Roll\");\nstyles[Math.floor((styles.length - 1) / 2)] = \"Classics\";\nalert( styles.shift() );\nstyles.unshift(\"Rap\", \"Reggae\");\n```",
        "parent": "array",
        "version": 1
      }
    },
    "call-array-this": {
      "type": "Task",
      "value": {
        "title": "在数组上下文调用",
        "slug": "call-array-this",
        "githubPath": "/1-js/05-data-types/04-array/3-call-array-this",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n结果是什么？为什么？\n\n```js\nlet arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n});\n\narr[2](); // ?\n```",
        "solution": "`arr[2]()` 调用从句法来看可以类比于 `obj[method]()`，与 `obj` 对应的是 `arr`，与 `method` 对应的是 `2`。\n\n所以调用 `arr[2]` 函数也就是调用对象函数。自然地，它接收 `this` 引用的对象 `arr` 然后输出该数组：\n\n```js run\nlet arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n})\n\narr[2](); // a,b,function(){...}\n```\n\n该数组有 3 项：最开始有两个，后来添加进来一个函数。",
        "parent": "array",
        "version": 1
      }
    },
    "array-input-sum": {
      "type": "Task",
      "value": {
        "title": "输入数字求和",
        "slug": "array-input-sum",
        "githubPath": "/1-js/05-data-types/04-array/5-array-input-sum",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\n\n写出函数 `sumInput()`，要求如下：\n\n- 使用 `prompt` 向用户索要值，并存在数组中。\n- 当用户输入了非数字、空字符串或者点击“取消”按钮的时候，问询结束。\n- 计算并返回数组所有项之和。\n\nP.S. `0` 是有效的数字，不要因为是 0 就停止问询。\n\n[demo]",
        "solution": "请注意这个解决方案的细微但是很重要的细节。我们没有在 `prompt` 后立即把 `value` 转换成数字，因为在执行 `value = +value` 之后，就没办法区分出空字符串（中断标志）和数字 0（合法输入）了，所以要放到后面再处理。\n\n```js run demo\nfunction sumInput() {\n \n  let numbers = [];\n\n  while (true) {\n\n    let value = prompt(\"A number please?\", 0);\n\n    // 应该结束了吗？\n    if (value === \"\" || value === null || !isFinite(value)) break;\n\n    numbers.push(+value);\n  }\n\n  let sum = 0;\n  for (let number of numbers) {\n    sum += number;\n  }\n  return sum;\n}\n\nalert( sumInput() ); \n```",
        "parent": "array",
        "version": 1
      }
    },
    "array-methods": {
      "type": "Article",
      "value": {
        "title": "数组方法",
        "slug": "array-methods",
        "githubPath": "/1-js/05-data-types/05-array-methods",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n数组提供的方法有很多。为了方便起见，在本章中，我们将按组讲解。\n\n## 添加/移除数组元素\n\n我们已经学了从数组的首端或尾端添加和删除元素的方法：\n\n- `arr.push(...items)` —— 从尾端添加元素，\n- `arr.pop()` —— 从尾端提取元素，\n- `arr.shift()` —— 从首端提取元素，\n- `arr.unshift(...items)` —— 从首端添加元素。\n\n这里还有其他几种方法。\n\n### splice\n\n如何从数组中删除元素？\n\n数组是对象，所以我们可以尝试使用 `delete`：\n\n```js run\nlet arr = [\"I\", \"go\", \"home\"];\n\ndelete arr[1]; // remove \"go\"\n\nalert( arr[1] ); // undefined\n\n// now arr = [\"I\",  , \"home\"];\nalert( arr.length ); // 3\n```\n\n元素被删除了，但数组仍然有 3 个元素，我们可以看到 `arr.length == 3`。\n\n这很正常，因为 `delete obj.key` 是通过 `key` 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们通常希望剩下的元素能够移动并占据被释放的位置。我们希望得到一个更短的数组。\n\n所以应该使用特殊的方法。\n\n[arr.splice](mdn:js/Array/splice) 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。\n\n语法是：\n\n```js\narr.splice(start[, deleteCount, elem1, ..., elemN])\n```\n\n它从索引 `start` 开始修改 `arr`：删除 `deleteCount` 个元素并在当前位置插入 `elem1, ..., elemN`。最后返回被删除的元素所组成的数组。\n\n通过例子我们可以很容易地掌握这个方法。\n\n让我们从删除开始：\n\n```js run\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\n*!*\narr.splice(1, 1); // 从索引 1 开始删除 1 个元素\n*/!*\n\nalert( arr ); // [\"I\", \"JavaScript\"]\n```\n\n简单，对吧？从索引 `1` 开始删除 `1` 个元素。（译注：当只填写了 `splice` 的 `start` 参数时，将删除从索引 `start` 开始的所有数组项）\n\n在下一个例子中，我们删除了 3 个元素，并用另外两个元素替换它们：\n\n```js run\nlet arr = [*!*\"I\", \"study\", \"JavaScript\",*/!* \"right\", \"now\"];\n\n// 删除数组的前三项，并使用其他内容代替它们\narr.splice(0, 3, \"Let's\", \"dance\");\n\nalert( arr ) // 现在 [*!*\"Let's\", \"dance\"*/!*, \"right\", \"now\"]\n```\n\n在这里我们可以看到 `splice` 返回了被删除的元素所组成的数组：\n\n```js run\nlet arr = [*!*\"I\", \"study\",*/!* \"JavaScript\", \"right\", \"now\"];\n\n// 删除前两个元素\nlet removed = arr.splice(0, 2);\n\nalert( removed ); // \"I\", \"study\" <-- 被从数组中删除了的元素\n```\n\n我们可以将 `deleteCount` 设置为 `0`，`splice` 方法就能够插入元素而不用删除任何元素：\n\n```js run\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\n// 从索引 2 开始\n// 删除 0 个元素\n// 然后插入 \"complex\" 和 \"language\"\narr.splice(2, 0, \"complex\", \"language\");\n\nalert( arr ); // \"I\", \"study\", \"complex\", \"language\", \"JavaScript\"\n```\n\n````smart header=\"允许负向索引\"\n在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示：\n\n```js run\nlet arr = [1, 2, 5];\n\n// 从索引 -1（尾端前一位）\n// 删除 0 个元素，\n// 然后插入 3 和 4\narr.splice(-1, 0, 3, 4);\n\nalert( arr ); // 1,2,3,4,5\n```\n````\n\n### slice\n\n[arr.slice](mdn:js/Array/slice) 方法比 `arr.splice` 简单得多。\n\n语法是：\n\n```js\narr.slice([start], [end])\n```\n\n它会返回一个新数组，将所有从索引 `start` 到 `end`（不包括 `end`）的数组项复制到一个新的数组。`start` 和 `end` 都可以是负数，在这种情况下，从末尾计算索引。\n\n它和字符串的 `str.slice` 方法有点像，就是把子字符串替换成子数组。\n\n例如：\n\n```js run\nlet arr = [\"t\", \"e\", \"s\", \"t\"];\n\nalert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）\n\nalert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素）\n```\n\n我们也可以不带参数地调用它：`arr.slice()` 会创建一个 `arr` 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。\n\n### concat\n\n[arr.concat](mdn:js/Array/concat) 创建一个新数组，其中包含来自于其他数组和其他项的值。\n\n语法：\n\n```js\narr.concat(arg1, arg2...)\n```\n\n它接受任意数量的参数 —— 数组或值都可以。\n\n结果是一个包含来自于 `arr`，然后是 `arg1`，`arg2` 的元素的新数组。\n\n如果参数 `argN` 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。\n\n例如：\n\n```js run\nlet arr = [1, 2];\n\n// 从 arr 和 [3,4] 创建一个新数组\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n\n// 从 arr、[3,4] 和 [5,6] 创建一个新数组\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n\n// 从 arr、[3,4]、5 和 6 创建一个新数组\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n```\n\n通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：\n\n```js run\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"something\",\n  length: 1\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,[object Object]\n```\n\n……但是，如果类数组对象具有 `Symbol.isConcatSpreadable` 属性，那么它就会被 `concat` 当作一个数组来处理：此对象中的元素将被添加：\n\n```js run\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"something\",\n  1: \"else\",\n*!*\n  [Symbol.isConcatSpreadable]: true,\n*/!*\n  length: 2\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,something,else\n```\n\n## 遍历：forEach\n\n[arr.forEach](mdn:js/Array/forEach) 方法允许为数组的每个元素都运行一个函数。\n\n语法：\n```js\narr.forEach(function(item, index, array) {\n  // ... do something with item\n});\n```\n\n例如，下面这个程序显示了数组的每个元素：\n\n```js run\n// 对每个元素调用 alert\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach(alert);\n```\n\n而这段代码更详细地介绍了它们在目标数组中的位置：\n\n```js run\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach((item, index, array) => {\n  alert(`${item} is at index ${index} in ${array}`);\n});\n```\n\n该函数的结果（如果它有返回）会被抛弃和忽略。\n\n\n## 在数组中搜索\n\n现在，让我们介绍在数组中进行搜索的方法。\n\n### indexOf/lastIndexOf 和 includes\n\n[arr.indexOf](mdn:js/Array/indexOf) 和 [arr.includes](mdn:js/Array/includes) 方法语法相似，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作：\n\n- `arr.indexOf(item, from)` —— 从索引 `from` 开始搜索 `item`，如果找到则返回索引，否则返回 `-1`。\n- `arr.includes(item, from)` —— 从索引 `from` 开始搜索 `item`，如果找到则返回 `true`（译注：如果没找到，则返回 `false`）。\n\n通常使用这些方法时只会传入一个参数：传入 `item` 开始搜索。默认情况下，搜索是从头开始的。\n\n例如：\n\n```js run\nlet arr = [1, 0, false];\n\nalert( arr.indexOf(0) ); // 1\nalert( arr.indexOf(false) ); // 2\nalert( arr.indexOf(null) ); // -1\n\nalert( arr.includes(1) ); // true\n```\n\n请注意，`indexOf` 和 `includes` 使用严格相等 `===` 进行比较。所以，如果我们搜索 `false`，它会准确找到 `false` 而不是数字 `0`。\n\n如果我们想检查数组中是否包含元素 `item`，并且不需要知道其确切的索引，那么 `arr.includes` 是首选。\n\n方法 [arr.lastIndexOf](mdn:js/Array/lastIndexOf) 与 `indexOf` 相同，但从右向左查找。\n\n```js run\nlet fruits = ['Apple', 'Orange', 'Apple'];\n\nalert( fruits.indexOf('Apple') ); // 0（第一个 Apple）\nalert( fruits.lastIndexOf('Apple') ); // 2（最后一个 Apple）\n```\n\n````smart header=\"方法 `includes` 可以正确的处理 `NaN`\"\n方法 `includes` 的一个次要但值得注意的特性是，它可以正确处理 `NaN`，这与 `indexOf` 不同：\n\n```js run\nconst arr = [NaN];\nalert( arr.indexOf(NaN) ); // -1（错，应该为 0）\nalert( arr.includes(NaN) );// true（正确）\n```\n这是因为 `includes` 是在比较晚的时候才被添加到 JavaScript 中的，并且在内部使用了更新了的比较算法。\n````\n\n### find 和 findIndex/findLastIndex\n\n想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？\n\n这时可以用 [arr.find](mdn:js/Array/find) 方法。\n\n语法如下：\n```js\nlet result = arr.find(function(item, index, array) {\n  // 如果返回 true，则返回 item 并停止迭代\n  // 对于假值（falsy）的情况，则返回 undefined\n});\n```\n\n依次对数组中的每个元素调用该函数：\n\n- `item` 是元素。\n- `index` 是它的索引。\n- `array` 是数组本身。\n\n如果它返回 `true`，则搜索停止，并返回 `item`。如果没有搜索到，则返回 `undefined`。\n\n例如，我们有一个存储用户的数组，每个用户都有 `id` 和 `name` 字段。让我们找到 `id == 1` 的那个用户：\n\n```js run\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\nlet user = users.find(item => item.id == 1);\n\nalert(user.name); // John\n```\n\n在现实生活中，对象数组是很常见的，所以 `find` 方法非常有用。\n\n注意在这个例子中，我们传给了 `find` 一个单参数函数 `item => item.id == 1`。这很典型，并且 `find` 方法的其他参数很少使用。\n\n[arr.findIndex](mdn:js/Array/findIndex) 方法（与 `arr.find`）具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回 `-1`。\n\n[arr.findLastIndex](mdn:js/Array/findLastIndex) 方法类似于 `findIndex`，但从右向左搜索，类似于 `lastIndexOf`。\n\n这是一个例子：\n\n```js run\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"},\n  {id: 4, name: \"John\"}\n];\n\n// 寻找第一个 John 的索引\nalert(users.findIndex(user => user.name == 'John')); // 0\n\n// 寻找最后一个 John 的索引\nalert(users.findLastIndex(user => user.name == 'John')); // 3\n```\n\n\n\n### filter\n\n`find` 方法搜索的是使函数返回 `true` 的第一个（单个）元素。\n\n如果需要匹配的有很多，我们可以使用 [arr.filter(fn)](mdn:js/Array/filter)。\n\n语法与 `find` 大致相同，但是 `filter` 返回的是所有匹配元素组成的数组：\n\n```js\nlet results = arr.filter(function(item, index, array) {\n  // 如果 true item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n```\n\n例如：\n\n```js run\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\n// 返回前两个用户的数组\nlet someUsers = users.filter(item => item.id < 3);\n\nalert(someUsers.length); // 2\n```\n\n## 转换数组\n\n让我们继续学习进行数组转换和重新排序的方法。\n\n### map\n\n[arr.map](mdn:js/Array/map) 方法是最有用和经常使用的方法之一。\n\n它对数组的每个元素都调用函数，并返回结果数组。\n\n语法：\n\n```js\nlet result = arr.map(function(item, index, array) {\n  // 返回新值而不是当前元素\n})\n```\n\n例如，在这里我们将每个元素转换为它的字符串长度：\n\n```js run\nlet lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item => item.length);\nalert(lengths); // 5,7,6\n```\n\n### sort(fn)\n\n[arr.sort](mdn:js/Array/sort) 方法对数组进行 **原位（in-place）** 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)\n\n它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 `arr` 本身。\n\n语法：\n\n```js run\nlet arr = [ 1, 2, 15 ];\n\n// 该方法重新排列 arr 的内容\narr.sort();\n\nalert( arr );  // *!*1, 15, 2*/!*\n```\n\n你有没有注意到结果有什么奇怪的地方？\n\n顺序变成了 `1, 15, 2`。不对，但为什么呢？\n\n**这些元素默认情况下被按字符串进行排序。**\n\n从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 `\"2\" > \"15\"`。\n\n要使用我们自己的排序顺序，我们需要提供一个函数作为 `arr.sort()` 的参数。\n\n该函数应该比较两个任意值并返回：\n\n```js\nfunction compare(a, b) {\n  if (a > b) return 1; // 如果第一个值比第二个值大\n  if (a == b) return 0; // 如果两个值相等\n  if (a < b) return -1; // 如果第一个值比第二个值小\n}\n```\n\n例如，按数字进行排序：\n\n```js run\nfunction compareNumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n\nlet arr = [ 1, 2, 15 ];\n\n*!*\narr.sort(compareNumeric);\n*/!*\n\nalert(arr);  // *!*1, 2, 15*/!*\n```\n\n现在结果符合预期了。\n\n我们思考一下这儿发生了什么。`arr` 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 **一些元素**。要对其进行排序，我们需要一个 **排序函数** 来确认如何比较这些元素。默认是按字符串进行排序的。\n\n`arr.sort(fn)` 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 [快速排序](https://en.wikipedia.org/wiki/Quicksort) 或 [Timsort](https://en.wikipedia.org/wiki/Timsort) 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 `fn`。\n\n顺便说一句，如果我们想知道要比较哪些元素 —— 那么什么都不会阻止 alert 它们：\n\n```js run\n[1, -2, 15, 2, 0, 8].sort(function(a, b) {\n  alert( a + \" <> \" + b );\n  return a - b;\n});\n```\n\n该算法可以在此过程中，将一个元素与多个其他元素进行比较，但是它会尝试进行尽可能少的比较。\n\n````smart header=\"比较函数可以返回任何数字\"\n实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。\n\n通过这个原理我们可以编写更短的函数：\n\n```js run\nlet arr = [ 1, 2, 15 ];\n\narr.sort(function(a, b) { return a - b; });\n\nalert(arr);  // *!*1, 2, 15*/!*\n```\n````\n\n````smart header=\"箭头函数最好\"\n你还记得 [箭头函数](info:arrow-functions-basics) 吗？这里使用箭头函数会更加简洁：\n\n```js\narr.sort( (a, b) => a - b );\n```\n\n这与上面更长的版本完全相同。\n````\n\n````smart header=\"使用 `localeCompare` for strings\"\n你记得 [字符串比较](info:string#correct-comparisons) 算法吗？默认情况下，它通过字母的代码比较字母。\n\n对于许多字母，最好使用 `str.localeCompare` 方法正确地对字母进行排序，例如 `Ö`。\n\n例如，让我们用德语对几个国家/地区进行排序：\n\n```js run\nlet countries = ['Österreich', 'Andorra', 'Vietnam'];\n\nalert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich（错的）\n\nalert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam（对的！）\n```\n````\n\n### reverse\n\n[arr.reverse](mdn:js/Array/reverse) 方法用于颠倒 `arr` 中元素的顺序。\n\n例如：\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\n\nalert( arr ); // 5,4,3,2,1\n```\n\n它也会返回颠倒后的数组 `arr`。\n\n### split 和 join\n\n举一个现实生活场景的例子。我们正在编写一个消息应用程序，并且该人员输入以逗号分隔的接收者列表：`John, Pete, Mary`。但对我们来说，名字数组比单个字符串舒适得多。怎么做才能获得这样的数组呢？\n\n[str.split(delim)](mdn:js/String/split) 方法可以做到。它通过给定的分隔符 `delim` 将字符串分割成一个数组。\n\n在下面的例子中，我们用“逗号后跟着一个空格”作为分隔符：\n\n```js run\nlet names = 'Bilbo, Gandalf, Nazgul';\n\nlet arr = names.split(', ');\n\nfor (let name of arr) {\n  alert( `A message to ${name}.` ); // A message to Bilbo（和其他名字）\n}\n```\n\n`split` 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用：\n\n```js run\nlet arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);\n\nalert(arr); // Bilbo, Gandalf\n```\n\n````smart header=\"拆分为字母\"\n调用带有空参数 `s` 的 `split(s)`，会将字符串拆分为字母数组：\n\n```js run\nlet str = \"test\";\n\nalert( str.split('') ); // t,e,s,t\n```\n````\n\n[arr.join(glue)](mdn:js/Array/join) 与 `split` 相反。它会在它们之间创建一串由 `glue` 粘合的 `arr` 项。\n\n例如：\n\n```js run\nlet arr = ['Bilbo', 'Gandalf', 'Nazgul'];\n\nlet str = arr.join(';'); // 使用分号 ; 将数组粘合成字符串\n\nalert( str ); // Bilbo;Gandalf;Nazgul\n```\n\n### reduce/reduceRight\n\n当我们需要遍历一个数组时 —— 我们可以使用 `forEach`，`for` 或 `for..of`。\n\n当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 `map`。\n\n[arr.reduce](mdn:js/Array/reduce) 方法和 [arr.reduceRight](mdn:js/Array/reduceRight) 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。\n\n语法是：\n\n```js\nlet value = arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);\n```\n\n该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。\n\n参数：\n\n- `accumulator` —— 是上一个函数调用的结果，第一次等于  `initial`（如果提供了 `initial` 的话）。\n- `item` —— 当前的数组元素。\n- `index` —— 当前索引。\n- `arr` —— 数组本身。\n\n应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。\n\n因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 `reduce` 的结果。\n\n听起来复杂吗？\n\n掌握这个知识点的最简单的方法就是通过示例。\n\n在这里，我们通过一行代码得到一个数组的总和：\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\nlet result = arr.reduce((sum, current) => sum + current, 0);\n\nalert(result); // 15\n```\n\n传递给 `reduce` 的函数仅使用了 2 个参数，通常这就足够了。\n\n让我们看看细节，到底发生了什么。\n\n1. 在第一次运行时，`sum` 的值为初始值 `initial`（`reduce` 的最后一个参数），等于 0，`current` 是第一个数组元素，等于 `1`。所以函数运行的结果是 `1`。\n2. 在第二次运行时，`sum = 1`，我们将第二个数组元素（`2`）与其相加并返回。\n3. 在第三次运行中，`sum = 3`，我们继续把下一个元素与其相加，以此类推……\n\n计算流程：\n\n![](reduce.svg)\n\n或者以表格的形式表示，每一行代表的是对下一个数组元素的函数调用：\n\n|   |`sum`|`current`|`result`|\n|---|-----|---------|---------|\n|第 1 次调用|`0`|`1`|`1`|\n|第 2 次调用|`1`|`2`|`3`|\n|第 3 次调用|`3`|`3`|`6`|\n|第 4 次调用|`6`|`4`|`10`|\n|第 5 次调用|`10`|`5`|`15`|\n\n在这里，我们可以清楚地看到上一个调用的结果如何成为下一个调用的第一个参数。\n\n我们也可以省略初始值：\n\n```js run\nlet arr = [1, 2, 3, 4, 5];\n\n// 删除 reduce 的初始值（没有 0）\nlet result = arr.reduce((sum, current) => sum + current);\n\nalert( result ); // 15\n```\n\n结果是一样的。这是因为如果没有初始值，那么 `reduce` 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。\n\n计算表与上面相同，只是去掉第一行。\n\n但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 `reduce` 会导致错误。\n\n例如：\n\n```js run\nlet arr = [];\n\n// Error: Reduce of empty array with no initial value\n// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。\narr.reduce((sum, current) => sum + current);\n```\n\n所以建议始终指定初始值。\n\n[arr.reduceRight](mdn:js/Array/reduceRight) 和 [arr.reduce](mdn:js/Array/reduce) 方法的功能一样，只是遍历为从右到左。\n\n## Array.isArray\n\n数组是基于对象的，不构成单独的语言类型。\n\n所以 `typeof` 不能帮助从数组中区分出普通对象：\n\n```js run\nalert(typeof {}); // object\nalert(typeof []); // object（相同）\n```\n\n……但是数组经常被使用，因此有一种特殊的方法用于判断：[Array.isArray(value)](mdn:js/Array/isArray)。如果 `value` 是一个数组，则返回 `true`；否则返回 `false`。\n\n```js run\nalert(Array.isArray({})); // false\n\nalert(Array.isArray([])); // true\n```\n\n## 大多数方法都支持 \"thisArg\"\n\n几乎所有调用函数的数组方法 —— 比如 `find`，`filter`，`map`，除了 `sort` 是一个特例，都接受一个可选的附加参数 `thisArg`。\n\n上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。\n\n以下是这些方法的完整语法：\n\n```js\narr.find(func, thisArg);\narr.filter(func, thisArg);\narr.map(func, thisArg);\n// ...\n// thisArg 是可选的最后一个参数\n```\n\n`thisArg` 参数的值在 `func` 中变为 `this`。\n\n例如，在这里我们使用 `army` 对象方法作为过滤器，`thisArg` 用于传递上下文（passes the context）：\n\n```js run\nlet army = {\n  minAge: 18,\n  maxAge: 27,\n  canJoin(user) {\n    return user.age >= this.minAge && user.age < this.maxAge;\n  }\n};\n\nlet users = [\n  {age: 16},\n  {age: 20},\n  {age: 23},\n  {age: 30}\n];\n\n*!*\n// 找到 army.canJoin 返回 true 的 user\nlet soldiers = users.filter(army.canJoin, army);\n*/!*\n\nalert(soldiers.length); // 2\nalert(soldiers[0].age); // 20\nalert(soldiers[1].age); // 23\n```\n\n如果在上面的示例中我们使用了 `users.filter(army.canJoin)`，那么 `army.canJoin` 将被作为独立函数调用，并且这时 `this=undefined`，从而会导致即时错误。\n\n可以用 `users.filter(user => army.canJoin(user))` 替换对 `users.filter(army.canJoin, army)` 的调用。前者的使用频率更高，因为对于大多数人来说，它更容易理解。\n\n## 总结\n\n数组方法备忘单：\n\n- 添加/删除元素：\n  - `push(...items)` —— 向尾端添加元素，\n  - `pop()` —— 从尾端提取一个元素，\n  - `shift()` —— 从首端提取一个元素，\n  - `unshift(...items)` —— 向首端添加元素，\n  - `splice(pos, deleteCount, ...items)` —— 从 `pos` 开始删除 `deleteCount` 个元素，并插入 `items`。\n  - `slice(start, end)` —— 创建一个新数组，将从索引 `start` 到索引 `end`（但不包括 `end`）的元素复制进去。\n  - `concat(...items)` —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 `items`。如果 `items` 中的任意一项是一个数组，那么就取其元素。\n\n- 搜索元素：\n  - `indexOf/lastIndexOf(item, pos)` ——  从索引 `pos` 开始搜索 `item`，搜索到则返回该项的索引，否则返回 `-1`。\n  - `includes(value)` —— 如果数组有 `value`，则返回 `true`，否则返回 `false`。\n  - `find/filter(func)` —— 通过 `func` 过滤元素，返回使 `func` 返回 `true` 的第一个值/所有值。 \n  - `findIndex` 和 `find` 类似，但返回索引而不是值。\n\n- 遍历元素：\n  - `forEach(func)` —— 对每个元素都调用 `func`，不返回任何内容。\n\n- 转换数组：\n  - `map(func)` —— 根据对每个元素调用 `func` 的结果创建一个新数组。\n  - `sort(func)` —— 对数组进行原位（in-place）排序，然后返回它。\n  - `reverse()` —— 原位（in-place）反转数组，然后返回它。\n  - `split/join` —— 将字符串转换为数组并返回。\n  - `reduce/reduceRight(func, initial)` —— 通过对每个元素调用 `func` 计算数组上的单个值，并在调用之间传递中间结果。\n\n- 其他：\n  - `Array.isArray(value)` 检查 `value` 是否是一个数组，如果是则返回 `true`，否则返回 `false`。\n\n请注意，`sort`，`reverse` 和 `splice` 方法修改的是数组本身。\n\n这些是最常用的方法，它们覆盖 99％ 的用例。但是还有其他几个：\n\n- [arr.some(fn)](mdn:js/Array/some)/[arr.every(fn)](mdn:js/Array/every) 检查数组。\n\n  与 `map` 类似，对数组的每个元素调用函数 `fn`。如果任何/所有结果为 `true`，则返回 `true`，否则返回 `false`。\n\n  这两个方法的行为类似于 `||` 和 `&&` 运算符：如果 `fn` 返回一个真值，`arr.some()` 立即返回 `true` 并停止迭代其余数组项；如果 `fn` 返回一个假值，`arr.every()` 立即返回 `false` 并停止对其余数组项的迭代。\n\n  我们可以使用 `every` 来比较数组：\n\n  ```js run\n  function arraysEqual(arr1, arr2) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n  }\n\n  alert( arraysEqual([1, 2], [1, 2])); // true\n  ```\n\n- [arr.fill(value, start, end)](mdn:js/Array/fill) —— 从索引 `start` 到 `end`，用重复的 `value` 填充数组。\n\n- [arr.copyWithin(target, start, end)](mdn:js/Array/copyWithin) —— 将从位置 `start` 到 `end` 的所有元素复制到 **自身** 的 `target` 位置（覆盖现有元素）。\n\n- [arr.flat(depth)](mdn:js/Array/flat)/[arr.flatMap(fn)](mdn:js/Array/flatMap) 从多维数组创建一个新的扁平数组。\n\n- [Array.of(element0[, element1[, ...[, elementN]]])](mdn:js/Array/of) 基于可变数量的参数创建一个新的 `Array` 实例，而不需要考虑参数的数量或类型。\n\n有关完整列表，请参阅 [手册](mdn:js/Array)。\n\n乍看起来，似乎有很多方法，很难记住。但实际上这比看起来要容易得多。\n\n浏览这个备忘单，以了解这些方法。然后解决本章中的习题来进行练习，以便让你有数组方法的使用经验。\n\n然后，每当你需要对数组进行某些操作，而又不知道怎么做的时候，请回到这儿，查看这个备忘单，然后找到正确的方法。示例将帮助你正确编写它。用不了多久，你就自然而然地记住这些方法了，根本不需要你死记硬背。",
        "libs": [],
        "children": [
          "camelcase",
          "filter-range",
          "filter-range-in-place",
          "sort-back",
          "copy-sort-array",
          "calculator-extendable",
          "array-get-names",
          "map-objects",
          "sort-objects",
          "shuffle",
          "average-age",
          "array-unique",
          "reduce-object"
        ],
        "parent": "data-types",
        "updatedAt": 1660368638
      }
    },
    "camelcase": {
      "type": "Task",
      "value": {
        "title": "将 border-left-width 转换成 borderLeftWidth",
        "slug": "camelcase",
        "githubPath": "/1-js/05-data-types/05-array-methods/1-camelcase",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写函数 `camelize(str)` 将诸如 \"my-short-string\" 之类的由短划线分隔的单词变成骆驼式的 \"myShortString\"。\n\n即：删除所有短横线，并将短横线后的每一个单词的首字母变为大写。\n\n示例：\n\n```js\ncamelize(\"background-color\") == 'backgroundColor';\ncamelize(\"list-style-image\") == 'listStyleImage';\ncamelize(\"-webkit-transition\") == 'WebkitTransition';\n```\n\n提示：使用 `split` 将字符串拆分成数组，对其进行转换之后再 `join` 回来。",
        "solution": "",
        "solutionJs": "function camelize(str) {\n  return str\n    .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']\n    .map(\n      // capitalizes first letters of all array items except the first one\n      // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']\n      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)\n    )\n    .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'\n}\n",
        "parent": "array-methods",
        "version": 1
      }
    },
    "average-age": {
      "type": "Task",
      "value": {
        "title": "获取平均年龄",
        "slug": "average-age",
        "githubPath": "/1-js/05-data-types/05-array-methods/10-average-age",
        "weight": 10,
        "libs": [],
        "importance": 4,
        "content": "\n\n编写 `getAverageAge(users)` 函数，该函数获取一个具有 `age` 属性的对象数组，并返回平均年龄。\n\n平均值的计算公式是 `(age1 + age2 + ... + ageN) / N`。\n\n例如：\n\n```js no-beautify\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 29 };\n\nlet arr = [ john, pete, mary ];\n\nalert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28\n```",
        "solution": "```js run\nfunction getAverageAge(users) {\n  return users.reduce((prev, user) => prev + user.age, 0) / users.length;\n}\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 29 };\n\nlet arr = [ john, pete, mary ];\n\nalert( getAverageAge(arr) ); // 28\n```",
        "parent": "array-methods",
        "version": 1
      }
    },
    "array-unique": {
      "type": "Task",
      "value": {
        "title": "数组去重",
        "slug": "array-unique",
        "githubPath": "/1-js/05-data-types/05-array-methods/11-array-unique",
        "weight": 11,
        "libs": [],
        "importance": 4,
        "content": "\n\n`arr` 是一个数组。\n\n创建一个函数 `unique(arr)`，返回去除重复元素后的数组 `arr`。\n\n例如：\n\n```js\nfunction unique(arr) {\n  /* your code */\n}\n\nlet strings = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(strings) ); // Hare, Krishna, :-O\n```",
        "solution": "让我们先遍历数字：\n- 对于每个元素，我们将检查结果数组是否已经有该元素。\n- 如果有，则忽略，否则将其添加到结果中。\n\n```js run demo\nfunction unique(arr) {\n  let result = [];\n\n  for (let str of arr) {\n    if (!result.includes(str)) {\n      result.push(str);\n    }\n  }\n\n  return result;\n}\n\nlet strings = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(strings) ); // Hare, Krishna, :-O\n```\n\n代码有效，但其中存在潜在的性能问题。\n\n方法 `result.includes(str)` 在内部遍历数组 `result`，并将每个元素与 `str` 进行比较以找到匹配项。\n\n所以如果 `result` 中有 `100` 个元素，并且没有任何一项与 `str` 匹配，那么它将遍历整个 `result` 并进行 `100` 次比较。如果 `result` 很大，比如 `10000`，那么就会有 `10000` 次的比较。\n\n这本身并不是问题，因为 JavaScript 引擎速度非常快，所以遍历一个有 `10000` 个元素的数组只需要几微秒。\n\n但是我们在 `for `循环中对 `arr` 的每个元素都进行了一次检测。\n\n因此，如果 `arr.length` 是 `10000`，我们会有 `10000 * 10000` = 1 亿次的比较。那真的太多了。\n\n所以该解决方案仅适用于小型数组。\n\n进一步，在后面的 <info:map-set> 一章中，我们将看到如何对该方法进行优化。",
        "solutionJs": "function unique(arr) {\n  let result = [];\n\n  for (let str of arr) {\n    if (!result.includes(str)) {\n      result.push(str);\n    }\n  }\n\n  return result;\n}\n",
        "parent": "array-methods",
        "version": 1
      }
    },
    "reduce-object": {
      "type": "Task",
      "value": {
        "title": "从数组创建键（值）对象",
        "slug": "reduce-object",
        "githubPath": "/1-js/05-data-types/05-array-methods/12-reduce-object",
        "weight": 12,
        "libs": [],
        "importance": 4,
        "content": "\n\n假设我们收到了一个用户数组，形式为：`{id:..., name:..., age:... }`。\n\n创建一个函数 `groupById(arr)` 从该数组创建对象，以 `id` 为键（key），数组项为值。\n\n例如:\n\n```js\nlet users = [\n  {id: 'john', name: \"John Smith\", age: 20},\n  {id: 'ann', name: \"Ann Smith\", age: 24},\n  {id: 'pete', name: \"Pete Peterson\", age: 31},\n];\n\nlet usersById = groupById(users);\n\n/*\n// 调用函数后，我们应该得到：\n\nusersById = {\n  john: {id: 'john', name: \"John Smith\", age: 20},\n  ann: {id: 'ann', name: \"Ann Smith\", age: 24},\n  pete: {id: 'pete', name: \"Pete Peterson\", age: 31},\n}\n*/\n```\n\n\n处理服务端数据时，这个函数很有用。\n\n在这个任务里我们假设 `id` 是唯一的。没有两个具有相同 `id` 的数组项。\n\n请在解决方案中使用数组的 `.reduce` 方法。",
        "solution": "",
        "solutionJs": "function groupById(array) {\n  return array.reduce((obj, value) => {\n    obj[value.id] = value;\n    return obj;\n  }, {})\n}\n",
        "parent": "array-methods",
        "version": 1
      }
    },
    "filter-range": {
      "type": "Task",
      "value": {
        "title": "过滤范围",
        "slug": "filter-range",
        "githubPath": "/1-js/05-data-types/05-array-methods/2-filter-range",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n写一个函数 `filterRange(arr, a, b)`，该函数获取一个数组 `arr`，在其中查找数值大于或等于 `a`，且小于或等于 `b` 的元素，并将结果以数组的形式返回。\n\n该函数不应该修改原数组。它应该返回新的数组。\n\n例如：\n\n```js\nlet arr = [5, 3, 8, 1];\n\nlet filtered = filterRange(arr, 1, 4); \n\nalert( filtered ); // 3,1（匹配值）\n\nalert( arr ); // 5,3,8,1（未修改）\n```",
        "solution": "```js run demo\nfunction filterRange(arr, a, b) {\n  // 在表达式周围添加了括号，以提高可读性\n  return arr.filter(item => (a <= item && item <= b));\n}\n\nlet arr = [5, 3, 8, 1];\n\nlet filtered = filterRange(arr, 1, 4);\n\nalert( filtered ); // 3,1（匹配的值）\n\nalert( arr ); // 5,3,8,1（未经改动的数组中的值）\n```",
        "solutionJs": "\nfunction filterRange(arr, a, b) {\n  // added brackets around the expression for better readability\n  return arr.filter(item => (a <= item && item <= b));\n}",
        "parent": "array-methods",
        "version": 1
      }
    },
    "filter-range-in-place": {
      "type": "Task",
      "value": {
        "title": "原位（in place）过滤范围",
        "slug": "filter-range-in-place",
        "githubPath": "/1-js/05-data-types/05-array-methods/3-filter-range-in-place",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\n\n写一个函数 `filterRangeInPlace(arr, a, b)`，该函数获取一个数组 `arr`，并删除其中介于 `a` 和 `b` 区间以外的所有值。检查：`a ≤ arr[i] ≤ b`。\n\n该函数应该只修改数组。它不应该返回任何东西。\n\n例如：\n```js\nlet arr = [5, 3, 8, 1];\n\nfilterRangeInPlace(arr, 1, 4); // 删除了范围在 1 到 4 之外的所有值\n\nalert( arr ); // [3, 1]\n```",
        "solution": "```js run demo\nfunction filterRangeInPlace(arr, a, b) {\n\n  for (let i = 0; i < arr.length; i++) {\n    let val = arr[i];\n\n    // 如果超出范围，则删除\n    if (val < a || val > b) {\n      arr.splice(i, 1);\n      i--;\n    }\n  }\n\n}\n\nlet arr = [5, 3, 8, 1];\n\nfilterRangeInPlace(arr, 1, 4); // 删除 1 到 4 范围之外的值\n\nalert( arr ); // [3, 1]\n```",
        "solutionJs": "\nfunction filterRangeInPlace(arr, a, b) {\n\n  for (let i = 0; i < arr.length; i++) {\n    let val = arr[i];\n\n    // remove if outside of the interval\n    if (val < a || val > b) {\n      arr.splice(i, 1);\n      i--;\n    }\n  }\n\n}\n",
        "parent": "array-methods",
        "version": 1
      }
    },
    "sort-back": {
      "type": "Task",
      "value": {
        "title": "降序排列",
        "slug": "sort-back",
        "githubPath": "/1-js/05-data-types/05-array-methods/4-sort-back",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n\n```js\nlet arr = [5, 2, 1, -10, 8];\n\n// ……你的代码以降序对其进行排序\n\nalert( arr ); // 8, 5, 2, 1, -10\n```",
        "solution": "```js run\nlet arr = [5, 2, 1, -10, 8];\n\narr.sort((a, b) => b - a);\n\nalert( arr );\n```",
        "parent": "array-methods",
        "version": 1
      }
    },
    "copy-sort-array": {
      "type": "Task",
      "value": {
        "title": "复制和排序数组",
        "slug": "copy-sort-array",
        "githubPath": "/1-js/05-data-types/05-array-methods/5-copy-sort-array",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有一个字符串数组 `arr`。我们希望有一个排序过的副本，但保持 `arr` 不变。\n\n创建一个函数 `copySorted(arr)` 返回这样一个副本。\n\n```js\nlet arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\nlet sorted = copySorted(arr);\n\nalert( sorted ); // CSS, HTML, JavaScript\nalert( arr ); // HTML, JavaScript, CSS (no changes)\n```",
        "solution": "我们可以使用 `slice()` 来创建一个副本并对其进行排序：\n\n```js run\nfunction copySorted(arr) {\n  return arr.slice().sort();\n}\n\nlet arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\n*!*\nlet sorted = copySorted(arr);\n*/!*\n\nalert( sorted );\nalert( arr );\n```",
        "parent": "array-methods",
        "version": 1
      }
    },
    "array-get-names": {
      "type": "Task",
      "value": {
        "title": "映射到 names",
        "slug": "array-get-names",
        "githubPath": "/1-js/05-data-types/05-array-methods/6-array-get-names",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n你有一个 `user` 对象数组，每个对象都有 `user.name`。编写将其转换为 names 数组的代码。\n\n例如：\n\n```js no-beautify\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet users = [ john, pete, mary ];\n\nlet names = /* ... your code */\n\nalert( names ); // John, Pete, Mary\n```",
        "solution": "```js run\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet users = [ john, pete, mary ];\n\nlet names = users.map(item => item.name);\n\nalert( names ); // John, Pete, Mary\n```",
        "parent": "array-methods",
        "version": 1
      }
    },
    "calculator-extendable": {
      "type": "Task",
      "value": {
        "title": "创建一个可扩展的 calculator",
        "slug": "calculator-extendable",
        "githubPath": "/1-js/05-data-types/05-array-methods/6-calculator-extendable",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个构造函数 `Calculator`，以创建“可扩展”的 calculator 对象。\n\n该任务由两部分组成。\n\n1. 首先，实现 `calculate(str)` 方法，该方法接受像 `\"1 + 2\"` 这样格式为“数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 `+` 和减号 `-`。\n\n    用法示例：\n\n    ```js\n    let calc = new Calculator;\n\n    alert( calc.calculate(\"3 + 7\") ); // 10\n    ```\n2. 然后添加方法 `addMethod(name, func)`，该方法教 calculator 进行新操作。它需要运算符 `name` 和实现它的双参数函数 `func(a,b)`。\n\n    例如，我们添加乘法 `*`，除法 `/` 和求幂 `**`：\n\n    ```js\n    let powerCalc = new Calculator;\n    powerCalc.addMethod(\"*\", (a, b) => a * b);\n    powerCalc.addMethod(\"/\", (a, b) => a / b);\n    powerCalc.addMethod(\"**\", (a, b) => a ** b);\n\n    let result = powerCalc.calculate(\"2 ** 3\");\n    alert( result ); // 8\n    ```\n\n- 此任务中没有括号或复杂的表达式。\n- 数字和运算符之间只有一个空格。\n- 你可以自行选择是否添加错误处理功能。",
        "solution": "- 请注意方法的存储方式。它们只是被添加到 `this.methods` 属性中。\n- 所有检测和数字转换都通过 `calculate` 方法完成。将来可能会扩展它以支持更复杂的表达式。",
        "solutionJs": "function Calculator() {\n\n  this.methods = {\n    \"-\": (a, b) => a - b,\n    \"+\": (a, b) => a + b\n  };\n\n  this.calculate = function(str) {\n\n    let split = str.split(' '),\n      a = +split[0],\n      op = split[1],\n      b = +split[2];\n\n    if (!this.methods[op] || isNaN(a) || isNaN(b)) {\n      return NaN;\n    }\n\n    return this.methods[op](a, b);\n  };\n\n  this.addMethod = function(name, func) {\n    this.methods[name] = func;\n  };\n}\n",
        "parent": "array-methods",
        "version": 1
      }
    },
    "map-objects": {
      "type": "Task",
      "value": {
        "title": "映射到对象",
        "slug": "map-objects",
        "githubPath": "/1-js/05-data-types/05-array-methods/7-map-objects",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\n\n你有一个 `user` 对象数组，每个对象都有 `name`，`surname` 和 `id`。\n\n编写代码以该数组为基础，创建另一个具有 `id` 和 `fullName` 的对象数组，其中 `fullName` 由 `name` 和 `surname` 生成。\n\n例如：\n\n```js no-beautify\nlet john = { name: \"John\", surname: \"Smith\", id: 1 };\nlet pete = { name: \"Pete\", surname: \"Hunt\", id: 2 };\nlet mary = { name: \"Mary\", surname: \"Key\", id: 3 };\n\nlet users = [ john, pete, mary ];\n\n*!*\nlet usersMapped = /* ... your code ... */\n*/!*\n\n/*\nusersMapped = [\n  { fullName: \"John Smith\", id: 1 },\n  { fullName: \"Pete Hunt\", id: 2 },\n  { fullName: \"Mary Key\", id: 3 }\n]\n*/\n\nalert( usersMapped[0].id ) // 1\nalert( usersMapped[0].fullName ) // John Smith\n```\n\n所以，实际上你需要将一个对象数组映射到另一个对象数组。在这儿尝试使用箭头函数 `=>` 来编写。",
        "solution": "```js run no-beautify\nlet john = { name: \"John\", surname: \"Smith\", id: 1 };\nlet pete = { name: \"Pete\", surname: \"Hunt\", id: 2 };\nlet mary = { name: \"Mary\", surname: \"Key\", id: 3 };\n\nlet users = [ john, pete, mary ];\n\n*!*\nlet usersMapped = users.map(user => ({\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n}));\n*/!*\n\n/*\nusersMapped = [\n  { fullName: \"John Smith\", id: 1 },\n  { fullName: \"Pete Hunt\", id: 2 },\n  { fullName: \"Mary Key\", id: 3 }\n]\n*/\n\nalert( usersMapped[0].id ); // 1\nalert( usersMapped[0].fullName ); // John Smith\n```\n\n请注意，在箭头函数中，我们需要使用额外的括号。 \n\n我们不能这样写：\n```js\nlet usersMapped = users.map(user => *!*{*/!*\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n});\n```\n\n我们记得，有两种箭头函数的写法：直接返回值 `value => expr` 和带主体的 `value => {...}`。\n\nJavaScript 在这里会把 `{` 视为函数体的开始，而不是对象的开始。解决方法是将它们包装在普通括号 `()` 中：\n\n```js\nlet usersMapped = users.map(user => *!*({*/!*\n  fullName: `${user.name} ${user.surname}`,\n  id: user.id\n}));\n```\n\n这样就可以了。",
        "parent": "array-methods",
        "version": 1
      }
    },
    "sort-objects": {
      "type": "Task",
      "value": {
        "title": "按年龄对用户排序",
        "slug": "sort-objects",
        "githubPath": "/1-js/05-data-types/05-array-methods/8-sort-objects",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写函数 `sortByAge(users)` 获得对象数组的 `age` 属性，并根据 `age` 对这些对象数组进行排序。\n\n例如：\n\n```js no-beautify\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet arr = [ pete, john, mary ];\n\nsortByAge(arr);\n\n// now: [john, mary, pete]\nalert(arr[0].name); // John\nalert(arr[1].name); // Mary\nalert(arr[2].name); // Pete\n```",
        "solution": "```js run no-beautify\nfunction sortByAge(arr) {\n  arr.sort((a, b) => a.age - b.age);\n}\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet arr = [ pete, john, mary ];\n\nsortByAge(arr);\n\n// 排序后的数组为：[john, mary, pete]\nalert(arr[0].name); // John\nalert(arr[1].name); // Mary\nalert(arr[2].name); // Pete\n```\n\n译注：解决方案的代码还可以更短一些\n\n```js\nfunction sortByAge(arr) {\n  arr.sort((a, b) => a.age - b.age);\n}\n```\n\n因为 `sort()` 方法的语法为 `arr.sort([compareFunction])`，如果没有指明 `compareFunction`，那么元素会被按照转换为的字符串的诸个字符的 Unicode 编码进行排序，如果指明了 `compareFunction`，那么数组会按照调用该函数的返回值排序。即 `a` 和 `b` 是两个将要被比较的元素：\n\n- 如果 `compareFunction(a, b)` 小于 `0`，那么 `a` 会被排列到 `b` 之前；\n- 如果 `compareFunction(a, b)` 等于 `0`，那么 `a` 和 `b` 的相对位置不变。备注：ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；\n- 如果 `compareFunction(a, b)` 大于 `0`，那么 `b` 会被排列到 `a` 之前。\n\n因此，升序排列的函数可以简写为：`(a, b) => a.age - b.age`。",
        "parent": "array-methods",
        "version": 1
      }
    },
    "shuffle": {
      "type": "Task",
      "value": {
        "title": "随机排列数组",
        "slug": "shuffle",
        "githubPath": "/1-js/05-data-types/05-array-methods/9-shuffle",
        "weight": 9,
        "libs": [],
        "importance": 3,
        "content": "\n\n编写函数 `shuffle(array)` 来随机排列数组的元素。\n\n多次运行 `shuffle` 可能导致元素顺序的不同。例如：\n\n```js\nlet arr = [1, 2, 3];\n\nshuffle(arr);\n// arr = [3, 2, 1]\n\nshuffle(arr);\n// arr = [2, 1, 3]\n\nshuffle(arr);\n// arr = [3, 1, 2]\n// ...\n```\n\n所有元素顺序应该具有相等的概率。例如，可以将 `[1,2,3]` 重新排序为 `[1,2,3]` 或 `[1,3,2]` 或 `[3,1,2]` 等，每种情况的概率相等。",
        "solution": "简单的解决方案可以是：\n\n```js run\n*!*\nfunction shuffle(array) {\n  array.sort(() => Math.random() - 0.5);\n}\n*/!*\n\nlet arr = [1, 2, 3];\nshuffle(arr);\nalert(arr);\n```\n\n这样是可以的，因为 `Math.random() - 0.5` 是一个可能是正数或负数的随机数，因此排序函数会随机地对数组中的元素进行重新排序。\n\n但是，由于排序函数并非旨在以这种方式使用，因此并非所有的排列都具有相同的概率。\n\n例如，请考虑下面的代码。它运行 100 万次 `shuffle` 并计算所有可能结果的出现次数：\n\n```js run\nfunction shuffle(array) {\n  array.sort(() => Math.random() - 0.5);\n}\n\n// 所有可能排列的出现次数\nlet count = {\n  '123': 0,\n  '132': 0,\n  '213': 0,\n  '231': 0,\n  '321': 0,\n  '312': 0\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  let array = [1, 2, 3];\n  shuffle(array);\n  count[array.join('')]++;\n}\n\n// 显示所有可能排列的出现次数\nfor (let key in count) {\n  alert(`${key}: ${count[key]}`);\n}\n```\n\n示例结果（取决于 Javascript 引擎）：\n\n```js\n123: 250706\n132: 124425\n213: 249618\n231: 124880\n312: 125148\n321: 125223\n```\n\n我们可以清楚地看到这种倾斜：`123` 和 `213` 的出现频率比其他情况高得多。\n\n使用不同的 JavaScript 引擎运行这个示例代码得到的结果可能会有所不同，但是我们已经可以看到这种方法是不可靠的。\n\n为什么它不起作用？一般来说，`sort` 是一个“黑匣子”：我们将一个数组和一个比较函数放入其中，并期望其对数组进行排序。但是由于比较的完全随机性，这个黑匣子疯了，它发疯地确切程度取决于引擎中的具体实现方法。\n\n还有其他很好的方法可以完成这项任务。例如，有一个很棒的算法叫作 [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)。其思路是：逆向遍历数组，并将每个元素与其前面的随机的一个元素互换位置：\n\n```js\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1)); // 从 0 到 i 的随机索引\n\n    // 交换元素 array[i] 和 array[j]\n    // 我们使用“解构分配（destructuring assignment）”语法来实现它\n    // 你将在后面的章节中找到有关该语法的更多详细信息\n    // 可以写成：\n    // let t = array[i]; array[i] = array[j]; array[j] = t\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n```\n\n让我们以相同的方式测试一下：\n\n```js run\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n\n// 所有可能排列的出现次数\nlet count = {\n  '123': 0,\n  '132': 0,\n  '213': 0,\n  '231': 0,\n  '321': 0,\n  '312': 0\n};\n\nfor (let i = 0; i < 1000000; i++) {\n  let array = [1, 2, 3];\n  shuffle(array);\n  count[array.join('')]++;\n}\n\n// 显示所有可能排列的出现次数\nfor (let key in count) {\n  alert(`${key}: ${count[key]}`);\n}\n```\n\n示例输出：\n\n```js\n123: 166693\n132: 166647\n213: 166628\n231: 167517\n312: 166199\n321: 166316\n```\n\n现在看起来不错：所有排列都以相同的概率出现。\n\n另外，在性能方面，Fisher — Yates 算法要好得多，没有“排序”开销。",
        "parent": "array-methods",
        "version": 1
      }
    },
    "iterable": {
      "type": "Article",
      "value": {
        "title": "Iterable object（可迭代对象）",
        "slug": "iterable",
        "githubPath": "/1-js/05-data-types/06-iterable",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n**可迭代（Iterable）** 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 `for..of` 循环中使用的对象。\n\n数组是可迭代的。但不仅仅是数组。很多其他内建对象也都是可迭代的。例如字符串也是可迭代的。\n\n如果从技术上讲，对象不是数组，而是表示某物的集合（列表，集合），`for..of` 是一个能够遍历它的很好的语法，因此，让我们来看看如何使其发挥作用。\n\n\n## Symbol.iterator\n\n通过自己创建一个对象，我们就可以轻松地掌握可迭代的概念。\n\n例如，我们有一个对象，它并不是数组，但是看上去很适合使用 `for..of` 循环。\n\n比如一个 `range` 对象，它代表了一个数字区间：\n\n```js\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// 我们希望 for..of 这样运行：\n// for(let num of range) ... num=1,2,3,4,5\n```\n\n为了让 `range` 对象可迭代（也就让 `for..of` 可以运行）我们需要为对象添加一个名为 `Symbol.iterator` 的方法（一个专门用于使对象可迭代的内建 symbol）。\n\n1. 当 `for..of` 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 **迭代器（iterator）** —— 一个有 `next` 方法的对象。\n2. 从此开始，`for..of` **仅适用于这个被返回的对象**。\n3. 当 `for..of` 循环希望取得下一个数值，它就调用这个对象的 `next()` 方法。\n4. `next()` 方法返回的结果的格式必须是 `{done: Boolean, value: any}`，当 `done=true` 时，表示循环结束，否则 `value` 是下一个值。\n\n这是带有注释的 `range` 的完整实现：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// 1. for..of 调用首先会调用这个：\nrange[Symbol.iterator] = function() {\n\n  // ……它返回迭代器对象（iterator object）：\n  // 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值\n  return {\n    current: this.from,\n    last: this.to,\n\n    // 3. next() 在 for..of 的每一轮循环迭代中被调用\n    next() {\n      // 4. 它将会返回 {done:.., value :...} 格式的对象\n      if (this.current <= this.last) {\n        return { done: false, value: this.current++ };\n      } else {\n        return { done: true };\n      }\n    }\n  };\n};\n\n// 现在它可以运行了！\nfor (let num of range) {\n  alert(num); // 1, 然后是 2, 3, 4, 5\n}\n```\n\n请注意可迭代对象的核心功能：关注点分离。\n\n- `range` 自身没有 `next()` 方法。\n- 相反，是通过调用 `range[Symbol.iterator]()` 创建了另一个对象，即所谓的“迭代器”对象，并且它的 `next` 会为迭代生成值。\n\n因此，迭代器对象和与其进行迭代的对象是分开的。\n\n从技术上说，我们可以将它们合并，并使用 `range` 自身作为迭代器来简化代码。\n\n就像这样：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.iterator]() {\n    this.current = this.from;\n    return this;\n  },\n\n  next() {\n    if (this.current <= this.to) {\n      return { done: false, value: this.current++ };\n    } else {\n      return { done: true };\n    }\n  }\n};\n\nfor (let num of range) {\n  alert(num); // 1, 然后是 2, 3, 4, 5\n}\n```\n\n现在 `range[Symbol.iterator]()` 返回的是 `range` 对象自身：它包括了必需的 `next()` 方法，并通过 `this.current` 记忆了当前的迭代进程。这样更短，对吗？是的。有时这样也可以。\n\n但缺点是，现在不可能同时在对象上运行两个 `for..of` 循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 `for..of` 是很罕见的，即使在异步情况下。\n\n```smart header=\"无穷迭代器（iterator）\"\n无穷迭代器也是可能的。例如，将 `range` 设置为 `range.to = Infinity`，这时 `range` 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。\n\n`next` 没有什么限制，它可以返回越来越多的值，这是正常的。\n\n当然，迭代这种对象的 `for..of` 循环将不会停止。但是我们可以通过使用 `break` 来停止它。\n```\n\n\n## 字符串是可迭代的\n\n数组和字符串是使用最广泛的内建可迭代对象。\n\n对于一个字符串，`for..of` 遍历它的每个字符：\n\n```js run\nfor (let char of \"test\") {\n  // 触发 4 次，每个字符一次\n  alert( char ); // t, then e, then s, then t\n}\n```\n\n对于代理对（surrogate pairs），它也能正常工作！（译注：这里的代理对也就指的是 UTF-16 的扩展字符）\n\n```js run\nlet str = '𝒳😂';\nfor (let char of str) {\n    alert( char ); // 𝒳，然后是 😂\n}\n```\n\n## 显式调用迭代器\n\n为了更深层地了解底层知识，让我们来看看如何显式地使用迭代器。\n\n我们将会采用与 `for..of` 完全相同的方式遍历字符串，但使用的是直接调用。这段代码创建了一个字符串迭代器，并“手动”从中获取值。\n\n```js run\nlet str = \"Hello\";\n\n// 和 for..of 做相同的事\n// for (let char of str) alert(char);\n\n*!*\nlet iterator = str[Symbol.iterator]();\n*/!*\n\nwhile (true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // 一个接一个地输出字符\n}\n```\n\n很少需要我们这样做，但是比 `for..of` 给了我们更多的控制权。例如，我们可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。\n\n## 可迭代（iterable）和类数组（array-like） [#array-like]\n\n这两个官方术语看起来差不多，但其实大不相同。请确保你能够充分理解它们的含义，以免造成混淆。\n\n- **Iterable** 如上所述，是实现了 `Symbol.iterator` 方法的对象。\n- **Array-like** 是有索引和 `length` 属性的对象，所以它们看起来很像数组。\n\n当我们将 JavaScript 用于编写在浏览器或任何其他环境中的实际任务时，我们可能会遇到可迭代对象或类数组对象，或两者兼有。\n\n例如，字符串即是可迭代的（`for..of` 对它们有效），又是类数组的（它们有数值索引和 `length` 属性）。\n\n但是一个可迭代对象也许不是类数组对象。反之亦然，类数组对象可能不可迭代。\n\n例如，上面例子中的 `range` 是可迭代的，但并非类数组对象，因为它没有索引属性，也没有 `length` 属性。\n\n下面这个对象则是类数组的，但是不可迭代：\n\n```js run\nlet arrayLike = { // 有索引和 length 属性 => 类数组对象\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\n*!*\n// Error (no Symbol.iterator)\nfor (let item of arrayLike) {}\n*/!*\n```\n\n可迭代对象和类数组对象通常都 **不是数组**，它们没有 `push` 和 `pop` 等方法。如果我们有一个这样的对象，并想像数组那样操作它，那就非常不方便。例如，我们想使用数组方法操作 `range`，应该如何实现呢？\n\n## Array.from\n\n有一个全局方法 [Array.from](mdn:js/Array/from) 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。然后我们就可以对其调用数组方法了。\n\n例如：\n\n```js run\nlet arrayLike = {\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\n*!*\nlet arr = Array.from(arrayLike); // (*)\n*/!*\nalert(arr.pop()); // World（pop 方法有效）\n```\n\n在 `(*)` 行的 `Array.from` 方法接受对象，检查它是一个可迭代对象或类数组对象，然后创建一个新数组，并将该对象的所有元素复制到这个新数组。\n\n如果是可迭代对象，也是同样：\n\n```js\n// 假设 range 来自上文的例子中\nlet arr = Array.from(range);\nalert(arr); // 1,2,3,4,5 （数组的 toString 转化方法生效）\n```\n\n`Array.from` 的完整语法允许我们提供一个可选的“映射（mapping）”函数：\n```js\nArray.from(obj[, mapFn, thisArg])\n```\n\n可选的第二个参数 `mapFn` 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 `thisArg` 允许我们为该函数设置 `this`。\n\n例如：\n\n```js\n// 假设 range 来自上文例子中\n\n// 求每个数的平方\nlet arr = Array.from(range, num => num * num);\n\nalert(arr); // 1,4,9,16,25\n```\n\n现在我们用 `Array.from` 将一个字符串转换为单个字符的数组：\n\n```js run\nlet str = '𝒳😂';\n\n// 将 str 拆分为字符数组\nlet chars = Array.from(str);\n\nalert(chars[0]); // 𝒳\nalert(chars[1]); // 😂\nalert(chars.length); // 2\n```\n\n与 `str.split` 方法不同，它依赖于字符串的可迭代特性。因此，就像 `for..of` 一样，可以正确地处理代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）\n\n技术上来讲，它和下面这段代码做的是相同的事：\n\n```js run\nlet str = '𝒳😂';\n\nlet chars = []; // Array.from 内部执行相同的循环\nfor (let char of str) {\n  chars.push(char);\n}\n\nalert(chars);\n```\n\n……但 `Array.from` 精简很多。\n\n我们甚至可以基于 `Array.from` 创建代理感知（surrogate-aware）的`slice` 方法（译注：也就是能够处理 UTF-16 扩展字符的 `slice` 方法）：\n\n```js run\nfunction slice(str, start, end) {\n  return Array.from(str).slice(start, end).join('');\n}\n\nlet str = '𝒳😂𩷶';\n\nalert( slice(str, 1, 3) ); // 😂𩷶\n\n// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）\nalert( str.slice(1, 3) ); // 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）\n```\n\n\n## 总结\n\n可以应用 `for..of` 的对象被称为 **可迭代的**。\n\n- 技术上来说，可迭代对象必须实现 `Symbol.iterator` 方法。\n    - `obj[Symbol.iterator]()` 的结果被称为 **迭代器（iterator）**。由它处理进一步的迭代过程。\n    - 一个迭代器必须有 `next()` 方法，它返回一个 `{done: Boolean, value: any}` 对象，这里 `done:true` 表明迭代结束，否则 `value` 就是下一个值。\n- `Symbol.iterator` 方法会被 `for..of` 自动调用，但我们也可以直接调用它。\n- 内建的可迭代对象例如字符串和数组，都实现了 `Symbol.iterator`。\n- 字符串迭代器能够识别代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）\n\n\n有索引属性和 `length` 属性的对象被称为 **类数组对象**。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。\n\n如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。\n\n`Array.from(obj[, mapFn, thisArg])` 将可迭代对象或类数组对象 `obj` 转化为真正的数组 `Array`，然后我们就可以对它应用数组的方法。可选参数 `mapFn` 和 `thisArg` 允许我们将函数应用到每个元素。",
        "libs": [],
        "children": [],
        "parent": "data-types",
        "updatedAt": 1644739900
      }
    },
    "map-set": {
      "type": "Article",
      "value": {
        "title": "Map and Set（映射和集合）",
        "slug": "map-set",
        "githubPath": "/1-js/05-data-types/07-map-set",
        "isFolder": false,
        "weight": 7,
        "content": "\n\n学到现在，我们已经了解了以下复杂的数据结构：\n\n- 对象，存储带有键的数据的集合。\n- 数组，存储有序集合。\n\n但这还不足以应对现实情况。这就是为什么存在 `Map` 和 `Set`。\n\n## Map\n\n[Map](mdn:js/Map) 是一个带键的数据项的集合，就像一个 `Object` 一样。 但是它们最大的差别是 `Map` 允许任何类型的键（key）。\n\n它的方法和属性如下：\n\n- `new Map()` —— 创建 map。\n- `map.set(key, value)` —— 根据键存储值。\n- `map.get(key)` —— 根据键来返回值，如果 `map` 中不存在对应的 `key`，则返回 `undefined`。\n- `map.has(key)` —— 如果 `key` 存在则返回 `true`，否则返回 `false`。\n- `map.delete(key)` —— 删除指定键的值。\n- `map.clear()` —— 清空 map。\n- `map.size` —— 返回当前元素个数。\n\n举个例子：\n\n```js run\nlet map = new Map();\n\nmap.set('1', 'str1');   // 字符串键\nmap.set(1, 'num1');     // 数字键\nmap.set(true, 'bool1'); // 布尔值键\n\n// 还记得普通的 Object 吗? 它会将键转化为字符串\n// Map 则会保留键的类型，所以下面这两个结果不同：\nalert( map.get(1)   ); // 'num1'\nalert( map.get('1') ); // 'str1'\n\nalert( map.size ); // 3\n```\n\n如我们所见，与对象不同，键不会被转换成字符串。键可以是任何类型。\n\n```smart header=\"`map[key]` 不是使用 `Map` 的正确方式\"\n虽然 `map[key]` 也有效，例如我们可以设置 `map[key] = 2`，这样会将 `map` 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（仅支持 string/symbol 键等）。\n\n所以我们应该使用 `map` 方法：`set` 和 `get` 等。\n```\n\n**Map 还可以使用对象作为键。**\n\n例如：\n\n```js run\nlet john = { name: \"John\" };\n\n// 存储每个用户的来访次数\nlet visitsCountMap = new Map();\n\n// john 是 Map 中的键\nvisitsCountMap.set(john, 123);\n\nalert( visitsCountMap.get(john) ); // 123\n```\n\n使用对象作为键是 `Map` 最值得注意和重要的功能之一。在 `Object` 中，我们则无法使用对象作为键。在 `Object` 中使用字符串作为键是可以的，但我们无法使用另一个 `Object` 作为 `Object` 中的键。\n  \n我们来尝试一下：\n\n```js run\nlet john = { name: \"John\" };\nlet ben = { name: \"Ben\" };\n\nlet visitsCountObj = {}; // 尝试使用对象\n\nvisitsCountObj[ben] = 234; // 尝试将对象 ben 用作键\nvisitsCountObj[john] = 123; // 尝试将对象 john 用作键，但我们会发现使用对象 ben 作为键存下的值会被替换掉\n\n*!*\n// 变成这样了！\nalert( visitsCountObj[\"[object Object]\"] ); // 123\n*/!*\n```\n\n因为 `visitsCountObj` 是一个对象，它会将所有 `Object` 键例如上面的 `john` 和 `ben` 转换为字符串 `\"[object Object]\"`。这显然不是我们想要的结果。\n\n```smart header=\"`Map` 是怎么比较键的？\"\n`Map` 使用 [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero) 算法来比较键是否相等。它和严格等于 `===` 差不多，但区别是 `NaN` 被看成是等于 `NaN`。所以 `NaN` 也可以被用作键。\n\n这个算法不能被改变或者自定义。\n```\n\n````smart header=\"链式调用\"\n每一次 `map.set` 调用都会返回 map 本身，所以我们可以进行“链式”调用：\n\n```js\nmap.set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');\n```\n````\n\n\n## Map 迭代\n\n如果要在 `map` 里使用循环，可以使用以下三个方法：\n\n- `map.keys()` —— 遍历并返回一个包含所有键的可迭代对象，\n- `map.values()` —— 遍历并返回一个包含所有值的可迭代对象，\n- `map.entries()` —— 遍历并返回一个包含所有实体 `[key, value]` 的可迭代对象，`for..of` 在默认情况下使用的就是这个。\n\n例如：\n\n```js run\nlet recipeMap = new Map([\n  ['cucumber', 500],\n  ['tomatoes', 350],\n  ['onion',    50]\n]);\n\n// 遍历所有的键（vegetables）\nfor (let vegetable of recipeMap.keys()) {\n  alert(vegetable); // cucumber, tomatoes, onion\n}\n\n// 遍历所有的值（amounts）\nfor (let amount of recipeMap.values()) {\n  alert(amount); // 500, 350, 50\n}\n\n// 遍历所有的实体 [key, value]\nfor (let entry of recipeMap) { // 与 recipeMap.entries() 相同\n  alert(entry); // cucumber,500 (and so on)\n}\n```\n\n```smart header=\"使用插入顺序\"\n迭代的顺序与插入值的顺序相同。与普通的 `Object` 不同，`Map` 保留了此顺序。\n```\n\n除此之外，`Map` 有内建的 `forEach` 方法，与 `Array` 类似：\n\n```js\n// 对每个键值对 (key, value) 运行 forEach 函数\nrecipeMap.forEach( (value, key, map) => {\n  alert(`${key}: ${value}`); // cucumber: 500 etc\n});\n```\n\n## Object.entries：从对象创建 Map\n\n当创建一个 `Map` 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化，如下所示：\n\n```js run\n// 键值对 [key, value] 数组\nlet map = new Map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);\n\nalert( map.get('1') ); // str1\n```\n\n如果我们想从一个已有的普通对象（plain object）来创建一个 `Map`，那么我们可以使用内建方法 [Object.entries(obj)](mdn:js/Object/entries)，该方法返回对象的键/值对数组，该数组格式完全按照 `Map` 所需的格式。\n\n所以可以像下面这样从一个对象创建一个 Map：\n\n```js run\nlet obj = {\n  name: \"John\",\n  age: 30\n};\n\n*!*\nlet map = new Map(Object.entries(obj));\n*/!*\n\nalert( map.get('name') ); // John\n```\n\n这里，`Object.entries` 返回键/值对数组：`[ [\"name\",\"John\"], [\"age\", 30] ]`。这就是 `Map` 所需要的格式。\n\n\n## Object.fromEntries：从 Map 创建对象\n\n我们刚刚已经学习了如何使用 `Object.entries(obj)` 从普通对象（plain object）创建 `Map`。\n\n`Object.fromEntries` 方法的作用是相反的：给定一个具有 `[key, value]` 键值对的数组，它会根据给定数组创建一个对象：\n\n```js run\nlet prices = Object.fromEntries([\n  ['banana', 1],\n  ['orange', 2],\n  ['meat', 4]\n]);\n\n// 现在 prices = { banana: 1, orange: 2, meat: 4 }\n\nalert(prices.orange); // 2\n```\n\n我们可以使用 `Object.fromEntries` 从 `Map` 得到一个普通对象（plain object）。\n\n例如，我们在 `Map` 中存储了一些数据，但是我们需要把这些数据传给需要普通对象（plain object）的第三方代码。\n\n我们来开始：\n\n```js run\nlet map = new Map();\nmap.set('banana', 1);\nmap.set('orange', 2);\nmap.set('meat', 4);\n\n*!*\nlet obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)\n*/!*\n\n// 完成了！\n// obj = { banana: 1, orange: 2, meat: 4 }\n\nalert(obj.orange); // 2\n```\n\n调用 `map.entries()` 将返回一个可迭代的键/值对，这刚好是 `Object.fromEntries` 所需要的格式。\n\n我们可以把带 `(*)` 这一行写得更短：\n```js\nlet obj = Object.fromEntries(map); // 省掉 .entries()\n```\n\n上面的代码作用也是一样的，因为 `Object.fromEntries` 期望得到一个可迭代对象作为参数，而不一定是数组。并且 `map` 的标准迭代会返回跟 `map.entries()` 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 `map` 相同。\n\n## Set\n\n`Set` 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。\n\n它的主要方法如下：\n\n- `new Set(iterable)` —— 创建一个 `set`，如果提供了一个 `iterable` 对象（通常是数组），将会从数组里面复制值到 `set` 中。\n- `set.add(value)` —— 添加一个值，返回 set 本身\n- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。\n- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。\n- `set.clear()` —— 清空 set。\n- `set.size` —— 返回元素个数。\n\n它的主要特点是，重复使用同一个值调用 `set.add(value)` 并不会发生什么改变。这就是 `Set` 里面的每一个值只出现一次的原因。\n\n例如，我们有客人来访，我们想记住他们每一个人。但是已经来访过的客人再次来访，不应造成重复记录。每个访客必须只被“计数”一次。\n\n`Set` 可以帮助我们解决这个问题：\n\n```js run\nlet set = new Set();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\n// visits，一些访客来访好几次\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\n// set 只保留不重复的值\nalert( set.size ); // 3\n\nfor (let user of set) {\n  alert(user.name); // John（然后 Pete 和 Mary）\n}\n```\n\n`Set` 的替代方法可以是一个用户数组，用 [arr.find](mdn:js/Array/find) 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。`Set` 内部对唯一性检查进行了更好的优化。\n\n##  Set 迭代（iteration）\n\n我们可以使用 `for..of` 或 `forEach` 来遍历 Set：\n\n```js run\nlet set = new Set([\"oranges\", \"apples\", \"bananas\"]);\n\nfor (let value of set) alert(value);\n\n// 与 forEach 相同：\nset.forEach((value, valueAgain, set) => {\n  alert(value);\n});\n```\n\n注意一件有趣的事儿。`forEach` 的回调函数有三个参数：一个 `value`，然后是 **同一个值** `valueAgain`，最后是目标对象。没错，同一个值在参数里出现了两次。\n\n`forEach` 的回调函数有三个参数，是为了与 `Map` 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 `Set` 代替 `Map` 很有帮助，反之亦然。\n\n`Map` 中用于迭代的方法在 `Set` 中也同样支持：\n\n- `set.keys()` —— 遍历并返回一个包含所有值的可迭代对象，\n- `set.values()` —— 与 `set.keys()` 作用相同，这是为了兼容 `Map`，\n- `set.entries()` —— 遍历并返回一个包含所有的实体 `[value, value]` 的可迭代对象，它的存在也是为了兼容 `Map`。\n\n## 总结\n\n`Map` —— 是一个带键的数据项的集合。\n\n方法和属性如下：\n\n- `new Map([iterable])` —— 创建 map，可选择带有 `[key,value]` 对的 `iterable`（例如数组）来进行初始化。\n- `map.set(key, value)` —— 根据键存储值，返回 map 自身。\n- `map.get(key)` —— 根据键来返回值，如果 `map` 中不存在对应的 `key`，则返回 `undefined`。\n- `map.has(key)` —— 如果 `key` 存在则返回 `true`，否则返回 `false`。\n- `map.delete(key)` —— 删除指定键对应的值，如果在调用时 `key` 存在，则返回 `true`，否则返回 `false`。\n- `map.clear()` —— 清空 map 。\n- `map.size` —— 返回当前元素个数。\n\n与普通对象 `Object` 的不同点：\n\n- 任何键、对象都可以作为键。\n- 有其他的便捷方法，如 `size` 属性。\n\n`Set` —— 是一组唯一值的集合。\n\n方法和属性：\n\n- `new Set([iterable])` —— 创建 set，可选择带有 `iterable`（例如数组）来进行初始化。\n- `set.add(value)` —— 添加一个值（如果 `value` 存在则不做任何修改），返回 set 本身。\n- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。\n- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。\n- `set.clear()` —— 清空 set。\n- `set.size` —— 元素的个数。\n\n在 `Map` 和 `Set` 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。",
        "libs": [],
        "children": [
          "array-unique-map",
          "filter-anagrams",
          "iterable-keys"
        ],
        "parent": "data-types",
        "updatedAt": 1652713808
      }
    },
    "array-unique-map": {
      "type": "Task",
      "value": {
        "title": "过滤数组中的唯一元素",
        "slug": "array-unique-map",
        "githubPath": "/1-js/05-data-types/07-map-set/01-array-unique-map",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n定义 `arr` 为一个数组。\n\n创建一个函数 `unique(arr)`，该函数返回一个由 `arr` 中所有唯一元素所组成的数组。\n\n例如：\n\n```js\nfunction unique(arr) {\n  /* 你的代码 */\n}\n\nlet values = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(values) ); // Hare, Krishna, :-O\n```\n\nP.S. 这里用到了 string 类型，但其实可以是任何类型的值。\n\nP.S. 使用 `Set` 来存储唯一值。",
        "solution": "",
        "solutionJs": "function unique(arr) {\n  return Array.from(new Set(arr));\n}\n",
        "parent": "map-set",
        "version": 1
      }
    },
    "filter-anagrams": {
      "type": "Task",
      "value": {
        "title": "过滤字谜（anagrams）",
        "slug": "filter-anagrams",
        "githubPath": "/1-js/05-data-types/07-map-set/02-filter-anagrams",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n[Anagrams](https://en.wikipedia.org/wiki/Anagram) 是具有相同数量相同字母但是顺序不同的单词。\n\n例如：\n\n```\nnap - pan\near - are - era\ncheaters - hectares - teachers\n```\n\n写一个函数 `aclean(arr)`，它返回被清除了字谜（anagrams）的数组。\n\n例如：\n\n```js\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) ); // \"nap,teachers,ear\" or \"PAN,cheaters,era\"\n```\n\n对于所有的字谜（anagram）组，都应该保留其中一个词，但保留的具体是哪一个并不重要。",
        "solution": "为了找到所有字谜（anagram），让我们把每个单词打散为字母并进行排序。当字母被排序后，所有的字谜就都一样了。\n\n例如：\n\n```\nnap, pan -> anp\near, era, are -> aer\ncheaters, hectares, teachers -> aceehrst\n...\n```\n\n我们将使用进行字母排序后的单词的变体（variant）作为 map 的键，每个键仅对应存储一个值：\n\n```js run\nfunction aclean(arr) {\n  let map = new Map();\n\n  for (let word of arr) {\n    // 将单词 split 成字母，对字母进行排序，之后再 join 回来\n*!*\n    let sorted = word.toLowerCase().split('').sort().join(''); // (*)\n*/!*\n    map.set(sorted, word);\n  }\n\n  return Array.from(map.values());\n}\n\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) );\n```\n\n字母排序在 `(*)` 行以链式调用的方式完成。\n\n为了方便，我们把它分解为多行：\n\n```js\nlet sorted = word // PAN\n  .toLowerCase() // pan\n  .split('') // ['p','a','n']\n  .sort() // ['a','n','p']\n  .join(''); // anp\n```\n\n两个不同的单词 `'PAN'` 和 `'nap'` 得到了同样的字母排序形式 `'anp'`。\n\n下一行是将单词放入 map：\n\n```js\nmap.set(sorted, word);\n```\n\n如果我们再次遇到相同字母排序形式的单词，那么它将会覆盖 map 中有相同键的前一个值。因此，每个字母形式（译注：排序后的）最多只有一个单词。（译注：并且是每个字母形式中最靠后的那个值）\n\n最后，`Array.from(map.values())` 将 map 的值迭代（我们不需要结果的键）为数组形式，并返回这个数组。\n\n在这里，我们也可以使用普通对象（plain object）而不用 `Map`，因为键就是字符串。\n\n下面是解决方案：\n\n```js run demo\nfunction aclean(arr) {\n  let obj = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    let sorted = arr[i].toLowerCase().split(\"\").sort().join(\"\");\n    obj[sorted] = arr[i];\n  }\n\n  return Object.values(obj);\n}\n\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) );\n```",
        "solutionJs": "\nfunction aclean(arr) {\n  let map = new Map();\n\n  for(let word of arr) {\n    let sorted = word.toLowerCase().split(\"\").sort().join(\"\");\n    map.set(sorted, word);\n  }\n\n  return Array.from(map.values());\n}",
        "parent": "map-set",
        "version": 1
      }
    },
    "iterable-keys": {
      "type": "Task",
      "value": {
        "title": "迭代键",
        "slug": "iterable-keys",
        "githubPath": "/1-js/05-data-types/07-map-set/03-iterable-keys",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们期望使用 `map.keys()` 得到一个数组，然后使用例如 `.push` 等特定的方法对其进行处理。\n\n但是运行不了：\n\n```js run\nlet map = new Map();\n\nmap.set(\"name\", \"John\");\n\nlet keys = map.keys();\n\n*!*\n// Error: keys.push is not a function\nkeys.push(\"more\");\n*/!*\n```\n\n为什么？我们应该如何修改代码让 `keys.push` 工作？",
        "solution": "这是因为 `map.keys()` 返回的是可迭代对象而非数组。\n\n我们可以使用方法 `Array.from` 来将它转换为数组：\n\n\n```js run\nlet map = new Map();\n\nmap.set(\"name\", \"John\");\n\n*!*\nlet keys = Array.from(map.keys());\n*/!*\n\nkeys.push(\"more\");\n\nalert(keys); // name, more\n```",
        "parent": "map-set",
        "version": 1
      }
    },
    "weakmap-weakset": {
      "type": "Article",
      "value": {
        "title": "WeakMap and WeakSet（弱映射和弱集合）",
        "slug": "weakmap-weakset",
        "githubPath": "/1-js/05-data-types/08-weakmap-weakset",
        "isFolder": false,
        "weight": 8,
        "content": "\n\n我们从前面的 <info:garbage-collection> 章节中知道，JavaScript 引擎在值“可达”和可能被使用时会将其保持在内存中。\n\n例如：\n```js\nlet john = { name: \"John\" };\n\n// 该对象能被访问，john 是它的引用\n\n// 覆盖引用\njohn = null;\n\n*!*\n// 该对象将会被从内存中清除\n*/!*\n```\n\n通常，当对象、数组之类的数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都被认为是可达的。\n\n例如，如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。\n\n就像这样:\n\n```js\nlet john = { name: \"John\" };\n\nlet array = [ john ];\n\njohn = null; // 覆盖引用\n\n*!*\n// 前面由 john 所引用的那个对象被存储在了 array 中\n// 所以它不会被垃圾回收机制回收\n// 我们可以通过 array[0] 获取到它\n*/!*\n```\n\n类似的，如果我们使用对象作为常规 `Map` 的键，那么当 `Map` 存在时，该对象也将存在。它会占用内存，并且不会被（垃圾回收机制）回收。\n\n例如：\n\n```js\nlet john = { name: \"John\" };\n\nlet map = new Map();\nmap.set(john, \"...\");\n\njohn = null; // 覆盖引用\n\n*!*\n// john 被存储在了 map 中，\n// 我们可以使用 map.keys() 来获取它\n*/!*\n```\n\n`WeakMap` 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。\n\n让我们通过例子来看看这指的到底是什么。\n\n## WeakMap\n\n`WeakMap` 和 `Map` 的第一个不同点就是，`WeakMap` 的键必须是对象，不能是原始值：\n\n```js run\nlet weakMap = new WeakMap();\n\nlet obj = {};\n\nweakMap.set(obj, \"ok\"); // 正常工作（以对象作为键）\n\n*!*\n// 不能使用字符串作为键\nweakMap.set(\"test\", \"Whoops\"); // Error，因为 \"test\" 不是一个对象\n*/!*\n```\n\n现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。\n\n```js\nlet john = { name: \"John\" };\n\nlet weakMap = new WeakMap();\nweakMap.set(john, \"...\");\n\njohn = null; // 覆盖引用\n\n// john 被从内存中删除了！\n```\n\n与上面常规的 `Map` 的例子相比，现在如果 `john` 仅仅是作为 `WeakMap` 的键而存在 —— 它将会被从 map（和内存）中自动删除。\n\n`WeakMap` 不支持迭代以及 `keys()`，`values()` 和 `entries()` 方法。所以没有办法获取 `WeakMap` 的所有键或值。\n\n`WeakMap` 只有以下的方法：\n\n- `weakMap.get(key)`\n- `weakMap.set(key, value)`\n- `weakMap.delete(key)`\n- `weakMap.has(key)`\n\n为什么会有这种限制呢？这是技术的原因。如果一个对象丢失了其它所有引用（就像上面示例中的 `john`），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 **何时会被回收**。\n\n这些都是由 JavaScript 引擎决定的。JavaScript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 JavaScript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲，`WeakMap` 的当前元素的数量是未知的。JavaScript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 `WeakMap` 的所有键/值的方法。\n\n那么，在哪里我们会需要这样的数据结构呢？\n\n## 使用案例：额外的数据\n\n`WeakMap` 的主要应用场景是 **额外数据的存储**。\n\n假如我们正在处理一个“属于”另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡 —— 这时候 `WeakMap` 正是我们所需要的利器。\n\n我们将这些数据放到 `WeakMap` 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。\n\n```js\nweakMap.set(john, \"secret documents\");\n// 如果 john 消失，secret documents 将会被自动清除\n```\n\n让我们来看一个例子。\n\n例如，我们有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时我们就不再需要他的访问次数了。\n\n下面是一个使用 `Map` 的计数函数的例子：\n\n```js\n// 📁 visitsCount.js\nlet visitsCountMap = new Map(); // map: user => visits count\n\n// 递增用户来访次数\nfunction countUser(user) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n```\n\n下面是其他部分的代码，可能是使用它的其它代码：\n\n```js\n// 📁 main.js\nlet john = { name: \"John\" };\n\ncountUser(john); // count his visits\n\n// 不久之后，john 离开了\njohn = null;\n```\n\n现在，`john` 这个对象应该被垃圾回收，但它仍在内存中，因为它是 `visitsCountMap` 中的一个键。\n\n当我们移除用户时，我们需要清理 `visitsCountMap`，否则它将在内存中无限增大。在复杂的架构中，这种清理会成为一项繁重的任务。\n\n我们可以通过使用 `WeakMap` 来避免这样的问题：\n\n```js\n// 📁 visitsCount.js\nlet visitsCountMap = new WeakMap(); // weakmap: user => visits count\n\n// 递增用户来访次数\nfunction countUser(user) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n```\n\n现在我们不需要去清理 `visitsCountMap` 了。当 `john` 对象变成不可达时，即便它是 `WeakMap` 里的一个键，它也会连同它作为 `WeakMap` 里的键所对应的信息一同被从内存中删除。\n\n## 使用案例：缓存\n\n另外一个常见的例子是缓存。我们可以存储（“缓存”）函数的结果，以便将来对同一个对象的调用可以重用这个结果。\n\n为了实现这一点，我们可以使用 `Map`（非最佳方案）：\n\n```js run\n// 📁 cache.js\nlet cache = new Map();\n\n// 计算并记住结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculations of the result for */ obj;\n\n    cache.set(obj, result);\n  }\n\n  return cache.get(obj);\n}\n\n*!*\n// 现在我们在其它文件中使用 process()\n*/!*\n\n// 📁 main.js\nlet obj = {/* 假设我们有个对象 */};\n\nlet result1 = process(obj); // 计算完成\n\n// ……稍后，来自代码的另外一个地方……\nlet result2 = process(obj); // 取自缓存的被记忆的结果\n\n// ……稍后，我们不再需要这个对象时：\nobj = null;\n\nalert(cache.size); // 1（啊！该对象依然在 cache 中，并占据着内存！）\n```\n\n对于多次调用同一个对象，它只需在第一次调用时计算出结果，之后的调用可以直接从 `cache` 中获取。这样做的缺点是，当我们不再需要这个对象的时候需要清理 `cache`。\n\n如果我们用 `WeakMap` 替代 `Map`，便不会存在这个问题。当对象被垃圾回收时，对应缓存的结果也会被自动从内存中清除。\n\n```js run\n// 📁 cache.js\n*!*\nlet cache = new WeakMap();\n*/!*\n\n// 计算并记结果\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculate the result for */ obj;\n\n    cache.set(obj, result);\n  }\n\n  return cache.get(obj);\n}\n\n// 📁 main.js\nlet obj = {/* some object */};\n\nlet result1 = process(obj);\nlet result2 = process(obj);\n\n// ……稍后，我们不再需要这个对象时：\nobj = null;\n\n// 无法获取 cache.size，因为它是一个 WeakMap，\n// 要么是 0，或即将变为 0\n// 当 obj 被垃圾回收，缓存的数据也会被清除\n```\n\n## WeakSet\n\n`WeakSet` 的表现类似：\n\n- 与 `Set` 类似，但是我们只能向 `WeakSet` 添加对象（而不能是原始值）。\n- 对象只有在其它某个（些）地方能被访问的时候，才能留在 `WeakSet` 中。\n- 跟 `Set` 一样，`WeakSet` 支持 `add`，`has` 和 `delete` 方法，但不支持 `size` 和 `keys()`，并且不可迭代。\n\n变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是/否”的事实。`WeakSet` 的元素可能代表着有关该对象的某些信息。\n\n例如，我们可以将用户添加到 `WeakSet` 中，以追踪访问过我们网站的用户：\n\n```js run\nlet visitedSet = new WeakSet();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\nvisitedSet.add(john); // John 访问了我们\nvisitedSet.add(pete); // 然后是 Pete\nvisitedSet.add(john); // John 再次访问\n\n// visitedSet 现在有两个用户了\n\n// 检查 John 是否来访过？\nalert(visitedSet.has(john)); // true\n\n// 检查 Mary 是否来访过？\nalert(visitedSet.has(mary)); // false\n\njohn = null;\n\n// visitedSet 将被自动清理(即自动清除其中已失效的值 john)\n```\n\n`WeakMap` 和 `WeakSet` 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 `WeakMap/WeakSet` 完成其主要工作 —— 为在其它地方存储/管理的对象数据提供“额外”存储。\n\n## 总结\n\n`WeakMap` 是类似于 `Map` 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。\n\n`WeakSet` 是类似于 `Set` 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。\n\n它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。\n\n这是以不支持 `clear`、`size`、`keys`、`values` 等作为代价换来的……\n\n`WeakMap` 和 `WeakSet` 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 `WeakMap` 或 `WeakSet` 的键，那么该对象将被自动清除。",
        "libs": [],
        "children": [
          "recipients-read",
          "recipients-when-read"
        ],
        "parent": "data-types",
        "updatedAt": 1658120677
      }
    },
    "recipients-read": {
      "type": "Task",
      "value": {
        "title": "存储 \"unread\" 标识",
        "slug": "recipients-read",
        "githubPath": "/1-js/05-data-types/08-weakmap-weakset/01-recipients-read",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n这里有一个 messages 数组：\n\n```js\nlet messages = [\n  {text: \"Hello\", from: \"John\"},\n  {text: \"How goes?\", from: \"John\"},\n  {text: \"See you soon\", from: \"Alice\"}\n];\n```\n\n你的代码可以访问它，但是 message 是由其他人的代码管理的。该代码会定期添加新消息，删除旧消息，但是你不知道这些操作确切的发生时间。\n\n现在，你应该使用什么数据结构来保存关于消息“是否已读”的信息？该结构必须很适合对给定的 message 对象给出“它读了吗？”的答案。\n\nP.S. 当一个消息被从 `messages` 中删除后，它应该也从你的数据结构中消失。\n\nP.S. 我们不能修改 message 对象，例如向其添加我们的属性。因为它们是由其他人的代码管理的，我们修改该数据可能会导致不好的后果。",
        "solution": "让我们将已读消息存储在 `WeakSet` 中：\n\n```js run\nlet messages = [\n  {text: \"Hello\", from: \"John\"},\n  {text: \"How goes?\", from: \"John\"},\n  {text: \"See you soon\", from: \"Alice\"}\n];\n\nlet readMessages = new WeakSet();\n\n// 两个消息已读\nreadMessages.add(messages[0]);\nreadMessages.add(messages[1]);\n// readMessages 包含两个元素\n\n// ……让我们再读一遍第一条消息！\nreadMessages.add(messages[0]);\n// readMessages 仍然有两个不重复的元素\n\n// 回答：message[0] 已读？\nalert(\"Read message 0: \" + readMessages.has(messages[0])); // true\n\nmessages.shift();\n// 现在 readMessages 有一个元素（技术上来讲，内存可能稍后才会被清理）\n```\n\n`WeakSet` 允许存储一系列的消息，并且很容易就能检查它是否包含某个消息。\n\n它会自动清理自身。代价是，我们不能对它进行迭代，也不能直接从中获取“所有已读消息”。但是，我们可以通过遍历所有消息，然后找出存在于 set 的那些消息来完成这个功能。\n\n另一种不同的解决方案可以是，在读取消息后向消息添加诸如 `message.isRead=true` 之类的属性。由于 `messages` 对象是由另一个代码管理的，因此通常不建议这样做，但是我们可以使用 symbol 属性来避免冲突。\n\n像这样：\n```js\n// symbol 属性仅对于我们的代码是已知的\nlet isRead = Symbol(\"isRead\");\nmessages[0][isRead] = true;\n```\n\n现在，第三方代码可能看不到我们的额外属性。\n\n尽管 symbol 可以降低出现问题的可能性，但从架构的角度来看，还是使用 `WeakSet` 更好。",
        "parent": "weakmap-weakset",
        "version": 1
      }
    },
    "recipients-when-read": {
      "type": "Task",
      "value": {
        "title": "保存阅读日期",
        "slug": "recipients-when-read",
        "githubPath": "/1-js/05-data-types/08-weakmap-weakset/02-recipients-when-read",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n这儿有一个和 [上一个任务](info:task/recipients-read) 类似的 `messages` 数组。场景也相似。\n\n```js\nlet messages = [\n  {text: \"Hello\", from: \"John\"},\n  {text: \"How goes?\", from: \"John\"},\n  {text: \"See you soon\", from: \"Alice\"}\n];\n```\n\n现在的问题是：你建议采用什么数据结构来保存信息：“消息是什么时候被阅读的？”。\n\n在前一个任务中我们只需要保存“是/否”。现在我们需要保存日期，并且它应该在消息被垃圾回收时也被从内存中清除。\n\nP.S. 日期可以存储为内建的 `Date` 类的对象，稍后我们将进行介绍。",
        "solution": "我们可以使用 `WeakMap` 保存日期：\n\n```js\nlet messages = [\n  {text: \"Hello\", from: \"John\"},\n  {text: \"How goes?\", from: \"John\"},\n  {text: \"See you soon\", from: \"Alice\"}\n];\n\nlet readMap = new WeakMap();\n\nreadMap.set(messages[0], new Date(2017, 1, 1));\n// 我们稍后将学习 Date 对象\n```",
        "parent": "weakmap-weakset",
        "version": 1
      }
    },
    "keys-values-entries": {
      "type": "Article",
      "value": {
        "title": "Object.keys，values，entries",
        "slug": "keys-values-entries",
        "githubPath": "/1-js/05-data-types/09-keys-values-entries",
        "isFolder": false,
        "weight": 9,
        "content": "\n\n对各个数据结构的学习至此告一段落，下面让我们讨论一下如何迭代它们。\n\n在前面的章节中，我们认识了 `map.keys()`，`map.values()` 和 `map.entries()` 方法。\n\n这些方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。\n\n它们支持：\n\n- `Map`\n- `Set`\n- `Array`\n\n普通对象也支持类似的方法，但是语法上有一些不同。\n\n## Object.keys，values，entries\n\n对于普通对象，下列这些方法是可用的：\n\n- [Object.keys(obj)](mdn:js/Object/keys) —— 返回一个包含该对象所有的键的数组。\n- [Object.values(obj)](mdn:js/Object/values) —— 返回一个包含该对象所有的值的数组。\n- [Object.entries(obj)](mdn:js/Object/entries) —— 返回一个包含该对象所有 [key, value] 键值对的数组。\n\n……但是请注意区别（比如说跟 map 的区别）：\n\n|             | Map              | Object       |\n|-------------|------------------|--------------|\n| 调用语法     | `map.keys()`  | `Object.keys(obj)`，而不是 `obj.keys()` |\n| 返回值       | 可迭代对象 | “真正的”数组   \n\n第一个区别是，对于对象我们使用的调用语法是 `Object.keys(obj)`，而不是 `obj.keys()`。\n\n为什么会这样？主要原因是灵活性。请记住，在 JavaScript 中，对象是所有复杂结构的基础。因此，我们可能有一个自己创建的对象，比如 `data`，并实现了它自己的 `data.values()` 方法。同时，我们依然可以对它调用 `Object.values(data)` 方法。\n\n第二个区别是 `Object.*` 方法返回的是“真正的”数组对象，而不只是一个可迭代对象。这主要是历史原因。\n\n举个例子：\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n```\n\n- `Object.keys(user) = [\"name\", \"age\"]`\n- `Object.values(user) = [\"John\", 30]`\n- `Object.entries(user) = [ [\"name\",\"John\"], [\"age\",30] ]`\n\n这里有一个使用 `Object.values` 来遍历属性值的例子：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// 遍历所有的值\nfor (let value of Object.values(user)) {\n  alert(value); // John, then 30\n}\n```\n\n```warn header=\"Object.keys/values/entries 会忽略 symbol 属性\"\n就像 `for..in` 循环一样，这些方法会忽略使用 `Symbol(...)` 作为键的属性。\n\n通常这很方便。但是，如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 [Object.getOwnPropertySymbols](mdn:js/Object/getOwnPropertySymbols)，它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys)，它会返回 **所有** 键。\n```\n\n\n## 转换对象\n\n对象缺少数组存在的许多方法，例如 `map` 和 `filter` 等。\n\n如果我们想应用它们，那么我们可以使用 `Object.entries`，然后使用 `Object.fromEntries`：\n\n1. 使用 `Object.entries(obj)` 从 `obj` 获取由键/值对组成的数组。\n2. 对该数组使用数组方法，例如 `map`，对这些键/值对进行转换。\n3. 对结果数组使用 `Object.fromEntries(array)` 方法，将结果转回成对象。\n\n例如，我们有一个带有价格的对象，并想将它们加倍：\n\n```js run\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\n\n*!*\nlet doublePrices = Object.fromEntries(\n  // 将价格转换为数组，将每个键/值对映射为另一对\n  // 然后通过 fromEntries 再将结果转换为对象\n  Object.entries(prices).map(entry => [entry[0], entry[1] * 2])\n);\n*/!*\n\nalert(doublePrices.meat); // 8\n```\n\n乍一看，可能感觉有点困难，但是使用一两次之后就很容易理解了。我们可以通过这种方式建立强大的转换链。",
        "libs": [],
        "children": [
          "sum-salaries",
          "count-properties"
        ],
        "parent": "data-types",
        "updatedAt": 1658126629
      }
    },
    "sum-salaries": {
      "type": "Task",
      "value": {
        "title": "属性求和",
        "slug": "sum-salaries",
        "githubPath": "/1-js/05-data-types/09-keys-values-entries/01-sum-salaries",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n有一个带有任意数量薪水的 `salaries` 对象。\n\n编写函数 `sumSalaries(salaries)`，该函数使用 `Object.values` 和 `for..of` 循环返回所有薪水的总和。\n\n如果 `salaries` 是空对象，那么结果必须是 `0`。\n\n举个例子：\n\n```js\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nalert( sumSalaries(salaries) ); // 650\n```",
        "solution": "```js run demo\nfunction sumSalaries(salaries) {\n\n  let sum = 0;\n  for (let salary of Object.values(salaries)) {\n    sum += salary;\n  }\n\n  return sum; // 650\n}\n\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nalert( sumSalaries(salaries) ); // 650\n```\n还有另外一种可选方案，即使用 `Object.values` 和 `reduce` 来求和：\n\n```js\n// 使用 reduce 方法遍历 salaries 数组\n// 把它们加起来\n// 返回最终结果\nfunction sumSalaries(salaries) {\n  return Object.values(salaries).reduce((a, b) => a + b, 0) // 650\n}\n```",
        "solutionJs": "function sumSalaries(salaries) {\n\n  let sum = 0;\n  for (let salary of Object.values(salaries)) {\n    sum += salary;\n  }\n\n  return sum;\n}\n\n",
        "parent": "keys-values-entries",
        "version": 1
      }
    },
    "count-properties": {
      "type": "Task",
      "value": {
        "title": "计算属性数量",
        "slug": "count-properties",
        "githubPath": "/1-js/05-data-types/09-keys-values-entries/02-count-properties",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n写一个函数 `count(obj)`，该函数返回对象中的属性的数量：\n\n```js\nlet user = {\n  name: 'John',\n  age: 30\n};\n\nalert( count(user) ); // 2\n```\n\n试着使代码尽可能简短。\n\nP.S. 忽略 Symbol 类型属性，只计算“常规”属性。",
        "solution": "",
        "solutionJs": "function count(obj) { \n  return Object.keys(obj).length;\n}\n\n",
        "parent": "keys-values-entries",
        "version": 1
      }
    },
    "destructuring-assignment": {
      "type": "Article",
      "value": {
        "title": "解构赋值",
        "slug": "destructuring-assignment",
        "githubPath": "/1-js/05-data-types/10-destructuring-assignment",
        "isFolder": false,
        "weight": 10,
        "content": "\n\nJavaScript 中最常用的两种数据结构是 `Object` 和 `Array`。\n\n- 对象是一种根据键存储数据的实体。\n- 数组是一种直接存储数据的有序列表。\n\n但是，当我们把它们传递给函数时，函数可能不需要整个对象/数组，而只需要其中一部分。\n\n**解构赋值** 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中。有时这样做更方便。\n\n解构操作对那些具有很多参数和默认值等的函数也很奏效。下面有一些例子。\n\n## 数组解构\n\n这是一个将数组解构到变量中的例子：\n\n```js\n// 我们有一个存放了名字和姓氏的数组\nlet arr = [\"John\", \"Smith\"]\n\n*!*\n// 解构赋值\n// 设置 firstName = arr[0]\n// 以及 surname = arr[1]\nlet [firstName, surname] = arr;\n*/!*\n\nalert(firstName); // John\nalert(surname);  // Smith\n```\n\n我们可以使用这些变量而非原来的数组项了。\n\n当与 `split` 函数（或其他返回值为数组的函数）结合使用时，看起来更优雅：\n\n```js run\nlet [firstName, surname] = \"John Smith\".split(' ');\nalert(firstName); // John\nalert(surname);  // Smith\n```\n\n正如我们所看到的，语法很简单。但是有几个需要注意的细节。让我们通过更多的例子来加深理解。\n\n````smart header=\"“解构”并不意味着“破坏”\"\n这种语法被叫做“解构赋值”，是因为它“拆开”了数组或对象，将其中的各元素复制给一些变量。原来的数组或对象自身没有被修改。\n\n换句话说，解构赋值只是写起来简洁一点。以下两种写法是等价的：\n```js\n// let [firstName, surname] = arr;\nlet firstName = arr[0];\nlet surname = arr[1];\n```\n````\n\n````smart header=\"忽略使用逗号的元素\"\n可以通过添加额外的逗号来丢弃数组中不想要的元素：\n\n```js run\n*!*\n// 不需要第二个元素\nlet [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n*/!*\n\nalert( title ); // Consul\n```\n\n在上面的代码中，数组的第二个元素被跳过了，第三个元素被赋值给了 `title` 变量。数组中剩下的元素也都被跳过了（因为在这没有对应给它们的变量）。\n````\n\n````smart header=\"等号右侧可以是任何可迭代对象\"\n\n……实际上，我们可以将其与任何可迭代对象一起使用，而不仅限于数组：\n\n```js\nlet [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"]\nlet [one, two, three] = new Set([1, 2, 3]);\n```\n这种情况下解构赋值是通过迭代右侧的值来完成工作的。这是一种用于对在 `=` 右侧的值上调用 `for..of` 并进行赋值的操作的语法糖。\n````\n\n\n````smart header=\"赋值给等号左侧的任何内容\"\n我们可以在等号左侧使用任何“可以被赋值的”东西。\n\n例如，一个对象的属性：\n```js run\nlet user = {};\n[user.name, user.surname] = \"John Smith\".split(' ');\n\nalert(user.name); // John\nalert(user.surname); // Smith\n```\n\n````\n\n````smart header=\"与 .entries() 方法进行循环操作\"\n在前面的章节中我们已经见过了 [Object.entries(obj)](mdn:js/Object/entries) 方法。\n\n我们可以将 .entries() 方法与解构语法一同使用，来遍历一个对象的“键—值”对：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// 使用循环遍历键—值对\n*!*\nfor (let [key, value] of Object.entries(user)) {\n*/!*\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n```\n\n用于 `Map` 的类似代码更简单，因为 Map 是可迭代的：\n\n```js run\nlet user = new Map();\nuser.set(\"name\", \"John\");\nuser.set(\"age\", \"30\");\n\n*!*\n// Map 是以 [key, value] 对的形式进行迭代的，非常便于解构\nfor (let [key, value] of user) {\n*/!*\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n```\n````\n\n````smart header=\"交换变量值的技巧\"\n使用解构赋值来交换两个变量的值是一个著名的技巧：\n\n```js run\nlet guest = \"Jane\";\nlet admin = \"Pete\";\n\n// 让我们来交换变量的值：使得 guest = Pete，admin = Jane\n*!*\n[guest, admin] = [admin, guest];\n*/!*\n\nalert(`${guest} ${admin}`); // Pete Jane（成功交换！）\n```\n\n这里我们创建了一个由两个变量组成的临时数组，并且立即以颠倒的顺序对其进行了解构赋值。\n\n我们也可以用这种方式交换两个以上的变量。\n````\n\n### 其余的 '...'\n\n通常，如果数组比左边的列表长，那么“其余”的数组项会被省略。\n\n例如，这里只取了两项，其余的就被忽略了：\n\n```js run\nlet [name1, name2] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n\nalert(name1); // Julius\nalert(name2); // Caesar\n// 其余数组项未被分配到任何地方\n```\n\n如果我们还想收集其余的数组项 —— 我们可以使用三个点 `\"...\"` 来再加一个参数以获取其余数组项：\n\n```js run\nlet [name1, name2, *!*...rest*/!*] = [\"Julius\", \"Caesar\", *!*\"Consul\", \"of the Roman Republic\"*/!*];\n\n*!*\n// rest 是包含从第三项开始的其余数组项的数组\nalert(rest[0]); // Consul\nalert(rest[1]); // of the Roman Republic\nalert(rest.length); // 2\n*/!*\n```\n\n`rest` 的值就是数组中剩下的元素组成的数组。\n\n不一定要使用变量名 `rest`，我们也可以使用任何其他的变量名。只要确保它前面有三个点，并且在解构赋值的最后一个参数位置上就行了：\n\n```js run\nlet [name1, name2, *!*...titles*/!*] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n// 现在 titles = [\"Consul\", \"of the Roman Republic\"]\n```\n\n### 默认值\n\n如果数组比左边的变量列表短，这里不会出现报错。缺少对应值的变量都会被赋 `undefined`：\n\n```js run\n*!*\nlet [firstName, surname] = [];\n*/!*\n\nalert(firstName); // undefined\nalert(surname); // undefined\n```\n\n如果我们想要一个“默认”值给未赋值的变量，我们可以使用 `=` 来提供：\n\n```js run\n*!*\n// 默认值\nlet [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"];\n*/!*\n\nalert(name);    // Julius（来自数组的值）\nalert(surname); // Anonymous（默认值被使用了）\n```\n\n默认值可以是更加复杂的表达式，甚至可以是函数调用。不过，这些表达式或函数只会在这个变量未被赋值的时候才会被计算。\n\n举个例子，我们使用了 `prompt` 函数来提供两个默认值：\n\n```js run\n// 只会提示输入姓氏\nlet [name = prompt('name?'), surname = prompt('surname?')] = [\"Julius\"];\n\nalert(name);    // Julius（来自数组）\nalert(surname); // 你输入的值\n```\n\n请注意：`prompt` 将仅针对缺失值（`surname`）运行。\n\n## 对象解构\n\n解构赋值同样适用于对象。\n\n基本语法是：\n\n```js\nlet {var1, var2} = {var1:…, var2:…}\n```\n\n在等号右侧是一个已经存在的对象，我们想把它拆分到变量中。等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 `{...}` 中的变量名列表。\n\n如下所示：\n\n```js run\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n*!*\nlet {title, width, height} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\n属性 `options.title`、`options.width` 和 `options.height` 值被赋给了对应的变量。\n\n变量的顺序并不重要，下面这个代码也是等价的：\n\n```js\n// 改变 let {...} 中元素的顺序\nlet {height, width, title} = { title: \"Menu\", height: 200, width: 100 }\n```\n\n等号左侧的模式（pattern）可以更加复杂，指定属性和变量之间的映射关系。\n\n如果我们想把一个属性赋值给另一个名字的变量，比如把 `options.width` 属性赋值给名为 `w` 的变量，那么我们可以使用冒号来设置变量名称：\n\n```js run\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n*!*\n// { sourceProperty: targetVariable }\nlet {width: w, height: h, title} = options;\n*/!*\n\n// width -> w\n// height -> h\n// title -> title\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n```\n\n冒号的语法是“从对象中什么属性的值：赋值给哪个变量”。上面的例子中，属性 `width` 被赋值给了 `w`，属性 `height` 被赋值给了 `h`，属性 `title` 被赋值给了同名变量。\n\n对于可能缺失的属性，我们可以使用 `\"=\"` 设置默认值，如下所示：\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width = 100, height = 200, title} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\n就像数组或函数参数一样，默认值可以是任意表达式甚至可以是函数调用。它们只会在未提供对应的值时才会被计算/调用。\n\n在下面的代码中，`prompt` 提示输入 `width` 值，但不会提示输入 `title` 值：\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width = prompt(\"width?\"), title = prompt(\"title?\")} = options;\n*/!*\n\nalert(title);  // Menu\nalert(width);  // (prompt 的返回值)\n```\n\n我们还可以将冒号和等号结合起来：\n\n```js run\nlet options = {\n  title: \"Menu\"\n};\n\n*!*\nlet {width: w = 100, height: h = 200, title} = options;\n*/!*\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n```\n\n如果我们有一个具有很多属性的复杂对象，那么我们可以只提取所需的内容：\n\n```js run\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n// 仅提取 title 作为变量\nlet { title } = options;\n\nalert(title); // Menu\n```\n\n### 剩余模式（pattern）\"...\"\n\n如果对象拥有的属性数量比我们提供的变量数量还多，该怎么办？我们可以只取其中的某一些属性，然后把“剩余的”赋值到其他地方吗？\n\n我们可以使用剩余模式（pattern），与数组类似。一些较旧的浏览器不支持此功能（例如 IE，可以使用 Babel 对其进行 polyfill），但可以在现代浏览器中使用。\n\n看起来就像这样：\n\n```js run\nlet options = {\n  title: \"Menu\",\n  height: 200,\n  width: 100\n};\n\n*!*\n// title = 名为 title 的属性\n// rest = 存有剩余属性的对象\nlet {title, ...rest} = options;\n*/!*\n\n// 现在 title=\"Menu\", rest={height: 200, width: 100}\nalert(rest.height);  // 200\nalert(rest.width);   // 100\n```\n\n````smart header=\"不使用 `let` 时的陷阱\"\n在上面的示例中，变量都是在赋值中通过正确方式声明的：`let {…} = {…}`。当然，我们也可以使用已有的变量，而不用 `let`，但这里有一个陷阱。\n\n以下代码无法正常运行：\n```js run\nlet title, width, height;\n\n// 这一行发生了错误\n{title, width, height} = {title: \"Menu\", width: 200, height: 100};\n```\n\n问题在于 JavaScript 把主代码流（即不在其他表达式中）的 `{...}` 当做一个代码块。这样的代码块可以用于对语句分组，如下所示：\n\n```js run\n{\n  // 一个代码块\n  let message = \"Hello\";\n  // ...\n  alert( message );\n}\n```\n\n因此，这里 JavaScript 假定我们有一个代码块，这就是报错的原因。我们需要解构它。\n\n为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 `(...)` 包起来：\n\n```js run\nlet title, width, height;\n\n// 现在就可以了\n*!*(*/!*{title, width, height} = {title: \"Menu\", width: 200, height: 100}*!*)*/!*;\n\nalert( title ); // Menu\n```\n````\n\n## 嵌套解构\n\n如果一个对象或数组嵌套了其他的对象和数组，我们可以在等号左侧使用更复杂的模式（pattern）来提取更深层的数据。\n\n在下面的代码中，`options` 的属性 `size` 是另一个对象，属性 `items` 是另一个数组。赋值语句中等号左侧的模式（pattern）具有相同的结构以从中提取值：\n\n```js run\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Cake\", \"Donut\"],\n  extra: true\n};\n\n// 为了清晰起见，解构赋值语句被写成多行的形式\nlet {\n  size: { // 把 size 赋值到这里\n    width,\n    height\n  },\n  items: [item1, item2], // 把 items 赋值到这里\n  title = \"Menu\" // 在对象中不存在（使用默认值）\n} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Cake\nalert(item2);  // Donut\n```\n\n对象 `options` 的所有属性，除了 `extra` 属性在等号左侧不存在，都被赋值给了对应的变量：\n\n![](destructuring-complex.svg)\n\n最终，我们得到了 `width`、`height`、`item1`、`item2` 和具有默认值的 `title` 变量。\n\n注意，`size` 和 `items` 没有对应的变量，因为我们取的是它们的内容。\n\n## 智能函数参数\n\n有时，一个函数有很多参数，其中大部分的参数都是可选的。对用户界面来说更是如此。想象一个创建菜单的函数。它可能具有宽度参数，高度参数，标题参数和项目列表等。\n\n下面是实现这种函数的一个很不好的写法：\n\n```js\nfunction showMenu(title = \"Untitled\", width = 200, height = 100, items = []) {\n  // ...\n}\n```\n\n在实际开发中，记忆如此多的参数的位置是一个很大的负担。通常集成开发环境（IDE）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但是…… 另一个问题就是，在大部分的参数只需采用默认值的情况下，调用这个函数时会需要写大量的 undefined。\n\n像这样：\n\n```js\n// 在采用默认值就可以的位置设置 undefined\nshowMenu(\"My Menu\", undefined, undefined, [\"Item1\", \"Item2\"])\n```\n\n这太难看了。而且，当我们处理更多参数的时候可读性会变得很差。\n\n解构赋值可以解决这些问题。\n\n我们可以用一个对象来传递所有参数，而函数负责把这个对象解构成各个参数：\n\n```js run\n// 我们传递一个对象给函数\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\n// ……然后函数马上把对象解构成变量\nfunction showMenu(*!*{title = \"Untitled\", width = 200, height = 100, items = []}*/!*) {\n  // title, items – 提取于 options，\n  // width, height – 使用默认值\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(options);\n```\n\n我们也可以使用带有嵌套对象和冒号映射的更加复杂的解构：\n\n```js run\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\n*!*\nfunction showMenu({\n  title = \"Untitled\",\n  width: w = 100,  // width goes to w\n  height: h = 200, // height goes to h\n  items: [item1, item2] // items first element goes to item1, second to item2\n}) {\n*/!*\n  alert( `${title} ${w} ${h}` ); // My Menu 100 200\n  alert( item1 ); // Item1\n  alert( item2 ); // Item2\n}\n\nshowMenu(options);\n```\n\n完整语法和解构赋值是一样的：\n```js\nfunction({\n  incomingProperty: varName = defaultValue\n  ...\n})\n```\n\n对于参数对象，属性 `incomingProperty` 对应的变量是 `varName`，默认值是 `defaultValue`。\n\n请注意，这种解构假定了 `showMenu()` 函数确实存在参数。如果我们想让所有的参数都使用默认值，那我们应该传递一个空对象：\n\n```js\nshowMenu({}); // 不错，所有值都取默认值\n\nshowMenu(); // 这样会导致错误\n```\n\n我们可以通过指定空对象 `{}` 为整个参数对象的默认值来解决这个问题：\n\n```js run\nfunction showMenu({ title = \"Menu\", width = 100, height = 200 }*!* = {}*/!*) {\n  alert( `${title} ${width} ${height}` );\n}\n\nshowMenu(); // Menu 100 200\n```\n\n在上面的代码中，整个参数对象的默认是 `{}`，因此总会有内容可以用来解构。\n\n## 总结\n\n- 解构赋值可以简洁地将一个对象或数组拆开赋值到多个变量上。\n- 解构对象的完整语法：\n    ```js\n    let {prop : varName = default, ...rest} = object\n    ```\n\n    这表示属性 `prop` 会被赋值给变量 `varName`，如果没有这个属性的话，就会使用默认值 `default`。\n    \n    没有对应映射的对象属性会被复制到 `rest` 对象。\n\n- 解构数组的完整语法：\n\n    ```js\n    let [item1 = default, item2, ...rest] = array\n    ```\n\n    数组的第一个元素被赋值给 `item1`，第二个元素被赋值给 `item2`，剩下的所有元素被复制到另一个数组 `rest`。\n\n- 从嵌套数组/对象中提取数据也是可以的，此时等号左侧必须和等号右侧有相同的结构。",
        "libs": [],
        "children": [
          "destruct-user",
          "max-salary"
        ],
        "parent": "data-types",
        "updatedAt": 1653192182
      }
    },
    "destruct-user": {
      "type": "Task",
      "value": {
        "title": "解构赋值",
        "slug": "destruct-user",
        "githubPath": "/1-js/05-data-types/10-destructuring-assignment/1-destruct-user",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有一个对象：\n\n```js\nlet user = {\n  name: \"John\",\n  years: 30\n};\n```\n\n写一个解构赋值语句使得：\n\n- `name` 属性赋值给变量 `name`。\n- `years` 属性赋值给变量 `age`。\n- `isAdmin` 属性赋值给变量 `isAdmin`（如果属性缺失则取默认值 false）。\n\n下面是赋值完成后的值的情况：\n\n```js\nlet user = { name: \"John\", years: 30 };\n\n// 等号左侧是你的代码\n// ... = user\n\nalert( name ); // John\nalert( age ); // 30\nalert( isAdmin ); // false\n```",
        "solution": "```js run\nlet user = {\n  name: \"John\",\n  years: 30\n};\n\nlet {name, years: age, isAdmin = false} = user;\n\nalert( name ); // John\nalert( age ); // 30\nalert( isAdmin ); // false\n```",
        "parent": "destructuring-assignment",
        "version": 1
      }
    },
    "max-salary": {
      "type": "Task",
      "value": {
        "title": "最高薪资",
        "slug": "max-salary",
        "githubPath": "/1-js/05-data-types/10-destructuring-assignment/6-max-salary",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n这儿有一个 `salaries` 对象：\n\n```js\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n```\n\n新建一个函数 `topSalary(salaries)`，返回收入最高的人的姓名。\n\n- 如果 `salaries` 是空的，函数应该返回 `null`。\n- 如果有多个收入最高的人，返回其中任意一个即可。\n\nP.S. 使用 `Object.entries` 和解构语法来遍历键/值对。",
        "solution": "",
        "solutionJs": "function topSalary(salaries) {\n\n  let maxSalary = 0;\n  let maxName = null;\n\n  for(let [name, salary] of Object.entries(salaries)) {\n    if (maxSalary < salary) {\n      maxSalary = salary;\n      maxName = name;\n    }\n  }\n\n  return maxName;\n}\n",
        "parent": "destructuring-assignment",
        "version": 1
      }
    },
    "date": {
      "type": "Article",
      "value": {
        "title": "日期和时间",
        "slug": "date",
        "githubPath": "/1-js/05-data-types/11-date",
        "isFolder": false,
        "weight": 11,
        "content": "\n\n让我们来学习一个新的内建对象：[日期（Date）](mdn:js/Date)。该对象存储日期和时间，并提供了日期/时间的管理方法。\n\n我们可以使用它来存储创建/修改时间，测量时间，或者仅用来打印当前时间。\n\n## 创建\n\n调用 `new Date()` 来创建一个新的 `Date` 对象。在调用时可以带有一些参数，如下所示：\n\n`new Date()`\n: 不带参数 —— 创建一个表示当前日期和时间的 `Date` 对象：\n\n    ```js run\n    let now = new Date();\n    alert( now ); // 显示当前的日期/时间\n    ```\n\n`new Date(milliseconds)`\n: 创建一个 `Date` 对象，其时间等于 1970 年 1 月 1 日 UTC+0 之后经过的毫秒数（1/1000 秒）。\n\n    ```js run\n    // 0 表示 01.01.1970 UTC+0\n    let Jan01_1970 = new Date(0);\n    alert( Jan01_1970 );\n\n    // 现在增加 24 小时，得到 02.01.1970 UTC+0\n    let Jan02_1970 = new Date(24 * 3600 * 1000);\n    alert( Jan02_1970 );\n    ```\n\n    传入的整数参数代表的是自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为 **时间戳**。\n\n    这是一种日期的轻量级数字表示形式。我们通常使用 `new Date(timestamp)` 通过时间戳来创建日期，并可以使用 `date.getTime()` 将现有的 `Date` 对象转化为时间戳（下文会讲到）。\n\n    在 01.01.1970 之前的日期带有负的时间戳，例如：\n    ```js run\n    // 31 Dec 1969\n    let Dec31_1969 = new Date(-24 * 3600 * 1000);\n    alert( Dec31_1969 );\n    ```\n\n`new Date(datestring)`\n: 如果只有一个参数，并且是字符串，那么它会被自动解析。该算法与 `Date.parse` 所使用的算法相同，将在下文中进行介绍。\n\n    ```js run\n    let date = new Date(\"2017-01-26\");\n    alert(date);\n    // 未指定具体时间，所以假定时间为格林尼治标准时间（GMT）的午夜零点\n    // 并根据运行代码时的用户的时区进行调整\n    // 因此，结果可能是\n    // Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)\n    // 或\n    // Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)\n    ```\n\n`new Date(year, month, date, hours, minutes, seconds, ms)`\n: 使用当前时区中的给定组件创建日期。只有前两个参数是必须的。\n\n    - `year` 应该是四位数。为了兼容性，也接受 2 位数，并将其视为 `19xx`，例如 `98` 与 `1998` 相同，但强烈建议始终使用 4 位数。\n    - `month` 计数从 `0`（一月）开始，到 `11`（十二月）结束。\n    - `date` 是当月的具体某一天，如果缺失，则为默认值 `1`。\n    - 如果 `hours/minutes/seconds/ms` 缺失，则均为默认值 `0`。\n\n    例如：\n\n    ```js\n    new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00\n    new Date(2011, 0, 1); // 同样，时分秒等均为默认值 0\n    ```\n\n    时间度量最大精确到 1 毫秒（1/1000 秒）：\n\n    ```js run\n    let date = new Date(2011, 0, 1, 2, 3, 4, 567);\n    alert( date ); // 1.01.2011, 02:03:04.567\n    ```\n\n## 访问日期组件\n\n从 `Date` 对象中访问年、月等信息有多种方式：\n\n[getFullYear()](mdn:js/Date/getFullYear)\n: 获取年份（4 位数）\n\n[getMonth()](mdn:js/Date/getMonth)\n: 获取月份，**从 0 到 11**。\n\n[getDate()](mdn:js/Date/getDate)\n: 获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。\n\n[getHours()](mdn:js/Date/getHours)，[getMinutes()](mdn:js/Date/getMinutes)，[getSeconds()](mdn:js/Date/getSeconds)，[getMilliseconds()](mdn:js/Date/getMilliseconds)\n: 获取相应的时间组件。\n\n```warn header=\"不是 `getYear()`，而是 `getFullYear()`\"\n很多 JavaScript 引擎都实现了一个非标准化的方法 `getYear()`。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远不要使用它。要获取年份就使用 `getFullYear()`。\n```\n\n另外，我们还可以获取一周中的第几天：\n\n[getDay()](mdn:js/Date/getDay)\n: 获取一周中的第几天，从 `0`（星期日）到 `6`（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变。\n\n**以上的所有方法返回的组件都是基于当地时区的。**\n\n当然，也有与当地时区的 UTC 对应项，它们会返回基于 UTC+0 时区的日、月、年等：[getUTCFullYear()](mdn:js/Date/getUTCFullYear)，[getUTCMonth()](mdn:js/Date/getUTCMonth)，[getUTCDay()](mdn:js/Date/getUTCDay)。只需要在 `\"get\"` 之后插入 `\"UTC\"` 即可。\n\n如果你当地时区相对于 UTC 有偏移，那么下面代码会显示不同的小时数：\n\n```js run\n//  当前日期\nlet date = new Date();\n\n// 当地时区的小时数\nalert( date.getHours() );\n\n// 在 UTC+0 时区的小时数（非夏令时的伦敦时间）\nalert( date.getUTCHours() );\n```\n\n除了上述给定的方法，还有两个没有 UTC 变体的特殊方法：\n\n[getTime()](mdn:js/Date/getTime)\n: 返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。\n\n[getTimezoneOffset()](mdn:js/Date/getTimezoneOffset)\n: 返回 UTC 与本地时区之间的时差，以分钟为单位：\n\n    ```js run\n    // 如果你在时区 UTC-1，输出 60\n    // 如果你在时区 UTC+3，输出 -180\n    alert( new Date().getTimezoneOffset() );\n\n    ```\n\n## 设置日期组件\n\n下列方法可以设置日期/时间组件：\n\n- [`setFullYear(year, [month], [date])`](mdn:js/Date/setFullYear)\n- [`setMonth(month, [date])`](mdn:js/Date/setMonth)\n- [`setDate(date)`](mdn:js/Date/setDate)\n- [`setHours(hour, [min], [sec], [ms])`](mdn:js/Date/setHours)\n- [`setMinutes(min, [sec], [ms])`](mdn:js/Date/setMinutes)\n- [`setSeconds(sec, [ms])`](mdn:js/Date/setSeconds)\n- [`setMilliseconds(ms)`](mdn:js/Date/setMilliseconds)\n- [`setTime(milliseconds)`](mdn:js/Date/setTime)（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）\n\n以上方法除了 `setTime()` 都有 UTC 变体，例如：`setUTCHours()`。\n\n我们可以看到，有些方法可以一次性设置多个组件，比如 `setHours`。未提及的组件不会被修改。\n\n举个例子：\n\n```js run\nlet today = new Date();\n\ntoday.setHours(0);\nalert(today); // 日期依然是今天，但是小时数被改为了 0\n\ntoday.setHours(0, 0, 0, 0);\nalert(today); // 日期依然是今天，时间为 00:00:00。\n```\n\n## 自动校准（Autocorrection）\n\n**自动校准** 是 `Date` 对象的一个非常方便的特性。我们可以设置超范围的数值，它会自动校准。\n\n举个例子：\n\n```js run\nlet date = new Date(2013, 0, *!*32*/!*); // 32 Jan 2013 ?!?\nalert(date); // ……是 1st Feb 2013!\n```\n\n超出范围的日期组件将会被自动分配。\n\n假设我们要在日期 \"28 Feb 2016\" 上加 2 天。结果可能是 \"2 Mar\" 或 \"1 Mar\"，因为存在闰年。但是我们不需要考虑这些，只需要直接加 2 天，剩下的 `Date` 对象会帮我们处理：\n\n```js run\nlet date = new Date(2016, 1, 28);\n*!*\ndate.setDate(date.getDate() + 2);\n*/!*\n\nalert( date ); // 1 Mar 2016\n```\n\n这个特性经常被用来获取给定时间段后的日期。例如，我们想获取“现在 70 秒后”的日期：\n\n```js run\nlet date = new Date();\ndate.setSeconds(date.getSeconds() + 70);\n\nalert( date ); // 显示正确的日期信息\n```\n\n我们还可以设置 0 甚至可以设置负值。例如：\n\n```js run\nlet date = new Date(2016, 0, 2); // 2016 年 1 月 2 日\n\ndate.setDate(1); // 设置为当月的第一天\nalert( date );\n\ndate.setDate(0); // 天数最小可以设置为 1，所以这里设置的是上一月的最后一天\nalert( date ); // 31 Dec 2015\n```\n\n## 日期转化为数字，日期差值\n\n当 `Date` 对象被转化为数字时，得到的是对应的时间戳，与使用 `date.getTime()` 的结果相同：\n\n```js run\nlet date = new Date();\nalert(+date); // 以毫秒为单位的数值，与使用 date.getTime() 的结果相同\n```\n\n有一个重要的副作用：日期可以相减，相减的结果是以毫秒为单位时间差。\n\n这个作用可以用于时间测量：\n\n```js run\nlet start = new Date(); // 开始测量时间\n\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\nlet end = new Date(); // 结束测量时间\n\nalert( `The loop took ${end - start} ms` );\n```\n\n## Date.now()\n\n如果我们仅仅想要测量时间间隔，我们不需要 `Date` 对象。\n\n有一个特殊的方法 `Date.now()`，它会返回当前的时间戳。\n\n它相当于 `new Date().getTime()`，但它不会创建中间的 `Date` 对象。因此它更快，而且不会对垃圾回收造成额外的压力。\n\n这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 JavaScript 编写游戏或其他的特殊应用场景。\n\n因此这样做可能会更好：\n\n```js run\n*!*\nlet start = Date.now(); // 从 1 Jan 1970 至今的时间戳\n*/!*\n\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\n*!*\nlet end = Date.now(); // 完成\n*/!*\n\nalert( `The loop took ${end - start} ms` ); // 相减的是时间戳，而不是日期\n```\n\n## 基准测试（Benchmarking）\n\n在对一个很耗 CPU 性能的函数进行可靠的基准测试（Benchmarking）时，我们需要谨慎一点。\n\n例如，我们想判断以下两个计算日期差值的函数：哪个更快？\n\n这种性能测量通常称为“基准测试（benchmark）”。\n\n```js\n// 我们有 date1 和 date2，哪个函数会更快地返回两者的时间差？\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\n// or\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n```\n\n这两个函数做的事情完全相同，但是其中一个函数使用显式的 `date.getTime()` 来获取毫秒形式的日期，另一个则依赖于“日期 — 数字”的转换。它们的结果是一样的。\n\n那么，哪个更快呢？\n\n首先想到的方法可能是连续运行两者很多次，并计算所消耗的时间之差。就这个例子而言，函数过于简单，所以我们必须执行至少 100000 次。\n\n让我们开始测量：\n\n```js run\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nalert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );\nalert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );\n```\n\n看起来使用 `getTime()` 这种方式快得多，这是因为它没有进行类型转换，对引擎优化来说更加简单。\n\n我们得到了结论，但是这并不是一个很好的度量的例子。\n\n想象一下当运行 `bench(diffSubtract)` 的同时，CPU 还在并行处理其他事务，并且这也会占用资源。然而，运行 `bench(diffGetTime)` 的时候，并行处理的事务完成了。\n\n对于现代多进程操作系统来说，这是一个非常常见的场景。\n\n比起第二个函数，第一个函数所能使用的 CPU 资源更少。这可能导致错误的结论。\n\n**为了得到更加可靠的度量，整个度量测试包应该重新运行多次。**\n\n例如，像下面的代码这样：\n\n```js run\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nlet time1 = 0;\nlet time2 = 0;\n\n*!*\n// 交替运行 bench(diffSubtract) 和 bench(diffGetTime) 各 10 次\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n*/!*\n\nalert( 'Total time for diffSubtract: ' + time1 );\nalert( 'Total time for diffGetTime: ' + time2 );\n```\n\n现代的 JavaScript 引擎的先进优化策略只对执行很多次的 \"hot code\" 有效（对于执行很少次数的代码没有必要优化）。因此，在上面的例子中，第一次执行的优化程度不高。我们可能需要增加一个预热步骤：\n\n```js\n// 在主循环中增加预热环节\nbench(diffSubtract);\nbench(diffGetTime);\n\n// 开始度量\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n```\n\n```warn header=\"进行微型基准测试时要小心\"\n现代的 JavaScript 引擎执行了很多优化。与正常编写的代码相比，它们可能会改变“人为编写的专用于测试的代码”的执行流程，特别是在我们对很小的代码片段进行基准测试时，例如某个运算符或内建函数的工作方式。因此，为了深入理解性能问题，请学习 JavaScript 引擎的工作原理。在那之后，你或许再也不需要进行微型基准测试了。\n\n<http://mrale.ph> 提供了很多 V8 引擎相关的文章。\n```\n\n## 对字符串调用 Date.parse\n\n[Date.parse(str)](mdn:js/Date/parse) 方法可以从一个字符串中读取日期。\n\n字符串的格式应该为：`YYYY-MM-DDTHH:mm:ss.sssZ`，其中：\n\n- `YYYY-MM-DD` —— 日期：年-月-日。\n- 字符 `\"T\"` 是一个分隔符。\n- `HH:mm:ss.sss` —— 时间：小时，分钟，秒，毫秒。\n- 可选字符 `'Z'` 为 `+-hh:mm` 格式的时区。单个字符 `Z` 代表 UTC+0 时区。\n\n简短形式也是可以的，比如 `YYYY-MM-DD` 或 `YYYY-MM`，甚至可以是 `YYYY`。\n\n`Date.parse(str)` 调用会解析给定格式的字符串，并返回时间戳（自 1970-01-01 00:00:00 起所经过的毫秒数）。如果给定字符串的格式不正确，则返回 `NaN`。\n\n举个例子：\n\n```js run\nlet ms = Date.parse('2012-01-26T13:51:50.417-07:00');\n\nalert(ms); // 1327611110417  (时间戳)\n```\n\n我们可以通过时间戳来立即创建一个 `new Date` 对象：\n\n```js run\nlet date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );\n\nalert(date);\n```\n\n## 总结\n\n- 在 JavaScript 中，日期和时间使用 [Date](mdn:js/Date) 对象来表示。我们不能单独创建日期或时间，`Date` 对象总是同时创建两者。\n- 月份从 0 开始计数（对，一月是 0）。\n- 一周中的某一天 `getDay()` 同样从 0 开始计算（0 代表星期日）。\n- 当设置了超出范围的组件时，`Date` 会进行自动校准。这一点对于日/月/小时的加减很有用。\n- 日期可以相减，得到的是以毫秒表示的两者的差值。因为当 `Date` 被转换为数字时，`Date` 对象会被转换为时间戳。\n- 使用 `Date.now()` 可以更快地获取当前时间的时间戳。\n\n和其他系统不同，JavaScript 中时间戳以毫秒为单位，而不是秒。\n\n有时我们需要更加精准的时间度量。JavaScript 自身并没有测量微秒的方法（百万分之一秒），但大多数运行环境会提供。例如：浏览器有 [performance.now()](mdn:api/Performance/now) 方法来给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位）：\n\n```js run\nalert(`Loading started ${performance.now()}ms ago`);\n// 类似于 \"Loading started 34731.26000000001ms ago\"\n// .26 表示的是微秒（260 微秒）\n// 小数点后超过 3 位的数字是精度错误，只有前三位数字是正确的\n```\n\nNode.js 可以通过 `microtime` 模块或使用其他方法。从技术上讲，几乎所有的设备和环境都允许获取更高精度的时间数值，只不过不是使用 `Date` 对象。",
        "libs": [],
        "children": [
          "new-date",
          "get-week-day",
          "weekday",
          "get-date-ago",
          "last-day-of-month",
          "get-seconds-today",
          "get-seconds-to-tomorrow",
          "format-date-relative"
        ],
        "parent": "data-types",
        "updatedAt": 1657705346
      }
    },
    "new-date": {
      "type": "Task",
      "value": {
        "title": "创建日期",
        "slug": "new-date",
        "githubPath": "/1-js/05-data-types/11-date/1-new-date",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个 `Date` 对象，日期是：Feb 20, 2012, 3:12am。时区是当地时区。\n\n使用 `alert` 显示结果。",
        "solution": "`new Date` 构造函数默认使用本地时区。所以唯一需要牢记的就是月份从 0 开始计数。\n\n所以二月对应的数值是 1。\n\n这是一个以数字作为日期参数的示例：\n\n```js run\n// new Date(year, month, date, hour, minute, second, millisecond)\nlet d1 = new Date(2012, 1, 20, 3, 12);\nalert( d1 );\n```\n我们还可以从字符串创建日期，像这样：\n\n```js run\n// new Date(datestring)\nlet d2 = new Date(\"2012-02-20T03:12\");\nalert( d2 );\n```",
        "parent": "date",
        "version": 1
      }
    },
    "get-week-day": {
      "type": "Task",
      "value": {
        "title": "显示星期数",
        "slug": "get-week-day",
        "githubPath": "/1-js/05-data-types/11-date/2-get-week-day",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写一个函数 `getWeekDay(date)` 以短格式来显示一个日期的星期数：'MO'，'TU'，'WE'，'TH'，'FR'，'SA'，'SU'。\n\n例如：\n\n```js no-beautify\nlet date = new Date(2012, 0, 3);  // 3 Jan 2012\nalert( getWeekDay(date) );        // 应该输出 \"TU\"\n```",
        "solution": "`date.getDay()` 方法返回从星期日开始的星期数。\n\n我们创建一个关于星期的数组，这样我们就可以通过编号获取正确的日期名称：\n\n```js run demo\nfunction getWeekDay(date) {\n  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n\n  return days[date.getDay()];\n}\n\nlet date = new Date(2014, 0, 3); // 3 Jan 2014\nalert( getWeekDay(date) ); // FR\n```",
        "solutionJs": "function getWeekDay(date) {\n  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n\n  return days[date.getDay()];\n}\n",
        "parent": "date",
        "version": 1
      }
    },
    "weekday": {
      "type": "Task",
      "value": {
        "title": "欧洲的星期表示方法",
        "slug": "weekday",
        "githubPath": "/1-js/05-data-types/11-date/3-weekday",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n欧洲国家的星期计算是从星期一（数字 1）开始的，然后是星期二（数字 2），直到星期日（数字 7）。编写一个函数 `getLocalDay(date)`，并返回日期的欧洲式星期数。\n\n```js no-beautify\nlet date = new Date(2012, 0, 3);  // 3 Jan 2012\nalert( getLocalDay(date) );       // 星期二，应该显示 2\n```",
        "solution": "",
        "solutionJs": "function getLocalDay(date) {\n\n  let day = date.getDay();\n\n  if (day == 0) { // weekday 0 (sunday) is 7 in european\n    day = 7;\n  }\n\n  return day;\n}\n",
        "parent": "date",
        "version": 1
      }
    },
    "get-date-ago": {
      "type": "Task",
      "value": {
        "title": "许多天之前是哪个月几号？",
        "slug": "get-date-ago",
        "githubPath": "/1-js/05-data-types/11-date/4-get-date-ago",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n\n写一个函数 `getDateAgo(date, days)`，返回特定日期 `date` 往前 `days` 天是哪个月的哪一天。\n\n例如，假设今天是 20 号，那么 `getDateAgo(new Date(), 1)` 的结果应该是 19 号，`getDateAgo(new Date(), 2)` 的结果应该是 18 号。\n\n跨月、年也应该是正确输出：\n\n```js\nlet date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)\n```\n\nP.S. 函数不应该修改给定的 `date` 值。",
        "solution": "思路很简单：从 `date` 中减去给定的天数：\n\n```js\nfunction getDateAgo(date, days) {\n  date.setDate(date.getDate() - days);\n  return date.getDate();\n}\n```\n\n……但是函数不能修改 `date`。这一点很重要，因为我们提供日期的外部代码不希望它被修改。\n\n要实现这一点，我们可以复制这个日期，就像这样：\n\n```js run demo\nfunction getDateAgo(date, days) {\n  let dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}\n\nlet date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)\n```",
        "solutionJs": "function getDateAgo(date, days) {\n  let dateCopy = new Date(date);\n\n  dateCopy.setDate(date.getDate() - days);\n  return dateCopy.getDate();\n}\n",
        "parent": "date",
        "version": 1
      }
    },
    "last-day-of-month": {
      "type": "Task",
      "value": {
        "title": "某月的最后一天？",
        "slug": "last-day-of-month",
        "githubPath": "/1-js/05-data-types/11-date/5-last-day-of-month",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n写一个函数 `getLastDayOfMonth(year, month)` 返回 month 月的最后一天。有时候是 30，有时是 31，甚至在二月的时候会是 28/29。\n\n参数：\n\n- `year` —— 四位数的年份，比如 2012。\n- `month` —— 月份，从 0 到 11。\n\n举个例子，`getLastDayOfMonth(2012, 1) = 29`（闰年，二月）",
        "solution": "让我们使用下个月创建日期，但将零作为天数（day）传递：\n```js run demo\nfunction getLastDayOfMonth(year, month) {\n  let date = new Date(year, month + 1, 0);\n  return date.getDate();\n}\n\nalert( getLastDayOfMonth(2012, 0) ); // 31\nalert( getLastDayOfMonth(2012, 1) ); // 29\nalert( getLastDayOfMonth(2013, 1) ); // 28\n```\n\n通常，日期从 1 开始，但从技术上讲，我们可以传递任何数字，日期会自动进行调整。因此，当我们传递 0 时，它的意思是“一个月的第一天的前一天”，换句话说：“上个月的最后一天”。",
        "solutionJs": "function getLastDayOfMonth(year, month) {\n  let date = new Date(year, month + 1, 0);\n  return date.getDate();\n}\n",
        "parent": "date",
        "version": 1
      }
    },
    "get-seconds-today": {
      "type": "Task",
      "value": {
        "title": "今天过去了多少秒？",
        "slug": "get-seconds-today",
        "githubPath": "/1-js/05-data-types/11-date/6-get-seconds-today",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n写一个函数 `getSecondsToday()`，返回今天已经过去了多少秒？\n\n例如：如果现在是 `10:00 am`，并且没有夏令时转换，那么：\n\n```js\ngetSecondsToday() == 36000 // (3600 * 10)\n```\n\n该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。",
        "solution": "为获取秒数，我们可以使用今天的日期和 00:00:00 这个时间创建一个日期，然后使用当前时间减去该时间。\n\n不同之处在于，从今天之初开始算起的时间是以毫秒计算的，我们应该将其除以 1000，进而得到秒数：\n\n```js run\nfunction getSecondsToday() {\n  let now = new Date();\n\n  // 使用当前的 day/month/year 创建一个对象\n  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\n  let diff = now - today; // ms difference\n  return Math.round(diff / 1000); // make seconds\n}\n\nalert( getSecondsToday() );\n```\n\n另一种解决方法是获取 hours/minutes/seconds，然后把它们转换为秒数：\n\n```js run\nfunction getSecondsToday() {\n  let d = new Date();\n  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();\n};\n\nalert( getSecondsToday() );\n```",
        "parent": "date",
        "version": 1
      }
    },
    "get-seconds-to-tomorrow": {
      "type": "Task",
      "value": {
        "title": "距离明天还有多少秒？",
        "slug": "get-seconds-to-tomorrow",
        "githubPath": "/1-js/05-data-types/11-date/7-get-seconds-to-tomorrow",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\n\n写一个函数 `getSecondsToTomorrow()`，返回距离明天的秒数。\n\n例如，现在是 `23:00`，那么：\n\n```js\ngetSecondsToTomorrow() == 3600\n```\n\nP.S. 该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。",
        "solution": "为获取距离明天的毫秒数，我们可以用“明天 00:00:00”这个日期减去当前的日期。\n\n首先我们生成“明天”，然后对其进行减法操作：\n\n```js run\nfunction getSecondsToTomorrow() {\n  let now = new Date();\n\n  // tomorrow date\n  let tomorrow = new Date(now.getFullYear(), now.getMonth(), *!*now.getDate()+1*/!*);\n\n  let diff = tomorrow - now; // difference in ms\n  return Math.round(diff / 1000); // convert to seconds\n}\n```\n\n另一种解法：\n\n```js run\nfunction getSecondsToTomorrow() {\n  let now = new Date();\n  let hour = now.getHours();\n  let minutes = now.getMinutes();\n  let seconds = now.getSeconds();\n  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;\n  let totalSecondsInADay = 86400;\n\n  return totalSecondsInADay - totalSecondsToday;\n}\n```\n\n请注意，很多国家有夏令时（DST），因此他们的一天可能有 23 小时或者 25 小时。我们对这些天数要区别对待。",
        "parent": "date",
        "version": 1
      }
    },
    "format-date-relative": {
      "type": "Task",
      "value": {
        "title": "格式化相对日期",
        "slug": "format-date-relative",
        "githubPath": "/1-js/05-data-types/11-date/8-format-date-relative",
        "weight": 8,
        "libs": [],
        "importance": 4,
        "content": "\n\n写一个函数 `formatDate(date)`，能够对 `date` 进行如下格式化：\n\n- 如果 `date` 距离现在不到 1 秒，输出 `\"right now\"`。\n- 否则，如果 `date` 距离现在不到 1 分钟，输出 `\"n sec. ago\"`。\n- 否则，如果不到 1 小时，输出 `\"m min. ago\"`。\n- 否则，以 `\"DD.MM.YY HH:mm\"` 格式输出完整日期。即：`\"day.month.year hours:minutes\"`，全部以两位数格式表示，例如：`31.12.16 10:00`。\n\n举个例子：\n\n```js\nalert( formatDate(new Date(new Date - 1)) ); // \"right now\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 sec. ago\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 min. ago\"\n\n// 昨天的日期，例如 31.12.16 20:00\nalert( formatDate(new Date(new Date - 86400 * 1000)) );\n```",
        "solution": "为了获取 `date` 距离当前时间的间隔 —— 我们将两个日期相减。\n\n```js run demo\nfunction formatDate(date) {\n  let diff = new Date() - date; // 以毫秒表示的差值\n\n  if (diff < 1000) { // 少于 1 秒\n    return 'right now';\n  }\n\n  let sec = Math.floor(diff / 1000); // 将 diff 转换为秒\n\n  if (sec < 60) {\n    return sec + ' sec. ago';\n  }\n\n  let min = Math.floor(diff / 60000); // 将 diff 转换为分钟\n  if (min < 60) {\n    return min + ' min. ago';\n  }\n\n  // 格式化 date\n  // 将前置 0 加到一位数 day/month/hours/minutes 前\n  let d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ].map(component => component.slice(-2)); // 得到每个组件的后两位\n\n  // 将时间信息和日期组合在一起\n return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}\n\nalert( formatDate(new Date(new Date - 1)) ); // \"right now\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 sec. ago\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 min. ago\"\n\n// 昨天的日期如：31.12.2016 20:00\nalert( formatDate(new Date(new Date - 86400 * 1000)) );\n```\n\n另一种解法：\n\n```js run\nfunction formatDate(date) {\n  let dayOfMonth = date.getDate();\n  let month = date.getMonth() + 1;\n  let year = date.getFullYear();\n  let hour = date.getHours();\n  let minutes = date.getMinutes();\n  let diffMs = new Date() - date;\n  let diffSec = Math.round(diffMs / 1000);\n  let diffMin = diffSec / 60;\n  let diffHour = diffMin / 60;\n\n  // 格式化\n  year = year.toString().slice(-2);\n  month = month < 10 ? '0' + month : month;\n  dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;\n  hour = hour < 10 ? '0' + hour : hour;\n  minutes = minutes < 10 ? '0' + minutes : minutes;\n\n  if (diffSec < 1) {\n    return 'right now';  \n  } else if (diffMin < 1) {\n    return `${diffSec} sec. ago`\n  } else if (diffHour < 1) {\n    return `${diffMin} min. ago`\n  } else {\n    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`\n  }\n}\n```",
        "solutionJs": "\nfunction formatDate(date) {\n  let diff = new Date() - date; // the difference in milliseconds\n\n  if (diff < 1000) { // less than 1 second\n    return 'right now';\n  }\n\n  let sec = Math.floor(diff / 1000); // convert diff to seconds\n\n  if (sec < 60) {\n    return sec + ' sec. ago';\n  }\n\n  let min = Math.floor(diff / 60000); // convert diff to minutes\n  if (min < 60) {\n    return min + ' min. ago';\n  }\n\n  // format the date\n  // add leading zeroes to single-digit day/month/hours/minutes\n  let d = date;\n  d = [\n    '0' + d.getDate(),\n    '0' + (d.getMonth() + 1),\n    '' + d.getFullYear(),\n    '0' + d.getHours(),\n    '0' + d.getMinutes()\n  ].map(component => component.slice(-2)); // take last 2 digits of every component\n\n  // join the components into date\n  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');\n}\n",
        "parent": "date",
        "version": 1
      }
    },
    "json": {
      "type": "Article",
      "value": {
        "title": "JSON 方法，toJSON",
        "slug": "json",
        "githubPath": "/1-js/05-data-types/12-json",
        "isFolder": false,
        "weight": 12,
        "content": "\n\n假设我们有一个复杂的对象，我们希望将其转换为字符串，以通过网络发送，或者只是为了在日志中输出它。\n\n当然，这样的字符串应该包含所有重要的属性。\n\n我们可以像这样实现转换：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n\n*!*\n  toString() {\n    return `{name: \"${this.name}\", age: ${this.age}}`;\n  }\n*/!*\n};\n\nalert(user); // {name: \"John\", age: 30}\n```\n\n……但在开发过程中，会新增一些属性，旧的属性会被重命名和删除。每次更新这种 `toString` 都会非常痛苦。我们可以尝试遍历其中的属性，但是如果对象很复杂，并且在属性中嵌套了对象呢？我们也需要对它们进行转换。\n\n幸运的是，不需要编写代码来处理所有这些问题。这项任务已经解决了。\n\n## JSON.stringify\n\n[JSON](https://en.wikipedia.org/wiki/JSON)（JavaScript Object Notation）是表示值和对象的通用格式。在 [RFC 4627](https://tools.ietf.org/html/rfc4627) 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby/PHP/Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。\n\nJavaScript 提供了如下方法：\n\n- `JSON.stringify` 将对象转换为 JSON。\n- `JSON.parse` 将 JSON 转换回对象。\n\n例如，在这里我们 `JSON.stringify` 一个 `student` 对象：\n```js run\nlet student = {\n  name: 'John',\n  age: 30,\n  isAdmin: false,\n  courses: ['html', 'css', 'js'],\n  spouse: null\n};\n\n*!*\nlet json = JSON.stringify(student);\n*/!*\n\nalert(typeof json); // we've got a string!\n\nalert(json);\n*!*\n/* JSON 编码的对象：\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"isAdmin\": false,\n  \"courses\": [\"html\", \"css\", \"js\"],\n  \"spouse\": null\n}\n*/\n*/!*\n```\n\n方法 `JSON.stringify(student)` 接收对象并将其转换为字符串。\n\n得到的 `json` 字符串是一个被称为 **JSON 编码（JSON-encoded）** 或 **序列化（serialized）** 或 **字符串化（stringified）** 或 **编组化（marshalled）** 的对象。我们现在已经准备好通过有线发送它或将其放入普通数据存储。\n\n\n请注意，JSON 编码的对象与对象字面量有几个重要的区别：\n\n- 字符串使用双引号。JSON 中没有单引号或反引号。所以 `'John'` 被转换为 `\"John\"`。\n- 对象属性名称也是双引号的。这是强制性的。所以 `age:30` 被转换成 `\"age\":30`。\n\n`JSON.stringify` 也可以应用于原始（primitive）数据类型。\n\nJSON 支持以下数据类型：\n\n- Objects `{ ... }`\n- Arrays `[ ... ]`\n- Primitives：\n    - strings，\n    - numbers，\n    - boolean values `true/false`，\n    - `null`。\n\n例如：\n\n```js run\n// 数字在 JSON 还是数字\nalert( JSON.stringify(1) ) // 1\n\n// 字符串在 JSON 中还是字符串，只是被双引号扩起来\nalert( JSON.stringify('test') ) // \"test\"\n\nalert( JSON.stringify(true) ); // true\n\nalert( JSON.stringify([1, 2, 3]) ); // [1,2,3]\n```\n\nJSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 `JSON.stringify` 跳过。\n\n即：\n\n- 函数属性（方法）。\n- Symbol 类型的键和值。\n- 存储 `undefined` 的属性。\n\n```js run\nlet user = {\n  sayHi() { // 被忽略\n    alert(\"Hello\");\n  },\n  [Symbol(\"id\")]: 123, // 被忽略\n  something: undefined // 被忽略\n};\n\nalert( JSON.stringify(user) ); // {}（空对象）\n```\n\n通常这很好。如果这不是我们想要的方式，那么我们很快就会看到如何自定义转换方式。\n\n最棒的是支持嵌套对象转换，并且可以自动对其进行转换。\n\n例如：\n\n```js run\nlet meetup = {\n  title: \"Conference\",\n*!*\n  room: {\n    number: 23,\n    participants: [\"john\", \"ann\"]\n  }\n*/!*\n};\n\nalert( JSON.stringify(meetup) );\n/* 整个结构都被字符串化了\n{\n  \"title\":\"Conference\",\n  \"room\":{\"number\":23,\"participants\":[\"john\",\"ann\"]},\n}\n*/\n```\n\n重要的限制：不得有循环引用。\n\n例如：\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [\"john\", \"ann\"]\n};\n\nmeetup.place = room;       // meetup 引用了 room\nroom.occupiedBy = meetup; // room 引用了 meetup\n\n*!*\nJSON.stringify(meetup); // Error: Converting circular structure to JSON\n*/!*\n```\n\n在这里，转换失败了，因为循环引用：`room.occupiedBy` 引用了 `meetup`，`meetup.place` 引用了 `room`：\n\n![](json-meetup.svg)\n\n\n## 排除和转换：replacer\n\n`JSON.stringify` 的完整语法是：\n\n```js\nlet json = JSON.stringify(value[, replacer, space])\n```\n\nvalue\n: 要编码的值。\n\nreplacer\n: 要编码的属性数组或映射函数 `function(key, value)`。\n\nspace\n: 用于格式化的空格数量\n\n大部分情况，`JSON.stringify` 仅与第一个参数一起使用。但是，如果我们需要微调替换过程，比如过滤掉循环引用，我们可以使用 `JSON.stringify` 的第二个参数。\n\n如果我们传递一个属性数组给它，那么只有这些属性会被编码。\n\n例如：\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup 引用了 room\n};\n\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nalert( JSON.stringify(meetup, *!*['title', 'participants']*/!*) );\n// {\"title\":\"Conference\",\"participants\":[{},{}]}\n```\n\n这里我们可能过于严格了。属性列表应用于了整个对象结构。所以 `participants` 是空的，因为 `name` 不在列表中。\n\n让我们包含除了会导致循环引用的 `room.occupiedBy` 之外的所有属性：\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup 引用了 room\n};\n\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nalert( JSON.stringify(meetup, *!*['title', 'participants', 'place', 'name', 'number']*/!*) );\n/*\n{\n  \"title\":\"Conference\",\n  \"participants\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```\n\n现在，除 `occupiedBy` 以外的所有内容都被序列化了。但是属性的列表太长了。\n\n幸运的是，我们可以使用一个函数代替数组作为 `replacer`。\n\n该函数会为每个 `(key,value)` 对调用并返回“已替换”的值，该值将替换原有的值。如果值被跳过了，则为 `undefined`。\n\n在我们的例子中，我们可以为 `occupiedBy` 以外的所有内容按原样返回 `value`。为了 `occupiedBy`，下面的代码返回 `undefined`：\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup 引用了 room\n};\n\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`);\n  return (key == 'occupiedBy') ? undefined : value;\n}));\n\n/* key:value pairs that come to replacer:\n:             [object Object]\ntitle:        Conference\nparticipants: [object Object],[object Object]\n0:            [object Object]\nname:         John\n1:            [object Object]\nname:         Alice\nplace:        [object Object]\nnumber:       23\noccupiedBy: [object Object]\n*/\n```\n\n请注意 `replacer` 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。`replacer` 中的 `this` 的值是包含当前属性的对象。\n\n第一个调用很特别。它是使用特殊的“包装对象”制作的：`{\"\": meetup}`。换句话说，第一个 `(key, value)` 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 `\":[object Object]\"` 的原因。\n\n这个理念是为了给 `replacer` 提供尽可能多的功能：如果有必要，它有机会分析并替换/跳过整个对象。\n\n\n## 格式化：space\n\n`JSON.stringify(value, replacer, spaces)` 的第三个参数是用于优化格式的空格数量。\n\n以前，所有字符串化的对象都没有缩进和额外的空格。如果我们想通过网络发送一个对象，那就没什么问题。`space` 参数专门用于调整出更美观的输出。\n\n这里的 `space = 2` 告诉 JavaScript 在多行中显示嵌套的对象，对象内部缩进 2 个空格：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\n\nalert(JSON.stringify(user, null, 2));\n/* 两个空格的缩进：\n{\n  \"name\": \"John\",\n  \"age\": 25,\n  \"roles\": {\n    \"isAdmin\": false,\n    \"isEditor\": true\n  }\n}\n*/\n\n/* 对于 JSON.stringify(user, null, 4) 的结果会有更多缩进：\n{\n    \"name\": \"John\",\n    \"age\": 25,\n    \"roles\": {\n        \"isAdmin\": false,\n        \"isEditor\": true\n    }\n}\n*/\n```\n\n第三个参数也可以是字符串。在这种情况下，字符串用于缩进，而不是空格的数量。\n\n`spaces` 参数仅用于日志记录和美化输出。\n\n## 自定义 \"toJSON\"\n\n像 `toString` 进行字符串转换，对象也可以提供 `toJSON` 方法来进行 JSON 转换。如果可用，`JSON.stringify` 会自动调用它。\n\n例如：\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  date: new Date(Date.UTC(2017, 0, 1)),\n  room\n};\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n*!*\n    \"date\":\"2017-01-01T00:00:00.000Z\",  // (1)\n*/!*\n    \"room\": {\"number\":23}               // (2)\n  }\n*/\n```\n\n在这儿我们可以看到 `date` `(1)` 变成了一个字符串。这是因为所有日期都有一个内建的 `toJSON` 方法来返回这种类型的字符串。\n\n现在让我们为对象 `room` 添加一个自定义的 `toJSON`：\n\n```js run\nlet room = {\n  number: 23,\n*!*\n  toJSON() {\n    return this.number;\n  }\n*/!*\n};\n\nlet meetup = {\n  title: \"Conference\",\n  room\n};\n\n*!*\nalert( JSON.stringify(room) ); // 23\n*/!*\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n*!*\n    \"room\": 23\n*/!*\n  }\n*/\n```\n\n正如我们所看到的，`toJSON` 既可以用于直接调用 `JSON.stringify(room)` 也可以用于当 `room` 嵌套在另一个编码对象中时。\n\n\n## JSON.parse\n\n要解码 JSON 字符串，我们需要另一个方法 [JSON.parse](mdn:js/JSON/parse)。\n\n语法：\n```js\nlet value = JSON.parse(str, [reviver]);\n```\n\nstr\n: 要解析的 JSON 字符串。\n\nreviver\n: 可选的函数 function(key,value)，该函数将为每个 `(key, value)` 对调用，并可以对值进行转换。\n\n例如：\n\n```js run\n// 字符串化数组\nlet numbers = \"[0, 1, 2, 3]\";\n\nnumbers = JSON.parse(numbers);\n\nalert( numbers[1] ); // 1\n```\n\n对于嵌套对象：\n\n```js run\nlet userData = '{ \"name\": \"John\", \"age\": 35, \"isAdmin\": false, \"friends\": [0,1,2,3] }';\n\nlet user = JSON.parse(userData);\n\nalert( user.friends[1] ); // 1\n```\n\nJSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。\n\n以下是手写 JSON 时的典型错误（有时我们必须出于调试目的编写它）：\n\n```js\nlet json = `{\n  *!*name*/!*: \"John\",                     // 错误：属性名没有双引号\n  \"surname\": *!*'Smith'*/!*,               // 错误：值使用的是单引号（必须使用双引号）\n  *!*'isAdmin'*/!*: false                  // 错误：键使用的是单引号（必须使用双引号）\n  \"birthday\": *!*new Date(2000, 2, 3)*/!*, // 错误：不允许使用 \"new\"，只能是裸值\n  \"friends\": [0,1,2,3]              // 这个没问题\n}`;\n```\n\n此外，JSON 不支持注释。向 JSON 添加注释无效。\n\n还有另一种名为 [JSON5](http://json5.org/) 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。\n\n常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。\n\n## 使用 reviver\n\n想象一下，我们从服务器上获得了一个字符串化的 `meetup` 对象。\n\n它看起来像这样：\n\n```js\n// title: (meetup title), date: (meetup date)\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n```\n\n……现在我们需要对它进行 **反序列（deserialize）**，把它转换回 JavaScript 对象。\n\n让我们通过调用 `JSON.parse` 来完成：\n\n```js run\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\nlet meetup = JSON.parse(str);\n\n*!*\nalert( meetup.date.getDate() ); // Error!\n*/!*\n```\n\n啊！报错了！\n\n`meetup.date` 的值是一个字符串，而不是 `Date` 对象。`JSON.parse` 怎么知道应该将字符串转换为 `Date` 呢？\n\n让我们将 reviver 函数传递给 `JSON.parse` 作为第二个参数，该函数按照“原样”返回所有值，但是 `date` 会变成 `Date`：\n\n```js run\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\n*!*\nlet meetup = JSON.parse(str, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n*/!*\n\nalert( meetup.date.getDate() ); // 现在正常运行了！\n```\n\n顺便说一下，这也适用于嵌套对象：\n\n```js run\nlet schedule = `{\n  \"meetups\": [\n    {\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"},\n    {\"title\":\"Birthday\",\"date\":\"2017-04-18T12:00:00.000Z\"}\n  ]\n}`;\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n\n*!*\nalert( schedule.meetups[1].date.getDate() ); // 正常运行了！\n*/!*\n```\n\n\n\n## 总结\n\n- JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。\n- JSON 支持 object，array，string，number，boolean 和 `null`。\n- JavaScript 提供序列化（serialize）成 JSON 的方法 [JSON.stringify](mdn:js/JSON/stringify) 和解析 JSON 的方法 [JSON.parse](mdn:js/JSON/parse)。\n- 这两种方法都支持用于智能读/写的转换函数。\n- 如果一个对象具有 `toJSON`，那么它会被 `JSON.stringify` 调用。",
        "libs": [],
        "children": [
          "serialize-object",
          "serialize-event-circular"
        ],
        "parent": "data-types",
        "updatedAt": 1657705346
      }
    },
    "serialize-object": {
      "type": "Task",
      "value": {
        "title": "将对象转换为 JSON，然后再转换回来",
        "slug": "serialize-object",
        "githubPath": "/1-js/05-data-types/12-json/1-serialize-object",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n将 `user` 转换为 JSON，然后将其转换回到另一个变量。\n\n```js\nlet user = {\n  name: \"John Smith\",\n  age: 35\n};\n```",
        "solution": "```js\nlet user = {\n  name: \"John Smith\",\n  age: 35\n};\n\n*!*\nlet user2 = JSON.parse(JSON.stringify(user));\n*/!*\n```",
        "parent": "json",
        "version": 1
      }
    },
    "serialize-event-circular": {
      "type": "Task",
      "value": {
        "title": "排除反向引用",
        "slug": "serialize-event-circular",
        "githubPath": "/1-js/05-data-types/12-json/2-serialize-event-circular",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n在简单循环引用的情况下，我们可以通过名称排除序列化中违规的属性。\n\n但是，有时我们不能只使用名称，因为它既可能在循环引用中也可能在常规属性中使用。因此，我们可以通过属性值来检查属性。\n\n编写 `replacer` 函数，移除引用 `meetup` 的属性，并将其他所有属性序列化：\n\n```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  occupiedBy: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room\n};\n\n*!*\n// 循环引用\nroom.occupiedBy = meetup;\nmeetup.self = meetup;\n*/!*\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  /* your code */\n}));\n\n/* 结果应该是：\n{\n  \"title\":\"Conference\",\n  \"occupiedBy\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```",
        "solution": "```js run\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  occupiedBy: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room\n};\n\nroom.occupiedBy = meetup;\nmeetup.self = meetup;\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  return (key != \"\" && value == meetup) ? undefined : value;\n}));\n\n/* \n{\n  \"title\":\"Conference\",\n  \"occupiedBy\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n```\n\n这里我们还需要判断 `key==\"\"` 以排除第一个调用时 `value` 是 `meetup` 的情况。",
        "parent": "json",
        "version": 1
      }
    },
    "advanced-functions": {
      "type": "Article",
      "value": {
        "title": "函数进阶内容",
        "slug": "advanced-functions",
        "githubPath": "/1-js/06-advanced-functions",
        "isFolder": true,
        "weight": 6,
        "content": "",
        "libs": [],
        "children": [
          "recursion",
          "rest-parameters-spread",
          "closure",
          "var",
          "global-object",
          "function-object",
          "new-function",
          "settimeout-setinterval",
          "call-apply-decorators",
          "bind",
          "arrow-functions"
        ],
        "parent": "js"
      }
    },
    "recursion": {
      "type": "Article",
      "value": {
        "title": "递归和堆栈",
        "slug": "recursion",
        "githubPath": "/1-js/06-advanced-functions/01-recursion",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n让我们回到函数，进行更深入的研究。\n\n我们的第一个主题是 **递归（recursion）**。\n\n如果你不是刚接触编程，那么你可能已经很熟悉它了，那么你可以跳过这一章。\n\n递归是一种编程模式，在一个任务可以自然地拆分成多个相同类型但更简单的任务的情况下非常有用。或者，在一个任务可以简化为一个简单的行为加上该任务的一个更简单的变体的时候可以使用。或者，就像我们很快会看到的那样，处理某些数据结构。\n\n当一个函数解决一个任务时，在解决的过程中它可以调用很多其它函数。在部分情况下，函数会调用 **自身**。这就是所谓的 **递归**。\n\n## 两种思考方式\n\n简单起见，让我们写一个函数 `pow(x, n)`，它可以计算 `x` 的 `n` 次方。换句话说就是，`x` 乘以自身 `n` 次。\n\n```js\npow(2, 2) = 4\npow(2, 3) = 8\npow(2, 4) = 16\n```\n\n有两种实现方式。\n\n1. 迭代思路：使用 `for` 循环：\n\n    ```js run\n    function pow(x, n) {\n      let result = 1;\n\n      // 再循环中，用 x 乘以 result n 次\n      for (let i = 0; i < n; i++) {\n        result *= x;\n      }\n\n      return result;\n    }\n\n    alert( pow(2, 3) ); // 8\n    ```\n\n2. 递归思路：简化任务，调用自身：\n\n    ```js run\n    function pow(x, n) {\n      if (n == 1) {\n        return x;\n      } else {\n        return x * pow(x, n - 1);\n      }\n    }\n\n    alert( pow(2, 3) ); // 8\n    ```\n\n请注意，递归变体在本质上是不同的。\n\n当 `pow(x, n)` 被调用时，执行分为两个分支：\n\n```js\n              if n==1  = x\n             /\npow(x, n) =\n             \\       \n              else     = x * pow(x, n - 1)\n```\n\n1. 如果 `n == 1`，所有事情都会很简单，这叫做 **基础** 的递归，因为它会立即产生明显的结果：`pow(x, 1)` 等于 `x`。\n2. 否则，我们可以用 `x * pow(x, n - 1)` 表示 `pow(x, n)`。在数学里，可能会写为 <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>。这叫做 **一个递归步骤**：我们将任务转化为更简单的行为（`x` 的乘法）和更简单的同类任务的调用（带有更小的 `n` 的 `pow` 运算）。接下来的步骤将其进一步简化，直到 `n` 达到 `1`。\n\n我们也可以说 `pow` **递归地调用自身** 直到 `n == 1`。\n\n![pow 的递归示意图](recursion-pow.svg)\n\n\n比如，为了计算 `pow(2, 4)`，递归变体经过了下面几个步骤：\n\n1. `pow(2, 4) = 2 * pow(2, 3)`\n2. `pow(2, 3) = 2 * pow(2, 2)`\n3. `pow(2, 2) = 2 * pow(2, 1)`\n4. `pow(2, 1) = 2`\n\n因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果变得显而易见。\n\n````smart header=\"递归通常更短\"\n递归解通常比迭代解更短。\n\n在这儿，我们可以使用条件运算符 `?` 而不是 `if` 语句，从而使 `pow(x, n)` 更简洁并且可读性依然很高：\n\n```js run\nfunction pow(x, n) {\n  return (n == 1) ? x : (x * pow(x, n - 1));\n}\n```\n````\n\n最大的嵌套调用次数（包括首次）被称为 **递归深度**。在我们的例子中，它正好等于 `n`。\n\n最大递归深度受限于 JavaScript 引擎。对我们来说，引擎在最大迭代深度为 10000 及以下时是可靠的，有些引擎可能允许更大的最大深度，但是对于大多数引擎来说，100000 可能就超出限制了。有一些自动优化能够帮助减轻这种情况（尾部调用优化），但目前它们还没有被完全支持，只能用于简单场景。\n\n这就限制了递归的应用，但是递归仍然被广泛使用。有很多任务中，递归思维方式会使代码更简单，更容易维护。\n\n## 执行上下文和堆栈\n\n现在我们来研究一下递归调用是如何工作的。为此，我们会先看看函数底层的工作原理。\n\n有关正在运行的函数的执行过程的相关信息被存储在其 **执行上下文** 中。\n\n[执行上下文](https://tc39.github.io/ecma262/#sec-execution-contexts) 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，`this` 的值（此处我们不使用它），以及其它的一些内部细节。\n\n一个函数调用仅具有一个与其相关联的执行上下文。\n\n当一个函数进行嵌套调用时，将发生以下的事儿：\n\n- 当前函数被暂停；\n- 与它关联的执行上下文被一个叫做 **执行上下文堆栈** 的特殊数据结构保存；\n- 执行嵌套调用；\n- 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。\n\n让我们看看 `pow(2, 3)` 调用期间都发生了什么。\n\n### pow(2, 3)\n\n在调用 `pow(2, 3)` 的开始，执行上下文（context）会存储变量：`x = 2, n = 3`，执行流程在函数的第 `1` 行。\n\n我们将其描绘如下：\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\n这是函数开始执行的时候。条件 `n == 1` 结果为假，所以执行流程进入 `if` 的第二分支。\n\n```js run\nfunction pow(x, n) {\n  if (n == 1) {\n    return x;\n  } else {\n*!*\n    return x * pow(x, n - 1);\n*/!*\n  }\n}\n\nalert( pow(2, 3) );\n```\n\n\n变量相同，但是行改变了，因此现在的上下文是：\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\n为了计算 `x * pow(x, n - 1)`，我们需要使用带有新参数的新的 `pow` 子调用 `pow(2, 2)`。\n\n### pow(2, 2)\n\n为了执行嵌套调用，JavaScript 会在 **执行上下文堆栈** 中记住当前的执行上下文。\n\n这里我们调用相同的函数 `pow`，但这绝对没问题。所有函数的处理都是一样的：\n\n1. 当前上下文被“记录”在堆栈的顶部。\n2. 为子调用创建新的上下文。\n3. 当子调用结束后 —— 前一个上下文被从堆栈中弹出，并继续执行。\n\n下面是进入子调用 `pow(2, 2)` 时的上下文堆栈：\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 2, at line 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\n新的当前执行上下文位于顶部（粗体显示），之前记住的上下文位于下方。\n\n当我们完成子调用后 —— 很容易恢复上一个上下文，因为它既保留了变量，也保留了当时所在代码的确切位置。\n\n```smart\n在上面的图中，我们使用“行（line）”一词，因为在我们的示例中，每一行只有一个子调用，但通常一行代码可能会包含多个子调用，例如 `pow(…) + pow(…) + somethingElse(…)`。\n\n因此，更准确地说，执行是“在子调用之后立即恢复”的。\n```\n\n### pow(2, 1)\n\n重复该过程：在第 `5` 行生成新的子调用，现在的参数是 `x=2`, `n=1`。\n\n新的执行上下文被创建，前一个被压入堆栈顶部：\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 1, at line 1 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 1)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 2, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\n此时，有 2 个旧的上下文和 1 个当前正在运行的 `pow(2, 1)` 的上下文。\n\n### 出口\n\n在执行 `pow(2, 1)` 时，与之前的不同，条件 `n == 1` 为真，因此 `if` 的第一个分支生效：\n\n```js\nfunction pow(x, n) {\n  if (n == 1) {\n*!*\n    return x;\n*/!*\n  } else {\n    return x * pow(x, n - 1);\n  }\n}\n```\n\n此时不再有更多的嵌套调用，所以函数结束，返回 `2`。\n\n函数完成后，就不再需要其执行上下文了，因此它被从内存中移除。前一个上下文恢复到堆栈的顶部：\n\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 2, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 2)</span>\n  </li>\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\n恢复执行 `pow(2, 2)`。它拥有子调用 `pow(2, 1)` 的结果，因此也可以完成 `x * pow(x, n - 1)` 的执行，并返回 `4`。\n\n然后，前一个上下文被恢复：\n\n<ul class=\"function-execution-context-list\">\n  <li>\n    <span class=\"function-execution-context\">Context: { x: 2, n: 3, at line 5 }</span>\n    <span class=\"function-execution-context-call\">pow(2, 3)</span>\n  </li>\n</ul>\n\n当它结束后，我们得到了结果 `pow(2, 3) = 8`。\n\n本示例中的递归深度为：**3**。\n\n从上面的插图我们可以看出，递归深度等于堆栈中上下文的最大数量。\n\n请注意内存要求。上下文占用内存，在我们的示例中，求 `n` 次方需要存储 `n` 个上下文，以供更小的 `n` 值进行计算使用。\n\n而循环算法更节省内存：\n\n```js\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n```\n\n迭代 `pow` 的过程中仅使用了一个上下文用于修改 `i` 和 `result`。它的内存要求小，并且是固定了，不依赖于 `n`。\n\n**任何递归都可以用循环来重写。通常循环变体更有效。**\n\n……但有时重写很难，尤其是函数根据条件使用不同的子调用，然后合并它们的结果，或者分支比较复杂时。而且有些优化可能没有必要，完全不值得。\n\n递归可以使代码更短，更易于理解和维护。并不是每个地方都需要优化，大多数时候我们需要一个好代码，这就是为什么要使用它。\n\n## 递归遍历\n\n递归的另一个重要应用就是递归遍历。\n\n假设我们有一家公司。人员结构可以表示为一个对象：\n\n```js\nlet company = {\n  sales: [{\n    name: 'John',\n    salary: 1000\n  }, {\n    name: 'Alice',\n    salary: 1600\n  }],\n\n  development: {\n    sites: [{\n      name: 'Peter',\n      salary: 2000\n    }, {\n      name: 'Alex',\n      salary: 1800\n    }],\n\n    internals: [{\n      name: 'Jack',\n      salary: 1300\n    }]\n  }\n};\n```\n\n换句话说，一家公司有很多部门。\n\n- 一个部门可能有一 **数组** 的员工，比如，`sales` 部门有 2 名员工：John 和 Alice。\n- 或者，一个部门可能会划分为几个子部门，比如 `development` 有两个分支：`sites` 和 `internals`，它们都有自己的员工。\n- 当一个子部门增长时，它也有可能被拆分成几个子部门（或团队）。\n\n    例如，`sites` 部门在未来可能会分为 `siteA` 和 `siteB`。并且，它们可能会被再继续拆分。没有图示，脑补一下吧。\n\n现在，如果我们需要一个函数来获取所有薪资的总数。我们该怎么做？\n\n迭代方式并不容易，因为结构比较复杂。首先想到的可能是在 `company` 上使用 `for` 循环，并在第一层部分上嵌套子循环。但是，之后我们需要更多的子循环来遍历像 `sites` 这样的二级部门的员工…… 然后，将来可能会出现在三级部门上的另一个子循环？如果我们在代码中写 3-4 级嵌套的子循环来遍历单个对象， 那代码得多丑啊。\n\n我们试试递归吧。\n\n我们可以看到，当我们的函数对一个部门求和时，有两种可能的情况：\n\n1. 要么是由一 **数组** 的人组成的“简单”的部门 —— 这样我们就可以通过一个简单的循环来计算薪资的总和。\n2. 或者它是一个有 `N` 个子部门的 **对象** —— 那么我们可以通过 `N` 层递归调用来求每一个子部门的薪资，然后将它们合并起来。\n\n第一种情况是由一数组的人组成的部门，这种情况很简单，是最基础的递归。\n\n第二种情况是我们得到的是对象。那么可将这个复杂的任务拆分成适用于更小部门的子任务。它们可能会被继续拆分，但很快或者不久就会拆分到第一种情况那样。\n\n这个算法从代码来看可能会更简单：\n\n\n```js run\nlet company = { // 是同一个对象，简洁起见被压缩了\n  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],\n  development: {\n    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],\n    internals: [{name: 'Jack', salary: 1300}]\n  }\n};\n\n// 用来完成任务的函数\n*!*\nfunction sumSalaries(department) {\n  if (Array.isArray(department)) { // 情况（1）\n    return department.reduce((prev, current) => prev + current.salary, 0); // 求数组的和\n  } else { // 情况（2）\n    let sum = 0;\n    for (let subdep of Object.values(department)) {\n      sum += sumSalaries(subdep); // 递归调用所有子部门，对结果求和\n    }\n    return sum;\n  }\n}\n*/!*\n\nalert(sumSalaries(company)); // 7700\n```\n\n代码很短也容易理解（希望是这样？）。这就是递归的能力。它适用于任何层次的子部门嵌套。\n\n下面是调用图：\n\n![递归 salaries 的示意图](recursive-salaries.svg)\n\n我们可以很容易地看到其原理：对于对象 `{...}` 会生成子调用，而数组 `[...]` 是递归树的“叶子”，它们会立即给出结果。\n\n请注意，该代码使用了我们之前讲过的智能特性（smart features）：\n\n- 在 <info:array-methods> 中我们介绍过的数组求和方法 `arr.reduce`。\n- 使用循环 `for(val of Object.values(obj))` 遍历对象的（属性）值：`Object.values` 返回它们组成的数组。\n\n\n## 递归结构\n\n递归（递归定义的）数据结构是一种部分复制自身的结构。\n\n我们刚刚在上面的公司结构的示例中看过了它。\n\n一个公司的 **部门** 是：\n- 一数组的人。\n- 或一个 **部门** 对象。\n\n对于 Web 开发者而言，有更熟知的例子：HTML 和 XML 文档。\n\n在 HTML 文档中，一个 **HTML 标签** 可能包括以下内容：\n- 文本片段。\n- HTML 注释。\n- 其它 **HTML 标签**（它有可能又包括文本片段、注释或其它标签等）。\n\n这又是一个递归定义。\n\n为了更好地理解递归，我们再讲一个递归结构的例子“链表”，在某些情况下，它可能是优于数组的选择。\n\n### 链表\n\n想象一下，我们要存储一个有序的对象列表。\n\n正常的选择会是一个数组：\n\n```js\nlet arr = [obj1, obj2, obj3];\n```\n\n……但是用数组有个问题。“删除元素”和“插入元素”的操作代价非常大。例如，`arr.unshift(obj)` 操作必须对所有元素重新编号以便为新的元素 `obj` 腾出空间，而且如果数组很大，会很耗时。`arr.shift()` 同理。\n\n唯一对数组结构做修改而不需要大量重排的操作就是对数组末端的操作：`arr.push/pop`。因此，对于大队列来说，当我们必须对数组首端的元素进行操作时，数组会很慢。（译注：此处的首端操作其实指的是在尾端以外的数组内的元素进行插入/删除操作。）\n\n如果我们确实需要快速插入/删除，则可以选择另一种叫做 [链表](https://en.wikipedia.org/wiki/Linked_list) 的数据结构。\n\n**链表元素** 是一个使用以下元素通过递归定义的对象：\n- `value`。\n- `next` 属性引用下一个 **链表元素** 或者代表末尾的 `null`。\n\n例如：\n\n```js\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n```\n\n链表的图形表示：\n\n![链表](linked-list.svg)\n\n一段用来创建链表的代码：\n\n```js no-beautify\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\nlist.next.next.next.next = null;\n```\n\n在这儿我们可以清楚地看到，这里有很多个对象，每一个都有 `value` 和指向邻居的 `next`。变量 `list` 是链条中的第一个对象，因此顺着 `next` 指针，我们可以抵达任何元素。\n\n该链表可以很容易被拆分为多个部分，然后再重新组装回去：\n\n```js\nlet secondList = list.next.next;\nlist.next.next = null;\n```\n\n![链表分割](linked-list-split.svg)\n\n合并：\n\n```js\nlist.next.next = secondList;\n```\n\n当然，我们可以在任何位置插入或移除元素。\n\n比如，要添加一个新值，我们需要更新链表的头：\n\n```js\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\n\n*!*\n// 将新值添加到链表头部\nlist = { value: \"new item\", next: list };\n*/!*\n```\n\n![链表](linked-list-0.svg)\n\n要从中间删除一个值，可以修改前一个元素的 `next`：\n\n```js\nlist.next = list.next.next;\n```\n\n![链表](linked-list-remove-1.svg)\n\n我们让 `list.next` 从 `1` 跳到值 `2`。现在值 `1` 就被从链表中移除了。如果它没有被存储在其它任何地方，那么它会被自动从内存中删除。\n\n与数组不同，链表没有大规模重排，我们可以很容易地重新排列元素。\n\n当然，链表也不总是优于数组的。不然大家就都去使用链表了。\n\n链表主要的缺点就是我们无法很容易地通过元素的编号获取元素。但在数组中却很容易：`arr[n]` 是一个直接引用。而在链表中，我们需要从起点元素开始，顺着 `next` 找 `N` 次才能获取到第 N 个元素。\n\n……但是我们也并不是总需要这样的操作。比如，当我们需要一个队列甚至一个 [双向队列](https://en.wikipedia.org/wiki/Double-ended_queue) —— 有序结构必须可以快速地从两端添加/移除元素，但是不需要访问的元素。\n\n链表可以得到增强：\n- 我们可以在 `next` 之外，再添加 `prev` 属性来引用前一个元素，以便轻松地往回移动。\n- 我们还可以添加一个名为 `tail` 的变量，该变量引用链表的最后一个元素（并在从末尾添加/删除元素时对该引用进行更新）。\n- ……数据结构可能会根据我们的需求而变化。\n\n## 总结\n\n术语：\n- **递归** 是编程的一个术语，表示从自身调用函数（译注：也就是自调用）。递归函数可用于以更优雅的方式解决问题。\n\n    当一个函数调用自身时，我们称其为 **递归步骤**。递归的 **基础** 是函数参数使任务简单到该函数不再需要进行进一步调用。\n\n- [递归定义](https://en.wikipedia.org/wiki/Recursive_data_type) 的数据结构是指可以使用自身来定义的数据结构。\n\n    例如，链表可以被定义为由对象引用一个列表（或 `null`）而组成的数据结构。\n\n    ```js\n    list = { value, next -> list }\n    ```\n\n    像 HTML 元素树或者本章中的  `department` 树等，本质上也是递归：它们有分支，而且分支又可以有其他分支。\n\n    就像我们在示例 `sumSalary` 中看到的那样，可以使用递归函数来遍历它们。\n\n任何递归函数都可以被重写为迭代（译注：也就是循环）形式。有时这是在优化代码时需要做的。但对于大多数任务来说，递归方法足够快，并且容易编写和维护。",
        "libs": [],
        "children": [
          "sum-to",
          "factorial",
          "fibonacci-numbers",
          "output-single-linked-list",
          "output-single-linked-list-reverse"
        ],
        "headHtml": "<style>\n.function-execution-context-list {\n  margin: 0;\n  padding: 0;\n  overflow: auto;\n}\n\n.function-execution-context {\n  border: 1px solid black;\n  font-family: 'DejaVu Sans Mono', 'Lucida Console', 'Menlo', 'Monaco', monospace;\n  padding: 4px 6px;\n  margin: 0 4px;\n}\n\n.function-execution-context-call {\n  color: gray;\n}\n\n.function-execution-context-call::before {\n  content: ' call: ';\n}\n\n.function-execution-context-list li:first-child {\n  font-weight: bold;\n}\n</style>\n",
        "parent": "advanced-functions",
        "updatedAt": 1675348125
      }
    },
    "sum-to": {
      "type": "Task",
      "value": {
        "title": "对数字求和到给定值",
        "slug": "sum-to",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/01-sum-to",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写一个函数 `sumTo(n)` 计算 `1 + 2 + ... + n` 的和。\n\n举个例子：\n\n```js no-beautify\nsumTo(1) = 1\nsumTo(2) = 2 + 1 = 3\nsumTo(3) = 3 + 2 + 1 = 6\nsumTo(4) = 4 + 3 + 2 + 1 = 10\n...\nsumTo(100) = 100 + 99 + ... + 2 + 1 = 5050\n```\n\n用三种方式实现：\n\n1. 使用循环。\n2. 使用递归，对 `n > 1` 执行 `sumTo(n) = n + sumTo(n-1)`。\n3. 使用 [等差数列](https://en.wikipedia.org/wiki/Arithmetic_progression) 求和公式.\n\n结果示例：\n\n```js\nfunction sumTo(n) { /*... 你的代码 ... */ }\n\nalert( sumTo(100) ); // 5050\n```\n\nP.S. 哪种解决方式最快？哪种最慢？为什么？\n\nP.P.S. 我们可以使用递归来计算 `sumTo(100000)` 吗？",
        "solution": "使用循环的解法：\n\n```js run\nfunction sumTo(n) {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\nalert( sumTo(100) );\n```\n\n使用递归的解法：\n\n```js run\nfunction sumTo(n) {\n  if (n == 1) return 1;\n  return n + sumTo(n - 1);\n}\n\nalert( sumTo(100) );\n```\n\n使用公式 `sumTo(n) = n*(n+1)/2` 的解法：\n\n```js run\nfunction sumTo(n) {\n  return n * (n + 1) / 2;\n}\n\nalert( sumTo(100) );\n```\n\nP.S. 当然是公式解法最快。对任何数字 `n`，只需要进行 3 次运算。数学大法好！\n\n循环的速度次之。在循环和递归方法里，我们对相同的数字求和。但是递归涉及嵌套调用和执行堆栈管理。这也会占用资源，因此递归的速度更慢一些。\n\nP.P.S. 一些引擎支持“尾调用（tail call）”优化：如果递归调用是函数中的最后一个调用（例如上面的 `sumTo`），那么外部的函数就不再需要恢复执行，因此引擎也就不再需要记住他的执行上下文。这样就减轻了内存负担，因此计算 `sumTo(100000)` 就变得可能。但是如果你的 JavaScript 引擎不支持尾调用优化，那就会报错：超出最大堆栈深度，因为通常总堆栈的大小是有限制的。",
        "parent": "recursion",
        "version": 1
      }
    },
    "factorial": {
      "type": "Task",
      "value": {
        "title": "计算阶乘",
        "slug": "factorial",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/02-factorial",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n自然数的 [阶乘](https://en.wikipedia.org/wiki/Factorial) 是指，一个数乘以 `数字减去 1`，然后乘以 `数字减去 2`，以此类推直到乘以 `1`。`n` 的阶乘被记作 `n!`。\n\n我们可以将阶乘的定义写成这样：\n\n```js\nn! = n * (n - 1) * (n - 2) * ...*1\n```\n\n不同 `n` 的阶乘的值：\n\n```js\n1! = 1\n2! = 2 * 1 = 2\n3! = 3 * 2 * 1 = 6\n4! = 4 * 3 * 2 * 1 = 24\n5! = 5 * 4 * 3 * 2 * 1 = 120\n```\n\n任务是编写一个函数 `factorial(n)` 使用递归调用计算 `n!`。\n\n```js\nalert( factorial(5) ); // 120\n```\n\nP.S. 提示：`n!` 可以被写成 `n * (n-1)!`，比如 `3! = 3*2! = 3*2*1! = 6`。",
        "solution": "根据定义，阶乘 `n!` 可以被写成 `n * (n-1)!`。\n\n换句话说，`factorial(n)` 的结果可以用 `n` 乘以 `factorial(n-1)` 的结果来获得。对 `n-1` 的调用同理可以依次地递减，直到 `1`。\n\n```js run\nfunction factorial(n) {\n  return (n != 1) ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```\n\n递归的基础是数值 `1`。我们也可以用 `0` 作为基础，不影响，除了会多一次递归步骤：\n\n```js run\nfunction factorial(n) {\n  return n ? n * factorial(n - 1) : 1;\n}\n\nalert( factorial(5) ); // 120\n```",
        "parent": "recursion",
        "version": 1
      }
    },
    "fibonacci-numbers": {
      "type": "Task",
      "value": {
        "title": "斐波那契数",
        "slug": "fibonacci-numbers",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/03-fibonacci-numbers",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n[斐波那契数](https://en.wikipedia.org/wiki/Fibonacci_number) 序列有这样的公式： <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>。换句话说，下一个数字是前两个数字的和。\n\n前两个数字是 `1`，然后是 `2(1+1)`，然后 `3(1+2)`，`5(2+3)` 等：`1, 1, 2, 3, 5, 8, 13, 21...`。\n\n斐波那契数与 [黄金比例](https://en.wikipedia.org/wiki/Golden_ratio) 以及我们周围的许多自然现象有关。\n\n编写一个函数 `fib(n)` 返回第 `n` 个斐波那契数。\n\n工作示例：\n\n```js\nfunction fib(n) { /* 你的代码 */ }\n\nalert(fib(3)); // 2\nalert(fib(7)); // 13\nalert(fib(77)); // 5527939700884757\n```\n\nP.S. 函数运行速度要快，对 `fib(77)` 的调用不应该超过几分之一秒。",
        "solution": "我们可以尝试的第一种解法是递归。\n\n斐波那契数根据定义是递归的：\n\n```js run\nfunction fib(n) {\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\n// fib(77); // 超级慢！\n```\n\n……但是 `n` 比较大时会很慢。比如 `fib(77)` 会挂起引擎一段时间，并且消耗所有 CPU 资源。\n\n因为函数产生了太多的子调用。同样的值被一遍又一遍地计算。\n\n例如，我们看下计算 `fib(5)` 的片段：\n\n```js no-beautify\n...\nfib(5) = fib(4) + fib(3)\nfib(4) = fib(3) + fib(2)\n...\n```\n\n可以看到，`fib(5)` 和 `fib(4)` 都需要 `fib(3)` 的值，所以 `fib(3)` 被独立计算了两次。\n\n这是完整的递归树：\n\n![斐波那契递归树](fibonacci-recursion-tree.svg)\n\n我们可以清楚的看到 `fib(3)` 被计算了两次，`fib(2)` 被计算了三次。总计算量远远超过了 `n`，这造成仅仅对于计算 `n=77` 来讲，计算量就是巨量的。\n\n我们可以通过记录已经计算过的值来进行优化：如果一个值比如 `fib(3)` 已经被计算过一次，那么我们可以在后面的计算中重复使用它。\n\n另一个选择就是不使用递归，而是使用完全不同的基于循环的算法。\n\n与从 `n` 到降到更小的值相反，我们可以使用循环从 `1` 和 `2` 开始，然后得到它们的和 `fib(3)`，然后再通过前两个数的和得到 `fib(4)`，然后 `fib(5)`，以此类推，直至达到所需要的值。在每一步，我们只需要记录前两个值就可以。\n\n下面是新算法的细节步骤：\n\n开始：\n\n```js\n// a = fib(1), b = fib(2)，这些值是根据定义 1 得到的\nlet a = 1, b = 1;\n\n// 求两者的和得到 c = fib(3)\nlet c = a + b;\n\n/* 现在我们有 fib(1)，fib(2) 和 fib(3)\na  b  c\n1, 1, 2\n*/\n```\n\n现在我们想要得到 `fib(4) = fib(2) + fib(3)`。\n\n我们移动变量：`a,b` 将得到 `fib(2),fib(3)`，`c` 将得到两者的和：\n\n```js no-beautify\na = b; // 现在 a = fib(2)\nb = c; // 现在 b = fib(3)\nc = a + b; // c = fib(4)\n\n/* 现在我们有这样的序列\n   a  b  c\n1, 1, 2, 3\n*/\n```\n\n下一步得到另一个序列数：\n\n```js no-beautify\na = b; // 现在 a = fib(3)\nb = c; // 现在 b = fib(4)\nc = a + b; // c = fib(5)\n\n/* 现在序列是（又加了一个数）：\n      a  b  c\n1, 1, 2, 3, 5\n*/\n```\n\n……依次类推，直到我们得到需要的值。这比递归快很多，而且没有重复计算。\n\n完整代码：\n\n```js run\nfunction fib(n) {\n  let a = 1;\n  let b = 1;\n  for (let i = 3; i <= n; i++) {\n    let c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}\n\nalert( fib(3) ); // 2\nalert( fib(7) ); // 13\nalert( fib(77) ); // 5527939700884757\n```\n\n循环从 `i=3` 开始，因为前两个序列值被硬编码到变量 `a=1`，`b=1`。\n\n这种方式称为 [自下而上的动态规划](https://en.wikipedia.org/wiki/Dynamic_programming)。",
        "parent": "recursion",
        "version": 1
      }
    },
    "output-single-linked-list": {
      "type": "Task",
      "value": {
        "title": "输出一个单链表",
        "slug": "output-single-linked-list",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/04-output-single-linked-list",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n假设我们有一个单链表（在 <info:recursion> 那章有讲过）：\n\n```js\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n```\n\n编写一个可以逐个输出链表元素的函数 `printList(list)`。\n\n使用两种方式实现：循环和递归。\n\n哪个更好：用递归还是不用递归的？",
        "solution": "# 循环解法\n\n基于循环的解法：\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n  let tmp = list;\n\n  while (tmp) {\n    alert(tmp.value);\n    tmp = tmp.next;\n  }\n\n}\n\nprintList(list);\n```\n\n请注意，我们使用了一个临时变量 `tmp` 来遍历链表。从技术上讲，我们可以使用函数的入参 `list` 来代替：\n\n```js\nfunction printList(list) {\n\n  while(*!*list*/!*) {\n    alert(list.value);\n    list = list.next;\n  }\n\n}\n```\n\n……但是这不够明智。未来我们可能想要扩展这个函数，使用这个链表做其他的事儿，如果我们修改了 `list`，那么我们就失去了这个能力。\n\n说到好的变量命名，`list` 在这里是链表本身。代表它的第一个元素。它应该保持原样，这是清晰可靠的。\n\n从另一个方面来说，`tmp` 是充当了完全遍历链表的角色，就像 `for` 循环中的 `i` 一样。\n\n# 递归解法\n\n`printList(list)` 的递归实现遵循一个简单的逻辑：为了输出链表，我们应该输出 `list` 的当前的元素，`list.next` 同理：\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printList(list) {\n\n  alert(list.value); // 输出当前元素\n\n  if (list.next) {\n    printList(list.next); // 链表中其余部分同理\n  }\n\n}\n\nprintList(list);\n```\n\n哪个更好呢？\n\n从技术上讲，循环更有效。这两种解法的做了同样的事儿，但循环不会为嵌套函数调用消耗资源。\n\n另一方面，递归解法更简洁，有时更容易理解。",
        "parent": "recursion",
        "version": 1
      }
    },
    "output-single-linked-list-reverse": {
      "type": "Task",
      "value": {
        "title": "反向输出单链表",
        "slug": "output-single-linked-list-reverse",
        "githubPath": "/1-js/06-advanced-functions/01-recursion/05-output-single-linked-list-reverse",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n反向输出前一个任务 <info:task/output-single-linked-list> 中的单链表。\n\n使用两种解法：循环和递归。",
        "solution": "# 使用递归\n\n递归逻辑在这稍微有点儿棘手。\n\n我们需要先输出列表的其它元素，**然后** 输出当前的元素：\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n\n  if (list.next) {\n    printReverseList(list.next);\n  }\n\n  alert(list.value);\n}\n\nprintReverseList(list);\n```\n\n# 使用循环\n\n循环解法也比直接输出稍微复杂了点儿。\n\n在这而没有什么方法可以获取 `list` 中的最后一个值。我们也不能“从后向前”读取。\n\n因此，我们可以做的就是直接按顺序遍历每个元素，并把它们存到一个数组中，然后反向输出我们存储在数组中的元素：\n\n```js run\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nfunction printReverseList(list) {\n  let arr = [];\n  let tmp = list;\n\n  while (tmp) {\n    arr.push(tmp.value);\n    tmp = tmp.next;\n  }\n\n  for (let i = arr.length - 1; i >= 0; i--) {\n    alert( arr[i] );\n  }\n}\n\nprintReverseList(list);\n```\n\n请注意，递归解法实际上也是这样做的：它顺着链表，记录每一个嵌套调用里链表的元素（在执行上下文堆栈里），然后输出它们。",
        "parent": "recursion",
        "version": 1
      }
    },
    "rest-parameters-spread": {
      "type": "Article",
      "value": {
        "title": "Rest 参数与 Spread 语法",
        "slug": "rest-parameters-spread",
        "githubPath": "/1-js/06-advanced-functions/02-rest-parameters-spread",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n在 JavaScript 中，很多内建函数都支持传入任意数量的参数。\n\n例如：\n\n- `Math.max(arg1, arg2, ..., argN)` —— 返回参数中的最大值。\n- `Object.assign(dest, src1, ..., srcN)` —— 依次将属性从 `src1..N` 复制到 `dest`。\n- ……等。\n\n在本章中，我们将学习如何编写支持传入任意数量参数的函数，以及如何将数组作为参数传递给这类函数。\n\n## Rest 参数 `...`\n\n在 JavaScript 中，无论函数是如何定义的，你都可以在调用它时传入任意数量的参数。\n\n例如：\n```js run\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert( sum(1, 2, 3, 4, 5) );\n```\n\n虽然这里这个函数不会因为传入过多的参数而报错。但是，当然，只有前两个参数被求和了。\n\n我们可以在函数定义中声明一个数组来收集参数。语法是这样的：`...变量名`，这将会声明一个数组并指定其名称，其中存有剩余的参数。这三个点的语义就是“收集剩余的参数并存进指定数组中”。\n\n例如，我们需要把所有的参数都放到数组 `args` 中：\n\n```js run\nfunction sumAll(...args) { // 数组名为 args\n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nalert( sumAll(1) ); // 1\nalert( sumAll(1, 2) ); // 3\nalert( sumAll(1, 2, 3) ); // 6\n```\n\n我们也可以选择将第一个参数获取为变量，并将剩余的参数收集起来。\n\n下面的例子把前两个参数获取为变量，并把剩余的参数收集到 `titles` 数组中：\n\n```js run\nfunction showName(firstName, lastName, ...titles) {\n  alert( firstName + ' ' + lastName ); // Julius Caesar\n\n  // 剩余的参数被放入 titles 数组中\n  // i.e. titles = [\"Consul\", \"Imperator\"]\n  alert( titles[0] ); // Consul\n  alert( titles[1] ); // Imperator\n  alert( titles.length ); // 2\n}\n\nshowName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\");\n```\n\n````warn header=\"Rest 参数必须放到参数列表的末尾\"\nRest 参数会收集剩余的所有参数，因此下面这种用法没有意义，并且会导致错误：\n\n```js\nfunction f(arg1, ...rest, arg2) { // arg2 在 ...rest 后面？！\n  // error\n}\n```\n\n`...rest` 必须写在参数列表最后。\n````\n\n## \"arguments\" 变量\n\n有一个名为 `arguments` 的特殊类数组对象可以在函数中被访问，该对象以参数在参数列表中的索引作为键，存储所有参数。\n\n例如：\n\n```js run\nfunction showName() {\n  alert( arguments.length );\n  alert( arguments[0] );\n  alert( arguments[1] );\n\n  // 它是可遍历的\n  // for(let arg of arguments) alert(arg);\n}\n\n// 依次显示：2，Julius，Caesar\nshowName(\"Julius\", \"Caesar\");\n\n// 依次显示：1，Ilya，undefined（没有第二个参数）\nshowName(\"Ilya\");\n```\n\n在过去，JavaScript 中不支持 rest 参数语法，而使用 `arguments` 是获取函数所有参数的唯一方法。现在它仍然有效，我们可以在一些老代码里找到它。\n\n但缺点是，尽管 `arguments` 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 `arguments.map(...)` 等方法。\n\n此外，它始终包含所有参数，我们不能像使用 rest 参数那样只截取参数的一部分。\n\n因此，当我们需要这些功能时，最好使用 rest 参数。\n\n````smart header=\"箭头函数没有 `\\\"arguments\\\"`\"\n如果我们在箭头函数中访问 `arguments`，访问到的 `arguments` 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。\n\n举个例子：\n\n```js run\nfunction f() {\n  let showArg = () => alert(arguments[0]);\n  showArg();\n}\n\nf(1); // 1\n```\n\n我们已经知道，箭头函数没有自身的 `this`。现在我们知道了它们也没有特殊的 `arguments` 对象。\n````\n\n\n## Spread 语法 [#spread-syntax]\n\n我们刚刚看到了如何从参数列表中获取数组。\n\n有时候我们也需要做与之相反的事。\n\n例如，内建函数 [Math.max](mdn:js/Math/max) 会返回参数中最大的值：\n\n```js run\nalert( Math.max(3, 5, 1) ); // 5\n```\n\n如果我们有一个数组 `[3, 5, 1]`，我们该如何用它调用 `Math.max` 呢？\n\n直接“原样”传入这个数组是不会奏效的，因为 `Math.max` 期望的是列表形式的数值型参数，而不是一个数组：\n\n```js run\nlet arr = [3, 5, 1];\n\n*!*\nalert( Math.max(arr) ); // NaN\n*/!*\n```\n\n毫无疑问，我们不能手动地去一一设置参数 `Math.max(arg[0], arg[1], arg[2])`，因为我们不确定这儿有多少个。在代码执行时，参数数组中可能有很多个元素，也可能一个都没有。而且，这样的代码也很不优雅。\n\n**Spread 语法** 可以解决这个问题！它看起来和 rest 参数很像，也使用 `...`，但是二者的用途完全相反。\n\n当在函数调用中使用 `...arr` 时，它会把可迭代对象 `arr` “展开”到参数列表中。\n\n以 `Math.max` 为例：\n\n```js run\nlet arr = [3, 5, 1];\n\nalert( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）\n```\n\n我们还可以通过这种方式传入多个可迭代对象：\n\n```js run\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(...arr1, ...arr2) ); // 8\n```\n\n我们甚至还可以将 spread 语法与常规值结合使用：\n\n\n```js run\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25\n```\n\n并且，我们还可以使用 spread 语法来合并数组：\n\n```js run\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\n*!*\nlet merged = [0, ...arr, 2, ...arr2];\n*/!*\n\nalert(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是 arr2）\n```\n\n在上面的示例中，我们使用数组展示了 spread 语法，其实我们可以用 spread 语法这样操作任何可迭代对象。\n\n例如，在这儿我们使用 spread 语法将字符串转换为字符数组：\n\n```js run\nlet str = \"Hello\";\n\nalert( [...str] ); // H,e,l,l,o\n```\n\nSpread 语法内部使用了迭代器来收集元素，与 `for..of` 的方式相同。\n\n因此，对于一个字符串，`for..of` 会逐个返回该字符串中的字符，`...str` 也同理会得到 `\"H\",\"e\",\"l\",\"l\",\"o\"` 这样的结果。随后，字符列表被传递给数组初始化器 `[...str]`。\n\n对于这个特定任务，我们还可以使用 `Array.from` 来实现，因为该方法会将一个可迭代对象（如字符串）转换为数组：\n\n```js run\nlet str = \"Hello\";\n\n// Array.from 将可迭代对象转换为数组\nalert( Array.from(str) ); // H,e,l,l,o\n```\n\n运行结果与 `[...str]` 相同。\n\n不过 `Array.from(obj)` 和 `[...obj]` 存在一个细微的差别：\n\n- `Array.from` 适用于类数组对象也适用于可迭代对象。\n- Spread 语法只适用于可迭代对象。\n\n因此，对于将一些“东西”转换为数组的任务，`Array.from` 往往更通用。\n\n\n## 复制 array/object\n\n还记得我们 [之前讲过的](info:object-copy#ke-long-yu-he-bing-objectassign) `Object.assign()` 吗？\n\n使用 spread 语法也可以做同样的事情（译注：也就是进行浅拷贝）。\n\n```js run\nlet arr = [1, 2, 3];\n\n*!*\nlet arrCopy = [...arr]; // 将数组 spread 到参数列表中\n                        // 然后将结果放到一个新数组\n*/!*\n\n// 两个数组中的内容相同吗？\nalert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true\n\n// 两个数组相等吗？\nalert(arr === arrCopy); // false（它们的引用是不同的）\n\n// 修改我们初始的数组不会修改副本：\narr.push(4);\nalert(arr); // 1, 2, 3, 4\nalert(arrCopy); // 1, 2, 3\n```\n\n并且，也可以通过相同的方式来复制一个对象：\n\n```js run\nlet obj = { a: 1, b: 2, c: 3 };\n\n*!*\nlet objCopy = { ...obj }; // 将对象 spread 到参数列表中\n                          // 然后将结果返回到一个新对象\n*/!*\n\n// 两个对象中的内容相同吗？\nalert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true\n\n// 两个对象相等吗？\nalert(obj === objCopy); // false (not same reference)\n\n// 修改我们初始的对象不会修改副本：\nobj.d = 4;\nalert(JSON.stringify(obj)); // {\"a\":1,\"b\":2,\"c\":3,\"d\":4}\nalert(JSON.stringify(objCopy)); // {\"a\":1,\"b\":2,\"c\":3}\n```\n\n这种方式比使用 `let arrCopy = Object.assign([], arr)` 复制数组，或使用 `let objCopy = Object.assign({}, obj)` 复制对象来说更为简便。因此，只要情况允许，我们倾向于使用它。\n\n\n## 总结\n\n当我们在代码中看到 `\"...\"` 时，它要么是 rest 参数，要么是 spread 语法。\n\n有一个简单的方法可以区分它们：\n\n- 若 `...` 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。\n- 若 `...` 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。\n\n使用场景：\n\n- Rest 参数用于创建可接受任意数量参数的函数。\n- Spread 语法用于将数组传递给通常需要含有许多参数的函数。\n\n我们可以使用这两种语法轻松地互相转换列表与参数数组。\n\n旧式的 `arguments`（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1657517544
      }
    },
    "closure": {
      "type": "Article",
      "value": {
        "title": "变量作用域，闭包",
        "slug": "closure",
        "githubPath": "/1-js/06-advanced-functions/03-closure",
        "isFolder": false,
        "weight": 3,
        "content": "\n\nJavaScript 是一种非常面向函数的语言。它给了我们很大的自由度。在 JavaScript 中，我们可以随时创建函数，可以将函数作为参数传递给另一个函数，并在完全不同的代码位置进行调用。\n\n我们已经知道函数可以访问其外部的变量。\n\n但是，如果在函数被创建之后，外部变量发生了变化会怎样？函数会获得新值还是旧值？\n\n如果将函数作为参数（argument）传递并在代码中的另一个位置调用它，该函数将访问的是新位置的外部变量吗？\n\n让我们通过本文来学习这些相关知识，以了解在这些场景以及更复杂的场景下到底会发生什么。\n\n```smart header=\"我们将在这探讨一下 `let/const`\"\n在 JavaScript 中，有三种声明变量的方式：`let`，`const`（现代方式），`var`（过去留下来的方式）。\n\n- 在本文的示例中，我们将使用 `let` 声明变量。\n- 用 `const` 声明的变量的行为也相同（译注：与 `let` 在作用域等特性上是相同的），因此，本文也涉及用 `const` 进行变量声明。\n- 旧的 `var` 与上面两个有着明显的区别，我们将在 <info:var> 中详细介绍。\n```\n\n## 代码块\n\n如果在代码块 `{...}` 内声明了一个变量，那么这个变量只在该代码块内可见。\n\n例如：\n\n```js run\n{\n  // 使用在代码块外不可见的局部变量做一些工作\n\n  let message = \"Hello\"; // 只在此代码块内可见\n\n  alert(message); // Hello\n}\n\nalert(message); // Error: message is not defined\n```\n\n我们可以使用它来隔离一段代码，该段代码执行自己的任务，并使用仅属于自己的变量：\n\n```js run\n{\n  // 显示 message\n  let message = \"Hello\";\n  alert(message);\n}\n\n{\n  // 显示另一个 message\n  let message = \"Goodbye\";\n  alert(message);\n}\n```\n\n````smart header=\"这里如果没有代码块则会报错\"\n请注意，如果我们使用 `let` 对已存在的变量进行重复声明，如果对应的变量没有单独的代码块，则会出现错误：\n\n```js run\n// 显示 message\nlet message = \"Hello\";\nalert(message);\n\n// 显示另一个 message\n*!*\nlet message = \"Goodbye\"; // Error: variable already declared\n*/!*\nalert(message);\n```\n````\n\n对于 `if`，`for` 和 `while` 等，在 `{...}` 中声明的变量也仅在内部可见：\n\n```js run\nif (true) {\n  let phrase = \"Hello!\";\n\n  alert(phrase); // Hello!\n}\n\nalert(phrase); // Error, no such variable!\n```\n\n在这儿，当 `if` 执行完毕，则下面的 `alert` 将看不到 `phrase`，因此会出现错误。（译注：就算下面的 `alert` 想在 `if` 没执行完成时去取 `phrase`（虽然这种情况不可能发生）也是取不到的，因为 `let` 声明的变量在代码块外不可见。）\n\n太好了，因为这就允许我们创建特定于 `if` 分支的块级局部变量。\n\n对于 `for` 和 `while` 循环也是如此：\n\n```js run\nfor (let i = 0; i < 3; i++) {\n  // 变量 i 仅在这个 for 循环的内部可见\n  alert(i); // 0，然后是 1，然后是 2\n}\n\nalert(i); // Error, no such variable\n```\n\n从视觉上看，`let i` 位于 `{...}` 之外。但是 `for` 构造在这里很特殊：在其中声明的变量被视为块的一部分。\n\n## 嵌套函数\n\n如果一个函数是在另一个函数中创建的，该函数就被称为“嵌套”函数。\n\n在 JavaScript 中很容易实现这一点。\n\n我们可以使用嵌套来组织代码，比如这样：\n\n```js\nfunction sayHiBye(firstName, lastName) {\n\n  // 辅助嵌套函数使用如下\n  function getFullName() {\n    return firstName + \" \" + lastName;\n  }\n\n  alert( \"Hello, \" + getFullName() );\n  alert( \"Bye, \" + getFullName() );\n\n}\n```\n\n这里创建的 **嵌套** 函数 `getFullName()` 是为了更加方便。它可以访问外部变量，因此可以返回全名。嵌套函数在 JavaScript 中很常见。\n\n更有意思的是，可以返回一个嵌套函数：作为一个新对象的属性或作为结果返回。之后可以在其他地方使用。不论在哪里调用，它仍然可以访问相同的外部变量。\n\n下面的 `makeCounter` 创建了一个 \"counter\" 函数，该函数在每次调用时返回下一个数字：\n\n```js run\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\nalert( counter() ); // 2\n```\n\n尽管很简单，但稍加变型就具有很强的实际用途，比如，用作 [随机数生成器](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) 以生成用于自动化测试的随机数值。\n\n这是如何运作的呢？如果我们创建多个计数器，它们会是独立的吗？这里的变量是怎么回事？\n\n理解这些内容对于掌握 JavaScript 的整体知识很有帮助，并且对于应对更复杂的场景也很有益处。因此，让我们继续深入探究。\n\n## 词法环境\n\n```warn header=\"前方高能！\"\n一大波深入的技术讲解即将到来。\n\n尽管我很想避免编程语言的一些底层细节，但是如果没有它们，我们就无法完整地理解词法作用域，所以我们这就开始吧！\n```\n\n为了使内容更清晰，这里将分步骤进行讲解。\n\n### Step 1. 变量\n\n在 JavaScript 中，每个运行的函数，代码块 `{...}` 以及整个脚本，都有一个被称为 **词法环境（Lexical Environment）** 的内部（隐藏）的关联对象。\n\n词法环境对象由两部分组成：\n\n1. **环境记录（Environment Record）** —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 `this` 的值）的对象。\n2. 对 **外部词法环境** 的引用，与外部代码相关联。\n\n一个“变量”只是 **环境记录** 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。\n\n举个例子，这段没有函数的简单的代码中只有一个词法环境：\n\n![lexical environment](lexical-environment-global.svg)\n\n这就是所谓的与整个脚本相关联的 **全局** 词法环境。\n\n在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。全局词法环境没有外部引用，所以箭头指向了 `null`。\n\n随着代码开始并继续运行，词法环境发生了变化。\n\n这是更长的代码：\n\n![lexical environment](closure-variable-phrase.svg)\n\n右侧的矩形演示了执行过程中全局词法环境的变化：\n\n1. 当脚本开始运行，词法环境预先填充了所有声明的变量。\n    - 最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 `let` 声明前，不能引用它。几乎就像变量不存在一样。\n2. 然后 `let phrase` 定义出现了。它尚未被赋值，因此它的值为 `undefined`。从这一刻起，我们就可以使用变量了。\n3. `phrase` 被赋予了一个值。\n4. `phrase` 的值被修改。\n\n现在看起来都挺简单的，是吧？\n\n- 变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。\n- 操作变量实际上是操作该对象的属性。\n\n```smart header=\"词法环境是一个规范对象\"\n“词法环境”是一个规范对象（specification object）：它只存在于 [语言规范](https://tc39.es/ecma262/#sec-lexical-environments) 的“理论”层面，用于描述事物是如何工作的。我们无法在代码中获取该对象并直接对其进行操作。\n\n但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。\n```\n\n### Step 2. 函数声明\n\n一个函数其实也是一个值，就像变量一样。\n\n**不同之处在于函数声明的初始化会被立即完成。**\n\n当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 `let` 那样直到声明处才可用）。\n\n这就是为什么我们甚至可以在声明自身之前调用一个以函数声明（Function Declaration）的方式声明的函数。\n\n例如，这是添加一个函数时全局词法环境的初始状态：\n\n![](closure-function-declaration.svg)\n\n正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 `let say = function(name)...`。\n\n### Step 3. 内部和外部的词法环境\n\n在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。\n\n例如，对于 `say(\"John\")`，它看起来像这样（当前执行位置在箭头标记的那一行上）：\n\n<!--\n    ```js\n    let phrase = \"Hello\";\n\n    function say(name) {\n     alert( `${phrase}, ${name}` );\n    }\n\n    say(\"John\"); // Hello, John\n    ```-->\n\n![](lexical-environment-simple.svg)\n\n在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）：\n\n- 内部词法环境与 `say` 的当前执行相对应。它具有一个单独的属性：`name`，函数的参数。我们调用的是 `say(\"John\")`，所以 `name` 的值为 `\"John\"`。\n- 外部词法环境是全局词法环境。它具有 `phrase` 变量和函数本身。\n\n内部词法环境引用了 `outer`。\n\n**当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。**\n\n如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。\n\n在这个示例中，搜索过程如下：\n\n- 对于 `name` 变量，当 `say` 中的 `alert` 试图访问 `name` 时，会立即在内部词法环境中找到它。\n- 当它试图访问 `phrase` 时，然而内部没有 `phrase`，所以它顺着对外部词法环境的引用找到了它。\n\n![lexical environment lookup](lexical-environment-simple-lookup.svg)\n\n\n### Step 4. 返回函数\n\n让我们回到 `makeCounter` 这个例子。\n\n```js\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\n```\n\n在每次 `makeCounter()` 调用的开始，都会创建一个新的词法环境对象，以存储该 `makeCounter` 运行时的变量。\n\n因此，我们有两层嵌套的词法环境，就像上面的示例一样：\n\n![](closure-makecounter.svg)\n\n不同的是，在执行 `makeCounter()` 的过程中创建了一个仅占一行的嵌套函数：`return count++`。我们尚未运行它，仅创建了它。\n\n所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 `[[Environment]]` 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。\n\n![](closure-makecounter-environment.svg)\n\n因此，`counter.[[Environment]]` 有对 `{count: 0}` 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。`[[Environment]]` 引用在函数创建时被设置并永久保存。\n\n稍后，当调用 `counter()` 时，会为该调用创建一个新的词法环境，并且其外部词法环境引用获取于 `counter.[[Environment]]`：\n\n![](closure-makecounter-nested-call.svg)\n\n现在，当 `counter()` 中的代码查找 `count` 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 `makeCounter()` 的词法环境，并且在哪里找到就在哪里修改。\n\n**在变量所在的词法环境中更新变量。**\n\n这是执行后的状态：\n\n![](closure-makecounter-nested-call-2.svg)\n\n如果我们调用 `counter()` 多次，`count` 变量将在同一位置增加到 `2`，`3` 等。\n\n```smart header=\"闭包\"\n开发者通常应该都知道“闭包”这个通用的编程术语。\n\n[闭包](https://en.wikipedia.org/wiki/Closure_(computer_programming)) 是指一个函数可以记住其外部变量并可以访问这些变量。在某些编程语言中，这是不可能的，或者应该以一种特殊的方式编写函数来实现。但如上所述，在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 <info:new-function> 中讲到）。\n\n也就是说：JavaScript 中的函数会自动通过隐藏的 `[[Environment]]` 属性记住创建它们的位置，所以它们都可以访问外部变量。\n\n在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 `[[Environment]]` 属性和词法环境原理的技术细节。\n```\n\n## 垃圾收集\n\n通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。\n\n但是，如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的 `[[Environment]]` 属性。\n\n在下面这个例子中，即使在（外部）函数执行完成后，它的词法环境仍然可达。因此，此词法环境仍然有效。\n\n例如：\n\n```js\nfunction f() {\n  let value = 123;\n\n  return function() {\n    alert(value);\n  }\n}\n\nlet g = f(); // g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用\n```\n\n请注意，如果多次调用 `f()`，并且返回的函数被保存，那么所有相应的词法环境对象也会保留在内存中。下面代码中有三个这样的函数：\n\n```js\nfunction f() {\n  let value = Math.random();\n\n  return function() { alert(value); };\n}\n\n// 数组中的 3 个函数，每个都与来自对应的 f() 的词法环境相关联\nlet arr = [f(), f(), f()];\n```\n\n当词法环境对象变得不可达时，它就会死去（就像其他任何对象一样）。换句话说，它仅在至少有一个嵌套函数引用它时才存在。\n\n在下面的代码中，嵌套函数被删除后，其封闭的词法环境（以及其中的 `value`）也会被从内存中删除：\n\n```js\nfunction f() {\n  let value = 123;\n\n  return function() {\n    alert(value);\n  }\n}\n\nlet g = f(); // 当 g 函数存在时，该值会被保留在内存中\n\ng = null; // ……现在内存被清理了\n```\n\n### 实际开发中的优化\n\n正如我们所看到的，理论上当函数可达时，它外部的所有变量也都将存在。\n\n但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。\n\n**在 V8（Chrome，Edge，Opera）中的一个重要的副作用是，此类变量在调试中将不可用。**\n\n打开 Chrome 浏览器的开发者工具，并尝试运行下面的代码。\n\n当代码执行暂停时，在控制台中输入 `alert(value)`。\n\n```js run\nfunction f() {\n  let value = Math.random();\n\n  function g() {\n    debugger; // 在 Console 中：输入 alert(value); No such variable!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n```\n\n正如你所见的 —— No such variable! 理论上，它应该是可以访问的，但引擎把它优化掉了。\n\n这可能会导致有趣的（如果不是那么耗时的）调试问题。其中之一 —— 我们可以看到的是一个同名的外部变量，而不是预期的变量：\n\n```js run global\nlet value = \"Surprise!\";\n\nfunction f() {\n  let value = \"the closest value\";\n\n  function g() {\n    debugger; // 在 console 中：输入 alert(value); Surprise!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n```\n\nV8 引擎的这个特性你真的应该知道。如果你要使用 Chrome/Edge/Opera 进行代码调试，迟早会遇到这样的问题。\n\n这不是调试器的 bug，而是 V8 的一个特别的特性。也许以后会被修改。你始终可以通过运行本文中的示例来进行检查。\n\n<!--\n\n## 补充内容\n\n```smart header=\"说明\"\n为了更清晰地讲解闭包，本文经过大幅重写，以下内容是重写时部分被优化掉的内容，译者认为还是很有学习价值的，遂保留下来供大家学习。\n```\n\n### 代码块\n\n我们可以使用“空”的代码块将变量隔离到“局部作用域”中。\n\n比如，在 Web 浏览器中，所有脚本都共享同一个全局环境。如果我们在一个脚本中创建一个全局变量，对于其他脚本来说它也是可用的。但是如果两个脚本有使用同一个变量并且相互覆盖，那么这会成为冲突的根源。\n\n如果变量名是一个被广泛使用的词，并且不同脚本的作者可能彼此也不知道。\n\n如果我们要避免这个，我们可以使用代码块来隔离整个脚本或其中一部分：\n\n```js run\n{\n  // 用局部变量完成一些不应该被外面访问的工作\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n}\n\nalert(message); // Error: message is not defined\n```\n\n这是因为代码块有其自身的词法环境，块之外（或另一个脚本内）的代码访问不到代码块内的变量。\n\n-->",
        "libs": [],
        "children": [
          "closure-latest-changes",
          "closure-variable-access",
          "counter-independent",
          "counter-object-independent",
          "function-in-if",
          "closure-sum",
          "let-scope",
          "filter-through-function",
          "sort-by-field",
          "make-army"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1658129578
      }
    },
    "closure-latest-changes": {
      "type": "Task",
      "value": {
        "title": "函数会选择最新的内容吗？",
        "slug": "closure-latest-changes",
        "githubPath": "/1-js/06-advanced-functions/03-closure/1-closure-latest-changes",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n函数 sayHi 使用外部变量。当函数运行时，将使用哪个值？\n\n```js\nlet name = \"John\";\n\nfunction sayHi() {\n  alert(\"Hi, \" + name);\n}\n\nname = \"Pete\";\n\nsayHi(); // 会显示什么：\"John\" 还是 \"Pete\"？\n```\n\n这种情况在浏览器和服务器端开发中都很常见。一个函数可能被计划在创建之后一段时间后才执行，例如在用户行为或网络请求之后。\n\n因此，问题是：它会接收最新的修改吗？",
        "solution": "答案：**Pete**。\n\n函数将从内到外依次在对应的词法环境中寻找目标变量，它使用最新的值。\n\n旧变量值不会保存在任何地方。当一个函数想要一个变量时，它会从自己的词法环境或外部词法环境中获取当前值。",
        "parent": "closure",
        "version": 1
      }
    },
    "make-army": {
      "type": "Task",
      "value": {
        "title": "函数大军",
        "slug": "make-army",
        "githubPath": "/1-js/06-advanced-functions/03-closure/10-make-army",
        "weight": 10,
        "libs": [],
        "importance": 5,
        "content": "\n\n下列的代码创建了一个 `shooters` 数组。\n\n每个函数都应该输出其编号。但好像出了点问题……\n\n```js run\nfunction makeArmy() {\n  let shooters = [];\n\n  let i = 0;\n  while (i < 10) {\n    let shooter = function() { // 创建一个 shooter 函数，\n      alert( i ); // 应该显示其编号\n    };\n    shooters.push(shooter); // 将此 shooter 函数添加到数组中\n    i++;\n  }\n\n  // ……返回 shooters 数组\n  return shooters;\n}\n\nlet army = makeArmy();\n\n*!*\n// ……所有的 shooter 显示的都是 10，而不是它们的编号 0, 1, 2, 3...\narmy[0](); // 编号为 0 的 shooter 显示的是 10\narmy[1](); // 编号为 1 的 shooter 显示的是 10\narmy[2](); // 10，其他的也是这样。\n*/!*\n```\n\n为什么所有的 shooter 显示的都是同样的值？\n\n修改代码以使得代码能够按照我们预期的那样工作。",
        "solution": "让我们检查一下 `makeArmy` 内部到底发生了什么，那样答案就显而易见了。\n\n1. 它创建了一个空数组 `shooters`：\n\n    ```js\n    let shooters = [];\n    ```\n2. 在循环中，通过 `shooters.push(function)` 用函数填充它。\n\n    每个元素都是函数，所以数组看起来是这样的：\n\n    ```js no-beautify\n    shooters = [\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); },\n      function () { alert(i); }\n    ];\n    ```\n\n3. 该数组返回自函数。\n\n    然后，对数组中的任意数组项的调用，例如调用 `army[5]()`（它是一个函数），将首先从数组中获取元素 `army[5]()` 并调用它。\n\n    那么，为什么所有此类函数都显示的是相同的值，`10` 呢？\n\n    这是因为 `shooter` 函数内没有局部变量 `i`。当一个这样的函数被调用时，`i` 是来自于外部词法环境的。\n\n    那么，`i` 的值是什么呢？\n\n    如果我们看一下源代码：\n\n    ```js\n    function makeArmy() {\n      ...\n      let i = 0;\n      while (i < 10) {\n        let shooter = function() { // shooter 函数\n          alert( i ); // 应该显示它自己的编号\n        };\n        shooters.push(shooter); // 将 shooter 函数添加到该数组中\n          i++;\n      }\n      ...\n    }\n    ```\n\n    ……我们可以看到，所有的 `shooter` 函数都是在 `makeArmy()` 的词法环境中被创建的。但当 `army[5]()` 被调用时，`makeArmy` 已经运行完了，最后 `i` 的值为 `10`（`while` 循环在 `i=10` 时停止）。\n\n    因此，所有的 `shooter` 函数获得的都是外部词法环境中的同一个值，即最后的 `i=10`。\n\n    ![](lexenv-makearmy-empty.svg)\n\n    正如你在上边所看到的那样，在 `while {...}` 块的每次迭代中，都会创建一个新的词法环境。因此，要解决此问题，我们可以将 `i` 的值复制到 `while {...}` 块内的变量中，如下所示：\n\n    ```js run\n    function makeArmy() {\n      let shooters = [];\n    \n      let i = 0;\n      while (i < 10) {\n        *!*\n          let j = i;\n        */!*\n          let shooter = function() { // shooter 函数\n            alert( *!*j*/!* ); // 应该显示它自己的编号\n          };\n        shooters.push(shooter);\n        i++;\n      }\n    \n      return shooters;\n    }\n    \n    let army = makeArmy();\n    \n    // 现在代码正确运行了\n    army[0](); // 0\n    army[5](); // 5\n    ```\n\n    在这里，`let j = i` 声明了一个“局部迭代”变量 `j`，并将 `i` 复制到其中。原始类型是“按值”复制的，因此实际上我们得到的是属于当前循环迭代的独立的 `i` 的副本。\n\n    shooter 函数正确运行了，因为 `i` 值的位置更近了（译注：指转到了更内部的词法环境）。不是在 `makeArmy()` 的词法环境中，而是在与当前循环迭代相对应的词法环境中：\n\n    ![](lexenv-makearmy-while-fixed.svg)\n\n    如果我们一开始使用 `for` 循环，也可以避免这样的问题，像这样：\n\n    ```js run demo\n    function makeArmy() {\n    \n      let shooters = [];\n    \n    *!*\n      for(let i = 0; i < 10; i++) {\n    */!*\n        let shooter = function() { // shooter 函数\n          alert( i ); // 应该显示它自己的编号\n        };\n        shooters.push(shooter);\n      }\n    \n      return shooters;\n    }\n    \n    let army = makeArmy();\n    \n    army[0](); // 0\n    army[5](); // 5\n    ```\n\n    这本质上是一样的，因为 `for` 循环在每次迭代中，都会生成一个带有自己的变量 `i` 的新词法环境。因此，在每次迭代中生成的 `shooter` 函数引用的都是自己的 `i`。\n\n    ![](lexenv-makearmy-for-fixed.svg)\n\n至此，你已经花了很长时间来阅读本文，发现最终的解决方案就这么简单 — 使用 `for` 循环，你可能会疑问 —— 我花了这么长时间读这篇文章，值得吗？\n\n其实，如果你可以轻松地明白并答对本题目，你应该就不会阅读它的答案。所以，希望这个题目可以帮助你更好地理解闭包。\n\n此外，确实存在有些人相较于 `for` 更喜欢 `while`，以及其他情况。",
        "solutionJs": "function makeArmy() {\n\n  let shooters = [];\n\n  for(let i = 0; i < 10; i++) {\n    let shooter = function() { // shooter function\n      alert( i ); // should show its number\n    };\n    shooters.push(shooter);\n  }\n\n  return shooters;\n}\n",
        "parent": "closure",
        "version": 1
      }
    },
    "closure-variable-access": {
      "type": "Task",
      "value": {
        "title": "哪些变量可用呢？",
        "slug": "closure-variable-access",
        "githubPath": "/1-js/06-advanced-functions/03-closure/2-closure-variable-access",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面的 `makeWorker` 函数创建了另一个函数并返回该函数。可以在其他地方调用这个新函数。\n\n它是否可以从它被创建的位置或调用位置（或两者）访问外部变量？\n\n```js\nfunction makeWorker() {\n  let name = \"Pete\";\n\n  return function() {\n    alert(name);\n  };\n}\n\nlet name = \"John\";\n\n// 创建一个函数\nlet work = makeWorker();\n\n// 调用它\nwork(); // 会显示什么？\n```\n\n会显示哪个值？\"Pete\" 还是 \"John\"？",
        "solution": "答案：**Pete**.\n\n下方代码中的函数 `work()` 在其被创建的位置通过外部词法环境引用获取 `name`：\n\n![](lexenv-nested-work.svg)\n\n所以这里的结果是 `\"Pete\"`。\n\n但如果在 `makeWorker()` 中没有 `let name`，那么将继续向外搜索并最终找到全局变量，正如我们可以从上图中看到的那样。在这种情况下，结果将是 `\"John\"`。",
        "parent": "closure",
        "version": 1
      }
    },
    "counter-independent": {
      "type": "Task",
      "value": {
        "title": "Counter 是独立的吗？",
        "slug": "counter-independent",
        "githubPath": "/1-js/06-advanced-functions/03-closure/3-counter-independent",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n在这儿我们用相同的 `makeCounter` 函数创建了两个计数器（counters）：`counter` 和 `counter2`。\n\n它们是独立的吗？第二个 counter 会显示什么？`0,1` 或 `2,3` 还是其他？\n\n```js\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\nlet counter2 = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\n\n*!*\nalert( counter2() ); // ?\nalert( counter2() ); // ?\n*/!*\n```",
        "solution": "答案是：**0，1。**\n\n函数 `counter` 和 `counter2` 是通过 `makeCounter` 的不同调用创建的。\n\n因此，它们具有独立的外部词法环境，每一个都有自己的 `count`。",
        "parent": "closure",
        "version": 1
      }
    },
    "counter-object-independent": {
      "type": "Task",
      "value": {
        "title": "Counter 对象",
        "slug": "counter-object-independent",
        "githubPath": "/1-js/06-advanced-functions/03-closure/4-counter-object-independent",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n这里通过构造函数创建了一个 counter 对象。\n\n它能正常工作吗？它会显示什么呢？\n\n```js\nfunction Counter() {\n  let count = 0;\n\n  this.up = function() {\n    return ++count;\n  };\n  this.down = function() {\n    return --count;\n  };\n}\n\nlet counter = new Counter();\n\nalert( counter.up() ); // ?\nalert( counter.up() ); // ?\nalert( counter.down() ); // ?\n```",
        "solution": "当然行得通。\n\n这两个嵌套函数都是在同一个词法环境中创建的，所以它们可以共享对同一个 count 变量的访问：\n\n```js run\nfunction Counter() {\n  let count = 0;\n\n  this.up = function() {\n    return ++count;\n  };\n  \n  this.down = function() {\n    return --count;\n  };\n}\n\nlet counter = new Counter();\n\nalert( counter.up() ); // 1\nalert( counter.up() ); // 2\nalert( counter.down() ); // 1\n```",
        "parent": "closure",
        "version": 1
      }
    },
    "function-in-if": {
      "type": "Task",
      "value": {
        "title": "if 内的函数",
        "slug": "function-in-if",
        "githubPath": "/1-js/06-advanced-functions/03-closure/5-function-in-if",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n看看下面这个代码。最后一行代码的执行结果是什么？\n\n```js run\nlet phrase = \"Hello\";\n\nif (true) {\n  let user = \"John\";\n\n  function sayHi() {\n    alert(`${phrase}, ${user}`);\n  }\n}\n\n*!*\nsayHi();\n*/!*\n```",
        "solution": "答案：**error**。\n\n函数 `sayHi` 是在 `if` 内声明的，所以它只存在于 `if` 中。外部是没有 `sayHi` 的。",
        "parent": "closure",
        "version": 1
      }
    },
    "closure-sum": {
      "type": "Task",
      "value": {
        "title": "闭包 sum",
        "slug": "closure-sum",
        "githubPath": "/1-js/06-advanced-functions/03-closure/6-closure-sum",
        "weight": 6,
        "libs": [],
        "importance": 4,
        "content": "\n\n编写一个像 `sum(a)(b) = a+b` 这样工作的 `sum` 函数。\n\n是的，就是这种通过双括号的方式（并不是错误）。\n\n举个例子：\n\n```js\nsum(1)(2) = 3\nsum(5)(-1) = 4\n```",
        "solution": "为了使第二个括号有效，第一个（括号）必须返回一个函数。\n\n就像这样：\n\n```js run\nfunction sum(a) {\n\n  return function(b) {\n    return a + b; // 从外部词法环境获得 \"a\"\n  };\n\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1) ); // 4\n```",
        "parent": "closure",
        "version": 1
      }
    },
    "let-scope": {
      "type": "Task",
      "value": {
        "title": "变量可见吗？",
        "slug": "let-scope",
        "githubPath": "/1-js/06-advanced-functions/03-closure/7-let-scope",
        "weight": 7,
        "libs": [],
        "importance": 4,
        "content": "\n\n下面这段代码的结果会是什么？\n\n```js\nlet x = 1;\n\nfunction func() {\n  console.log(x); // ?\n\n  let x = 2;\n}\n\nfunc();\n```\n\nP.S. 这个任务有一个陷阱。解决方案并不明显。",
        "solution": "答案：**error**。\n\n你运行一下试试：\n\n```js run\nlet x = 1;\n\nfunction func() {\n*!*\n  console.log(x); // ReferenceError: Cannot access 'x' before initialization\n*/!*\n  let x = 2;\n}\n\nfunc();\n```\n\n在这个例子中，我们可以观察到“不存在”的变量和“未初始化”的变量之间的特殊差异。\n\n你可能已经在 [](info:closure) 中学过了，从程序执行进入代码块（或函数）的那一刻起，变量就开始进入“未初始化”状态。它一直保持未初始化状态，直至程序执行到相应的 `let` 语句。\n\n换句话说，一个变量从技术的角度来讲是存在的，但是在 `let` 之前还不能使用。\n\n下面的这段代码证实了这一点。\n\n```js\nfunction func() {\n*!*\n  // 引擎从函数开始就知道局部变量 x，\n  // 但是变量 x 一直处于“未初始化”（无法使用）的状态，直到结束 let（“死区”）\n  // 因此答案是 error\n*/!*\n\n  console.log(x); // ReferenceError: Cannot access 'x' before initialization\n\n  let x = 2;\n}\n```\n\n变量暂时无法使用的区域（从代码块的开始到 `let`）有时被称为“死区”。",
        "parent": "closure",
        "version": 1
      }
    },
    "filter-through-function": {
      "type": "Task",
      "value": {
        "title": "通过函数筛选",
        "slug": "filter-through-function",
        "githubPath": "/1-js/06-advanced-functions/03-closure/8-filter-through-function",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有一个内建的数组方法 `arr.filter(f)`。它通过函数 `f` 过滤元素。如果它返回 `true`，那么该元素会被返回到结果数组中。\n\n制造一系列“即用型”过滤器：\n\n- `inBetween(a, b)` —— 在 `a` 和 `b` 之间或与它们相等（包括）。\n- `inArray([...])` —— 包含在给定的数组中。\n\n用法如下所示：\n\n- `arr.filter(inBetween(3,6))` —— 只挑选范围在 3 到 6 的值。\n- `arr.filter(inArray([1,2,3]))` —— 只挑选与 `[1,2,3]` 中的元素匹配的元素。\n\n例如：\n\n```js\n/* .. inBetween 和 inArray 的代码 */\nlet arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6\n\nalert( arr.filter(inArray([1, 2, 10])) ); // 1,2\n```",
        "solution": "# inBetween 筛选器\n\n```js run\nfunction inBetween(a, b) {\n  return function(x) {\n    return x >= a && x <= b;\n  };\n}\n\nlet arr = [1, 2, 3, 4, 5, 6, 7];\nalert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6\n```\n\n# inArray 筛选器\n\n```js run demo\nfunction inArray(arr) {\n  return function(x) {\n    return arr.includes(x);\n  };\n}\n\nlet arr = [1, 2, 3, 4, 5, 6, 7];\nalert( arr.filter(inArray([1, 2, 10])) ); // 1,2\n```",
        "solutionJs": "\nfunction inArray(arr) {\n  return x => arr.includes(x);\n}\n\nfunction inBetween(a, b) {\n  return x => (x >= a && x <= b);\n}",
        "parent": "closure",
        "version": 1
      }
    },
    "sort-by-field": {
      "type": "Task",
      "value": {
        "title": "按字段排序",
        "slug": "sort-by-field",
        "githubPath": "/1-js/06-advanced-functions/03-closure/9-sort-by-field",
        "weight": 9,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有一组要排序的对象：\n\n```js\nlet users = [\n  { name: \"John\", age: 20, surname: \"Johnson\" },\n  { name: \"Pete\", age: 18, surname: \"Peterson\" },\n  { name: \"Ann\", age: 19, surname: \"Hathaway\" }\n];\n```\n\n通常的做法应该是这样的：\n\n```js\n// 通过 name (Ann, John, Pete)\nusers.sort((a, b) => a.name > b.name ? 1 : -1);\n\n// 通过 age (Pete, Ann, John)\nusers.sort((a, b) => a.age > b.age ? 1 : -1);\n```\n\n我们可以让它更加简洁吗，比如这样？\n\n```js\nusers.sort(byField('name'));\nusers.sort(byField('age'));\n```\n\n这样我们就只需要写 `byField(fieldName)`，而不是写一个函数。\n\n编写函数 `byField` 来实现这个需求。",
        "solution": "",
        "solutionJs": "function byField(fieldName){\n  return (a, b) => a[fieldName] > b[fieldName] ? 1 : -1;\n}\n",
        "parent": "closure",
        "version": 1
      }
    },
    "var": {
      "type": "Article",
      "value": {
        "title": "老旧的 \"var\"",
        "slug": "var",
        "githubPath": "/1-js/06-advanced-functions/04-var",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n```smart header=\"本文用于帮助理解旧脚本\"\n本文所讲的内容对于帮助理解旧脚本很有用。\n\n但这不是我们编写新代码的方式。\n```\n\n在本教程最开始那部分的 [变量](info:variables) 这章中，我们提到了变量声明的三种方式：\n\n1. `let`\n2. `const`\n3. `var`\n\n`var` 声明与 `let` 相似。大部分情况下，我们可以用 `let` 代替 `var` 或者 `var` 代替 `let`，都能达到预期的效果：\n\n```js run\nvar message = \"Hi\";\nalert(message); // Hi\n```\n\n但实际上 `var` 却是一头非常不同的，源自远古时代的怪兽。在现代脚本中一般不再使用它，但它仍然潜伏在旧脚本中。\n\n如果你不打算接触这样的脚本，你甚至可以跳过本章或推迟阅读本章。\n\n另一方面，了解将旧脚本从 `var` 迁移到 `let` 时的区别，以避免奇怪的错误，是很重要的。\n\n## \"var\" 没有块级作用域\n\n用 `var` 声明的变量，不是函数作用域就是全局作用域。它们在代码块外也是可见的（译注：也就是说，`var` 声明的变量只有函数作用域和全局作用域，没有块级作用域）。\n\n举个例子：\n\n```js run\nif (true) {\n  var test = true; // 使用 \"var\" 而不是 \"let\"\n}\n\n*!*\nalert(test); // true，变量在 if 结束后仍存在\n*/!*\n```\n\n由于 `var` 会忽略代码块，因此我们有了一个全局变量 `test`。\n\n如果我们在第二行使用 `let test` 而不是 `var test`，那么该变量将仅在 `if` 内部可见：\n\n```js run\nif (true) {\n  let test = true; // 使用 \"let\"\n}\n\n*!*\nalert(test); // ReferenceError: test is not defined\n*/!*\n```\n\n对于循环也是这样的，`var` 声明的变量没有块级作用域也没有循环局部作用域：\n\n```js\nfor (var i = 0; i < 10; i++) {\n  var one = 1;\n  // ...\n}\n\n*!*\nalert(i);   // 10，\"i\" 在循环结束后仍可见，它是一个全局变量\nalert(one); // 1，\"one\" 在循环结束后仍可见，它是一个全局变量\n*/!*\n```\n\n如果一个代码块位于函数内部，那么 `var` 声明的变量的作用域将为函数作用域：\n\n```js run\nfunction sayHi() {\n  if (true) {\n    var phrase = \"Hello\";\n  }\n\n  alert(phrase); // 能正常工作\n}\n\nsayHi();\nalert(phrase); // ReferenceError: phrase is not defined\n```\n\n可以看到，`var` 穿透了 `if`，`for` 和其它代码块。这是因为在早期的 JavaScript 中，块没有词法环境，而 `var` 就是这个时期的代表之一。\n\n## \"var\" 允许重新声明\n\n如果我们用 `let` 在同一作用域下将同一个变量声明两次，则会出现错误：\n\n```js run\nlet user;\nlet user; // SyntaxError: 'user' has already been declared\n```\n\n使用 `var`，我们可以重复声明一个变量，不管多少次都行。如果我们对一个已经声明的变量使用 `var`，这条新的声明语句会被忽略：\n\n```js run\nvar user = \"Pete\";\n\nvar user = \"John\"; // 这个 \"var\" 无效（因为变量已经声明过了）\n// ……不会触发错误\n\nalert(user); // John\n```\n\n## \"var\" 声明的变量，可以在其声明语句前被使用\n\n当函数开始的时候，就会处理 `var` 声明（脚本启动对应全局变量）。\n\n换言之，`var` 声明的变量会在函数开头被定义，与它在代码中定义的位置无关（这里不考虑定义在嵌套函数中的情况）。\n\n那么看一下这段代码：\n\n```js run\nfunction sayHi() {\n  phrase = \"Hello\";\n\n  alert(phrase);\n\n*!*\n  var phrase;\n*/!*\n}\nsayHi();\n```\n\n……从技术上讲，它与下面这种情况是一样的（`var phrase` 被上移至函数开头）：\n\n```js run\nfunction sayHi() {\n*!*\n  var phrase;\n*/!*\n\n  phrase = \"Hello\";\n\n  alert(phrase);\n}\nsayHi();\n```\n\n……甚至与这种情况也一样（记住，代码块是会被忽略的）：\n\n```js run\nfunction sayHi() {\n  phrase = \"Hello\"; // (*)\n\n  *!*\n  if (false) {\n    var phrase;\n  }\n  */!*\n\n  alert(phrase);\n}\nsayHi();\n```\n\n人们将这种行为称为“提升”（英文为 \"hoisting\" 或 \"raising\"），因为所有的 `var` 都被“提升”到了函数的顶部。\n\n所以，在上面的例子中，`if (false)` 分支永远都不会执行，但没关系，它里面的 `var` 在函数刚开始时就被处理了，所以在执行 `(*)` 那行代码时，变量是存在的。\n\n**声明会被提升，但是赋值不会。**\n\n我们最好用例子来说明：\n\n```js run\nfunction sayHi() {\n  alert(phrase);  \n\n*!*\n  var phrase = \"Hello\";\n*/!*\n}\n\nsayHi();\n```\n\n`var phrase = \"Hello\"` 这行代码包含两个行为：\n\n1. 使用 `var` 声明变量\n2. 使用 `=` 给变量赋值。\n\n声明在函数刚开始执行的时候（“提升”）就被处理了，但是赋值操作始终是在它出现的地方才起作用。所以这段代码实际上是这样工作的：\n\n```js run\nfunction sayHi() {\n*!*\n  var phrase; // 在函数刚开始时进行变量声明\n*/!*\n\n  alert(phrase); // undefined\n\n*!*\n  phrase = \"Hello\"; // ……赋值 — 当程序执行到这一行时。\n*/!*\n}\n\nsayHi();\n```\n\n因为所有的 `var` 声明都是在函数开头处理的，我们可以在任何地方引用它们。但是在它们被赋值之前都是 undefined。\n\n上面两个例子中，`alert` 运行都不会报错，因为变量 `phrase` 是存在的。但是它还没有被赋值，所以显示 `undefiend`。\n\n## IIFE\n\n在之前，JavaScript 中只有 `var` 这一种声明变量的方式，并且这种方式声明的变量没有块级作用域，程序员们就发明了一种模仿块级作用域的方法。这种方法被称为“立即调用函数表达式”（immediately-invoked function expressions，IIFE）。\n\n如今，我们不应该再使用 IIFE 了，但是你可以在旧脚本中找到它们。\n\nIIFE 看起来像这样：\n\n```js run\n(function() {\n\n  var message = \"Hello\";\n\n  alert(message); // Hello\n\n})();\n```\n\n这里，创建了一个函数表达式并立即调用。因此，代码立即执行并拥有了自己的私有变量。\n\n函数表达式被括号 `(function {...})` 包裹起来，因为当 JavaScript 引擎在主代码中遇到 `\"function\"` 时，它会把它当成一个函数声明的开始。但函数声明必须有一个函数名，所以这样的代码会导致错误：\n\n```js run\n// 尝试声明并立即调用一个函数\nfunction() { // <-- SyntaxError: Function statements require a function name\n\n  var message = \"Hello\";\n\n  alert(message); // Hello\n\n}();\n```\n\n即使我们说：“好吧，那我们加一个名称吧”，但它仍然不工作，因为 JavaScript 不允许立即调用函数声明：\n\n```js run\n// 下面的括号会导致语法错误\nfunction go() {\n\n}(); // <-- 不能立即调用函数声明\n```\n\n因此，需要使用圆括号把该函数表达式包起来，以告诉 JavaScript，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用。\n\n除了使用括号，还有其他方式可以告诉 JavaScript 在这我们指的是函数表达式：\n\n```js run\n// 创建 IIFE 的方法\n\n*!*(*/!*function() {\n  alert(\"Parentheses around the function\");\n}*!*)*/!*();\n\n*!*(*/!*function() {\n  alert(\"Parentheses around the whole thing\");\n}()*!*)*/!*;\n\n*!*!*/!*function() {\n  alert(\"Bitwise NOT operator starts the expression\");\n}();\n\n*!*+*/!*function() {\n  alert(\"Unary plus starts the expression\");\n}();\n```\n\n在上面的所有情况中，我们都声明了一个函数表达式并立即运行它。请再注意一下：如今我们没有理由来编写这样的代码。\n\n## 总结\n\n`var` 与 `let/const` 有两个主要的区别：\n\n1. `var` 声明的变量没有块级作用域，它们仅在当前函数内可见，或者全局可见（如果变量是在函数外声明的）。\n2. `var` 变量声明在函数开头就会被处理（脚本启动对应全局变量）。\n\n涉及全局对象时，还有一个非常小的差异，我们将在下一章中介绍。\n\n这些差异使 `var` 在大多数情况下都比 `let` 更糟糕。块级作用域是这么好的一个东西。这就是 `let` 在几年前就被写入到标准中的原因，并且现在（与 `const` 一起）已经成为了声明变量的主要方式。",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1651565269
      }
    },
    "global-object": {
      "type": "Article",
      "value": {
        "title": "全局对象",
        "slug": "global-object",
        "githubPath": "/1-js/06-advanced-functions/05-global-object",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n全局对象提供可在任何地方使用的变量和函数。默认情况下，这些全局变量内建于语言或环境中。\n\n在浏览器中，它的名字是 \"window\"，对 Node.js 而言，它的名字是 \"global\"，其它环境可能用的是别的名字。\n\n最近，`globalThis` 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称。所有主流浏览器都支持它。\n\n假设我们的环境是浏览器，我们将在这儿使用 \"window\"。如果你的脚本可能会用来在其他环境中运行，则最好使用 `globalThis`。\n\n全局对象的所有属性都可以被直接访问：\n\n```js run\nalert(\"Hello\");\n// 等同于\nwindow.alert(\"Hello\");\n```\n\n在浏览器中，使用 `var`（而不是 `let/const`！）声明的全局函数和变量会成为全局对象的属性。\n\n```js run untrusted refresh\nvar gVar = 5;\n\nalert(window.gVar); // 5（成为了全局对象的属性）\n```\n\n函数声明（特指在主代码流中具有 `function` 关键字的语句，而不是函数表达式）也有这样的效果。\n\n请不要依赖它！这种行为是出于兼容性而存在的。现代脚本使用 [JavaScript modules](info:modules) 所以不会发生这种事情。\n\n如果我们使用 `let`，就不会发生这种情况：\n\n```js run untrusted refresh\nlet gLet = 5;\n\nalert(window.gLet); // undefined（不会成为全局对象的属性）\n```\n\n如果一个值非常重要，以至于你想使它在全局范围内可用，那么可以直接将其作为属性写入：\n\n```js run\n*!*\n// 将当前用户信息全局化，以允许所有脚本访问它\nwindow.currentUser = {\n  name: \"John\"\n};\n*/!*\n\n// 代码中的另一个位置\nalert(currentUser.name);  // John\n\n// 或者，如果我们有一个名为 \"currentUser\" 的局部变量\n// 从 window 显式地获取它（这是安全的！）\nalert(window.currentUser.name); // John\n```\n\n也就是说，一般不建议使用全局变量。全局变量应尽可能的少。与使用外部变量或全局变量相比，函数获取“输入”变量并产生特定“输出”的代码设计更加清晰，不易出错且更易于测试。\n\n## 使用 polyfills\n\n我们使用全局对象来测试对现代语言功能的支持。\n\n例如，测试是否存在内建的 `Promise` 对象（在版本特别旧的浏览器中不存在）：\n```js run\nif (!window.Promise) {\n  alert(\"Your browser is really old!\");\n}\n```\n\n如果没有（例如，我们使用的是旧版浏览器），那么我们可以创建 \"polyfills\"：添加环境不支持但在现代标准中存在的功能。\n\n```js run\nif (!window.Promise) {\n  window.Promise = ... // 定制实现现代语言功能\n}\n```\n\n## 总结\n\n- 全局对象包含应该在任何位置都可见的变量。\n\n    其中包括 JavaScript 的内建方法，例如 \"Array\" 和环境特定（environment-specific）的值，例如 `window.innerHeight` — 浏览器中的窗口高度。\n- 全局对象有一个通用名称 `globalThis`。\n\n    ……但是更常见的是使用“老式”的环境特定（environment-specific）的名字，例如 `window`（浏览器）和 `global`（Node.js）。\n- 仅当值对于我们的项目而言确实是全局的时候，才应将其存储在全局对象中。并保持其数量最少。\n- 在浏览器中，除非我们使用 [modules](info:modules)，否则使用 `var` 声明的全局函数和变量会成为全局对象的属性。\n- 为了使我们的代码面向未来并更易于理解，我们应该使用直接的方式访问全局对象的属性，如 `window.x`。",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1656808231
      }
    },
    "function-object": {
      "type": "Article",
      "value": {
        "title": "函数对象，NFE",
        "slug": "function-object",
        "githubPath": "/1-js/06-advanced-functions/06-function-object",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n我们已经知道，在 JavaScript 中，函数也是一个值。\n\n而 JavaScript 中的每个值都有一种类型，那么函数是什么类型呢？\n\n在 JavaScript 中，函数的类型是对象。\n\n一个容易理解的方式是把函数想象成可被调用的“行为对象（action object）”。我们不仅可以调用它们，还能把它们当作对象来处理：增/删属性，按引用传递等。\n\n\n## 属性 \"name\"\n\n函数对象包含一些便于使用的属性。\n\n比如，一个函数的名字可以通过属性 \"name\" 来访问：\n\n```js run\nfunction sayHi() {\n  alert(\"Hi\");\n}\n\nalert(sayHi.name); // sayHi\n```\n\n更有趣的是，名称赋值的逻辑很智能。即使函数被创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值：\n\n```js run\nlet sayHi = function() {\n  alert(\"Hi\");\n};\n\nalert(sayHi.name); // sayHi（有名字！）\n```\n\n当以默认值的方式完成了赋值时，它也有效：\n\n```js run\nfunction f(sayHi = function() {}) {\n  alert(sayHi.name); // sayHi（生效了！）\n}\n\nf();\n```\n\n规范中把这种特性叫做「上下文命名」。如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个。\n\n对象方法也有名字：\n\n```js run\nlet user = {\n\n  sayHi() {\n    // ...\n  },\n\n  sayBye: function() {\n    // ...\n  }\n\n}\n\nalert(user.sayHi.name); // sayHi\nalert(user.sayBye.name); // sayBye\n```\n\n这没有什么神奇的。有时会出现无法推测名字的情况。此时，属性 `name` 会是空，像这样：\n\n```js\n// 函数是在数组中创建的\nlet arr = [function() {}];\n\nalert( arr[0].name ); // <空字符串>\n// 引擎无法设置正确的名字，所以没有值\n```\n\n而实际上，大多数函数都是有名字的。\n\n## 属性 \"length\"\n\n还有另一个内建属性 \"length\"，它返回函数入参的个数，比如：\n\n```js run\nfunction f1(a) {}\nfunction f2(a, b) {}\nfunction many(a, b, ...more) {}\n\nalert(f1.length); // 1\nalert(f2.length); // 2\nalert(many.length); // 2\n```\n\n可以看到，rest 参数不参与计数。\n\n属性 `length` 有时在操作其它函数的函数中用于做 [内省/运行时检查（introspection）](https://zh.wikipedia.org/wiki/内省_(计算机科学))。\n\n比如，下面的代码中函数 `ask` 接受一个询问答案的参数 `question` 和可能包含任意数量 `handler` 的参数 `...handlers`。\n\n当用户提供了自己的答案后，函数会调用那些 `handlers`。我们可以传入两种 `handlers`：\n\n- 一种是无参函数，它仅在用户给出肯定回答时被调用。\n- 一种是有参函数，它在两种情况都会被调用，并且返回一个答案。\n\n为了正确地调用 `handler`，我们需要检查 `handler.length` 属性。\n\n我们的想法是，我们用一个简单的无参数的 `handler` 语法来处理积极的回答（最常见的变体），但也要能够提供通用的 handler：\n\n```js run\nfunction ask(question, ...handlers) {\n  let isYes = confirm(question);\n\n  for(let handler of handlers) {\n    if (handler.length == 0) {\n      if (isYes) handler();\n    } else {\n      handler(isYes);\n    }\n  }\n\n}\n\n// 对于肯定的回答，两个 handler 都会被调用\n// 对于否定的回答，只有第二个 handler 被调用\nask(\"Question?\", () => alert('You said yes'), result => alert(result));\n```\n\n这就是所谓的 [多态性](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) 的一个例子 —— 根据参数的类型，或者根据在我们的具体情景下的 `length` 来做不同的处理。这种思想在 JavaScript 的库里有应用。\n\n## 自定义属性\n\n我们也可以添加我们自己的属性。\n\n这里我们添加了 `counter` 属性，用来跟踪总的调用次数：\n\n```js run\nfunction sayHi() {\n  alert(\"Hi\");\n\n  *!*\n  // 计算调用次数\n  sayHi.counter++;\n  */!*\n}\nsayHi.counter = 0; // 初始值\n\nsayHi(); // Hi\nsayHi(); // Hi\n\nalert( `Called ${sayHi.counter} times` ); // Called 2 times\n```\n\n```warn header=\"属性不是变量\"\n被赋值给函数的属性，比如 `sayHi.counter = 0`，**不会** 在函数内定义一个局部变量 `counter`。换句话说，属性 `counter` 和变量 `let counter` 是毫不相关的两个东西。\n\n我们可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不是函数属性，反之亦然。它们之间是平行的。\n```\n\n函数属性有时会用来替代闭包。例如，我们可以使用函数属性将 <info:closure> 章节中 counter 函数的例子进行重写：\n\n```js run\nfunction makeCounter() {\n  // 不需要这个了\n  // let count = 0\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\nalert( counter() ); // 0\nalert( counter() ); // 1\n```\n\n现在 `count` 被直接存储在函数里，而不是它外部的词法环境。\n\n那么它和闭包谁好谁赖？\n\n两者最大的不同就是如果 `count` 的值位于外层（函数）变量中，那么外部的代码无法访问到它，只有嵌套的那些函数可以修改它。而如果它是绑定到函数的，那么就可以这样：\n\n```js run\nfunction makeCounter() {\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\n\n*!*\ncounter.count = 10;\nalert( counter() ); // 10\n*/!*\n```\n\n所以，选择哪种实现方式取决于我们的需求是什么。\n\n## 命名函数表达式\n\n命名函数表达式（NFE，Named Function Expression），指带有名字的函数表达式的术语。\n\n例如，让我们写一个普通的函数表达式：\n\n```js\nlet sayHi = function(who) {\n  alert(`Hello, ${who}`);\n};\n```\n\n然后给它加一个名字：\n\n```js\nlet sayHi = function *!*func*/!*(who) {\n  alert(`Hello, ${who}`);\n};\n```\n\n我们这里得到了什么吗？为它添加一个 `\"func\"` 名字的目的是什么？\n\n首先请注意，它仍然是一个函数表达式。在 `function` 后面加一个名字 `\"func\"` 没有使它成为一个函数声明，因为它仍然是作为赋值表达式中的一部分被创建的。\n\n添加这个名字当然也没有打破任何东西。\n\n函数依然可以通过 `sayHi()` 来调用：\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  alert(`Hello, ${who}`);\n};\n\nsayHi(\"John\"); // Hello, John\n```\n\n关于名字 `func` 有两个特殊的地方，这就是添加它的原因：\n\n1. 它允许函数在内部引用自己。\n2. 它在函数外是不可见的。\n\n例如，下面的函数 `sayHi` 会在没有入参 `who` 时，以 `\"Guest\"` 为入参调用自己：\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    func(\"Guest\"); // 使用 func 再次调用函数自身\n*/!*\n  }\n};\n\nsayHi(); // Hello, Guest\n\n// 但这不工作：\nfunc(); // Error, func is not defined（在函数外不可见）\n```\n\n我们为什么使用 `func` 呢？为什么不直接使用 `sayHi` 进行嵌套调用？\n\n\n当然，在大多数情况下我们可以这样做：\n\n```js\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    sayHi(\"Guest\");\n*/!*\n  }\n};\n```\n\n上面这段代码的问题在于 `sayHi` 的值可能会被函数外部的代码改变。如果该函数被赋值给另外一个变量（译注：也就是原变量被修改），那么函数就会开始报错：\n\n```js run\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    sayHi(\"Guest\"); // Error: sayHi is not a function\n*/!*\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Error，嵌套调用 sayHi 不再有效！\n```\n\n发生这种情况是因为该函数从它的外部词法环境获取 `sayHi`。没有局部的 `sayHi` 了，所以使用外部变量。而当调用时，外部的 `sayHi` 是 `null`。\n\n我们给函数表达式添加的可选的名字，正是用来解决这类问题的。\n\n让我们使用它来修复我们的代码：\n\n```js run\nlet sayHi = function *!*func*/!*(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n*!*\n    func(\"Guest\"); // 现在一切正常\n*/!*\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Hello, Guest（嵌套调用有效）\n```\n\n现在它可以正常运行了，因为名字 `func` 是函数局部域的。它不是从外部获取的（而且它对外部也是不可见的）。规范确保它只会引用当前函数。\n\n外部代码仍然有该函数的 `sayHi` 或 `welcome` 变量。而且 `func` 是一个“内部函数名”，是函数可以可靠地调用自身的方式。\n\n```smart header=\"函数声明没有这个东西\"\n这里所讲的“内部名”特性只针对函数表达式，而不是函数声明。对于函数声明，没有用来添加“内部”名的语法。\n\n有时，当我们需要一个可靠的内部名时，这就成为了你把函数声明重写成函数表达式的理由了。\n```\n\n## 总结\n\n函数的类型是对象。\n\n我们介绍了它们的一些属性：\n\n- `name` —— 函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。\n- `length` —— 函数定义时的入参的个数。Rest 参数不参与计数。\n\n如果函数是通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字，那么它被称为命名函数表达式（Named Function Expression）。这个名字可以用于在该函数内部进行自调用，例如递归调用等。\n\n此外，函数可以带有额外的属性。很多知名的 JavaScript 库都充分利用了这个功能。\n\n它们创建一个“主”函数，然后给它附加很多其它“辅助”函数。例如，[jQuery](https://jquery.com) 库创建了一个名为 `$` 的函数。[lodash](https://lodash.com) 库创建一个 `_` 函数，然后为其添加了 `_.add`、`_.keyBy` 以及其它属性（想要了解更多内容，参查阅 [docs](https://lodash.com/docs)）。实际上，它们这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量。这样就降低了命名冲突的可能性。\n\n所以，一个函数本身可以完成一项有用的工作，还可以在自身的属性中附带许多其他功能。",
        "libs": [],
        "children": [
          "counter-inc-dec",
          "sum-many-brackets"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1657705346
      }
    },
    "counter-inc-dec": {
      "type": "Task",
      "value": {
        "title": "为 counter 添加 set 和 decrease 方法",
        "slug": "counter-inc-dec",
        "githubPath": "/1-js/06-advanced-functions/06-function-object/2-counter-inc-dec",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n修改 `makeCounter()` 代码，使得 counter 可以进行减一和设置值的操作：\n\n- `counter()` 应该返回下一个数字（与之前的逻辑相同）。\n- `counter.set(value)` 应该将 `count` 设置为 `value`。\n- `counter.decrease()` 应该把 `count` 减 1。\n\n查看沙箱中的代码获取完整使用示例。\n\nP.S. 你可以使用闭包或者函数属性来保持当前的计数，或者两种都写。",
        "solution": "该解决方案在局部变量中使用 `count`，而进行加法操作的方法是直接写在 `counter` 中的。它们共享同一个外部词法环境，并且可以访问当前的 `count`。",
        "solutionJs": "function makeCounter() {\n  let count = 0;\n\n  function counter() {\n    return count++;\n  }\n\n  counter.set = value => count = value;\n\n  counter.decrease = () => count--;\n\n  return counter;\n}\n",
        "parent": "function-object",
        "version": 1
      }
    },
    "sum-many-brackets": {
      "type": "Task",
      "value": {
        "title": "任意数量的括号求和",
        "slug": "sum-many-brackets",
        "githubPath": "/1-js/06-advanced-functions/06-function-object/5-sum-many-brackets",
        "weight": 5,
        "libs": [],
        "importance": 2,
        "content": "\n\n写一个函数 `sum`，它有这样的功能：\n\n```js\nsum(1)(2) == 3; // 1 + 2\nsum(1)(2)(3) == 6; // 1 + 2 + 3\nsum(5)(-1)(2) == 6\nsum(6)(-1)(-2)(-3) == 0\nsum(0)(1)(2)(3)(4)(5) == 15\n```\n\nP.S. 提示：你可能需要创建自定义对象来为你的函数提供基本类型转换。",
        "solution": "1. 为了使整个程序无论如何都能正常工作，`sum` 的结果必须是函数。\n2. 这个函数必须将两次调用之间的当前值保存在内存中。\n3. 根据这个题目，当函数被用于 `==` 比较时必须转换成数字。函数是对象，所以转换规则会按照 <info:object-toprimitive> 章节所讲的进行，我们可以提供自己的方法来返回数字。\n\n代码如下：\n\n```js demo run\nfunction sum(a) {\n\n  let currentSum = a;\n\n  function f(b) {\n    currentSum += b;\n    return f;\n  }\n\n  f.toString = function() {\n    return currentSum;\n  };\n\n  return f;\n}\n\nalert( sum(1)(2) ); // 3\nalert( sum(5)(-1)(2) ); // 6\nalert( sum(6)(-1)(-2)(-3) ); // 0\nalert( sum(0)(1)(2)(3)(4)(5) ); // 15\n```\n\n请注意 `sum` 函数只工作一次，它返回了函数 `f`。\n\n然后，接下来的每一次子调用，`f` 都会把自己的参数加到求和 `currentSum` 上，然后 `f` 自身。\n\n**在 `f` 的最后一行没有递归。**\n\n递归是这样子的：\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f(); // <-- 递归调用\n}\n```\n\n在我们的例子中，只是返回了函数，并没有调用它：\n\n```js\nfunction f(b) {\n  currentSum += b;\n  return f; // <-- 没有调用自己，只是返回了自己\n}\n```\n\n这个 `f` 会被用于下一次调用，然后再次返回自己，按照需要重复。然后，当它被用做数字或字符串时 —— `toString` 返回 `currentSum`。我们也可以使用 `Symbol.toPrimitive` 或者 `valueOf` 来实现转换。",
        "solutionJs": "function sum(a) {\n\n  let currentSum = a;\n\n  function f(b) {\n    currentSum += b;\n    return f;\n  }\n\n  f.toString = function() {\n    return currentSum;\n  };\n\n  return f;\n}\n",
        "parent": "function-object",
        "version": 1
      }
    },
    "new-function": {
      "type": "Article",
      "value": {
        "title": "\"new Function\" 语法",
        "slug": "new-function",
        "githubPath": "/1-js/06-advanced-functions/07-new-function",
        "isFolder": false,
        "weight": 7,
        "content": "\n\n还有一种创建函数的方法。它很少被使用，但有些时候只能选择它。\n\n## 语法\n\n创建函数的语法：\n\n```js\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n```\n\n该函数是通过使用参数 `arg1...argN` 和给定的 `functionBody` 创建的。\n\n下面这个例子可以帮助你理解创建语法。这是一个带有两个参数的函数：\n\n```js run\nlet sum = new Function('a', 'b', 'return a + b');\n\nalert( sum(1, 2) ); // 3\n```\n\n这里有一个没有参数的函数，只有函数体：\n\n```js run\nlet sayHi = new Function('alert(\"Hello\")');\n\nsayHi(); // Hello\n```\n\n与我们已知的其他方法相比，这种方法最大的不同在于，它实际上是通过运行时通过参数传递过来的字符串创建的。\n\n以前的所有声明方法都需要我们 —— 程序员，在脚本中编写函数的代码。\n\n但是 `new Function` 允许我们将任意字符串变为函数。例如，我们可以从服务器接收一个新的函数并执行它：\n\n```js\nlet str = ... 动态地接收来自服务器的代码 ...\n\nlet func = new Function(str);\nfunc();\n```\n\n使用 `new Function` 创建函数的应用场景非常特殊，比如在复杂的 Web 应用程序中，我们需要从服务器获取代码或者动态地从模板编译函数时才会使用。\n\n## 闭包\n\n通常，闭包是指使用一个特殊的属性 `[[Environment]]` 来记录函数自身的创建时的环境的函数。它具体指向了函数创建时的词法环境。（我们在 <info:closure> 一章中对此进行了详细的讲解）。\n\n但是如果我们使用 `new Function` 创建一个函数，那么该函数的 `[[Environment]]` 并不指向当前的词法环境，而是指向全局环境。\n\n因此，此类函数无法访问外部（outer）变量，只能访问全局变量。\n\n```js run\nfunction getFunc() {\n  let value = \"test\";\n\n*!*\n  let func = new Function('alert(value)');\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // error: value is not defined\n```\n\n将其与常规行为进行比较：\n\n```js run\nfunction getFunc() {\n  let value = \"test\";\n\n*!*\n  let func = function() { alert(value); };\n*/!*\n\n  return func;\n}\n\ngetFunc()(); // *!*\"test\"*/!*，从 getFunc 的词法环境中获取的\n```\n\n`new Function` 的这种特性看起来有点奇怪，不过在实际中却非常实用。\n\n想象一下我们必须通过一个字符串来创建一个函数。在编写脚本时我们不会知道该函数的代码（这也就是为什么我们不用常规方法创建函数），但在执行过程中会知道了。我们可能会从服务器或其他来源获取它。\n\n我们的新函数需要和主脚本进行交互。\n\n如果这个函数能够访问外部（outer）变量会怎么样？\n\n问题在于，在将 JavaScript 发布到生产环境之前，需要使用 **压缩程序（minifier）** 对其进行压缩 —— 一个特殊的程序，通过删除多余的注释和空格等压缩代码 —— 更重要的是，将局部变量命名为较短的变量。\n\n例如，如果一个函数有 `let userName`，压缩程序会把它替换为 `let a`（如果 a 已被占用了，那就使用其他字符），剩余的局部变量也会被进行类似的替换。一般来说这样的替换是安全的，毕竟这些变量是函数内的局部变量，函数外的任何东西都无法访问它。在函数内部，压缩程序会替换所有使用了使用了这些变量的代码。压缩程序很聪明，它会分析代码的结构，而不是呆板地查找然后替换，因此它不会“破坏”你的程序。\n\n但是在这种情况下，如果使 `new Function` 可以访问自身函数以外的变量，它也很有可能无法找到重命名的 `userName`，这是因为新函数的创建发生在代码压缩以后，变量名已经被替换了。\n\n**即使我们可以在 `new Function` 中访问外部词法环境，我们也会受挫于压缩程序。**\n\n此外，这样的代码在架构上很差并且容易出错。\n\n当我们需要向 `new Function` 创建出的新函数传递数据时，我们必须显式地通过参数进行传递。\n\n## 总结\n\n语法：\n\n```js\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n```\n\n由于历史原因，参数也可以按逗号分隔符的形式给出。 \n\n以下三种声明的含义相同：\n\n```js \nnew Function('a', 'b', 'return a + b'); // 基础语法\nnew Function('a,b', 'return a + b'); // 逗号分隔\nnew Function('a , b', 'return a + b'); // 逗号和空格分隔\n```\n\n使用 `new Function` 创建的函数，它的 `[[Environment]]` 指向全局词法环境，而不是函数所在的外部词法环境。因此，我们不能在 `new Function` 中直接使用外部变量。不过这样是好事，这有助于降低我们代码出错的可能。并且，从代码架构上讲，显式地使用参数传值是一种更好的方法，并且避免了与使用压缩程序而产生冲突的问题。",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1653356134
      }
    },
    "settimeout-setinterval": {
      "type": "Article",
      "value": {
        "title": "调度：setTimeout 和 setInterval",
        "slug": "settimeout-setinterval",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval",
        "isFolder": false,
        "weight": 8,
        "content": "\n\n有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。\n\n目前有两种方式可以实现：\n\n- `setTimeout` 允许我们将函数推迟到一段时间间隔之后再执行。\n- `setInterval` 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。\n\n这两个方法并不在 JavaScript 的规范中。但是大多数运行环境都有内建的调度程序，并且提供了这些方法。目前来讲，所有浏览器以及 Node.js 都支持这两个方法。\n\n## setTimeout\n\n语法：\n\n```js\nlet timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)\n```\n\n参数说明：\n\n`func|code`\n: 想要执行的函数或代码字符串。\n一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。\n\n`delay`\n: 执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；\n\n`arg1`，`arg2`...\n: 要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）\n\n例如，在下面这个示例中，`sayHi()` 方法会在 1 秒后执行：\n\n```js run\nfunction sayHi() {\n  alert('Hello');\n}\n\n*!*\nsetTimeout(sayHi, 1000);\n*/!*\n```\n\n带参数的情况：\n\n```js run\nfunction sayHi(phrase, who) {\n  alert( phrase + ', ' + who );\n}\n\n*!*\nsetTimeout(sayHi, 1000, \"Hello\", \"John\"); // Hello, John\n*/!*\n```\n\n如果第一个参数位传入的是字符串，JavaScript 会自动为其创建一个函数。\n\n所以这么写也是可以的：\n\n```js run no-beautify\nsetTimeout(\"alert('Hello')\", 1000);\n```\n\n但是，不建议使用字符串，我们可以使用箭头函数代替它们，如下所示：\n\n```js run no-beautify\nsetTimeout(() => alert('Hello'), 1000);\n```\n\n````smart header=\"传入一个函数，但不要执行它\"\n新手开发者有时候会误将一对括号 `()` 加在函数后面：\n\n```js\n// 错的！\nsetTimeout(sayHi(), 1000);\n```\n这样不行，因为 `setTimeout` 期望得到一个对函数的引用。而这里的 `sayHi()` 很明显是在执行函数，所以实际上传入 `setTimeout` 的是 **函数的执行结果**。在这个例子中，`sayHi()` 的执行结果是 `undefined`（也就是说函数没有返回任何结果），所以实际上什么也没有调度。\n````\n\n### 用 clearTimeout 来取消调度\n\n`setTimeout` 在调用时会返回一个“定时器标识符（timer identifier）”，在我们的例子中是 `timerId`，我们可以使用它来取消执行。\n\n取消调度的语法：\n\n```js\nlet timerId = setTimeout(...);\nclearTimeout(timerId);\n```\n\n在下面的代码中，我们对一个函数进行了调度，紧接着取消了这次调度（中途反悔了）。所以最后什么也没发生：\n\n```js run no-beautify\nlet timerId = setTimeout(() => alert(\"never happens\"), 1000);\nalert(timerId); // 定时器标识符\n\nclearTimeout(timerId);\nalert(timerId); // 还是这个标识符（并没有因为调度被取消了而变成 null）\n```\n\n从 `alert` 的输出来看，在浏览器中，定时器标识符是一个数字。在其他环境中，可能是其他的东西。例如 Node.js 返回的是一个定时器对象，这个对象包含一系列方法。\n\n我再重申一遍，这些方法没有统一的规范定义，所以这没什么问题。\n\n针对浏览器环境，定时器在 HTML5 的标准中有详细描述，详见 [timers section](https://www.w3.org/TR/html5/webappapis.html#timers)。\n\n## setInterval\n\n`setInterval` 方法和 `setTimeout` 的语法相同：\n\n```js\nlet timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)\n```\n\n所有参数的意义也是相同的。不过与 `setTimeout` 只执行一次不同，`setInterval` 是每间隔给定的时间周期性执行。\n\n想要阻止后续调用，我们需要调用 `clearInterval(timerId)`。\n\n下面的例子将每间隔 2 秒就会输出一条消息。5 秒之后，输出停止：\n\n```js run\n// 每 2 秒重复一次\nlet timerId = setInterval(() => alert('tick'), 2000);\n\n// 5 秒之后停止\nsetTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);\n```\n\n```smart header=\"alert 弹窗显示的时候计时器依然在进行计时\"\n在大多数浏览器中，包括 Chrome 和 Firefox，在显示 `alert/confirm/prompt` 弹窗时，内部的定时器仍旧会继续“嘀嗒”。\n\n所以，在运行上面的代码时，如果在一定时间内没有关掉 `alert` 弹窗，那么在你关闭弹窗后，下一个 `alert` 会立即显示。两次 `alert` 之间的时间间隔将小于 2 秒。\n```\n\n## 嵌套的 setTimeout\n\n周期性调度有两种方式。\n\n一种是使用 `setInterval`，另外一种就是嵌套的 `setTimeout`，就像这样：\n\n```js\n/** instead of:\nlet timerId = setInterval(() => alert('tick'), 2000);\n*/\n\nlet timerId = setTimeout(function tick() {\n  alert('tick');\n*!*\n  timerId = setTimeout(tick, 2000); // (*)\n*/!*\n}, 2000);\n```\n\n上面这个 `setTimeout` 在当前这一次函数执行完时 `(*)` 立即调度下一次调用。\n\n嵌套的 `setTimeout` 要比 `setInterval` 灵活得多。采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同。\n\n例如，我们要实现一个服务（server），每间隔 5 秒向服务器发送一个数据请求，但如果服务器过载了，那么就要降低请求频率，比如将间隔增加到 10、20、40 秒等。\n\n以下是伪代码：\n```js\nlet delay = 5000;\n\nlet timerId = setTimeout(function request() {\n  ...发送请求...\n\n  if (request failed due to server overload) {\n    // 下一次执行的间隔是当前的 2 倍\n    delay *= 2;\n  }\n\n  timerId = setTimeout(request, delay);\n\n}, delay);\n```\n\n\n并且，如果我们调度的函数占用大量的 CPU，那么我们可以测量执行所需要花费的时间，并安排下次调用是应该提前还是推迟。\n\n**嵌套的 `setTimeout` 相较于 `setInterval` 能够更精确地设置两次执行之间的延时。**\n\n下面来比较这两个代码片段。第一个使用的是 `setInterval`：\n\n```js\nlet i = 1;\nsetInterval(function() {\n  func(i++);\n}, 100);\n```\n\n第二个使用的是嵌套的 `setTimeout`：\n\n```js\nlet i = 1;\nsetTimeout(function run() {\n  func(i++);\n  setTimeout(run, 100);\n}, 100);\n```\n\n对 `setInterval` 而言，内部的调度程序会每间隔 100 毫秒执行一次 `func(i++)`：\n\n![](setinterval-interval.svg)\n\n注意到了吗？\n\n**使用 `setInterval` 时，`func` 函数的实际调用间隔要比代码中设定的时间间隔要短！**\n\n这也是正常的，因为 `func` 的执行所花费的时间“消耗”了一部分间隔时间。\n\n也可能出现这种情况，就是 `func` 的执行所花费的时间比我们预期的时间更长，并且超出了 100 毫秒。\n\n在这种情况下，JavaScript 引擎会等待 `func` 执行完成，然后检查调度程序，如果时间到了，则 **立即** 再次执行它。\n\n极端情况下，如果函数每次执行时间都超过 `delay` 设置的时间，那么每次调用之间将完全没有停顿。\n\n这是嵌套的 `setTimeout` 的示意图：\n\n![](settimeout-interval.svg)\n\n**嵌套的 `setTimeout` 就能确保延时的固定（这里是 100 毫秒）。**\n\n这是因为下一次调用是在前一次调用完成时再调度的。\n\n````smart header=\"垃圾回收和 setInterval/setTimeout 回调（callback）\"\n当一个函数传入 `setInterval/setTimeout` 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。\n\n```js\n// 在调度程序调用这个函数之前，这个函数将一直存在于内存中\nsetTimeout(function() {...}, 100);\n```\n\n对于 `setInterval`，传入的函数也是一直存在于内存中，直到 `clearInterval` 被调用。\n\n这里还要提到一个副作用。如果函数引用了外部变量（译注：闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。\n````\n\n## 零延时的 setTimeout\n\n这儿有一种特殊的用法：`setTimeout(func, 0)`，或者仅仅是 `setTimeout(func)`。\n\n这样调度可以让 `func` 尽快执行。但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。\n\n也就是说，该函数被调度在当前脚本执行完成“之后”立即执行。\n\n例如，下面这段代码会先输出 \"Hello\"，然后立即输出 \"World\"：\n\n```js run\nsetTimeout(() => alert(\"World\"));\n\nalert(\"Hello\");\n```\n\n第一行代码“将调用安排到日程（calendar）0 毫秒处”。但是调度程序只有在当前脚本执行完毕时才会去“检查日程”，所以先输出 `\"Hello\"`，然后才输出 `\"World\"`。\n\n此外，还有与浏览器相关的 0 延时 timeout 的高级用例，我们将在 <info:event-loop> 一章中详细讲解。\n\n````smart header=\"零延时实际上不为零（在浏览器中）\"\n在浏览器环境下，嵌套定时器的运行频率是受限制的。根据 [HTML5 标准](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers) 所讲：“经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒”。\n\n让我们用下面的示例来看看这到底是什么意思。其中 `setTimeout` 调用会以零延时重新调度自身的调用。每次调用都会在 `times` 数组中记录上一次调用的实际时间。那么真正的延迟是什么样的？让我们来看看：\n\n```js run\nlet start = Date.now();\nlet times = [];\n\nsetTimeout(function run() {\n  times.push(Date.now() - start); // 保存前一个调用的延时\n\n  if (start + 100 < Date.now()) alert(times); // 100 毫秒之后，显示延时信息\n  else setTimeout(run); // 否则重新调度\n});\n\n// 输出示例：\n// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100\n```\n\n第一次，定时器是立即执行的（正如规范里所描述的那样），接下来我们可以看到 `9, 15, 20, 24...`。两次调用之间必须经过 4 毫秒以上的强制延时。（译注：这里作者没说清楚，timer 数组里存放的是每次定时器运行的时刻与 start 的差值，所以数字只会越来越大，实际上前后调用的延时是数组值的差值。示例中前几次都是 1，所以延时为 0）\n\n如果我们使用 `setInterval` 而不是 `setTimeout`，也会发生类似的情况：`setInterval(f)` 会以零延时运行几次 `f`，然后以 4 毫秒以上的强制延时运行。\n\n这个限制来自“远古时代”，并且许多脚本都依赖于此，所以这个机制也就存在至今。\n\n对于服务端的 JavaScript，就没有这个限制，并且还有其他调度即时异步任务的方式。例如 Node.js 的 [setImmediate](https://nodejs.org/api/timers.html#timers_setimmediate_callback_args)。因此，这个提醒只是针对浏览器环境的。\n````\n\n## 总结\n\n- `setTimeout(func, delay, ...args)` 和 `setInterval(func, delay, ...args)` 方法允许我们在 `delay` 毫秒之后运行 `func` 一次或以 `delay` 毫秒为时间间隔周期性运行 `func`。\n- 要取消函数的执行，我们应该调用 `clearInterval/clearTimeout`，并将 `setInterval/setTimeout` 返回的值作为入参传入。\n- 嵌套的 `setTimeout` 比 `setInterval` 用起来更加灵活，允许我们更精确地设置两次执行之间的时间。\n- 零延时调度 `setTimeout(func, 0)`（与 `setTimeout(func)` 相同）用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。\n- 浏览器会将 `setTimeout` 或 `setInterval` 的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。\n\n请注意，所有的调度方法都不能 **保证** 确切的延时。\n\n例如，浏览器内的计时器可能由于许多原因而变慢：\n- CPU 过载。\n- 浏览器页签处于后台模式。\n- 笔记本电脑用的是省电模式。\n\n所有这些因素，可能会将定时器的最小计时器分辨率（最小延迟）增加到 300ms 甚至 1000ms，具体以浏览器及其设置为准。\n\n<!--\n\n### 分割 CPU 高占用的任务\n\n下面讲一个用 `setTimeout` 分割 CPU 高占用任务的技巧。\n\n譬如，一个语法高亮脚本（用来给示例代码着色）会占用非常大的 CPU 资源。为了给代码进行高亮显示，它首先要进行代码分析，然后创建一堆着色后的元素，再将其添加到页面文档中 —— 文本量很大时，耗费时间也会很长。有时候甚至会导致浏览器“挂起”，这种情况是显然不能接受的。\n\n所以，我们不妨将长文本分割成几部分处理。首先处理前 100 行，然后用 `setTimeout(...,0)` 安排接下来 100 行的处理，以此类推。\n\n为了方便理解，来考虑一个稍微简单点的例子。比如我们有个函数，从 `1` 数到 `1000000000`。\n\n运行时，会观察到 CPU 挂起，服务器端 JS 表现的尤为明显。如果在浏览器下运行，试试点击页面的其他按钮，你会发现整个 JavaScript 的执行都暂停了，除非等这段代码运行完，否则什么也做不了。\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // 执行一个耗时的任务\n  for (let j = 0; j < 1e9; j++) {\n    i++;\n  }\n\n  alert(\"Done in \" + (Date.now() - start) + 'ms');\n}\n\ncount();\n```\n\n机会好的话，浏览器还会显示“the script takes too long（页面脚本执行时间过长）”这样的警告（实际上不太可能，毕竟给的数字也不是特别大）。\n\n下面用 `setTimeout` 分割任务：\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // 先完成一部分任务(*)\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  } else {\n    setTimeout(count, 0); // 安排下一次任务 (**)\n  }\n\n}\n\ncount();\n```\n\n现在，浏览器的 UI 界面即使在“计数”正在进行的情况下也能正常工作了。\n\n`(*)` 处代码是这么一步步完成任务的：\n\n1. 第一次做：`i=1...1000000` 的计数。\n2. 第二次做：`i=1000001..2000000` 的计数。\n3. ...等等，其中 `while` 语句检查 `i` 是否刚好能被 `1000000` 整除。\n\n如果任务还没完成，在代码 `(*)` 处安排下一次调用。\n\n`count` 函数调用的间隙足以让 JavaScript 引擎“缓口气了”，（浏览器）趁这段时间可以对用户的操作作出回应。\n\n用 `setTimeout` 进行分割和没用这两种做法在速度方面平分秋色，总的计数过程所花的时间几乎没什么差别。\n\n为了进一步阐述，下面做一下改进。\n\n将调度代码挪到 `count()` 函数开头位置：\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // 现在将调度放在开头\n  if (i < 1e9 - 1e6) {\n    setTimeout(count, 0); // 安排下一次调用\n  }\n\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  }\n\n}\n\ncount();\n```\n\n因为知道 `count()` 不会只执行一次，所以这一次在计数开始前就安排好下一次计数任务。\n\n如果你自己跑一遍，会观察到这次的耗时要短上不少。\n\n### 给浏览器渲染的机会\n\n行间脚本还有个益处，可以用来向用户展示进度条等。因为浏览器在所有脚本执行完后，才会开始“重绘（repainting）”过程。\n\n所以，如果运行一个非常耗时的函数，即便在这个函数中改变了文档内容，除非这个函数执行完，那么变化是不会立刻反映到页面上的。\n\n以下是一个示例：\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n    for (let j = 0; j < 1e6; j++) {\n      i++;\n      // 将当前 i 值放到 <div> 内\n      // （innerHTML 在以后具体章节会讲到，这行代码看懂应该没问题）\n      progress.innerHTML = i;\n    }\n  }\n\n  count();\n</script>\n```\n\n运行后会发现，`i` 值只在整个计数过程完成后才显示。\n\n接下来用 `setTimeout` 对任务进行分割，这样就能在每一轮运行的间隙观察到变化了，效果要好得多：\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // 每次只完成一部分 (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e9) {\n      setTimeout(count, 0);\n    }\n\n  }\n\n  count();\n</script>\n```\n\n现在就可以观察到 `<div>` 里 `i` 值的增长过程了。\n\n-->",
        "libs": [],
        "children": [
          "output-numbers-100ms",
          "settimeout-result"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1658121269
      }
    },
    "output-numbers-100ms": {
      "type": "Task",
      "value": {
        "title": "每秒输出一次",
        "slug": "output-numbers-100ms",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/1-output-numbers-100ms",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写一个函数 `printNumbers(from, to)`，使其每秒输出一个数字，数字从 `from ` 开始，到 `to` 结束。\n\n使用以下两种方法来实现。\n\n1. 使用 `setInterval`。\n2. 使用嵌套的 `setTimeout`。",
        "solution": "使用 `setInterval`：\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  let timerId = setInterval(function() {\n    alert(current);\n    if (current == to) {\n      clearInterval(timerId);\n    }\n    current++;\n  }, 1000);\n}\n\n// 用例：\nprintNumbers(5, 10);\n```\n\n使用嵌套的 `setTimeout`：\n\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  setTimeout(function go() {\n    alert(current);\n    if (current < to) {\n      setTimeout(go, 1000);\n    }\n    current++;\n  }, 1000);\n}\n\n// 用例：\nprintNumbers(5, 10);\n```\n\n请注意，在这两种解决方案中，在第一个输出之前都有一个初始延迟。函数在 `1000ms` 之后才被第一次调用。\n\n如果我们还希望函数立即运行，那么我们可以在单独的一行上添加一个额外的调用，像这样：\n\n```js run\nfunction printNumbers(from, to) {\n  let current = from;\n\n  function go() {\n    alert(current);\n    if (current == to) {\n      clearInterval(timerId);\n    }\n    current++;\n  }\n\n*!*\n  go();\n*/!*\n  let timerId = setInterval(go, 1000);\n}\n\nprintNumbers(5, 10);\n```",
        "parent": "settimeout-setinterval",
        "version": 1
      }
    },
    "settimeout-result": {
      "type": "Task",
      "value": {
        "title": "setTimeout 会显示什么？",
        "slug": "settimeout-result",
        "githubPath": "/1-js/06-advanced-functions/08-settimeout-setinterval/4-settimeout-result",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面代码中使用 `setTimeout` 调度了一个调用，然后需要运行一个计算量很大的 `for` 循环，这段运算耗时超过 100 毫秒。\n\n调度的函数会在何时运行？\n\n1. 循环执行完成后。\n2. 循环执行前。\n3. 循环刚开始时。\n\n\n`alert` 会显示什么？\n\n```js\nlet i = 0;\n\nsetTimeout(() => alert(i), 100); // ?\n\n// 假设这段代码的运行时间 >100ms\nfor(let j = 0; j < 100000000; j++) {\n  i++; \n}\n```",
        "solution": "任何 `setTimeout` 都只会在当前代码执行完毕之后才会执行。\n\n所以 `i` 的取值为：`100000000`。\n\n```js run\nlet i = 0;\n\nsetTimeout(() => alert(i), 100); // 100000000\n\n// 假设这段代码的运行时间 >100ms\nfor(let j = 0; j < 100000000; j++) {\n  i++; \n}\n```",
        "parent": "settimeout-setinterval",
        "version": 1
      }
    },
    "call-apply-decorators": {
      "type": "Article",
      "value": {
        "title": "装饰器模式和转发，call/apply",
        "slug": "call-apply-decorators",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators",
        "isFolder": false,
        "weight": 9,
        "content": "\n\nJavaScript 在处理函数时提供了非凡的灵活性。它们可以被传递，用作对象，现在我们将看到如何在它们之间 **转发（forward）** 调用并 **装饰（decorate）** 它们。\n\n## 透明缓存\n\n假设我们有一个 CPU 重负载的函数 `slow(x)`，但它的结果是稳定的。换句话说，对于相同的 `x`，它总是返回相同的结果。\n\n如果经常调用该函数，我们可能希望将结果缓存（记住）下来，以避免在重新计算上花费额外的时间。\n\n但是我们不是将这个功能添加到 `slow()` 中，而是创建一个包装器（wrapper）函数，该函数增加了缓存功能。正如我们将要看到的，这样做有很多好处。\n\n下面是代码和解释：\n\n```js run\nfunction slow(x) {\n  // 这里可能会有重负载的 CPU 密集型工作\n  alert(`Called with ${x}`);\n  return x;\n}\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n\n  return function(x) {\n    if (cache.has(x)) {    // 如果缓存中有对应的结果\n      return cache.get(x); // 从缓存中读取结果\n    }\n\n    let result = func(x);  // 否则就调用 func\n\n    cache.set(x, result);  // 然后将结果缓存（记住）下来\n    return result;\n  };\n}\n\nslow = cachingDecorator(slow);\n\nalert( slow(1) ); // slow(1) 被缓存下来了，并返回结果\nalert( \"Again: \" + slow(1) ); // 返回缓存中的 slow(1) 的结果\n\nalert( slow(2) ); // slow(2) 被缓存下来了，并返回结果\nalert( \"Again: \" + slow(2) ); // 返回缓存中的 slow(2) 的结果\n```\n\n在上面的代码中，`cachingDecorator` 是一个 **装饰器（decorator）**：一个特殊的函数，它接受另一个函数并改变它的行为。\n\n其思想是，我们可以为任何函数调用 `cachingDecorator`，它将返回缓存包装器。这很棒啊，因为我们有很多函数可以使用这样的特性，而我们需要做的就是将 `cachingDecorator` 应用于它们。\n\n通过将缓存与主函数代码分开，我们还可以使主函数代码变得更简单。\n\n`cachingDecorator(func)` 的结果是一个“包装器”：`function(x)` 将 `func(x)` 的调用“包装”到缓存逻辑中：\n\n![](decorator-makecaching-wrapper.svg)\n\n从外部代码来看，包装的 `slow` 函数执行的仍然是与之前相同的操作。它只是在其行为上添加了缓存功能。\n\n总而言之，使用分离的 `cachingDecorator` 而不是改变 `slow` 本身的代码有几个好处：\n\n- `cachingDecorator` 是可重用的。我们可以将它应用于另一个函数。\n- 缓存逻辑是独立的，它没有增加 `slow` 本身的复杂性（如果有的话）。\n- 如果需要，我们可以组合多个装饰器（其他装饰器将遵循同样的逻辑）。\n\n## 使用 \"func.call\" 设定上下文\n\n上面提到的缓存装饰器不适用于对象方法。\n\n例如，在下面的代码中，`worker.slow()` 在装饰后停止工作：\n\n```js run\n// 我们将对 worker.slow 的结果进行缓存\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // 可怕的 CPU 过载任务\n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\n// 和之前例子中的代码相同\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n*!*\n    let result = func(x); // (**)\n*/!*\n    cache.set(x, result);\n    return result;\n  };\n}\n\nalert( worker.slow(1) ); // 原始方法有效\n\nworker.slow = cachingDecorator(worker.slow); // 现在对其进行缓存\n\n*!*\nalert( worker.slow(2) ); // 蛤！Error: Cannot read property 'someMethod' of undefined\n*/!*\n```\n\n错误发生在试图访问 `this.someMethod` 并失败了的 `(*)` 行中。你能看出来为什么吗？\n\n原因是包装器将原始函数调用为 `(**)` 行中的 `func(x)`。并且，当这样调用时，函数将得到 `this = undefined`。\n\n如果尝试运行下面这段代码，我们会观察到类似的问题：\n\n```js\nlet func = worker.slow;\nfunc(2);\n```\n\n因此，包装器将调用传递给原始方法，但没有上下文 `this`。因此，发生了错误。\n\n让我们来解决这个问题。\n\n有一个特殊的内建函数方法 [func.call(context, ...args)](mdn:js/Function/call)，它允许调用一个显式设置 `this` 的函数。\n\n语法如下：\n\n```js\nfunc.call(context, arg1, arg2, ...)\n```\n\n它运行 `func`，提供的第一个参数作为 `this`，后面的作为参数（arguments）。\n\n简单地说，这两个调用几乎相同：\n```js\nfunc(1, 2, 3);\nfunc.call(obj, 1, 2, 3)\n```\n\n它们调用的都是 `func`，参数是 `1`、`2` 和 `3`。唯一的区别是 `func.call` 还会将 `this` 设置为 `obj`。\n\n例如，在下面的代码中，我们在不同对象的上下文中调用 `sayHi`：`sayHi.call(user)` 运行 `sayHi` 并提供了 `this=user`，然后下一行设置 `this=admin`：\n\n```js run\nfunction sayHi() {\n  alert(this.name);\n}\n\nlet user = { name: \"John\" };\nlet admin = { name: \"Admin\" };\n\n// 使用 call 将不同的对象传递为 \"this\"\nsayHi.call( user ); // John\nsayHi.call( admin ); // Admin\n```\n\n在这里我们用带有给定上下文和 phrase 的 `call` 调用 `say`：\n\n\n```js run\nfunction say(phrase) {\n  alert(this.name + ': ' + phrase);\n}\n\nlet user = { name: \"John\" };\n\n// user 成为 this，\"Hello\" 成为第一个参数\nsay.call( user, \"Hello\" ); // John: Hello\n```\n\n在我们的例子中，我们可以在包装器中使用 `call` 将上下文传递给原始函数：\n\n```js run\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n*!*\n    let result = func.call(this, x); // 现在 \"this\" 被正确地传递了\n*/!*\n    cache.set(x, result);\n    return result;\n  };\n}\n\nworker.slow = cachingDecorator(worker.slow); // 现在对其进行缓存\n\nalert( worker.slow(2) ); // 工作正常\nalert( worker.slow(2) ); // 工作正常，没有调用原始函数（使用的缓存）\n```\n\n现在一切都正常工作了。\n\n为了让大家理解地更清晰一些，让我们更深入地看看 `this` 是如何被传递的：\n\n1. 在经过装饰之后，`worker.slow` 现在是包装器 `function (x) { ... }`。\n2. 因此，当 `worker.slow(2)` 执行时，包装器将 `2` 作为参数，并且 `this=worker`（它是点符号 `.` 之前的对象）。\n3. 在包装器内部，假设结果尚未缓存，`func.call(this, x)` 将当前的 `this`（`=worker`）和当前的参数（`=2`）传递给原始方法。\n\n## 传递多个参数\n\n现在让我们把 `cachingDecorator` 写得更加通用。到现在为止，它只能用于单参数函数。\n\n现在如何缓存多参数 `worker.slow` 方法呢？\n\n```js\nlet worker = {\n  slow(min, max) {\n    return min + max; // scary CPU-hogger is assumed\n  }\n};\n\n// 应该记住相同参数的调用\nworker.slow = cachingDecorator(worker.slow);\n```\n\n之前，对于单个参数 `x`，我们可以只使用 `cache.set(x, result)` 来保存结果，并使用 `cache.get(x)` 来检索并获取结果。但是现在，我们需要记住 **参数组合** `(min,max)` 的结果。原生的 `Map` 仅将单个值作为键（key）。\n\n这儿有许多解决方案可以实现：\n\n1. 实现一个新的（或使用第三方的）类似 map 的更通用并且允许多个键的数据结构。\n2. 使用嵌套 map：`cache.set(min)` 将是一个存储（键值）对 `(max, result)` 的 `Map`。所以我们可以使用 `cache.get(min).get(max)` 来获取 `result`。\n3. 将两个值合并为一个。为了灵活性，我们可以允许为装饰器提供一个“哈希函数”，该函数知道如何将多个值合并为一个值。\n\n对于许多实际应用，第三种方式就足够了，所以我们就用这个吧。\n\n当然，我们需要传入的不仅是 `x`，还需要传入 `func.call` 的所有参数。让我们回想一下，在 `function()` 中我们可以得到一个包含所有参数的伪数组（pseudo-array）`arguments`，那么 `func.call(this, x)` 应该被替换为 `func.call(this, ...arguments)`。\n\n这是一个更强大的 `cachingDecorator`：\n\n```js run\nlet worker = {\n  slow(min, max) {\n    alert(`Called with ${min},${max}`);\n    return min + max;\n  }\n};\n\nfunction cachingDecorator(func, hash) {\n  let cache = new Map();\n  return function() {\n*!*\n    let key = hash(arguments); // (*)\n*/!*\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n*!*\n    let result = func.call(this, ...arguments); // (**)\n*/!*\n\n    cache.set(key, result);\n    return result;\n  };\n}\n\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n\nworker.slow = cachingDecorator(worker.slow, hash);\n\nalert( worker.slow(3, 5) ); // works\nalert( \"Again \" + worker.slow(3, 5) ); // same (cached)\n```\n\n现在这个包装器可以处理任意数量的参数了（尽管哈希函数还需要被进行调整以允许任意数量的参数。一种有趣的处理方法将在下面讲到）。\n\n这里有两个变化：\n\n- 在 `(*)` 行中它调用 `hash` 来从 `arguments` 创建一个单独的键。这里我们使用一个简单的“连接”函数，将参数 `(3, 5)` 转换为键 `\"3,5\"`。更复杂的情况可能需要其他哈希函数。\n- 然后 `(**)` 行使用 `func.call(this, ...arguments)` 将包装器获得的上下文和所有参数（不仅仅是第一个参数）传递给原始函数。\n\n## func.apply\n\n我们可以使用 `func.apply(this, arguments)` 代替 `func.call(this, ...arguments)`。\n\n内建方法 [func.apply](mdn:js/Function/apply) 的语法是：\n\n```js\nfunc.apply(context, args)\n```\n\n它运行 `func` 设置 `this=context`，并使用类数组对象 `args` 作为参数列表（arguments）。\n\n`call` 和 `apply` 之间唯一的语法区别是，`call` 期望一个参数列表，而 `apply` 期望一个包含这些参数的类数组对象。\n\n因此，这两个调用几乎是等效的：\n\n```js\nfunc.call(context, ...args);\nfunc.apply(context, args);\n```\n\n它们使用给定的上下文和参数执行相同的 `func` 调用。\n\n只有一个关于 `args` 的细微的差别：\n\n- Spread 语法 `...` 允许将 **可迭代对象** `args` 作为列表传递给 `call`。\n- `apply` 只接受 **类数组** `args`。\n\n……对于即可迭代又是类数组的对象，例如一个真正的数组，我们使用 `call` 或 `apply` 均可，但是 `apply` 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。\n\n将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”。\n\n这是它的最简形式：\n\n```js\nlet wrapper = function() {\n  return func.apply(this, arguments);\n};\n```\n\n当外部代码调用这种包装器 `wrapper` 时，它与原始函数 `func` 的调用是无法区分的。\n\n## 借用一种方法 [#method-borrowing]\n\n现在，让我们对哈希函数再做一个较小的改进：\n\n```js\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n```\n\n截至目前，它仅适用于两个参数。如果它可以适用于任何数量的 `args` 就更好了。\n\n自然的解决方案是使用 [arr.join](mdn:js/Array/join) 方法：\n\n```js\nfunction hash(args) {\n  return args.join();\n}\n```\n\n……不幸的是，这不行。因为我们正在调用 `hash(arguments)`，`arguments` 对象既是可迭代对象又是类数组对象，但它并不是真正的数组。\n\n所以在它上面调用 `join` 会失败，我们可以在下面看到：\n\n```js run\nfunction hash() {\n*!*\n  alert( arguments.join() ); // Error: arguments.join is not a function\n*/!*\n}\n\nhash(1, 2);\n```\n\n不过，有一种简单的方法可以使用数组的 join 方法：\n\n```js run\nfunction hash() {\n*!*\n  alert( [].join.call(arguments) ); // 1,2\n*/!*\n}\n\nhash(1, 2);\n```\n\n这个技巧被称为 **方法借用（method borrowing）**。\n\n我们从常规数组 `[].join` 中获取（借用）join 方法，并使用 `[].join.call` 在 `arguments` 的上下文中运行它。\n\n它为什么有效？\n\n那是因为原生方法 `arr.join(glue)` 的内部算法非常简单。\n\n从规范中几乎“按原样”解释如下：\n\n1. 让 `glue` 成为第一个参数，如果没有参数，则使用逗号 `\",\"`。\n2. 让 `result` 为空字符串。\n3. 将 `this[0]` 附加到 `result`。\n4. 附加 `glue` 和 `this[1]`。\n5. 附加 `glue` 和 `this[2]`。\n6. ……以此类推，直到 `this.length` 项目被粘在一起。\n7. 返回 `result`。\n\n因此，从技术上讲，它需要 `this` 并将 `this[0]`，`this[1]` ……等 join 在一起。它的编写方式是故意允许任何类数组的 `this` 的（不是巧合，很多方法都遵循这种做法）。这就是为什么它也可以和 `this=arguments` 一起使用。\n\n## 装饰器和函数属性\n\n通常，用装饰的函数替换一个函数或一个方法是安全的，除了一件小东西。如果原始函数有属性，例如 `func.calledCount` 或其他，则装饰后的函数将不再提供这些属性。因为这是装饰器。因此，如果有人使用它们，那么就需要小心。\n\n例如，在上面的示例中，如果 `slow` 函数具有任何属性，而 `cachingDecorator(slow)` 则是一个没有这些属性的包装器。\n\n一些包装器可能会提供自己的属性。例如，装饰器会计算一个函数被调用了多少次以及花费了多少时间，并通过包装器属性公开（expose）这些信息。\n\n存在一种创建装饰器的方法，该装饰器可保留对函数属性的访问权限，但这需要使用特殊的 `Proxy` 对象来包装函数。我们将在后面的 <info:proxy#proxy-apply> 中学习它。\n\n## 总结\n\n**装饰器** 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。\n\n装饰器可以被看作是可以添加到函数的 \"features\" 或 \"aspects\"。我们可以添加一个或添加多个。而这一切都无需更改其代码！\n\n为了实现 `cachingDecorator`，我们研究了以下方法：\n\n- [func.call(context, arg1, arg2...)](mdn:js/Function/call) —— 用给定的上下文和参数调用 `func`。\n- [func.apply(context, args)](mdn:js/Function/apply) —— 调用 `func` 将 `context` 作为 `this` 和类数组的 `args` 传递给参数列表。\n\n通用的 **呼叫转移（call forwarding）** 通常是使用 `apply` 完成的：\n\n```js\nlet wrapper = function() {\n  return original.apply(this, arguments);\n};\n```\n\n我们也可以看到一个 **方法借用（method borrowing）** 的例子，就是我们从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它。采用数组方法并将它们应用于参数 `arguments` 是很常见的。另一种方法是使用 Rest 参数对象，该对象是一个真正的数组。\n\n在 JavaScript 领域里有很多装饰器（decorators）。通过解决本章的任务，来检查你掌握它们的程度吧。",
        "libs": [],
        "children": [
          "spy-decorator",
          "delay",
          "debounce",
          "throttle"
        ],
        "parent": "advanced-functions",
        "updatedAt": 1657705346
      }
    },
    "spy-decorator": {
      "type": "Task",
      "value": {
        "title": "间谍装饰器",
        "slug": "spy-decorator",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/01-spy-decorator",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个装饰器 `spy(func)`，它应该返回一个包装器，该包装器将所有对函数的调用保存在其 `calls` 属性中。 \n\n每个调用都保存为一个参数数组。\n\n例如：\n\n```js\nfunction work(a, b) {\n  alert( a + b ); // work 是一个任意的函数或方法\n}\n\n*!*\nwork = spy(work);\n*/!*\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (let args of work.calls) {\n  alert( 'call:' + args.join() ); // \"call:1,2\", \"call:4,5\"\n}\n```\n\nP.S. 该装饰器有时对于单元测试很有用。它的高级形式是 [Sinon.JS](http://sinonjs.org/) 库中的 `sinon.spy`。",
        "solution": "由 `spy(f)` 返回的包装器应存储所有参数，然后使用 `f.apply` 转发调用。",
        "solutionJs": "function spy(func) {\n\n  function wrapper(...args) {\n    // using ...args instead of arguments to store \"real\" array in wrapper.calls\n    wrapper.calls.push(args);\n    return func.apply(this, args);\n  }\n\n  wrapper.calls = [];\n\n  return wrapper;\n}\n",
        "parent": "call-apply-decorators",
        "version": 1
      }
    },
    "delay": {
      "type": "Task",
      "value": {
        "title": "延时装饰器",
        "slug": "delay",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/02-delay",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个装饰器 `delay(f, ms)`，该装饰器将 `f` 的每次调用延时 `ms` 毫秒。\n\n例如：\n\n```js\nfunction f(x) {\n  alert(x);\n}\n\n// create wrappers\nlet f1000 = delay(f, 1000);\nlet f1500 = delay(f, 1500);\n\nf1000(\"test\"); // 在 1000ms 后显示 \"test\"\nf1500(\"test\"); // 在 1500ms 后显示 \"test\"\n```\n\n换句话说，`delay(f, ms)` 返回的是延迟 `ms` 后的 `f` 的变体。\n\n在上面的代码中，`f` 是单个参数的函数，但是你的解决方案应该传递所有参数和上下文 `this`。",
        "solution": "解决方案：\n\n```js run demo\nfunction delay(f, ms) {\n\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n\n}\n\nlet f1000 = delay(alert, 1000);\n\nf1000(\"test\"); // shows \"test\" after 1000ms\n```\n\n注意这里是如何使用箭头函数的。我们知道，箭头函数没有自己的 `this` 和 `arguments`，所以 `f.apply(this, arguments)` 从包装器中获取 `this` 和 `arguments`。\n\n如果我们传递一个常规函数，`setTimeout` 将调用它且不带参数，并且 `this=window`（假设我们在浏览器环境）。\n\n我们仍然可以通过使用中间变量来传递正确的 `this`，但这有点麻烦：\n\n```js\nfunction delay(f, ms) {\n\n  return function(...args) {\n    let savedThis = this; // 将 this 存储到中间变量\n    setTimeout(function() {\n      f.apply(savedThis, args); // 在这儿使用它\n    }, ms);\n  };\n\n}\n```",
        "solutionJs": "function delay(f, ms) {\n\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n\n};",
        "parent": "call-apply-decorators",
        "version": 1
      }
    },
    "debounce": {
      "type": "Task",
      "value": {
        "title": "防抖装饰器",
        "slug": "debounce",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/03-debounce",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n`debounce(f, ms)` 装饰器的结果是一个包装器，该包装器将暂停对 `f` 的调用，直到经过 `ms` 毫秒的非活动状态（没有函数调用，“冷却期”），然后使用最新的参数调用 `f` 一次。\n\n换句话说，`debounce` 就像一个“接听电话”的秘书，并一直等到 `ms` 毫秒的安静时间之后，才将最新的呼叫信息传达给“老板”（调用实际的 `f`）。\n\n举个例子，我们有一个函数 `f`，并将其替换为 `f = debounce(f, 1000)`。\n\n然后，如果包装函数分别在 0ms、200ms 和 500ms 时被调用了，之后没有其他调用，那么实际的 `f` 只会在 1500ms 时被调用一次。也就是说：从最后一次调用开始经过 1000ms 的冷却期之后。\n\n![](debounce.svg)\n\n……并且，它将获得最后一个调用的所有参数，其他调用的参数将被忽略。\n\n以下是其实现代码（使用了 [Lodash library](https://lodash.com/docs/4.17.15#debounce) 中的防抖装饰器 ):\n\n```js\nlet f = _.debounce(alert, 1000);\n\nf(\"a\");\nsetTimeout( () => f(\"b\"), 200);\nsetTimeout( () => f(\"c\"), 500);\n// 防抖函数从最后一次函数调用以后等待 1000ms，然后执行：alert(\"c\")\n```\n\n现在我们举一个实际中的例子。假设用户输入了一些内容，我们想要在用户输入完成时向服务器发送一个请求。\n\n我们没有必要为每一个字符的输入都发送请求。相反，我们想要等一段时间，然后处理整个结果。\n\n在 Web 浏览器中，我们可以设置一个事件处理程序 —— 一个在每次输入内容发生改动时都会调用的函数。通常，监听所有按键输入的事件的处理程序会被调用的非常频繁。但如果我们为这个处理程序做一个 1000ms 的 `debounce` 处理，它仅会在最后一次输入后的 1000ms 后被调用一次。\n\n```online\n\n在这个实时演示的示例中，处理程序将结果显示在了下面的方框中，试试看：\n\n[iframe border=1 src=\"debounce\" height=200]\n\n看到了吗？第二个输入框调用了防抖函数，所以它的内容是在最后一次输入的 1000ms 后被处理的。\n```\n\n因此，`debounce` 是一个处理一系列事件的好方法：无论是系列键盘输入，鼠标移动还是其他类似的事件。\n\n它在最后一次调用之后等待给定的时间，然后运行其可以处理结果的函数。\n\n任务是实现一个 `debounce` 装饰器。\n\n提示：如果你好好想想，实现它只需要几行代码 :)",
        "solution": "```js demo\nfunction debounce(func, ms) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, arguments), ms);\n  };\n}\n```\n\n调用 `debounce` 会返回一个包装器。当它被调用时，它会安排一个在给定的 `ms` 之后对原始函数的调用，并取消之前的此类超时。",
        "solutionJs": "function debounce(func, ms) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, arguments), ms);\n  };\n}\n",
        "parent": "call-apply-decorators",
        "version": 1
      }
    },
    "throttle": {
      "type": "Task",
      "value": {
        "title": "节流装饰器",
        "slug": "throttle",
        "githubPath": "/1-js/06-advanced-functions/09-call-apply-decorators/04-throttle",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个“节流”装饰器 `throttle(f, ms)` —— 返回一个包装器。\n\n当被多次调用时，它会在每 `ms` 毫秒最多将调用传递给 `f` 一次。\n\n与防抖（debounce）装饰器相比，其行为完全不同：\n- `debounce` 会在“冷却（cooldown）”期后运行函数一次。适用于处理最终结果。\n- `throttle` 运行函数的频率不会大于所给定的时间 `ms` 毫秒。适用于不应该经常进行的定期更新。\n\n换句话说，`throttle` 就像接电话的秘书，但是打扰老板（实际调用 `f`）的频率不能超过每 `ms` 毫秒一次。\n\n让我们看看现实生活中的应用程序，以便更好地理解这个需求，并了解它的来源。\n\n**例如，我们想要跟踪鼠标移动。**\n\n在浏览器中，我们可以设置一个函数，使其在每次鼠标移动时运行，并获取鼠标移动时的指针位置。在使用鼠标的过程中，此函数通常会执行地非常频繁，大概每秒 100 次（每 10 毫秒）。\n\n**我们想要在鼠标指针移动时，更新网页上的某些信息。**\n\n……但是更新函数 `update()` 太重了，无法在每个微小移动上都执行。高于每 100ms 更新一次的更新频次也没有意义。\n\n因此，我们将其包装到装饰器中：使用 `throttle(update, 100)` 作为在每次鼠标移动时运行的函数，而不是原始的 `update()`。装饰器会被频繁地调用，但是最多每 100ms 将调用转发给 `update()` 一次。\n\n在视觉上，它看起来像这样：\n\n1. 对于第一个鼠标移动，装饰的变体立即将调用传递给 `update`。这很重要，用户会立即看到我们对其动作的反应。\n2. 然后，随着鼠标移动，直到 `100ms` 没有任何反应。装饰的变体忽略了调用。\n3. 在 `100ms` 结束时 —— 最后一个坐标又发生了一次 `update`。\n4. 然后，最后，鼠标停在某处。装饰的变体会等到 `100ms` 到期，然后用最后一个坐标运行一次 `update`。因此，非常重要的是，处理最终的鼠标坐标。\n\n一个代码示例：\n\n```js\nfunction f(a) {\n  console.log(a);\n}\n\n// f1000 最多每 1000ms 将调用传递给 f 一次\nlet f1000 = throttle(f, 1000);\n\nf1000(1); // 显示 1\nf1000(2); // (节流，尚未到 1000ms)\nf1000(3); // (节流，尚未到 1000ms)\n\n// 当 1000ms 时间到...\n// ...输出 3，中间值 2 被忽略\n```\n\nP.S. 参数（arguments）和传递给 `f1000` 的上下文 `this` 应该被传递给原始的 `f`。",
        "solution": "```js demo\nfunction throttle(func, ms) {\n\n  let isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) { // (2)\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n    isThrottled = true;\n\n    func.apply(this, arguments); // (1)\n\n    setTimeout(function() {\n      isThrottled = false; // (3)\n      if (savedArgs) {\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}\n```\n\n调用 `throttle(func, ms)` 返回 `wrapper`。\n\n1. 在第一次调用期间，`wrapper` 只运行 `func` 并设置冷却状态（`isThrottled = true`）。\n2. 在这种状态下，所有调用都记忆在 `savedArgs/savedThis` 中。请注意，上下文和参数（arguments）同等重要，应该被记下来。我们同时需要他们以重现调用。\n3. ……然后经过 `ms` 毫秒后，触发 `setTimeout`。冷却状态被移除（`isThrottled = false`），如果我们忽略了调用，则将使用最后记忆的参数和上下文执行 `wrapper`。\n\n第 3 步运行的不是 `func`，而是 `wrapper`，因为我们不仅需要执行 `func`，还需要再次进入冷却状态并设置 timeout 以重置它。",
        "solutionJs": "function throttle(f, ms) {\n\n  let isThrottled = false,\n    savedArgs,\n    savedThis;\n\n  function wrapper() {\n\n    if (isThrottled) {\n      // memo last arguments to call after the cooldown\n      savedArgs = arguments;\n      savedThis = this;\n      return;\n    }\n\n    // otherwise go to cooldown state\n    f.apply(this, arguments);\n\n    isThrottled = true;\n\n    // plan to reset isThrottled after the delay\n    setTimeout(function() {\n      isThrottled = false;\n      if (savedArgs) {\n        // if there were calls, savedThis/savedArgs have the last one\n        // recursive call runs the function and sets cooldown again\n        wrapper.apply(savedThis, savedArgs);\n        savedArgs = savedThis = null;\n      }\n    }, ms);\n  }\n\n  return wrapper;\n}\n",
        "parent": "call-apply-decorators",
        "version": 1
      }
    },
    "bind": {
      "type": "Article",
      "value": {
        "title": "函数绑定",
        "slug": "bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind",
        "isFolder": false,
        "weight": 10,
        "content": "\n\n当将对象方法作为回调进行传递，例如传递给 `setTimeout`，这儿会存在一个常见的问题：“丢失 `this`”。\n\n在本章中，我们会学习如何去解决这个问题。\n\n## 丢失 \"this\"\n\n我们已经看到了丢失 `this` 的例子。一旦方法被传递到与对象分开的某个地方 —— `this` 就丢失。\n\n下面是使用 `setTimeout` 时 `this` 是如何丢失的：\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\n*!*\nsetTimeout(user.sayHi, 1000); // Hello, undefined!\n*/!*\n```\n\n正如我们所看到的，输出没有像 `this.firstName` 那样显示 \"John\"，而显示了 `undefined`！\n\n这是因为 `setTimeout` 获取到了函数 `user.sayHi`，但它和对象分离开了。最后一行可以被重写为：\n\n```js\nlet f = user.sayHi;\nsetTimeout(f, 1000); // 丢失了 user 上下文\n```\n\n浏览器中的 `setTimeout` 方法有些特殊：它为函数调用设定了 `this=window`（对于 Node.js，`this` 则会变为计时器（timer）对象，但在这儿并不重要）。所以对于 `this.firstName`，它其实试图获取的是 `window.firstName`，这个变量并不存在。在其他类似的情况下，通常 `this` 会变为 `undefined`。\n\n这个需求很典型 —— 我们想将一个对象方法传递到别的地方（这里 —— 传递到调度程序），然后在该位置调用它。如何确保在正确的上下文中调用它？\n\n## 解决方案 1：包装器\n\n最简单的解决方案是使用一个包装函数：\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\n*!*\nsetTimeout(function() {\n  user.sayHi(); // Hello, John!\n}, 1000);\n*/!*\n```\n\n现在它可以正常工作了，因为它从外部词法环境中获取到了 `user`，就可以正常地调用方法了。\n\n相同的功能，但是更简短：\n\n```js\nsetTimeout(() => user.sayHi(), 1000); // Hello, John!\n```\n\n看起来不错，但是我们的代码结构中出现了一个小漏洞。\n\n如果在 `setTimeout` 触发之前（有一秒的延迟！）`user` 的值改变了怎么办？那么，突然间，它将调用错误的对象！\n\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\nsetTimeout(() => user.sayHi(), 1000);\n\n// ……user 的值在不到 1 秒的时间内发生了改变\nuser = {\n  sayHi() { alert(\"Another user in setTimeout!\"); }\n};\n\n// Another user in setTimeout!\n```\n\n下一个解决方案保证了这样的事情不会发生。\n\n## 解决方案 2：bind\n\n函数提供了一个内建方法 [bind](mdn:js/Function/bind)，它可以绑定 `this`。\n\n基本的语法是：\n\n```js\n// 稍后将会有更复杂的语法\nlet boundFunc = func.bind(context);\n```\n\n`func.bind(context)` 的结果是一个特殊的类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地（transparently）将调用传递给 `func` 并设定 `this=context`。\n\n换句话说，`boundFunc` 调用就像绑定了 `this` 的 `func`。\n\n举个例子，这里的 `funcUser` 将调用传递给了 `func` 同时 `this=user`：\n\n```js run  \nlet user = {\n  firstName: \"John\"\n};\n\nfunction func() {\n  alert(this.firstName);\n}\n\n*!*\nlet funcUser = func.bind(user);\nfuncUser(); // John  \n*/!*\n```\n\n这里的 `func.bind(user)` 作为 `func` 的“绑定的（bound）变体”，绑定了 `this=user`。\n\n所有的参数（arguments）都被“原样”传递给了初始的 `func`，例如：\n\n```js run  \nlet user = {\n  firstName: \"John\"\n};\n\nfunction func(phrase) {\n  alert(phrase + ', ' + this.firstName);\n}\n\n// 将 this 绑定到 user\nlet funcUser = func.bind(user);\n\n*!*\nfuncUser(\"Hello\"); // Hello, John（参数 \"Hello\" 被传递，并且 this=user）\n*/!*\n```\n\n现在我们来尝试一个对象方法：\n\n\n```js run\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\n*!*\nlet sayHi = user.sayHi.bind(user); // (*)\n*/!*\n\n// 可以在没有对象（译注：与对象分离）的情况下运行它\nsayHi(); // Hello, John!\n\nsetTimeout(sayHi, 1000); // Hello, John!\n\n// 即使 user 的值在不到 1 秒内发生了改变\n// sayHi 还是会使用预先绑定（pre-bound）的值，该值是对旧的 user 对象的引用\nuser = {\n  sayHi() { alert(\"Another user in setTimeout!\"); }\n};\n```\n\n在 `(*)` 行，我们取了方法 `user.sayHi` 并将其绑定到 `user`。`sayHi` 是一个“绑定后（bound）”的方法，它可以被单独调用，也可以被传递给 `setTimeout` —— 都没关系，函数上下文都会是正确的。\n\n这里我们能够看到参数（arguments）都被“原样”传递了，只是 `this` 被 `bind` 绑定了：\n\n```js run\nlet user = {\n  firstName: \"John\",\n  say(phrase) {\n    alert(`${phrase}, ${this.firstName}!`);\n  }\n};\n\nlet say = user.say.bind(user);\n\nsay(\"Hello\"); // Hello, John!（参数 \"Hello\" 被传递给了 say）\nsay(\"Bye\"); // Bye, John!（参数 \"Bye\" 被传递给了 say）\n```\n\n````smart header=\"便捷方法：`bindAll`\"\n如果一个对象有很多方法，并且我们都打算将它们都传递出去，那么我们可以在一个循环中完成所有方法的绑定：\n\n```js\nfor (let key in user) {\n  if (typeof user[key] == 'function') {\n    user[key] = user[key].bind(user);\n  }\n}\n```\n\nJavaScript 库还提供了方便批量绑定的函数，例如 lodash 中的 [_.bindAll(object, methodNames)](http://lodash.com/docs#bindAll)。\n````\n\n## 部分（应用）函数（Partial functions）\n\n到现在为止，我们只在谈论绑定 `this`。让我们再深入一步。\n\n我们不仅可以绑定 `this`，还可以绑定参数（arguments）。虽然很少这么做，但有时它可以派上用场。\n\n`bind` 的完整语法如下：\n\n```js\nlet bound = func.bind(context, [arg1], [arg2], ...);\n```\n\n它允许将上下文绑定为 `this`，以及绑定函数的部分参数。\n\n例如，我们有一个乘法函数 `mul(a, b)`：\n\n```js\nfunction mul(a, b) {\n  return a * b;\n}\n```\n\n让我们使用 `bind` 在该函数基础上创建一个 `double` 函数：\n\n```js run\nfunction mul(a, b) {\n  return a * b;\n}\n\n*!*\nlet double = mul.bind(null, 2);\n*/!*\n\nalert( double(3) ); // = mul(2, 3) = 6\nalert( double(4) ); // = mul(2, 4) = 8\nalert( double(5) ); // = mul(2, 5) = 10\n```\n\n对 `mul.bind(null, 2)` 的调用创建了一个新函数 `double`，它将调用传递到 `mul`，将 `null` 绑定为上下文，并将 `2` 绑定为第一个参数。并且，参数（arguments）均被“原样”传递。\n\n它被称为 [函数的部分应用（partial function application）](https://en.wikipedia.org/wiki/Partial_application) —— 我们通过绑定先有函数的一些参数来创建一个新函数。\n\n请注意，这里我们实际上没有用到 `this`。但是 `bind` 需要它，所以我们必须传入 `null` 之类的东西。\n\n下面这段代码中的 `triple` 函数将值乘了三倍：\n\n```js run\nfunction mul(a, b) {\n  return a * b;\n}\n\n*!*\nlet triple = mul.bind(null, 3);\n*/!*\n\nalert( triple(3) ); // = mul(3, 3) = 9\nalert( triple(4) ); // = mul(3, 4) = 12\nalert( triple(5) ); // = mul(3, 5) = 15\n```\n\n为什么我们通常会创建一个部分应用函数？\n\n好处是我们可以创建一个具有可读性高的名字（`double`，`triple`）的独立函数。我们可以使用它，并且不必每次都提供一个参数，因为参数是被绑定了的。\n\n另一方面，当我们有一个非常灵活的函数，并希望有一个不那么灵活的变型时，部分应用函数会非常有用。\n\n例如，我们有一个函数 `send(from, to, text)`。然后，在一个 `user` 对象的内部，我们可能希望对它使用 `send` 的部分应用函数变型：从当前 user 发送 `sendTo(to, text)`。\n\n## 在没有上下文情况下的 partial\n\n当我们想绑定一些参数（arguments），但是这里没有上下文 `this`，应该怎么办？例如，对于一个对象方法。\n\n原生的 `bind` 不允许这种情况。我们不可以省略上下文直接跳到参数（arguments）。\n\n幸运的是，仅绑定参数（arguments）的函数 `partial` 比较容易实现。\n\n像这样：\n\n```js run\n*!*\nfunction partial(func, ...argsBound) {\n  return function(...args) { // (*)\n    return func.call(this, ...argsBound, ...args);\n  }\n}\n*/!*\n\n// 用法：\nlet user = {\n  firstName: \"John\",\n  say(time, phrase) {\n    alert(`[${time}] ${this.firstName}: ${phrase}!`);\n  }\n};\n\n// 添加一个带有绑定时间的 partial 方法\nuser.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());\n\nuser.sayNow(\"Hello\");\n// 类似于这样的一些内容：\n// [10:00] John: Hello!\n```\n\n`partial(func[, arg1, arg2...])` 调用的结果是一个包装器 `(*)`，它调用 `func` 并具有以下内容：\n- 与它获得的函数具有相同的 `this`（对于 `user.sayNow` 调用来说，它是 `user`）\n- 然后给它 `...argsBound` —— 来自于 `partial` 调用的参数（`\"10:00\"`）\n- 然后给它 `...args` —— 给包装器的参数（`\"Hello\"`）\n\n使用 spread 可以很容易实现这些操作，对吧？\n\n此外，还有来自 lodash 库的现成的 [_.partial](https://lodash.com/docs#partial) 实现。\n\n## 总结\n\n方法 `func.bind(context, ...args)` 返回函数 `func` 的“绑定的（bound）变体”，它绑定了上下文 `this` 和第一个参数（如果给定了）。\n\n通常我们应用 `bind` 来绑定对象方法的 `this`，这样我们就可以把它们传递到其他地方使用。例如，传递给 `setTimeout`。\n\n当我们绑定一个现有的函数的某些参数时，绑定后的（不太通用的）函数被称为 **partially applied** 或 **partial**。\n\n当我们不想一遍又一遍地重复相同的参数时，部分应用函数非常有用。就像我们有一个 `send(from, to)` 函数，并且对于我们的任务来说，`from` 应该总是一样的，那么我们就可以使用它的一个部分应用函数。",
        "libs": [
          "lodash"
        ],
        "children": [
          "write-to-object-after-bind",
          "second-bind",
          "function-property-after-bind",
          "question-use-bind",
          "ask-partial"
        ],
        "headHtml": "<script>\nfunction mul(a, b) {\n  return a * b;\n};\n\nfunction ask(question, answer, ok, fail) {\n  let result = prompt(question, '');\n  if (result.toLowerCase() == answer.toLowerCase()) ok();\n  else fail();\n}\n\nfunction bind(func, context /*, args*/) {\n  let bindArgs = [].slice.call(arguments, 2); // (1)\n  function wrapper() {                        // (2)\n    let args = [].slice.call(arguments);\n    let unshiftArgs = bindArgs.concat(args);  // (3)\n    return func.apply(context, unshiftArgs);  // (4)\n  }\n  return wrapper;\n}\n</script>",
        "parent": "advanced-functions",
        "updatedAt": 1669556173
      }
    },
    "write-to-object-after-bind": {
      "type": "Task",
      "value": {
        "title": "作为方法的绑定函数",
        "slug": "write-to-object-after-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/2-write-to-object-after-bind",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n输出将会是什么？\n\n```js\nfunction f() {\n  alert( this ); // ?\n}\n\nlet user = {\n  g: f.bind(null)\n};\n\nuser.g();\n```",
        "solution": "答案：`null`。\n\n\n```js run\nfunction f() {\n  alert( this ); // null\n}\n\nlet user = {\n  g: f.bind(null)\n};\n\nuser.g();\n```\n\n绑定函数的上下文是硬绑定（hard-fixed）的。没有办法再修改它。\n\n所以即使我们执行 `user.g()`，源方法调用时还是 `this=null`。",
        "parent": "bind",
        "version": 1
      }
    },
    "second-bind": {
      "type": "Task",
      "value": {
        "title": "二次 bind",
        "slug": "second-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/3-second-bind",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们可以通过额外的绑定改变 `this` 吗？\n\n输出将会是什么？\n\n```js no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"John\"} ).bind( {name: \"Ann\" } );\n\nf();\n```",
        "solution": "答案：**John**。\n\n```js run no-beautify\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"John\"} ).bind( {name: \"Pete\"} );\n\nf(); // John\n```\n\n`f.bind(...)` 返回的外来（exotic）[绑定函数](https://tc39.github.io/ecma262/#sec-bound-function-exotic-objects) 对象仅在创建的时候记忆上下文（以及参数，如果提供了的话）。\n\n一个函数不能被重绑定（re-bound）。",
        "parent": "bind",
        "version": 1
      }
    },
    "function-property-after-bind": {
      "type": "Task",
      "value": {
        "title": "bind 后的函数属性",
        "slug": "function-property-after-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/4-function-property-after-bind",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n函数的属性中有一个值。`bind` 之后它会改变吗？为什么，阐述一下？\n\n```js run\nfunction sayHi() {\n  alert( this.name );\n}\nsayHi.test = 5;\n\n*!*\nlet bound = sayHi.bind({\n  name: \"John\"\n});\n\nalert( bound.test ); // 输出将会是什么？为什么？\n*/!*\n```",
        "solution": "答案：`undefined`。\n\n`bind` 的结果是另一个对象。它并没有 `test` 属性。",
        "parent": "bind",
        "version": 1
      }
    },
    "question-use-bind": {
      "type": "Task",
      "value": {
        "title": "修复丢失了 \"this\" 的函数",
        "slug": "question-use-bind",
        "githubPath": "/1-js/06-advanced-functions/10-bind/5-question-use-bind",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面代码中对 `askPassword()` 的调用将会检查 password，然后基于结果调用 `user.loginOk/loginFail`。\n\n但是它导致了一个错误。为什么？\n\n修改高亮的行，以使所有内容都能正常工作（其它行不用修改）。\n\n```js run\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  loginOk() {\n    alert(`${this.name} logged in`);\n  },\n\n  loginFail() {\n    alert(`${this.name} failed to log in`);\n  },\n\n};\n\n*!*\naskPassword(user.loginOk, user.loginFail);\n*/!*\n```",
        "solution": "发生了错误是因为 `ask` 获得的是没有绑定对象的 `loginOk/loginFail` 函数。\n\n当 `ask` 调用这两个函数时，它们自然会认定 `this=undefined`。\n\n让我们 `bind` 上下文：\n\n```js run\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  loginOk() {\n    alert(`${this.name} logged in`);\n  },\n\n  loginFail() {\n    alert(`${this.name} failed to log in`);\n  },\n\n};\n\n*!*\naskPassword(user.loginOk.bind(user), user.loginFail.bind(user));\n*/!*\n```\n\n现在它能正常工作了。\n\n另一个可替换解决方案是：\n```js\n//...\naskPassword(() => user.loginOk(), () => user.loginFail());\n```\n\n通常这也能正常工作，也看起来挺好的。\n\n但是可能会在更复杂的场景下失效，例如变量 `user` 在调用 `askPassword` 之后但在访问者应答和调用 `() => user.loginOk()` 之前被修改。",
        "parent": "bind",
        "version": 1
      }
    },
    "ask-partial": {
      "type": "Task",
      "value": {
        "title": "偏函数在登录中的应用",
        "slug": "ask-partial",
        "githubPath": "/1-js/06-advanced-functions/10-bind/6-ask-partial",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n这个任务是比 <info:task/question-use-bind> 略微复杂的变体。\n\n`user` 对象被修改了。现在不是两个函数 `loginOk/loginFail`，现在只有一个函数 `user.login(true/false)`。\n\n在下面的代码中，我们应该向 `askPassword` 传入什么参数，以使得 `user.login(true)` 结果是 `ok`，`user.login(fasle)` 结果是 `fail`？\n\n```js\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  login(result) {\n    alert( this.name + (result ? ' logged in' : ' failed to log in') );\n  }\n};\n\n*!*\naskPassword(?, ?); // ?\n*/!*\n```\n\n你只能修改高亮部分的代码。",
        "solution": "1. 使用包装（wapper）函数，箭头函数很简洁：\n\n    ```js \n    askPassword(() => user.login(true), () => user.login(false)); \n    ```\n\n    现在它从外部变量中获得了 `user`，然后以常规方式运行它。\n\n2. 或者从 `user.login` 创建一个偏函数，该函数使用 `user` 作为上下文，并具有正确的第一个参数：\n\n\n    ```js \n    askPassword(user.login.bind(user, true), user.login.bind(user, false)); \n    ```",
        "parent": "bind",
        "version": 1
      }
    },
    "arrow-functions": {
      "type": "Article",
      "value": {
        "title": "深入理解箭头函数",
        "slug": "arrow-functions",
        "githubPath": "/1-js/06-advanced-functions/12-arrow-functions",
        "isFolder": false,
        "weight": 12,
        "content": "\n\n让我们深入研究一下箭头函数。\n\n箭头函数不仅仅是编写简洁代码的“捷径”。它还具有非常特殊且有用的特性。\n\nJavaScript 充满了我们需要编写在其他地方执行的小函数的情况。\n\n例如：\n\n- `arr.forEach(func)` —— `forEach` 对每个数组元素都执行 `func`。\n- `setTimeout(func)` —— `func` 由内建调度器执行。\n- ……还有更多。\n\nJavaScript 的精髓在于创建一个函数并将其传递到某个地方。\n\n在这样的函数中，我们通常不想离开当前上下文。这就是箭头函数的主战场啦。\n\n## 箭头函数没有 \"this\"\n\n正如我们在 <info:object-methods> 一章中所学到的，箭头函数没有 `this`。如果访问 `this`，则会从外部获取。\n\n例如，我们可以使用它在对象方法内部进行迭代：\n\n```js run\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n*!*\n    this.students.forEach(\n      student => alert(this.title + ': ' + student)\n    );\n*/!*\n  }\n};\n\ngroup.showList();\n```\n\n这里 `forEach` 中使用了箭头函数，所以其中的 `this.title` 其实和外部方法 `showList` 的完全一样。那就是：`group.title`。\n\n如果我们使用正常的函数，则会出现错误：\n\n```js run\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n*!*\n    this.students.forEach(function(student) {\n      // Error: Cannot read property 'title' of undefined\n      alert(this.title + ': ' + student);\n    });\n*/!*\n  }\n};\n\ngroup.showList();\n```\n\n报错是因为 `forEach` 运行它里面的这个函数，但是这个函数的 `this` 为默认值 `this=undefined`，因此就出现了尝试访问 `undefined.title` 的情况。\n\n但箭头函数就没事，因为它们没有 `this`。\n\n```warn header=\"不能对箭头函数进行 `new` 操作\"\n不具有 `this` 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 `new` 调用它们。\n```\n\n```smart header=\"箭头函数 VS bind\"\n箭头函数 `=>` 和使用 `.bind(this)` 调用的常规函数之间有细微的差别：\n\n- `.bind(this)` 创建了一个该函数的“绑定版本”。\n- 箭头函数 `=>` 没有创建任何绑定。箭头函数只是没有 `this`。`this` 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找。\n```\n\n## 箭头函数没有 \"arguments\"\n\n箭头函数也没有 `arguments` 变量。\n\n当我们需要使用当前的 `this` 和 `arguments` 转发一个调用时，这对装饰器（decorators）来说非常有用。\n\n例如，`defer(f, ms)` 获得了一个函数，并返回一个包装器，该包装器将调用延迟 `ms` 毫秒：\n\n```js run\nfunction defer(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(who) {\n  alert('Hello, ' + who);\n}\n\nlet sayHiDeferred = defer(sayHi, 2000);\nsayHiDeferred(\"John\"); // 2 秒后显示：Hello, John\n```\n\n不用箭头函数的话，可以这么写：\n\n```js\nfunction defer(f, ms) {\n  return function(...args) {\n    let ctx = this;\n    setTimeout(function() {\n      return f.apply(ctx, args);\n    }, ms);\n  };\n}\n```\n\n在这里，我们必须创建额外的变量 `args` 和 `ctx`，以便 `setTimeout` 内部的函数可以获取它们。\n\n## 总结\n\n箭头函数：\n\n- 没有 `this`\n- 没有 `arguments`\n- 不能使用 `new` 进行调用\n- 它们也没有 `super`，但目前我们还没有学到它。我们将在 <info:class-inheritance> 一章中学习它。\n\n这是因为，箭头函数是针对那些没有自己的“上下文”，但在当前上下文中起作用的短代码的。并且箭头函数确实在这种使用场景中大放异彩。",
        "libs": [],
        "children": [],
        "parent": "advanced-functions",
        "updatedAt": 1644761096
      }
    },
    "object-properties": {
      "type": "Article",
      "value": {
        "title": "对象属性配置",
        "slug": "object-properties",
        "githubPath": "/1-js/07-object-properties",
        "isFolder": true,
        "weight": 7,
        "content": "\n\n在本节中，我们将回到对象，并更深入地研究其属性。",
        "libs": [],
        "children": [
          "property-descriptors",
          "property-accessors"
        ],
        "parent": "js"
      }
    },
    "property-descriptors": {
      "type": "Article",
      "value": {
        "title": "属性标志和属性描述符",
        "slug": "property-descriptors",
        "githubPath": "/1-js/07-object-properties/01-property-descriptors",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n我们知道，对象可以存储属性。\n\n到目前为止，属性对我们来说只是一个简单的“键值”对。但对象属性实际上是更灵活且更强大的东西。\n\n在本章中，我们将学习其他配置选项，在下一章中，我们将学习如何将它们无形地转换为 getter/setter 函数。\n\n## 属性标志\n\n对象属性（properties），除 **`value`** 外，还有三个特殊的特性（attributes），也就是所谓的“标志”：\n\n- **`writable`** — 如果为 `true`，则值可以被修改，否则它是只可读的。\n- **`enumerable`** — 如果为 `true`，则会被在循环中列出，否则不会被列出。\n- **`configurable`** — 如果为 `true`，则此属性可以被删除，这些特性也可以被修改，否则不可以。\n\n我们到现在还没看到它们，是因为它们通常不会出现。当我们用“常用的方式”创建一个属性时，它们都为 `true`。但我们也可以随时更改它们。\n\n首先，让我们来看看如何获得这些标志。\n\n[Object.getOwnPropertyDescriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor) 方法允许查询有关属性的 **完整** 信息。\n\n语法是：\n```js\nlet descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n```\n\n`obj`\n: 需要从中获取信息的对象。\n\n`propertyName`\n: 属性的名称。\n\n返回值是一个所谓的“属性描述符”对象：它包含值和所有的标志。\n\n例如：\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/* 属性描述符：\n{\n  \"value\": \"John\",\n  \"writable\": true,\n  \"enumerable\": true,\n  \"configurable\": true\n}\n*/\n```\n\n为了修改标志，我们可以使用 [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。\n\n语法是：\n\n```js\nObject.defineProperty(obj, propertyName, descriptor)\n```\n\n`obj`，`propertyName`\n: 要应用描述符的对象及其属性。\n\n`descriptor`\n: 要应用的属性描述符对象。\n\n如果该属性存在，`defineProperty` 会更新其标志。否则，它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 `false`。\n\n例如，这里创建了一个属性 `name`，该属性的所有标志都为 `false`：\n\n```js run\nlet user = {};\n\n*!*\nObject.defineProperty(user, \"name\", {\n  value: \"John\"\n});\n*/!*\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": \"John\",\n*!*\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n*/!*\n}\n */\n```\n\n将它与上面的“以常用方式创建的” `user.name` 进行比较：现在所有标志都为 `false`。如果这不是我们想要的，那么我们最好在 `descriptor` 中将它们设置为 `true`。\n\n现在让我们通过示例来看看标志的影响。\n\n## 只读\n\n让我们通过更改 `writable` 标志来把 `user.name` 设置为只读（`user.name` 不能被重新赋值）：\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n*!*\n  writable: false\n*/!*\n});\n\n*!*\nuser.name = \"Pete\"; // Error: Cannot assign to read only property 'name'\n*/!*\n```\n\n现在没有人可以改变我们 `user` 的 `name`，除非它们应用自己的 `defineProperty` 来覆盖我们的 `user` 的 `name`。\n\n```smart header=\"只在严格模式下会出现 Errors\"\n在非严格模式下，在对不可写的属性等进行写入操作时，不会出现错误。但是操作仍然不会成功。在非严格模式下，违反标志的行为（flag-violating action）只会被默默地忽略掉。\n```\n\n这是相同的示例，但针对的是属性不存在的情况：\n\n```js run\nlet user = { };\n\nObject.defineProperty(user, \"name\", {\n*!*\n  value: \"John\",\n  // 对于新属性，我们需要明确地列出哪些是 true\n  enumerable: true,\n  configurable: true\n*/!*\n});\n\nalert(user.name); // John\nuser.name = \"Pete\"; // Error\n```\n\n## 不可枚举\n\n现在让我们向 `user` 添加一个自定义的 `toString`。\n\n通常，对象中内建的 `toString` 是不可枚举的，它不会显示在 `for..in` 中。但是如果我们添加我们自己的 `toString`，那么默认情况下它将显示在 `for..in` 中，如下所示：\n\n```js run\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\n// 默认情况下，我们的两个属性都会被列出：\nfor (let key in user) alert(key); // name, toString\n```\n\n如果我们不喜欢它，那么我们可以设置 `enumerable:false`。之后它就不会出现在 `for..in` 循环中了，就像内建的 `toString` 一样：\n\n```js run\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\nObject.defineProperty(user, \"toString\", {\n*!*\n  enumerable: false\n*/!*\n});\n\n*!*\n// 现在我们的 toString 消失了：\n*/!*\nfor (let key in user) alert(key); // name\n```\n\n不可枚举的属性也会被 `Object.keys` 排除：\n\n```js\nalert(Object.keys(user)); // name\n```\n\n## 不可配置\n\n不可配置标志（`configurable:false`）有时会预设在内建对象和属性中。\n\n不可配置的属性不能被删除，它的特性（attribute）不能被修改。\n\n例如，`Math.PI` 是只读的、不可枚举和不可配置的：\n\n```js run\nlet descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": 3.141592653589793,\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n}\n*/\n```\n因此，开发人员无法修改 `Math.PI` 的值或覆盖它。\n\n```js run\nMath.PI = 3; // Error，因为其 writable: false\n\n// 删除 Math.PI 也不会起作用\n```\n\n我们也无法将 `Math.PI` 改为 `writable`：\n\n```js run\n// Error，因为 configurable: false\nObject.defineProperty(Math, \"PI\", { writable: true });\n```\n\n我们对 `Math.PI` 什么也做不了。\n\n使属性变成不可配置是一条单行道。我们无法通过 `defineProperty` 再把它改回来。\n\n**请注意：`configurable: false` 防止更改和删除属性标志，但是允许更改对象的值。**\n\n这里的 `user.name` 是不可配置的，但是我们仍然可以更改它，因为它是可写的：\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n  configurable: false\n});\n\nuser.name = \"Pete\"; // 正常工作\ndelete user.name; // Error\n```\n\n现在，我们将 `user.name` 设置为一个“永不可改”的常量，就像内建的 `Math.PI`：\n\n```js run\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n  writable: false,\n  configurable: false\n});\n\n// 不能修改 user.name 或它的标志\n// 下面的所有操作都不起作用：\nuser.name = \"Pete\";\ndelete user.name;\nObject.defineProperty(user, \"name\", { value: \"Pete\" });\n```\n\n```smart header=\"唯一可行的特性更改：writable true -> false\"\n对于更改标志，有一个小例外。\n\n对于不可配置的属性，我们可以将 `writable: true` 更改为 `false`，从而防止其值被修改（以添加另一层保护）。但无法反向行之。\n```\n\n## Object.defineProperties\n\n有一个方法 [Object.defineProperties(obj, descriptors)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)，允许一次定义多个属性。\n\n语法是：\n\n```js\nObject.defineProperties(obj, {\n  prop1: descriptor1,\n  prop2: descriptor2\n  // ...\n});\n```\n\n例如：\n\n```js\nObject.defineProperties(user, {\n  name: { value: \"John\", writable: false },\n  surname: { value: \"Smith\", writable: false },\n  // ...\n});\n```\n\n所以，我们可以一次性设置多个属性。\n\n## Object.getOwnPropertyDescriptors\n\n要一次获取所有属性描述符，我们可以使用 [Object.getOwnPropertyDescriptors(obj)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors) 方法。\n\n它与 `Object.defineProperties` 一起可以用作克隆对象的“标志感知”方式：\n\n```js\nlet clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n```\n\n通常，当我们克隆一个对象时，我们使用赋值的方式来复制属性，像这样：\n\n```js\nfor (let key in user) {\n  clone[key] = user[key]\n}\n```\n\n……但是，这并不能复制标志。所以如果我们想要一个“更好”的克隆，那么 `Object.defineProperties` 是首选。\n\n另一个区别是 `for..in` 会忽略 symbol 类型的和不可枚举的属性，但是 `Object.getOwnPropertyDescriptors` 返回包含 symbol 类型的和不可枚举的属性在内的 **所有** 属性描述符。\n\n## 设定一个全局的密封对象\n\n属性描述符在单个属性的级别上工作。\n\n还有一些限制访问 **整个** 对象的方法：\n\n[Object.preventExtensions(obj)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)\n: 禁止向对象添加新属性。\n\n[Object.seal(obj)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\n: 禁止添加/删除属性。为所有现有的属性设置 `configurable: false`。\n\n[Object.freeze(obj)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n: 禁止添加/删除/更改属性。为所有现有的属性设置 `configurable: false, writable: false`。\n\n还有针对它们的测试：\n\n[Object.isExtensible(obj)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)\n: 如果添加属性被禁止，则返回 `false`，否则返回 `true`。\n\n[Object.isSealed(obj)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed)\n: 如果添加/删除属性被禁止，并且所有现有的属性都具有 `configurable: false`则返回 `true`。\n\n[Object.isFrozen(obj)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen)\n: 如果添加/删除/更改属性被禁止，并且所有当前属性都是 `configurable: false, writable: false`，则返回 `true`。\n\n这些方法在实际中很少使用。",
        "libs": [],
        "children": [],
        "parent": "object-properties",
        "updatedAt": 1646570029
      }
    },
    "property-accessors": {
      "type": "Article",
      "value": {
        "title": "属性的 getter 和 setter",
        "slug": "property-accessors",
        "githubPath": "/1-js/07-object-properties/02-property-accessors",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n有两种类型的对象属性。\n\n第一种是 **数据属性**。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。\n\n第二种类型的属性是新东西。它是 **访问器属性（accessor property）**。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。\n\n## getter 和 setter\n\n访问器属性由 \"getter\" 和 \"setter\" 方法表示。在对象字面量中，它们用 `get` 和 `set` 表示：\n\n```js\nlet obj = {\n  *!*get propName()*/!* {\n    // 当读取 obj.propName 时，getter 起作用\n  },\n\n  *!*set propName(value)*/!* {\n    // 当执行 obj.propName = value 操作时，setter 起作用\n  }\n};\n```\n\n当读取 `obj.propName` 时，getter 起作用，当 `obj.propName` 被赋值时，setter 起作用。\n\n例如，我们有一个具有 `name` 和 `surname` 属性的对象 `user`：\n\n```js\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n```\n\n现在我们想添加一个 `fullName` 属性，该属性值应该为 `\"John Smith\"`。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n*!*\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n*/!*\n};\n\n*!*\nalert(user.fullName); // John Smith\n*/!*\n```\n\n从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式 **调用** `user.fullName`，我们正常 **读取** 它：getter 在幕后运行。\n\n截至目前，`fullName` 只有一个 getter。如果我们尝试赋值操作 `user.fullName=`，将会出现错误：\n\n```js run\nlet user = {\n  get fullName() {\n    return `...`;\n  }\n};\n\n*!*\nuser.fullName = \"Test\"; // Error（属性只有一个 getter）\n*/!*\n```\n\n让我们通过为 `user.fullName` 添加一个 setter 来修复它：\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  },\n\n*!*\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n*/!*\n};\n\n// set fullName 将以给定值执行\nuser.fullName = \"Alice Cooper\";\n\nalert(user.name); // Alice\nalert(user.surname); // Cooper\n```\n\n现在，我们就有一个“虚拟”属性。它是可读且可写的。\n\n## 访问器描述符\n\n访问器属性的描述符与数据属性的不同。\n\n对于访问器属性，没有 `value` 和 `writable`，但是有 `get` 和 `set` 函数。\n\n所以访问器描述符可能有：\n\n- **`get`** —— 一个没有参数的函数，在读取属性时工作，\n- **`set`** —— 带有一个参数的函数，当属性被设置时调用，\n- **`enumerable`** —— 与数据属性的相同，\n- **`configurable`** —— 与数据属性的相同。\n\n例如，要使用 `defineProperty` 创建一个 `fullName` 访问器，我们可以使用 `get` 和 `set` 来传递描述符：\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n\n*!*\nObject.defineProperty(user, 'fullName', {\n  get() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n*/!*\n});\n\nalert(user.fullName); // John Smith\n\nfor(let key in user) alert(key); // name, surname\n```\n\n请注意，一个属性要么是访问器（具有 `get/set` 方法），要么是数据属性（具有 `value`），但不能两者都是。\n\n如果我们试图在同一个描述符中同时提供 `get` 和 `value`，则会出现错误：\n\n```js run\n*!*\n// Error: Invalid property descriptor.\n*/!*\nObject.defineProperty({}, 'prop', {\n  get() {\n    return 1\n  },\n\n  value: 2\n});\n```\n\n## 更聪明的 getter/setter\n\ngetter/setter 可以用作“真实”属性值的包装器，以便对它们进行更多的控制。\n\n例如，如果我们想禁止太短的 `user` 的 name，我们可以创建一个 setter `name`，并将值存储在一个单独的属性 `_name` 中：\n\n```js run\nlet user = {\n  get name() {\n    return this._name;\n  },\n\n  set name(value) {\n    if (value.length < 4) {\n      alert(\"Name is too short, need at least 4 characters\");\n      return;\n    }\n    this._name = value;\n  }\n};\n\nuser.name = \"Pete\";\nalert(user.name); // Pete\n\nuser.name = \"\"; // Name 太短了……\n```\n\n所以，name 被存储在 `_name` 属性中，并通过 getter 和 setter 进行访问。\n\n从技术上讲，外部代码可以使用 `user._name` 直接访问 name。但是，这儿有一个众所周知的约定，即以下划线 `\"_\"` 开头的属性是内部属性，不应该从对象外部进行访问。\n\n\n## 兼容性\n\n访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性，来控制和调整这些属性的行为。\n\n想象一下，我们开始使用数据属性 `name` 和 `age` 来实现 user 对象：\n\n```js\nfunction User(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet john = new User(\"John\", 25);\n\nalert( john.age ); // 25\n```\n\n……但迟早，情况可能会发生变化。我们可能会决定存储 `birthday`，而不是 `age`，因为它更精确，更方便：\n\n```js\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n```\n\n现在应该如何处理仍使用 `age` 属性的旧代码呢？\n\n我们可以尝试找到所有这些地方并修改它们，但这会花费很多时间，而且如果其他很多人都在使用该代码，那么可能很难完成所有修改。而且，`user` 中有 `age` 是一件好事，对吧？\n\n那我们就把它保留下来吧。\n\n为 `age` 添加一个 getter 来解决这个问题：\n\n```js run no-beautify\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\n*!*\n  // 年龄是根据当前日期和生日计算得出的\n  Object.defineProperty(this, \"age\", {\n    get() {\n      let todayYear = new Date().getFullYear();\n      return todayYear - this.birthday.getFullYear();\n    }\n  });\n*/!*\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n\nalert( john.birthday ); // birthday 是可访问的\nalert( john.age );      // ……age 也是可访问的\n```\n\n现在旧的代码也可以工作，而且我们还拥有了一个不错的附加属性。",
        "libs": [],
        "children": [],
        "parent": "object-properties",
        "updatedAt": 1651420873
      }
    },
    "prototypes": {
      "type": "Article",
      "value": {
        "title": "原型，继承",
        "slug": "prototypes",
        "githubPath": "/1-js/08-prototypes",
        "isFolder": true,
        "weight": 8,
        "content": "",
        "libs": [],
        "children": [
          "prototype-inheritance",
          "function-prototype",
          "native-prototypes",
          "prototype-methods"
        ],
        "parent": "js"
      }
    },
    "prototype-inheritance": {
      "type": "Article",
      "value": {
        "title": "原型继承",
        "slug": "prototype-inheritance",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n在编程中，我们经常会想获取并扩展一些东西。\n\n例如，我们有一个 `user` 对象及其属性和方法，并希望将 `admin` 和 `guest` 作为基于 `user` 稍加修改的变体。我们想重用 `user` 中的内容，而不是复制/重新实现它的方法，而只是在其之上构建一个新的对象。\n\n**原型继承（Prototypal inheritance）** 这个语言特性能够帮助我们实现这一需求。\n\n## [[Prototype]]\n\n在 JavaScript 中，对象有一个特殊的隐藏属性 `[[Prototype]]`（如规范中所命名的），它要么为 `null`，要么就是对另一个对象的引用。该对象被称为“原型”：\n\n![prototype](object-prototype-empty.svg)\n\n当我们从 `object` 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。在编程中，这被称为“原型继承”。很快，我们将通过很多示例来学习此类继承，以及基于此类继承的更炫酷的语言功能。\n\n属性 `[[Prototype]]` 是内部的而且是隐藏的，但是这儿有很多设置它的方式。\n\n其中之一就是使用特殊的名字 `__proto__`，就像这样：\n\n```js run\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\n*!*\nrabbit.__proto__ = animal; // 设置 rabbit.[[Prototype]] = animal\n*/!*\n```\n\n现在，如果我们从 `rabbit` 中读取一个它没有的属性，JavaScript 会自动从 `animal` 中获取。\n\n例如：\n\n```js\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\n*!*\nrabbit.__proto__ = animal; // (*)\n*/!*\n\n// 现在这两个属性我们都能在 rabbit 中找到：\n*!*\nalert( rabbit.eats ); // true (**)\n*/!*\nalert( rabbit.jumps ); // true\n```\n\n这里的 `(*)` 行将 `animal` 设置为 `rabbit` 的原型。\n\n当 `alert` 试图读取 `rabbit.eats` `(**)` 时，因为它不存在于 `rabbit` 中，所以 JavaScript 会顺着 `[[Prototype]]` 引用，在 `animal` 中查找（自下而上）：\n\n![](proto-animal-rabbit.svg)\n\n在这儿我们可以说 \"`animal` 是 `rabbit` 的原型\"，或者说 \"`rabbit` 的原型是从 `animal` 继承而来的\"。\n\n因此，如果 `animal` 有许多有用的属性和方法，那么它们将自动地变为在 `rabbit` 中可用。这种属性被称为“继承”。\n\n如果我们在 `animal` 中有一个方法，它可以在 `rabbit` 中被调用：\n\n```js run\nlet animal = {\n  eats: true,\n*!*\n  walk() {\n    alert(\"Animal walk\");\n  }\n*/!*\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n// walk 方法是从原型中获得的\n*!*\nrabbit.walk(); // Animal walk\n*/!*\n```\n\n该方法是自动地从原型中获得的，像这样：\n\n![](proto-animal-rabbit-walk.svg)\n\n原型链可以很长：\n\n```js run\nlet animal = {\n  eats: true,\n  walk() {\n    alert(\"Animal walk\");\n  }\n};\n\nlet rabbit = {\n  jumps: true,\n*!*\n  __proto__: animal\n*/!*\n};\n\nlet longEar = {\n  earLength: 10,\n*!*\n  __proto__: rabbit\n*/!*\n};\n\n// walk 是通过原型链获得的\nlongEar.walk(); // Animal walk\nalert(longEar.jumps); // true（从 rabbit）\n```\n\n![](proto-animal-rabbit-chain.svg)\n\n现在，如果我们从 `longEar` 中读取一些它不存在的内容，JavaScript 会先在 `rabbit` 中查找，然后在 `animal` 中查找。\n\n这里只有两个限制：\n\n1. 引用不能形成闭环。如果我们试图给 `__proto__` 赋值但会导致引用形成闭环时，JavaScript 会抛出错误。\n2. `__proto__` 的值可以是对象，也可以是 `null`。而其他的类型都会被忽略。\n\n当然，这可能很显而易见，但是仍然要强调：只能有一个 `[[Prototype]]`。一个对象不能从其他两个对象获得继承。\n\n```smart header=\"`__proto__` 是 `[[Prototype]]` 的因历史原因而留下来的 getter/setter\"\n初学者常犯一个普遍的错误，就是不知道 `__proto__` 和 `[[Prototype]]` 的区别。\n\n请注意，`__proto__` 与内部的 `[[Prototype]]` **不一样**。`__proto__` 是 `[[Prototype]]` 的 getter/setter。稍后，我们将看到在什么情况下理解它们很重要，在建立对 JavaScript 语言的理解时，让我们牢记这一点。\n\n`__proto__` 属性有点过时了。它的存在是出于历史的原因，现代编程语言建议我们应该使用函数 `Object.getPrototypeOf/Object.setPrototypeOf` 来取代 `__proto__` 去 get/set 原型。稍后我们将介绍这些函数。\n\n根据规范，`__proto__` 必须仅受浏览器环境的支持。但实际上，包括服务端在内的所有环境都支持它，因此我们使用它是非常安全的。\n\n由于 `__proto__` 标记在观感上更加明显，所以我们在后面的示例中将使用它。\n```\n\n## 写入不使用原型\n\n原型仅用于读取属性。\n\n对于写入/删除操作可以直接在对象上进行。\n\n在下面的示例中，我们将为 `rabbit` 的 `walk` 属性赋值：\n\n```js run\nlet animal = {\n  eats: true,\n  walk() {\n    /* rabbit 不会使用此方法 */  \n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\n*!*\nrabbit.walk = function() {\n  alert(\"Rabbit! Bounce-bounce!\");\n};\n*/!*\n\nrabbit.walk(); // Rabbit! Bounce-bounce!\n```\n\n从现在开始，`rabbit.walk()` 将立即在对象中找到该方法并执行，而无需使用原型：\n\n![](proto-animal-rabbit-walk-2.svg)\n\n访问器（accessor）属性是一个例外，因为赋值（assignment）操作是由 setter 函数处理的。因此，写入此类属性实际上与调用函数相同。\n\n也就是这个原因，所以下面这段代码中的 `admin.fullName` 能够正常运行：\n\n```js run\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  },\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nlet admin = {\n  __proto__: user,\n  isAdmin: true\n};\n\nalert(admin.fullName); // John Smith (*)\n\n// setter triggers!\nadmin.fullName = \"Alice Cooper\"; // (**)\n\nalert(admin.fullName); // Alice Cooper，admin 的内容被修改了\nalert(user.fullName);  // John Smith，user 的内容被保护了\n```\n\n在 `(*)` 行中，属性 `admin.fullName` 在原型 `user` 中有一个 getter，因此它会被调用。在 `(**)` 行中，属性在原型中有一个 setter，因此它会被调用。\n\n## \"this\" 的值\n\n在上面的例子中可能会出现一个有趣的问题：在 `set fullName(value)` 中 `this` 的值是什么？属性 `this.name` 和 `this.surname` 被写在哪里：在 `user` 还是 `admin`？\n\n答案很简单：`this` 根本不受原型的影响。\n\n**无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，`this` 始终是点符号 `.` 前面的对象。**\n\n因此，setter 调用 `admin.fullName=` 使用 `admin` 作为 `this`，而不是 `user`。\n\n这是一件非常重要的事儿，因为我们可能有一个带有很多方法的大对象，并且还有从其继承的对象。当继承的对象运行继承的方法时，它们将仅修改自己的状态，而不会修改大对象的状态。\n\n例如，这里的 `animal` 代表“方法存储”，`rabbit` 在使用其中的方法。\n\n调用 `rabbit.sleep()` 会在 `rabbit` 对象上设置 `this.isSleeping`：\n\n```js run\n// animal 有一些方法\nlet animal = {\n  walk() {\n    if (!this.isSleeping) {\n      alert(`I walk`);\n    }\n  },\n  sleep() {\n    this.isSleeping = true;\n  }\n};\n\nlet rabbit = {\n  name: \"White Rabbit\",\n  __proto__: animal\n};\n\n// 修改 rabbit.isSleeping\nrabbit.sleep();\n\nalert(rabbit.isSleeping); // true\nalert(animal.isSleeping); // undefined（原型中没有此属性）\n```\n\n结果示意图：\n\n![](proto-animal-rabbit-walk-3.svg)\n\n如果我们还有从 `animal` 继承的其他对象，像 `bird` 和 `snake` 等，它们也将可以访问 `animal` 的方法。但是，每个方法调用中的 `this` 都是在调用时（点符号前）评估的对应的对象，而不是 `animal`。因此，当我们将数据写入 `this` 时，会将其存储到这些对象中。\n\n所以，方法是共享的，但对象状态不是。\n\n## for..in 循环\n\n`for..in` 循环也会迭代继承的属性。\n\n例如：\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n*!*\n// Object.keys 只返回自己的 key\nalert(Object.keys(rabbit)); // jumps\n*/!*\n\n*!*\n// for..in 会遍历自己以及继承的键\nfor(let prop in rabbit) alert(prop); // jumps，然后是 eats\n*/!*\n```\n\n如果这不是我们想要的，并且我们想排除继承的属性，那么这儿有一个内建方法 [obj.hasOwnProperty(key)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)：如果 `obj` 具有自己的（非继承的）名为 `key` 的属性，则返回 `true`。\n\n因此，我们可以过滤掉继承的属性（或对它们进行其他操作）：\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nfor(let prop in rabbit) {\n  let isOwn = rabbit.hasOwnProperty(prop);\n\n  if (isOwn) {\n    alert(`Our: ${prop}`); // Our: jumps\n  } else {\n    alert(`Inherited: ${prop}`); // Inherited: eats\n  }\n}\n```\n\n这里我们有以下继承链：`rabbit` 从 `animal` 中继承，`animal` 从 `Object.prototype` 中继承（因为 `animal` 是对象字面量 `{...}`，所以这是默认的继承），然后再向上是 `null`：\n\n![](rabbit-animal-object.svg)\n\n注意，这有一件很有趣的事儿。方法 `rabbit.hasOwnProperty` 来自哪儿？我们并没有定义它。从上图中的原型链我们可以看到，该方法是 `Object.prototype.hasOwnProperty` 提供的。换句话说，它是继承的。\n\n……如果 `for..in` 循环会列出继承的属性，那为什么 `hasOwnProperty` 没有像 `eats` 和 `jumps` 那样出现在 `for..in` 循环中？\n\n答案很简单：它是不可枚举的。就像 `Object.prototype` 的其他属性，`hasOwnProperty` 有 `enumerable:false` 标志。并且 `for..in` 只会列出可枚举的属性。这就是为什么它和其余的 `Object.prototype` 属性都未被列出。\n\n```smart header=\"几乎所有其他键/值获取方法都忽略继承的属性\"\n几乎所有其他键/值获取方法，例如 `Object.keys` 和 `Object.values` 等，都会忽略继承的属性。\n\n它们只会对对象自身进行操作。**不考虑** 继承自原型的属性。\n```\n\n## 总结\n\n- 在 JavaScript 中，所有的对象都有一个隐藏的 `[[Prototype]]` 属性，它要么是另一个对象，要么就是 `null`。\n- 我们可以使用 `obj.__proto__` 访问它（历史遗留下来的 getter/setter，这儿还有其他方法，很快我们就会讲到）。\n- 通过 `[[Prototype]]` 引用的对象被称为“原型”。\n- 如果我们想要读取 `obj` 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。\n- 写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。\n- 如果我们调用 `obj.method()`，而且 `method` 是从原型中获取的，`this` 仍然会引用 `obj`。因此，方法始终与当前对象一起使用，即使方法是继承的。\n- `for..in` 循环在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。",
        "libs": [],
        "children": [
          "property-after-delete",
          "search-algorithm",
          "proto-and-this",
          "hamster-proto"
        ],
        "parent": "prototypes",
        "updatedAt": 1666799532
      }
    },
    "property-after-delete": {
      "type": "Task",
      "value": {
        "title": "使用原型",
        "slug": "property-after-delete",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/1-property-after-delete",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面这段代码创建了一对对象，然后对它们进行修改。\n\n过程中会显示哪些值？\n\n```js\nlet animal = {\n  jumps: null\n};\nlet rabbit = {\n  __proto__: animal,\n  jumps: true\n};\n\nalert( rabbit.jumps ); // ? (1)\n\ndelete rabbit.jumps;\n\nalert( rabbit.jumps ); // ? (2)\n\ndelete animal.jumps;\n\nalert( rabbit.jumps ); // ? (3)\n```\n\n应该有 3 个答案。",
        "solution": "1. `true`，来自于 `rabbit`。\n2. `null`，来自于 `animal`。\n3. `undefined`，不再有这样的属性存在。",
        "parent": "prototype-inheritance",
        "version": 1
      }
    },
    "search-algorithm": {
      "type": "Task",
      "value": {
        "title": "搜索算法",
        "slug": "search-algorithm",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/2-search-algorithm",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n本题目有两个部分。\n\n给定以下对象：\n\n```js\nlet head = {\n  glasses: 1\n};\n\nlet table = {\n  pen: 3\n};\n\nlet bed = {\n  sheet: 1,\n  pillow: 2\n};\n\nlet pockets = {\n  money: 2000\n};\n```\n\n1. 使用 `__proto__` 来分配原型，以使得任何属性的查找都遵循以下路径：`pockets` -> `bed` -> `table` -> `head`。例如，`pockets.pen` 应该是 `3`（在 `table` 中找到），`bed.glasses` 应该是 `1`（在 `head` 中找到）。\n2. 回答问题：通过 `pockets.glasses` 或 `head.glasses` 获取 `glasses`，哪个更快？必要时需要进行基准测试。",
        "solution": "1. 让我们添加 `__proto__`：\n\n    ```js run\n    let head = {\n      glasses: 1\n    };\n\n    let table = {\n      pen: 3,\n      __proto__: head\n    };\n\n    let bed = {\n      sheet: 1,\n      pillow: 2,\n      __proto__: table\n    };\n\n    let pockets = {\n      money: 2000,\n      __proto__: bed\n    };\n\n    alert( pockets.pen ); // 3\n    alert( bed.glasses ); // 1\n    alert( table.money ); // undefined\n    ```\n\n2. 在现代引擎中，从性能的角度来看，我们是从对象还是从原型链获取属性都是没区别的。它们（引擎）会记住在哪里找到的该属性，并在下一次请求中重用它。\n\n    例如，对于 `pockets.glasses` 来说，它们（引擎）会记得在哪里找到的 `glasses`（在 `head` 中），这样下次就会直接在这个位置进行搜索。并且引擎足够聪明，一旦有内容更改，它们就会自动更新内部缓存，因此，该优化是安全的。",
        "parent": "prototype-inheritance",
        "version": 1
      }
    },
    "proto-and-this": {
      "type": "Task",
      "value": {
        "title": "写在哪里？",
        "slug": "proto-and-this",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/3-proto-and-this",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有从 `animal` 中继承的 `rabbit`。\n\n如果我们调用 `rabbit.eat()`，哪一个对象会接收到 `full` 属性：`animal` 还是 `rabbit`？\n\n```js\nlet animal = {\n  eat() {\n    this.full = true;\n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\nrabbit.eat();\n```",
        "solution": "**答案：`rabbit`。**\n\n这是因为 `this` 是点符号前面的这个对象，因此 `rabbit.eat()` 修改了 `rabbit`。\n\n属性查找和执行是两回事儿。\n\n首先在原型中找到 `rabbit.eat` 方法，然后在 `this=rabbit` 的情况下执行。",
        "parent": "prototype-inheritance",
        "version": 1
      }
    },
    "hamster-proto": {
      "type": "Task",
      "value": {
        "title": "为什么两只仓鼠都饱了？",
        "slug": "hamster-proto",
        "githubPath": "/1-js/08-prototypes/01-prototype-inheritance/4-hamster-proto",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有两只仓鼠：`speedy` 和 `lazy` 都继承自普通的 `hamster` 对象。 \n\n当我们喂其中一只的时候，另一只也吃饱了。为什么？如何修复它？\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster\n};\n\nlet lazy = {\n  __proto__: hamster\n};\n\n// 这只仓鼠找到了食物\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// 这只仓鼠也找到了食物，为什么？请修复它。\nalert( lazy.stomach ); // apple\n```",
        "solution": "我们仔细研究一下在调用 `speedy.eat(\"apple\")` 的时候，发生了什么。\n\n1. `speedy.eat` 方法在原型（`=hamster`）中被找到，然后执行 `this=speedy`（在点符号前面的对象）。\n\n2. `this.stomach.push()` 需要找到 `stomach` 属性，然后对其调用 `push`。它在 `this`（`=speedy`）中查找 `stomach`，但并没有找到。\n\n3. 然后它顺着原型链，在 `hamster` 中找到 `stomach`。\n\n4. 然后它对 `stomach` 调用 `push`，将食物添加到 **`stomach` 的原型** 中。\n\n因此，所有的仓鼠共享了同一个胃！\n\n对于 `lazy.stomach.push(...)` 和 `speedy.stomach.push()` 而言，属性 `stomach` 被在原型中找到（不是在对象自身），然后向其中 `push` 了新数据。\n\n请注意，在简单的赋值 `this.stomach=` 的情况下不会出现这种情况：\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n*!*\n    // 分配给 this.stomach 而不是 this.stomach.push\n    this.stomach = [food];\n*/!*\n  }\n};\n\nlet speedy = {\n   __proto__: hamster\n};\n\nlet lazy = {\n  __proto__: hamster\n};\n\n// 仓鼠 Speedy 找到了食物\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// 仓鼠 Lazy 的胃是空的\nalert( lazy.stomach ); // <nothing>\n```\n\n现在，一切都运行正常，因为 `this.stomach=` 不会执行对 `stomach` 的查找。该值会被直接写入 `this` 对象。\n\n此外，我们还可以通过确保每只仓鼠都有自己的胃来完全回避这个问题：\n\n```js run\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster,\n*!*\n  stomach: []\n*/!*\n};\n\nlet lazy = {\n  __proto__: hamster,\n*!*\n  stomach: []\n*/!*\n};\n\n// 仓鼠 Speedy 找到了食物\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// 仓鼠 Lazy 的胃是空的\nalert( lazy.stomach ); // <nothing>\n```\n\n作为一种常见的解决方案，所有描述特定对象状态的属性，例如上面的 `stomach`，都应该被写入该对象中。这样可以避免此类问题。",
        "parent": "prototype-inheritance",
        "version": 1
      }
    },
    "function-prototype": {
      "type": "Article",
      "value": {
        "title": "F.prototype",
        "slug": "function-prototype",
        "githubPath": "/1-js/08-prototypes/02-function-prototype",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n我们还记得，可以使用诸如 `new F()` 这样的构造函数来创建一个新对象。\n\n如果 `F.prototype` 是一个对象，那么 `new` 操作符会使用它为新对象设置 `[[Prototype]]`。\n\n```smart\nJavaScript 从一开始就有了原型继承。这是 JavaScript 编程语言的核心特性之一。\n\n但是在过去，没有直接对其进行访问的方式。唯一可靠的方法是本章中会介绍的构造函数的 `\"prototype\"` 属性。目前仍有许多脚本仍在使用它。\n```\n\n请注意，这里的 `F.prototype` 指的是 `F` 的一个名为 `\"prototype\"` 的常规属性。这听起来与“原型”这个术语很类似，但这里我们实际上指的是具有该名字的常规属性。\n\n下面是一个例子：\n\n```js run\nlet animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n\n*!*\nRabbit.prototype = animal;\n*/!*\n\nlet rabbit = new Rabbit(\"White Rabbit\"); //  rabbit.__proto__ == animal\n\nalert( rabbit.eats ); // true\n```\n\n设置 `Rabbit.prototype = animal` 的字面意思是：“当创建了一个 `new Rabbit` 时，把它的 `[[Prototype]]` 赋值为 `animal`”。\n\n这是结果示意图：\n\n![](proto-constructor-animal-rabbit.svg)\n\n在上图中，`\"prototype\"` 是一个水平箭头，表示一个常规属性，`[[Prototype]]` 是垂直的，表示 `rabbit` 继承自 `animal`。\n\n```smart header=\"`F.prototype` 仅用在 `new F` 时\"\n`F.prototype` 属性仅在 `new F` 被调用时使用，它为新对象的 `[[Prototype]]` 赋值。\n\n如果在创建之后，`F.prototype` 属性有了变化（`F.prototype = <another object>`），那么通过 `new F` 创建的新对象也将随之拥有新的对象作为 `[[Prototype]]`，但已经存在的对象将保持旧有的值。\n```\n\n##  默认的 F.prototype，构造器属性\n\n每个函数都有 `\"prototype\"` 属性，即使我们没有提供它。\n\n默认的 `\"prototype\"` 是一个只有属性 `constructor` 的对象，属性 `constructor` 指向函数自身。\n\n像这样：\n\n```js\nfunction Rabbit() {}\n\n/* 默认的 prototype\nRabbit.prototype = { constructor: Rabbit };\n*/\n```\n\n![](function-prototype-constructor.svg)\n\n我们可以检查一下：\n\n```js run\nfunction Rabbit() {}\n// 默认：\n// Rabbit.prototype = { constructor: Rabbit }\n\nalert( Rabbit.prototype.constructor == Rabbit ); // true\n```\n\n通常，如果我们什么都不做，`constructor` 属性可以通过 `[[Prototype]]` 给所有 rabbits 使用：\n\n```js run\nfunction Rabbit() {}\n// 默认：\n// Rabbit.prototype = { constructor: Rabbit }\n\nlet rabbit = new Rabbit(); // 继承自 {constructor: Rabbit}\n\nalert(rabbit.constructor == Rabbit); // true (from prototype)\n```\n\n![](rabbit-prototype-constructor.svg)\n\n我们可以使用 `constructor` 属性来创建一个新对象，该对象使用与现有对象相同的构造器。\n\n像这样：\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n  alert(name);\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\n*!*\nlet rabbit2 = new rabbit.constructor(\"Black Rabbit\");\n*/!*\n```\n\n当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。\n\n但是，关于 `\"constructor\"` 最重要的是……\n\n**……JavaScript 自身并不能确保正确的 `\"constructor\"` 函数值。**\n\n是的，它存在于函数的默认 `\"prototype\"` 中，但仅此而已。之后会发生什么 —— 完全取决于我们。\n\n特别是，如果我们将整个默认 prototype 替换掉，那么其中就不会有 `\"constructor\"` 了。\n\n例如：\n\n```js run\nfunction Rabbit() {}\nRabbit.prototype = {\n  jumps: true\n};\n\nlet rabbit = new Rabbit();\n*!*\nalert(rabbit.constructor === Rabbit); // false\n*/!*\n```\n\n因此，为了确保正确的 `\"constructor\"`，我们可以选择添加/删除属性到默认 `\"prototype\"`，而不是将其整个覆盖：\n\n```js\nfunction Rabbit() {}\n\n// 不要将 Rabbit.prototype 整个覆盖\n// 可以向其中添加内容 \nRabbit.prototype.jumps = true\n// 默认的 Rabbit.prototype.constructor 被保留了下来\n```\n\n或者，也可以手动重新创建 `constructor` 属性：\n\n```js\nRabbit.prototype = {\n  jumps: true,\n*!*\n  constructor: Rabbit\n*/!*\n};\n\n// 这样的 constructor 也是正确的，因为我们手动添加了它\n```\n\n\n## 总结\n\n在本章中，我们简要介绍了为通过构造函数创建的对象设置 `[[Prototype]]` 的方法。稍后我们将看到更多依赖于此的高级编程模式。\n\n一切都很简单，只需要记住几条重点就可以清晰地掌握了：\n\n- `F.prototype` 属性（不要把它与 `[[Prototype]]` 弄混了）在 `new F` 被调用时为新对象的 `[[Prototype]]` 赋值。\n- `F.prototype` 的值要么是一个对象，要么就是 `null`：其他值都不起作用。\n- `\"prototype\"` 属性仅当设置在一个构造函数上，并通过 `new` 调用时，才具有这种特殊的影响。\n\n在常规对象上，`prototype` 没什么特别的：\n```js\nlet user = {\n  name: \"John\",\n  prototype: \"Bla-bla\" // 这里只是普通的属性\n};\n```\n\n默认情况下，所有函数都有 `F.prototype = {constructor：F}`，所以我们可以通过访问它的 `\"constructor\"` 属性来获取一个对象的构造器。",
        "libs": [],
        "children": [
          "changing-prototype",
          "new-object-same-constructor"
        ],
        "parent": "prototypes",
        "updatedAt": 1658221850
      }
    },
    "changing-prototype": {
      "type": "Task",
      "value": {
        "title": "修改 \"prototype\"",
        "slug": "changing-prototype",
        "githubPath": "/1-js/08-prototypes/02-function-prototype/1-changing-prototype",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n在下面的代码中，我们创建了 `new Rabbit`，然后尝试修改它的 prototype。\n\n最初，我们有以下代码：\n\n```js run\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\nalert( rabbit.eats ); // true\n```\n\n\n1. 我们增加了一行代码（已高亮）。现在 `alert` 会显示什么？\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    Rabbit.prototype = {};\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n2. ……如果代码是这样的（修改了一行）？\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    Rabbit.prototype.eats = false;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n3. 像这样呢（修改了一行）？\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    delete rabbit.eats;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```\n\n4. 最后一种变体：\n\n    ```js\n    function Rabbit() {}\n    Rabbit.prototype = {\n      eats: true\n    };\n\n    let rabbit = new Rabbit();\n\n    *!*\n    delete Rabbit.prototype.eats;\n    */!*\n\n    alert( rabbit.eats ); // ?\n    ```",
        "solution": "答案：\n\n1. `true`。\n\n    `Rabbit.prototype` 的赋值操作为新对象设置了 `[[Prototype]]`，但它不影响已有的对象。\n\n2. `false`。\n\n    对象通过引用被赋值。来自 `Rabbit.prototype` 的对象并没有被赋值，它仍然是被 `Rabbit.prototype` 和 `rabbit` 的 `[[Prototype]]` 引用的单个对象。\n\n    所以当我们通过一个引用更改其内容时，它对其他引用也是可见的。\n\n3. `true`。\n\n    所有 `delete` 操作都直接应用于对象。这里的 `delete rabbit.eats` 试图从 `rabbit` 中删除 `eats` 属性，但 `rabbit` 对象并没有 `eats` 属性。所以这个操作不会有任何影响。\n\n4. `undefined`。\n\n    属性 `eats` 被从 prototype 中删除，prototype 中就没有这个属性了。",
        "parent": "function-prototype",
        "version": 1
      }
    },
    "new-object-same-constructor": {
      "type": "Task",
      "value": {
        "title": "使用相同的构造函数创建一个对象",
        "slug": "new-object-same-constructor",
        "githubPath": "/1-js/08-prototypes/02-function-prototype/4-new-object-same-constructor",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n想象一下，我们有一个由构造函数创建的对象 `obj` —— 我们不知道使用的是哪个构造函数，但是我们想使用它创建一个新对象。\n\n我们可以这样做吗？\n\n```js\nlet obj2 = new obj.constructor();\n```\n\n请给出一个可以使这样的代码正常工作的 `obj` 的构造函数的例子。再给出会导致这样的代码无法正确工作的例子。",
        "solution": "如果我们确信 `\"constructor\"` 属性具有正确的值，那么就可以使用这种方法。\n\n例如，如果我们不触碰默认的 `\"prototype\"`，那么这段代码肯定可以正常运行：\n\n```js run\nfunction User(name) {\n  this.name = name;\n}\n\nlet user = new User('John');\nlet user2 = new user.constructor('Pete');\n\nalert( user2.name ); // Pete (worked!)\n```\n\n它起作用了，因为 `User.prototype.constructor == User`。\n\n……但是如果有人，重写了 `User.prototype`，并忘记可重新创建 `constructor` 以引用 `User`，那么上面这段代码就会运行失败。\n\n例如：\n\n```js run\nfunction User(name) {\n  this.name = name;\n}\n*!*\nUser.prototype = {}; // (*)\n*/!*\n\nlet user = new User('John');\nlet user2 = new user.constructor('Pete');\n\nalert( user2.name ); // undefined\n```\n\n为什么 `user2.name` 是 `undefined`？\n\n这是 `new user.constructor('Pete')` 的工作流程：\n\n1. 首先，它在 `user` 中寻找 `constructor`。没找到。\n2. 然后它追溯原型链。`user` 的原型是 `User.prototype`，它也没有 `constructor`（因为我们“忘记”在右侧设定它了）。\n3. 再向上追溯，`User.prototype` 是一个普通对象 `{}`，其原型是 `Object.prototype`。\n4. 最终，对于内建的 `Object.prototype`，有一个内建的 `Object.prototype.constructor == Object`。所以就用它了。\n\n所以，最终我们得到了 `let user2 = new Object('Pete')`。\n\n可能这不是我们想要的。我们想创建 `new User` 而不是 `new Object`。这就是缺少 `constructor` 的结果。\n\n（以防你好奇，`new Object(...)` 调用会将其参数转换为对象。这是理论上的，在实际中没有人会调用 `new Object` 并传入一个值，通常我们也不会使用 `new Object` 来创建对象）。",
        "parent": "function-prototype",
        "version": 1
      }
    },
    "native-prototypes": {
      "type": "Article",
      "value": {
        "title": "原生的原型",
        "slug": "native-prototypes",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n`\"prototype\"` 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内建构造函数都用到了它。\n\n首先，我们将看看原生原型的详细信息，然后学习如何使用它为内建对象添加新功能。\n\n## Object.prototype\n\n假如我们输出一个空对象：\n\n```js run\nlet obj = {};\nalert( obj ); // \"[object Object]\" ?\n```\n\n生成字符串 `\"[object Object]\"` 的代码在哪里？那就是一个内建的 `toString` 方法，但是它在哪里呢？`obj` 是空的！\n\n……然而简短的表达式 `obj = {}` 和 `obj = new Object()` 是一个意思，其中 `Object` 就是一个内建的对象构造函数，其自身的 `prototype` 指向一个带有 `toString` 和其他方法的一个巨大的对象。\n\n就像这样：\n\n![](object-prototype.svg)\n\n当 `new Object()` 被调用（或一个字面量对象 `{...}` 被创建），按照前面章节中我们学习过的规则，这个对象的 `[[Prototype]]` 属性被设置为 `Object.prototype`：\n\n![](object-prototype-1.svg)\n\n所以，之后当 `obj.toString()` 被调用时，这个方法是从 `Object.prototype` 中获取的。\n\n我们可以这样验证它：\n\n```js run\nlet obj = {};\n\nalert(obj.__proto__ === Object.prototype); // true\n\nalert(obj.toString === obj.__proto__.toString); //true\nalert(obj.toString === Object.prototype.toString); //true\n```\n\n请注意在 `Object.prototype` 上方的链中没有更多的 `[[Prototype]]`：\n\n```js run\nalert(Object.prototype.__proto__); // null\n```\n\n## 其他内建原型\n\n其他内建对象，像 `Array`、`Date`、`Function` 及其他，都在 prototype 上挂载了方法。\n\n例如，当我们创建一个数组 `[1, 2, 3]`，在内部会默认使用 `new Array()` 构造器。因此 `Array.prototype` 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。\n\n按照规范，所有的内建原型顶端都是 `Object.prototype`。这就是为什么有人说“一切都从对象继承而来”。\n\n下面是完整的示意图（3 个内建对象）：\n\n![](native-prototypes-classes.svg)\n\n让我们手动验证原型：\n\n```js run\nlet arr = [1, 2, 3];\n\n// 它继承自 Array.prototype？\nalert( arr.__proto__ === Array.prototype ); // true\n\n// 接下来继承自 Object.prototype？\nalert( arr.__proto__.__proto__ === Object.prototype ); // true\n\n// 原型链的顶端为 null。\nalert( arr.__proto__.__proto__.__proto__ ); // null\n```\n\n一些方法在原型上可能会发生重叠，例如，`Array.prototype` 有自己的 `toString` 方法来列举出来数组的所有元素并用逗号分隔每一个元素。\n\n```js run\nlet arr = [1, 2, 3]\nalert(arr); // 1,2,3 <-- Array.prototype.toString 的结果\n```\n\n正如我们之前看到的那样，`Object.prototype` 也有 `toString` 方法，但是 `Array.prototype` 在原型链上更近，所以数组对象原型上的方法会被使用。\n\n\n![](native-prototypes-array-tostring.svg)\n\n\n浏览器内的工具，像 Chrome 开发者控制台也会显示继承性（可能需要对内建对象使用 `console.dir`）：\n\n![](console_dir_array.png)\n\n其他内建对象也以同样的方式运行。即使是函数 —— 它们是内建构造器 `Function` 的对象，并且它们的方法（`call`/`apply` 及其他）都取自 `Function.prototype`。函数也有自己的 `toString` 方法。\n\n```js run\nfunction f() {}\n\nalert(f.__proto__ == Function.prototype); // true\nalert(f.__proto__.__proto__ == Object.prototype); // true，继承自 Object\n```\n\n## 基本数据类型\n\n最复杂的事情发生在字符串、数字和布尔值上。\n\n正如我们记忆中的那样，它们并不是对象。但是如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 `String`、`Number` 和 `Boolean` 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。\n\n这些对象对我们来说是无形地创建出来的。大多数引擎都会对其进行优化，但是规范中描述的就是通过这种方式。这些对象的方法也驻留在它们的 prototype 中，可以通过 `String.prototype`、`Number.prototype` 和 `Boolean.prototype` 进行获取。\n\n```warn header=\"值 `null` 和 `undefined` 没有对象包装器\"\n特殊值 `null` 和 `undefined` 比较特殊。它们没有对象包装器，所以它们没有方法和属性。并且它们也没有相应的原型。\n```\n\n## 更改原生原型 [#native-prototype-change]\n\n原生的原型是可以被修改的。例如，我们向 `String.prototype` 中添加一个方法，这个方法将对所有的字符串都是可用的：\n\n```js run\nString.prototype.show = function() {\n  alert(this);\n};\n\n\"BOOM!\".show(); // BOOM!\n```\n\n在开发的过程中，我们可能会想要一些新的内建方法，并且想把它们添加到原生原型中。但这通常是一个很不好的想法。\n\n```warn\n原型是全局的，所以很容易造成冲突。如果有两个库都添加了 `String.prototype.show` 方法，那么其中的一个方法将被另一个覆盖。\n\n所以，通常来说，修改原生原型被认为是一个很不好的想法。\n```\n\n**在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。**\n\nPolyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。\n\n例如：\n\n```js run\nif (!String.prototype.repeat) { // 如果这儿没有这个方法\n  // 那就在 prototype 中添加它\n\n  String.prototype.repeat = function(n) {\n    // 重复传入的字符串 n 次\n\n    // 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）\n    // 但即使是不够完美的 polyfill 也常常被认为是足够好的\n    return new Array(n + 1).join(this);\n  };\n}\n\nalert( \"La\".repeat(3) ); // LaLaLa\n```\n\n\n## 从原型中借用\n\n在 <info:call-apply-decorators#method-borrowing> 一章中，我们讨论了方法借用。\n\n那是指我们从一个对象获取一个方法，并将其复制到另一个对象。\n\n一些原生原型的方法通常会被借用。\n\n例如，如果我们要创建类数组对象，则可能需要向其中复制一些 `Array` 方法。\n\n例如：\n\n```js run\nlet obj = {\n  0: \"Hello\",\n  1: \"world!\",\n  length: 2,\n};\n\n*!*\nobj.join = Array.prototype.join;\n*/!*\n\nalert( obj.join(',') ); // Hello,world!\n```\n\n上面这段代码有效，是因为内建的方法 `join` 的内部算法只关心正确的索引和 `length` 属性。它不会检查这个对象是否是真正的数组。许多内建方法就是这样。\n\n另一种方式是通过将 `obj.__proto__` 设置为 `Array.prototype`，这样 `Array` 中的所有方法都自动地可以在 `obj` 中使用了。\n\n但是如果 `obj` 已经从另一个对象进行了继承，那么这种方法就不可行了（译注：因为这样会覆盖掉已有的继承。此处 `obj` 其实已经从 `Object` 进行了继承，但是 `Array` 也继承自 `Object`，所以此处的方法借用不会影响 `obj` 对原有继承的继承，因为 `obj` 通过原型链依旧继承了 `Object`）。请记住，我们一次只能继承一个对象。\n\n方法借用很灵活，它允许在需要时混合来自不同对象的方法。\n\n## 总结\n\n- 所有的内建对象都遵循相同的模式（pattern）：\n    - 方法都存储在 prototype 中（`Array.prototype`、`Object.prototype`、`Date.prototype` 等）。\n    - 对象本身只存储数据（数组元素、对象属性、日期）。\n- 原始数据类型也将方法存储在包装器对象的 prototype 中：`Number.prototype`、`String.prototype` 和 `Boolean.prototype`。只有 `undefined` 和 `null` 没有包装器对象。\n- 内建原型可以被修改或被用新的方法填充。但是不建议更改它们。唯一允许的情况可能是，当我们添加一个还没有被 JavaScript 引擎支持，但已经被加入 JavaScript 规范的新标准时，才可能允许这样做。",
        "libs": [],
        "children": [
          "defer-to-prototype",
          "defer-to-prototype-extended"
        ],
        "parent": "prototypes",
        "updatedAt": 1658223468
      }
    },
    "defer-to-prototype": {
      "type": "Task",
      "value": {
        "title": "给函数添加一个 \"f.defer(ms)\" 方法",
        "slug": "defer-to-prototype",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes/1-defer-to-prototype",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n在所有函数的原型中添加 `defer(ms)` 方法，该方法将在 `ms` 毫秒后运行该函数。\n\n当你完成添加后，下面的代码应该是可执行的：\n\n```js\nfunction f() {\n  alert(\"Hello!\");\n}\n\nf.defer(1000); // 1 秒后显示 \"Hello!\"\n```",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  setTimeout(this, ms);\n};\n\nfunction f() {\n  alert(\"Hello!\");\n}\n\nf.defer(1000); // 1 秒后显示 \"Hello!\"\n```",
        "parent": "native-prototypes",
        "version": 1
      }
    },
    "defer-to-prototype-extended": {
      "type": "Task",
      "value": {
        "title": "将装饰器 \"defer()\" 添加到函数",
        "slug": "defer-to-prototype-extended",
        "githubPath": "/1-js/08-prototypes/03-native-prototypes/2-defer-to-prototype-extended",
        "weight": 2,
        "libs": [],
        "importance": 4,
        "content": "\n\n在所有函数的原型中添加 `defer(ms)` 方法，该方法返回一个包装器，将函数调用延迟 `ms` 毫秒。\n\n下面是它应该如何执行的例子：\n\n```js\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // 1 秒后显示 3\n```\n\n请注意，参数应该被传给原始函数。",
        "solution": "```js run\nFunction.prototype.defer = function(ms) {\n  let f = this;\n  return function(...args) {\n    setTimeout(() => f.apply(this, args), ms);\n  }\n};\n\n// check it\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // 1 秒后显示 3\n```\n\n请注意：我们在 `f.apply` 中使用 `this` 以使装饰器适用于对象方法。\n\n因此，如果将包装器函数作为对象方法调用，那么 `this` 将会被传递给原始方法 `f`。\n\n```js run\nFunction.prototype.defer = function(ms) {\n  let f = this;\n  return function(...args) {\n    setTimeout(() => f.apply(this, args), ms);\n  }\n};\n\nlet user = {\n  name: \"John\",\n  sayHi() {\n    alert(this.name);\n  }\n}\n\nuser.sayHi = user.sayHi.defer(1000);\n\nuser.sayHi();\n```",
        "parent": "native-prototypes",
        "version": 1
      }
    },
    "prototype-methods": {
      "type": "Article",
      "value": {
        "title": "原型方法，没有 __proto__ 的对象",
        "slug": "prototype-methods",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n在这部分内容的第一章中，我们提到了设置原型的现代方法。\n\n使用 `obj.__proto__` 设置或读取原型被认为已经过时且不推荐使用（deprecated）了（已经被移至 JavaScript 规范的附录 B，意味着仅适用于浏览器）。\n\n现代的获取/设置原型的方法有：\n\n- [Object.getPrototypeOf(obj)](mdn:js/Object/getPrototypeOf) —— 返回对象 `obj` 的 `[[Prototype]]`。\n- [Object.setPrototypeOf(obj, proto)](mdn:js/Object/setPrototypeOf) —— 将对象 `obj` 的 `[[Prototype]]` 设置为 `proto`。\n\n`__proto__` 不被反对的唯一的用法是在创建新对象时，将其用作属性：`{ __proto__: ... }`。\n\n虽然，也有一种特殊的方法：\n\n- [Object.create(proto, [descriptors])](mdn:js/Object/create) —— 利用给定的 `proto` 作为 `[[Prototype]]` 和可选的属性描述来创建一个空对象。\n\n例如：\n\n```js run\nlet animal = {\n  eats: true\n};\n\n// 创建一个以 animal 为原型的新对象\n*!*\nlet rabbit = Object.create(animal); // 与 {__proto__: animal} 相同\n*/!*\n\nalert(rabbit.eats); // true\n\n*!*\nalert(Object.getPrototypeOf(rabbit) === animal); // true\n*/!*\n\n*!*\nObject.setPrototypeOf(rabbit, {}); // 将 rabbit 的原型修改为 {}\n*/!*\n```\n\n`Object.create` 方法更强大，因为它有一个可选的第二参数：属性描述器。\n\n我们可以在此处为新对象提供额外的属性，就像这样：\n\n```js run\nlet animal = {\n  eats: true\n};\n\nlet rabbit = Object.create(animal, {\n  jumps: {\n    value: true\n  }\n});\n\nalert(rabbit.jumps); // true\n```\n\n描述器的格式与 <info:property-descriptors> 一章中所讲的一样。\n\n我们可以使用 `Object.create` 来实现比复制 `for..in` 循环中的属性更强大的对象克隆方式：\n\n```js\nlet clone = Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n);\n```\n\n此调用可以对 `obj` 进行真正准确地拷贝，包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 `[[Prototype]]`。\n\n## 原型简史\n\n有这么多可以处理 `[[Prototype]]` 的方式。发生了什么？为什么会这样？\n\n这是历史原因。\n\n原型继承从一开始就存在于语言中，但管理它的方式随着时间的推移而演变。\n\n- 构造函数的 `\"prototype\"` 属性自古以来就起作用。这是使用给定原型创建对象的最古老的方式。\n- 之后，在 2012 年，`Object.create` 出现在标准中。它提供了使用给定原型创建对象的能力。但没有提供 get/set 它的能力。一些浏览器实现了非标准的 `__proto__` 访问器，以为开发者提供更多的灵活性。\n- 之后，在 2015 年，`Object.setPrototypeOf` 和 `Object.getPrototypeOf` 被加入到标准中，执行与 `__proto__` 相同的功能。由于 `__proto__` 实际上已经在所有地方都得到了实现，但它已过时，所以被加入到该标准的附件 B 中，即：在非浏览器环境下，它的支持是可选的。\n- 之后，在 2022 年，官方允许在对象字面量 `{...}` 中使用 `__proto__`（从附录 B 中移出来了），但不能用作 getter/setter `obj.__proto__`（仍在附录 B 中）。\n\n为什么要用函数 `getPrototypeOf/setPrototypeOf` 取代 `__proto__`？\n\n为什么 `__proto__` 被部分认可并允许在 `{...}` 中使用，但仍不能用作 getter/setter？\n\n这是一个有趣的问题，需要我们理解为什么 `__proto__` 不好。\n\n很快我们就会看到答案。\n\n```warn header=\"如果速度很重要，就请不要修改已存在的对象的 `[[Prototype]]`\"\n从技术上来讲，我们可以在任何时候 get/set `[[Prototype]]`。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改：`rabbit` 继承自 `animal`，之后不再更改。\n\n并且，JavaScript 引擎对此进行了高度优化。用 `Object.setPrototypeOf` 或 `obj.__proto__=` “即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。因此，除非你知道自己在做什么，或者 JavaScript 的执行速度对你来说完全不重要，否则请避免使用它。\n```\n\n## \"Very plain\" objects [#very-plain]\n\n我们知道，对象可以用作关联数组（associative arrays）来存储键/值对。\n\n……但是如果我们尝试在其中存储 **用户提供的** 键（例如：一个用户输入的字典），我们可以发现一个有趣的小故障：所有的键都正常工作，除了 `\"__proto__\"`。\n\n看一下这个例子：\n\n```js run\nlet obj = {};\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // [object Object]，并不是 \"some value\"！\n```\n\n这里如果用户输入 `__proto__`，那么在第四行的赋值会被忽略！\n\n对于非开发者来说，这肯定很令人惊讶，但对我们来说却是可以理解的。`__proto__` 属性很特殊：它必须是一个对象或者 `null`。字符串不能成为原型。这就是为什么将字符串赋值给 `__proto__` 会被忽略。\n\n但我们不是 **打算** 实现这种行为，对吧？我们想要存储键值对，然而键名为 `\"__proto__\"` 的键值对没有被正确存储。所以这是一个 bug。\n\n这里的后果并没有很严重。但在其他情况下，我们可能会在 `obj` 中存储对象而不是字符串，则原型确实会被改变。结果，执行将以完全意想不到的方式出错。\n\n最可怕的是 —— 通常开发者完全不会考虑到这一点。这让此类 bug 很难被发现，甚至变成漏洞，尤其是在 JavaScript 被用在服务端的时候。\n\n对 `obj.toString` 进行赋值时也可能发生意想不到的事情，因为它是一个内建的对象方法。\n\n我们怎么避免这样的问题呢？\n\n首先，我们可以改用 `Map` 来代替普通对象进行存储，这样一切都迎刃而解：\n\n```js run\nlet map = new Map();\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nmap.set(key, \"some value\");\n\nalert(map.get(key)); // \"some value\"（符合预期）\n```\n\n……但 `Object` 语法通常更吸引人，因为它更简洁。\n\n幸运的是，我们 **可以** 使用对象，因为 JavaScript 语言的制造者很久以前就考虑过这个问题。\n\n正如我们所知道的，`__proto__` 不是对象的属性，而是 `Object.prototype` 的访问器属性：\n\n![](object-prototype-2.svg)\n\n因此，如果 `obj.__proto__` 被读取或者赋值，那么对应的 getter/setter 会被从它的原型中调用，它会 set/get `[[Prototype]]`。\n\n就像在本部分教程的开头所说的那样：`__proto__` 是一种访问 `[[Prototype]]` 的方式，而不是 `[[prototype]]` 本身。\n\n现在，我们想要将一个对象用作关联数组，并且摆脱此类问题，我们可以使用一些小技巧：\n\n```js run\n*!*\nlet obj = Object.create(null);\n// 或者：obj = { __proto__: null }\n*/!*\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // \"some value\"\n```\n\n`Object.create(null)` 创建了一个空对象，这个对象没有原型（`[[Prototype]]` 是 `null`）：\n\n![](object-prototype-null.svg)\n\n因此，它没有继承 `__proto__` 的 getter/setter 方法。现在，它被作为正常的数据属性进行处理，因此上面的这个示例能够正常工作。\n\n我们可以把这样的对象称为 \"very plain\" 或 \"pure dictionary\" 对象，因为它们甚至比通常的普通对象（plain object）`{...}` 还要简单。\n\n缺点是这样的对象没有任何内建的对象的方法，例如 `toString`：\n\n```js run\n*!*\nlet obj = Object.create(null);\n*/!*\n\nalert(obj); // Error (no toString)\n```\n\n……但是它们通常对关联数组而言还是很友好。\n\n请注意，大多数与对象相关的方法都是 `Object.something(...)`，例如 `Object.keys(obj)` —— 它们不在 prototype 中，因此在 \"very plain\" 对象中它们还是可以继续使用：\n\n\n```js run\nlet chineseDictionary = Object.create(null);\nchineseDictionary.hello = \"你好\";\nchineseDictionary.bye = \"再见\";\n\nalert(Object.keys(chineseDictionary)); // hello,bye\n```\n\n## 总结\n\n- 要使用给定的原型创建对象，使用：\n\n    - 字面量语法：`{ __proto__: ... }`，允许指定多个属性\n    - 或 [Object.create(proto, [descriptors])](mdn:js/Object/create)，允许指定属性描述符。\n\n    `Object.create` 提供了一种简单的方式来浅拷贝对象及其所有属性描述符（descriptors）。\n\n    ```js\n    let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n    ```\n\n- 设置和访问原型的现代方法有：\n\n  - [Object.getPrototypeOf(obj)](mdn:js/Object/getPrototypeOf) —— 返回对象 `obj` 的 `[[Prototype]]`（与 `__proto__` 的 getter 相同）。\n  - [Object.setPrototypeOf(obj, proto)](mdn:js/Object/setPrototypeOf) —— 将对象 `obj` 的 `[[Prototype]]` 设置为 `proto`（与 `__proto__` 的 setter 相同）。\n\n- 不推荐使用内建的的 `__proto__` getter/setter 获取/设置原型，它现在在 ECMA 规范的附录 B 中。\n\n- 我们还介绍了使用 `Object.create(null)` 或 `{__proto__: null}` 创建的无原型的对象。\n\n    这些对象被用作字典，以存储任意（可能是用户生成的）键。\n\n    通常，对象会从 `Object.prototype` 继承内建的方法和 `__proto__` getter/setter，会占用相应的键，且可能会导致副作用。原型为 `null` 时，对象才真正是空的。",
        "libs": [],
        "children": [
          "dictionary-tostring",
          "compare-calls"
        ],
        "parent": "prototypes",
        "updatedAt": 1667832827
      }
    },
    "dictionary-tostring": {
      "type": "Task",
      "value": {
        "title": "为 dictionary 添加 toString 方法",
        "slug": "dictionary-tostring",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods/2-dictionary-tostring",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n这儿有一个通过 `Object.create(null)` 创建的，用来存储任意 `key/value` 对的对象 `dictionary`。\n\n为该对象添加 `dictionary.toString()` 方法，该方法应该返回以逗号分隔的所有键的列表。你的 `toString` 方法不应该在使用 `for...in` 循环遍历数组的时候显现出来。\n\n它的工作方式如下：\n\n```js\nlet dictionary = Object.create(null);\n\n*!*\n// 你的添加 dictionary.toString 方法的代码\n*/!*\n\n// 添加一些数据\ndictionary.apple = \"Apple\";\ndictionary.__proto__ = \"test\"; // 这里 __proto__ 是一个常规的属性键\n\n// 在循环中只有 apple 和 __proto__\nfor(let key in dictionary) {\n  alert(key); // \"apple\", then \"__proto__\"\n}  \n\n// 你的 toString 方法在发挥作用\nalert(dictionary); // \"apple,__proto__\"\n```",
        "solution": "可以使用 `Object.keys` 获取所有可枚举的键，并输出其列表。\n\n为了使 `toString` 不可枚举，我们使用一个属性描述器来定义它。`Object.create` 语法允许我们为一个对象提供属性描述器作为第二参数。\n\n```js run\n*!*\nlet dictionary = Object.create(null, {\n  toString: { // 定义 toString 属性\n    value() { // value 是一个 function\n      return Object.keys(this).join();\n    }\n  }\n});\n*/!*\n\ndictionary.apple = \"Apple\";\ndictionary.__proto__ = \"test\";\n\n// apple 和 __proto__ 在循环中\nfor(let key in dictionary) {\n  alert(key); // \"apple\"，然后是 \"__proto__\"\n}  \n\n// 通过 toString 处理获得的以逗号分隔的属性列表\nalert(dictionary); // \"apple,__proto__\"\n```\n\n当我们使用描述器创建一个属性，它的标识默认是 `false`。因此在上面这段代码中，`dictonary.toString` 是不可枚举的。\n\n请阅读 [](info:property-descriptors) 一章进行回顾。",
        "parent": "prototype-methods",
        "version": 1
      }
    },
    "compare-calls": {
      "type": "Task",
      "value": {
        "title": "调用方式的差异",
        "slug": "compare-calls",
        "githubPath": "/1-js/08-prototypes/04-prototype-methods/3-compare-calls",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n让我们创建一个新的 `rabbit` 对象：\n\n```js\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert(this.name);\n};\n\nlet rabbit = new Rabbit(\"Rabbit\");\n```\n\n以下调用做的是相同的事儿还是不同的？\n\n```js\nrabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();\n```",
        "solution": "第一个调用中 `this == rabbit`，其他的 `this` 等同于 `Rabbit.prototype`，因为 `this` 就是点符号前面的对象。\n\n所以，只有第一个调用显示 `Rabbit`，其他的都显示的是 `undefined`：\n\n```js run\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert( this.name );\n}\n\nlet rabbit = new Rabbit(\"Rabbit\");\n\nrabbit.sayHi();                        // Rabbit\nRabbit.prototype.sayHi();              // undefined\nObject.getPrototypeOf(rabbit).sayHi(); // undefined\nrabbit.__proto__.sayHi();              // undefined\n```",
        "parent": "prototype-methods",
        "version": 1
      }
    },
    "classes": {
      "type": "Article",
      "value": {
        "title": "类",
        "slug": "classes",
        "githubPath": "/1-js/09-classes",
        "isFolder": true,
        "weight": 9,
        "content": "",
        "libs": [],
        "children": [
          "class",
          "class-inheritance",
          "static-properties-methods",
          "private-protected-properties-methods",
          "extend-natives",
          "instanceof",
          "mixins"
        ],
        "parent": "js"
      }
    },
    "class": {
      "type": "Article",
      "value": {
        "title": "Class 基本语法",
        "slug": "class",
        "githubPath": "/1-js/09-classes/01-class",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n```quote author=\"Wikipedia\"\n在面向对象的编程中，*class* 是用于创建对象的可扩展的程序代码模版，它为对象提供了状态（成员变量）的初始值和行为（成员函数或方法）的实现。\n```\n\n在日常开发中，我们经常需要创建许多相同类型的对象，例如用户（users）、商品（goods）或者任何其他东西。\n\n正如我们在 <info:constructor-new> 一章中已经学到的，`new function` 可以帮助我们实现这种需求。\n\n但在现代 JavaScript 中，还有一个更高级的“类（class）”构造方式，它引入许多非常棒的新功能，这些功能对于面向对象编程很有用。\n\n## \"class\" 语法\n\n基本语法是：\n```js\nclass MyClass {\n  // class 方法\n  constructor() { ... }\n  method1() { ... }\n  method2() { ... }\n  method3() { ... }\n  ...\n}\n```\n\n然后使用 `new MyClass()` 来创建具有上述列出的所有方法的新对象。\n\n`new` 会自动调用 `constructor()` 方法，因此我们可以在 `constructor()` 中初始化对象。\n\n例如：\n\n```js run\nclass User {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    alert(this.name);\n  }\n\n}\n\n// 用法：\nlet user = new User(\"John\");\nuser.sayHi();\n```\n\n当 `new User(\"John\")` 被调用：\n1. 一个新对象被创建。\n2. `constructor` 使用给定的参数运行，并将其赋值给 `this.name`。\n\n……然后我们就可以调用对象方法了，例如 `user.sayHi`。\n\n\n```warn header=\"类的方法之间没有逗号\"\n对于新手开发人员来说，常见的陷阱是在类的方法之间放置逗号，这会导致语法错误。\n\n不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。\n```\n\n## 什么是 class？\n\n所以，`class` 到底是什么？正如人们可能认为的那样，这不是一个全新的语言级实体。\n\n让我们揭开其神秘面纱，看看类究竟是什么。这将有助于我们理解许多复杂的方面。\n\n在 JavaScript 中，类是一种函数。\n\n看看下面这段代码：\n\n```js run\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// 佐证：User 是一个函数\n*!*\nalert(typeof User); // function\n*/!*\n```\n\n`class User {...}` 构造实际上做了如下的事儿：\n\n1. 创建一个名为 `User` 的函数，该函数成为类声明的结果。该函数的代码来自于 `constructor` 方法（如果我们不编写这种方法，那么它就被假定为空）。\n2. 存储类中的方法，例如 `User.prototype` 中的 `sayHi`。\n\n当 `new User` 对象被创建后，当我们调用其方法时，它会从原型中获取对应的方法，正如我们在 <info:function-prototype> 一章中所讲的那样。因此，对象 `new User` 可以访问类中的方法。\n\n我们可以将 `class User` 声明的结果解释为：\n\n![](class-user.svg)\n\n下面这些代码很好地解释了它们：\n\n```js run\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// class 是一个函数\nalert(typeof User); // function\n\n// ...或者，更确切地说，是 constructor 方法\nalert(User === User.prototype.constructor); // true\n\n// 方法在 User.prototype 中，例如：\nalert(User.prototype.sayHi); // sayHi 方法的代码\n\n// 在原型中实际上有两个方法\nalert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi\n```\n\n## 不仅仅是语法糖\n\n人们常说 `class` 是一个语法糖（旨在使内容更易阅读，但不引入任何新内容的语法），因为我们实际上可以在不使用 `class` 的情况下声明相同的内容：\n\n```js run\n// 用纯函数重写 class User\n\n// 1. 创建构造器函数\nfunction User(name) {\n  this.name = name;\n}\n// 函数的原型（prototype）默认具有 \"constructor\" 属性，\n// 所以，我们不需要创建它\n\n// 2. 将方法添加到原型\nUser.prototype.sayHi = function() {\n  alert(this.name);\n};\n\n// 用法：\nlet user = new User(\"John\");\nuser.sayHi();\n```\n\n这个定义的结果与使用类得到的结果基本相同。因此，这确实是将 `class` 视为一种定义构造器及其原型方法的语法糖的理由。\n\n尽管，它们之间存在着重大差异：\n\n1. 首先，通过 `class` 创建的函数具有特殊的内部属性标记 `[[IsClassConstructor]]: true`。因此，它与手动创建并不完全相同。\n\n    编程语言会在许多地方检查该属性。例如，与普通函数不同，必须使用 `new` 来调用它：\n\n    ```js run\n    class User {\n      constructor() {}\n    }\n\n    alert(typeof User); // function\n    User(); // Error: Class constructor User cannot be invoked without 'new'\n    ```\n\n    此外，大多数 JavaScript 引擎中的类构造器的字符串表示形式都以 \"class...\" 开头\n\n    ```js run\n    class User {\n      constructor() {}\n    }\n\n    alert(User); // class User { ... }\n    ```\n    还有其他的不同之处，我们很快就会看到。\n\n2. 类方法不可枚举。\n    类定义将 `\"prototype\"` 中的所有方法的 `enumerable` 标志设置为 `false`。\n\n    这很好，因为如果我们对一个对象调用 `for..in` 方法，我们通常不希望 class 方法出现。\n\n3. 类总是使用 `use strict`。\n    在类构造中的所有代码都将自动进入严格模式。\n\n此外，`class` 语法还带来了许多其他功能，我们稍后将会探索它们。\n\n## 类表达式\n\n就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。\n\n这是一个类表达式的例子：\n\n```js\nlet User = class {\n  sayHi() {\n    alert(\"Hello\");\n  }\n};\n```\n\n类似于命名函数表达式（Named Function Expressions），类表达式可能也应该有一个名字。\n\n如果类表达式有名字，那么该名字仅在类内部可见：\n\n```js run\n// “命名类表达式（Named Class Expression）”\n// (规范中没有这样的术语，但是它和命名函数表达式类似)\nlet User = class *!*MyClass*/!* {\n  sayHi() {\n    alert(MyClass); // MyClass 这个名字仅在类内部可见\n  }\n};\n\nnew User().sayHi(); // 正常运行，显示 MyClass 中定义的内容\n\nalert(MyClass); // error，MyClass 在外部不可见\n```\n\n我们甚至可以动态地“按需”创建类，就像这样：\n\n```js run\nfunction makeClass(phrase) {\n  // 声明一个类并返回它\n  return class {\n    sayHi() {\n      alert(phrase);\n    }\n  };\n}\n\n// 创建一个新的类\nlet User = makeClass(\"Hello\");\n\nnew User().sayHi(); // Hello\n```\n\n\n## Getters/setters\n\n就像对象字面量，类可能包括 getters/setters，计算属性（computed properties）等。\n\n这是一个使用 `get/set` 实现 `user.name` 的示例：\n\n```js run\nclass User {\n\n  constructor(name) {\n    // 调用 setter\n    this.name = name;\n  }\n\n*!*\n  get name() {\n*/!*\n    return this._name;\n  }\n\n*!*\n  set name(value) {\n*/!*\n    if (value.length < 4) {\n      alert(\"Name is too short.\");\n      return;\n    }\n    this._name = value;\n  }\n\n}\n\nlet user = new User(\"John\");\nalert(user.name); // John\n\nuser = new User(\"\"); // Name is too short.\n```\n\n从技术上来讲，这样的类声明可以通过在 `User.prototype` 中创建 getters 和 setters 来实现。\n\n## 计算属性名称 [...]\n\n这里有一个使用中括号 `[...]` 的计算方法名称示例：\n\n```js run\nclass User {\n\n*!*\n  ['say' + 'Hi']() {\n*/!*\n    alert(\"Hello\");\n  }\n\n}\n\nnew User().sayHi();\n```\n\n这种特性很容易记住，因为它们和对象字面量类似。\n\n## Class 字段\n\n```warn header=\"旧的浏览器可能需要 polyfill\"\n类字段（field）是最近才添加到语言中的。\n```\n\n之前，我们的类仅具有方法。\n\n“类字段”是一种允许添加任何属性的语法。\n\n例如，让我们在 `class User` 中添加一个 `name` 属性：\n\n```js run\nclass User {\n*!*\n  name = \"John\";\n*/!*\n\n  sayHi() {\n    alert(`Hello, ${this.name}!`);\n  }\n}\n\nnew User().sayHi(); // Hello, John!\n```\n\n所以，我们就只需在表达式中写 \"<property name> = <value>\"，就这样。\n\n类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在 `User.prototype`：\n\n```js run\nclass User {\n*!*\n  name = \"John\";\n*/!*\n}\n\nlet user = new User();\nalert(user.name); // John\nalert(User.prototype.name); // undefined\n```\n\n我们也可以在赋值时使用更复杂的表达式和函数调用：\n\n```js run\nclass User {\n*!*\n  name = prompt(\"Name, please?\", \"John\");\n*/!*\n}\n\nlet user = new User();\nalert(user.name); // John\n```\n\n\n### 使用类字段制作绑定方法\n\n正如 <info:bind> 一章中所讲的，JavaScript 中的函数具有动态的 `this`。它取决于调用上下文。\n\n因此，如果一个对象方法被传递到某处，或者在另一个上下文中被调用，则 `this` 将不再是对其对象的引用。\n\n例如，此代码将显示 `undefined`：\n\n```js run\nclass Button {\n  constructor(value) {\n    this.value = value;\n  }\n\n  click() {\n    alert(this.value);\n  }\n}\n\nlet button = new Button(\"hello\");\n\n*!*\nsetTimeout(button.click, 1000); // undefined\n*/!*\n```\n\n这个问题被称为“丢失 `this`”。\n\n我们在 <info:bind> 一章中讲过，有两种可以修复它的方式：\n\n1. 传递一个包装函数，例如 `setTimeout(() => button.click(), 1000)`。\n2. 将方法绑定到对象，例如在 constructor 中。\n\n类字段提供了另一种非常优雅的语法：\n\n```js run\nclass Button {\n  constructor(value) {\n    this.value = value;\n  }\n*!*\n  click = () => {\n    alert(this.value);\n  }\n*/!*\n}\n\nlet button = new Button(\"hello\");\n\nsetTimeout(button.click, 1000); // hello\n```\n\n类字段 `click = () => {...}` 是基于每一个对象被创建的，在这里对于每一个 `Button` 对象都有一个独立的方法，在内部都有一个指向此对象的 `this`。我们可以把 `button.click` 传递到任何地方，而且 `this` 的值总是正确的。\n\n在浏览器环境中，它对于进行事件监听尤为有用。\n\n## 总结\n\n基本的类语法看起来像这样：\n\n```js\nclass MyClass {\n  prop = value; // 属性\n\n  constructor(...) { // 构造器\n    // ...\n  }\n\n  method(...) {} // method\n\n  get something(...) {} // getter 方法\n  set something(...) {} // setter 方法 \n\n  [Symbol.iterator]() {} // 有计算名称（computed name）的方法（此处为 symbol）\n  // ...\n}\n```\n\n技术上来说，`MyClass` 是一个函数（我们提供作为 `constructor` 的那个），而 methods、getters 和 setters 都被写入了 `MyClass.prototype`。\n\n在下一章，我们将会进一步学习类的相关知识，包括继承和其他功能。",
        "libs": [],
        "children": [
          "rewrite-to-class"
        ],
        "parent": "classes",
        "updatedAt": 1662701785
      }
    },
    "rewrite-to-class": {
      "type": "Task",
      "value": {
        "title": "重写为 class",
        "slug": "rewrite-to-class",
        "githubPath": "/1-js/09-classes/01-class/1-rewrite-to-class",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n`Clock` 类（请见沙箱）是以函数式编写的。请以 \"class\" 语法重写它。\n\nP.S. 时钟在控制台（console）中滴答，打开控制台即可查看。",
        "solution": "",
        "solutionJs": "class Clock {\n  constructor({ template }) {\n    this.template = template;\n  }\n\n  render() {\n    let date = new Date();\n\n    let hours = date.getHours();\n    if (hours < 10) hours = '0' + hours;\n\n    let mins = date.getMinutes();\n    if (mins < 10) mins = '0' + mins;\n\n    let secs = date.getSeconds();\n    if (secs < 10) secs = '0' + secs;\n\n    let output = this.template\n      .replace('h', hours)\n      .replace('m', mins)\n      .replace('s', secs);\n\n    console.log(output);\n  }\n\n  stop() {\n    clearInterval(this.timer);\n  }\n\n  start() {\n    this.render();\n    this.timer = setInterval(() => this.render(), 1000);\n  }\n}\n\n\nlet clock = new Clock({template: 'h:m:s'});\nclock.start();\n",
        "parent": "class",
        "version": 1
      }
    },
    "class-inheritance": {
      "type": "Article",
      "value": {
        "title": "类继承",
        "slug": "class-inheritance",
        "githubPath": "/1-js/09-classes/02-class-inheritance",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n类继承是一个类扩展另一个类的一种方式。\n\n因此，我们可以在现有功能之上创建新功能。\n\n## \"extends\" 关键字\n\n假设我们有 class `Animal`：\n\n```js\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed = speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stands still.`);\n  }\n}\n\nlet animal = new Animal(\"My animal\");\n```\n\n这是我们对对象 `animal` 和 class `Animal` 的图形化表示：\n\n![](rabbit-animal-independent-animal.svg)\n\n……然后我们想创建另一个 `class Rabbit`：\n\n因为 rabbit 是 animal，所以 class `Rabbit` 应该是基于 class `Animal` 的，可以访问 animal 的方法，以便 rabbit 可以做“一般”动物可以做的事儿。\n\n扩展另一个类的语法是：`class Child extends Parent`。\n\n让我们创建一个继承自 `Animal` 的 `class Rabbit`：\n\n```js\n*!*\nclass Rabbit extends Animal {\n*/!*\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.hide(); // White Rabbit hides!\n```\n\nclass `Rabbit` 的对象可以访问例如 `rabbit.hide()` 等 `Rabbit` 的方法，还可以访问例如 `rabbit.run()` 等 `Animal` 的方法。\n\n在内部，关键字 `extends` 使用了很好的旧的原型机制进行工作。它将 `Rabbit.prototype.[[Prototype]]` 设置为 `Animal.prototype`。所以，如果在 `Rabbit.prototype` 中找不到一个方法，JavaScript 就会从 `Animal.prototype` 中获取该方法。\n\n![](animal-rabbit-extends.svg)\n\n例如，要查找 `rabbit.run` 方法，JavaScript 引擎会进行如下检查（如图所示从下到上）：\n1. 查找对象 `rabbit`（没有 `run`）。\n2. 查找它的原型，即 `Rabbit.prototype`（有 `hide`，但没有 `run`）。\n3. 查找它的原型，即（由于 `extends`）`Animal.prototype`，在这儿找到了 `run` 方法。\n\n我们可以回忆一下 <info:native-prototypes> 这一章的内容，JavaScript 内建对象同样也使用原型继承。例如，`Date.prototype.[[Prototype]]` 是 `Object.prototype`。这就是为什么日期可以访问通用对象的方法。\n\n````smart header=\"在 `extends` 后允许任意表达式\"\n类语法不仅允许指定一个类，在 `extends` 后可以指定任意表达式。\n\n例如，一个生成父类的函数调用：\n\n```js run\nfunction f(phrase) {\n  return class {\n    sayHi() { alert(phrase); }\n  };\n}\n\n*!*\nclass User extends f(\"Hello\") {}\n*/!*\n\nnew User().sayHi(); // Hello\n```\n这里 `class User` 继承自 `f(\"Hello\")` 的结果。\n\n这对于高级编程模式，例如当我们根据许多条件使用函数生成类，并继承它们时来说可能很有用。\n````\n\n## 重写方法\n\n现在，让我们继续前行并尝试重写一个方法。默认情况下，所有未在 `class Rabbit` 中指定的方法均从 `class Animal` 中直接获取。\n\n但是如果我们在 `Rabbit` 中指定了我们自己的方法，例如 `stop()`，那么将会使用它：\n\n```js\nclass Rabbit extends Animal {\n  stop() {\n    // ……现在这个将会被用作 rabbit.stop()\n    // 而不是来自于 class Animal 的 stop()\n  }\n}\n```\n\n然而通常，我们不希望完全替换父类的方法，而是希望在父类方法的基础上进行调整或扩展其功能。我们在我们的方法中做一些事儿，但是在它之前或之后或在过程中会调用父类方法。\n\nClass 为此提供了 `\"super\"` 关键字。\n\n- 执行 `super.method(...)` 来调用一个父类方法。\n- 执行 `super(...)` 来调用一个父类 constructor（只能在我们的 constructor 中）。\n\n例如，让我们的 rabbit 在停下来的时候自动 hide：\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  run(speed) {\n    this.speed = speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stands still.`);\n  }\n\n}\n\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n\n*!*\n  stop() {\n    super.stop(); // 调用父类的 stop\n    this.hide(); // 然后 hide\n  }\n*/!*\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.stop(); // White Rabbit stands still. White Rabbit hides!\n```\n\n现在，`Rabbit` 在执行过程中调用父类的 `super.stop()` 方法，所以 `Rabbit` 也具有了 `stop` 方法。\n\n````smart header=\"箭头函数没有 `super`\"\n正如我们在 <info:arrow-functions> 一章中所提到的，箭头函数没有 `super`。\n\n如果被访问，它会从外部函数获取。例如：\n\n```js\nclass Rabbit extends Animal {\n  stop() {\n    setTimeout(() => super.stop(), 1000); // 1 秒后调用父类的 stop\n  }\n}\n```\n\n箭头函数中的 `super` 与 `stop()` 中的是一样的，所以它能按预期工作。如果我们在这里指定一个“普通”函数，那么将会抛出错误：\n\n```js\n// 意料之外的 super\nsetTimeout(function() { super.stop() }, 1000);\n```\n````\n\n## 重写 constructor\n\n对于重写 constructor 来说，则有点棘手。\n\n到目前为止，`Rabbit` 还没有自己的 `constructor`。\n\n根据 [规范](https://tc39.github.io/ecma262/#sec-runtime-semantics-classdefinitionevaluation)，如果一个类扩展了另一个类并且没有 `constructor`，那么将生成下面这样的“空” `constructor`：\n\n```js\nclass Rabbit extends Animal {\n  // 为没有自己的 constructor 的扩展类生成的\n*!*\n  constructor(...args) {\n    super(...args);\n  }\n*/!*\n}\n```\n\n正如我们所看到的，它调用了父类的 `constructor`，并传递了所有的参数。如果我们没有写自己的 constructor，就会出现这种情况。\n\n现在，我们给 `Rabbit` 添加一个自定义的 constructor。除了 `name` 之外，它还会指定 `earLength`。\n\n```js run\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n*!*\n  constructor(name, earLength) {\n    this.speed = 0;\n    this.name = name;\n    this.earLength = earLength;\n  }\n*/!*\n\n  // ...\n}\n\n*!*\n// 不工作！\nlet rabbit = new Rabbit(\"White Rabbit\", 10); // Error: this is not defined.\n*/!*\n```\n\n哎呦！我们得到了一个报错。现在我们没法新建 rabbit。是什么地方出错了？\n\n简短的解释是：\n\n**继承类的 constructor 必须调用 `super(...)`，并且 (!) 一定要在使用 `this` 之前调用。**\n\n……但这是为什么呢？这里发生了什么？确实，这个要求看起来很奇怪。\n\n当然，本文会给出一个解释。让我们深入细节，这样你就可以真正地理解发生了什么。\n\n在 JavaScript 中，继承类（所谓的“派生构造器”，英文为 \"derived constructor\"）的构造函数与其他函数之间是有区别的。派生构造器具有特殊的内部属性 `[[ConstructorKind]]:\"derived\"`。这是一个特殊的内部标签。\n\n该标签会影响它的 `new` 行为：\n\n- 当通过 `new` 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 `this`。\n- 但是当继承的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作。\n\n因此，派生的 constructor 必须调用 `super` 才能执行其父类（base）的 constructor，否则 `this` 指向的那个对象将不会被创建。并且我们会收到一个报错。\n\n为了让 `Rabbit` 的 constructor 可以工作，它需要在使用 `this` 之前调用 `super()`，就像下面这样：\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n  constructor(name, earLength) {\n*!*\n    super(name);\n*/!*\n    this.earLength = earLength;\n  }\n\n  // ...\n}\n\n*!*\n// 现在可以了\nlet rabbit = new Rabbit(\"White Rabbit\", 10);\nalert(rabbit.name); // White Rabbit\nalert(rabbit.earLength); // 10\n*/!*\n```\n\n### 重写类字段: 一个棘手的注意要点\n\n```warn header=\"高阶要点\"\n这个要点假设你对类已经有了一定的经验，或许是在其他编程语言中。\n\n这里提供了一个更好的视角来窥探这门语言，且解释了它的行为为什么可能会是 bugs 的来源(但不是非常频繁)。\n\n如果你发现这难以理解，什么都别管，继续往下阅读，之后有机会再回来看。\n```\n\n我们不仅可以重写方法，还可以重写类字段。\n\n不过，当我们在父类构造器中访问一个被重写的字段时，有一个诡异的行为，这与绝大多数其他编程语言都很不一样。\n\n请思考此示例：\n\n```js run\nclass Animal {\n  name = 'animal';\n\n  constructor() {\n    alert(this.name); // (*)\n  }\n}\n\nclass Rabbit extends Animal {\n  name = 'rabbit';\n}\n\nnew Animal(); // animal\n*!*\nnew Rabbit(); // animal\n*/!*\n```\n\n这里，`Rabbit` 继承自 `Animal`，并且用它自己的值重写了 `name` 字段。\n\n因为 `Rabbit` 中没有自己的构造器，所以 `Animal` 的构造器被调用了。\n\n有趣的是在这两种情况下：`new Animal()` 和 `new Rabbit()`，在 `(*)` 行的 `alert` 都打印了 `animal`。\n\n**换句话说，父类构造器总是会使用它自己字段的值，而不是被重写的那一个。**\n\n古怪的是什么呢？\n\n如果这还不清楚，那么让我们用方法来进行比较。\n\n这里是相同的代码，但是我们调用 `this.showName()` 方法而不是 `this.name` 字段：\n\n```js run\nclass Animal {\n  showName() {  // 而不是 this.name = 'animal'\n    alert('animal');\n  }\n\n  constructor() {\n    this.showName(); // 而不是 alert(this.name);\n  }\n}\n\nclass Rabbit extends Animal {\n  showName() {\n    alert('rabbit');\n  }\n}\n\nnew Animal(); // animal\n*!*\nnew Rabbit(); // rabbit\n*/!*\n```\n\n请注意：这时的输出是不同的。\n\n这才是我们本来所期待的结果。当父类构造器在派生的类中被调用时，它会使用被重写的方法。\n\n……但对于类字段并非如此。正如前文所述，父类构造器总是使用父类的字段。\n\n这里为什么会有这样的区别呢？\n\n实际上，原因在于字段初始化的顺序。类字段是这样初始化的：\n- 对于基类（还未继承任何东西的那种），在构造函数调用前初始化。\n- 对于派生类，在 `super()` 后立刻初始化。\n\n在我们的例子中，`Rabbit` 是派生类，里面没有 `constructor()`。正如先前所说，这相当于一个里面只有 `super(...args)` 的空构造器。\n\n所以，`new Rabbit()` 调用了 `super()`，因此它执行了父类构造器，并且（根据派生类规则）只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候，`Rabbit` 还没有自己的类字段，这就是为什么 `Animal` 类字段被使用了。\n\n这种字段与方法之间微妙的区别只特定于 JavaScript。\n\n幸运的是，这种行为仅在一个被重写的字段被父类构造器使用时才会显现出来。接下来它会发生的东西可能就比较难理解了，所以我们要在这里对此行为进行解释。\n\n如果出问题了，我们可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题。\n\n## 深入：内部探究和 [[HomeObject]]\n\n```warn header=\"进阶内容\"\n如果你是第一次阅读本教程，那么则可以跳过本节。\n\n这是关于继承和 `super` 背后的内部机制。\n```\n\n让我们更深入地研究 `super`。我们将在这个过程中发现一些有趣的事儿。\n\n首先要说的是，从我们迄今为止学到的知识来看，`super` 是不可能运行的。\n\n的确是这样，让我们问问自己，以技术的角度它是如何工作的？当一个对象方法执行时，它会将当前对象作为 `this`。随后如果我们调用 `super.method()`，那么引擎需要从当前对象的原型中获取 `method`。但这是怎么做到的？\n\n这个任务看起来是挺容易的，但其实并不简单。引擎知道当前对象的 `this`，所以它可以获取父 `method` 作为 `this.__proto__.method`。不幸的是，这个“天真”的解决方法是行不通的。\n\n让我们演示一下这个问题。简单起见，我们使用普通对象而不使用类。\n\n如果你不想知道更多的细节知识，你可以跳过此部分，并转到下面的 `[[HomeObject]]` 小节。这没关系的。但如果你感兴趣，想学习更深入的知识，那就继续阅读吧。\n\n在下面的例子中，`rabbit.__proto__ = animal`。现在让我们尝试一下：在 `rabbit.eat()` 我们将会使用 `this.__proto__` 调用 `animal.eat()`：\n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {\n*!*\n    // 这就是 super.eat() 可以大概工作的方式\n    this.__proto__.eat.call(this); // (*)\n*/!*\n  }\n};\n\nrabbit.eat(); // Rabbit eats.\n```\n\n在 `(*)` 这一行，我们从原型（`animal`）中获取 `eat`，并在当前对象的上下文中调用它。请注意，`.call(this)` 在这里非常重要，因为简单的调用 `this.__proto__.eat()` 将在原型的上下文中执行 `eat`，而非当前对象。\n\n在上面的代码中，它确实按照了期望运行：我们获得了正确的 `alert`。\n\n现在，让我们在原型链上再添加一个对象。我们将看到这件事是如何被打破的：\n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat() {\n    // ...bounce around rabbit-style and call parent (animal) method\n    this.__proto__.eat.call(this); // (*)\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  eat() {\n    // ...do something with long ears and call parent (rabbit) method\n    this.__proto__.eat.call(this); // (**)\n  }\n};\n\n*!*\nlongEar.eat(); // Error: Maximum call stack size exceeded\n*/!*\n```\n\n代码无法再运行了！我们可以看到，在试图调用 `longEar.eat()` 时抛出了错误。\n\n原因可能不那么明显，但是如果我们跟踪 `longEar.eat()` 调用，就可以发现原因。在 `(*)` 和 `(**)` 这两行中，`this` 的值都是当前对象（`longEar`）。这是至关重要的一点：所有的对象方法都将当前对象作为 `this`，而非原型或其他什么东西。\n\n因此，在 `(*)` 和 `(**)` 这两行中，`this.__proto__` 的值是完全相同的：都是 `rabbit`。它们俩都调用的是 `rabbit.eat`，它们在不停地循环调用自己，而不是在原型链上向上寻找方法。\n\n这张图介绍了发生的情况：\n\n![](this-super-loop.svg)\n\n1. 在 `longEar.eat()` 中，`(**)` 这一行调用 `rabbit.eat` 并为其提供 `this=longEar`。\n    ```js\n    // 在 longEar.eat() 中我们有 this = longEar\n    this.__proto__.eat.call(this) // (**)\n    // 变成了\n    longEar.__proto__.eat.call(this)\n    // 也就是\n    rabbit.eat.call(this);\n    ```\n2. 之后在 `rabbit.eat` 的 `(*)` 行中，我们希望将函数调用在原型链上向更高层传递，但是 `this=longEar`，所以 `this.__proto__.eat` 又是 `rabbit.eat`！\n\n    ```js\n    // 在 rabbit.eat() 中我们依然有 this = longEar\n    this.__proto__.eat.call(this) // (*)\n    // 变成了\n    longEar.__proto__.eat.call(this)\n    // 或（再一次）\n    rabbit.eat.call(this);\n    ```\n\n3. ……所以 `rabbit.eat` 在不停地循环调用自己，因此它无法进一步地提升。\n\n这个问题没法仅仅通过使用 `this` 来解决。\n\n### `[[HomeObject]]`\n\n为了提供解决方法，JavaScript 为函数添加了一个特殊的内部属性：`[[HomeObject]]`。\n\n当一个函数被定义为类或者对象方法时，它的 `[[HomeObject]]` 属性就成为了该对象。\n\n然后 `super` 使用它来解析（resolve）父原型及其方法。\n\n让我们看看它是怎么工作的，首先，对于普通对象：\n\n```js run\nlet animal = {\n  name: \"Animal\",\n  eat() {         // animal.eat.[[HomeObject]] == animal\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {         // rabbit.eat.[[HomeObject]] == rabbit\n    super.eat();\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  name: \"Long Ear\",\n  eat() {         // longEar.eat.[[HomeObject]] == longEar\n    super.eat();\n  }\n};\n\n*!*\n// 正确执行\nlongEar.eat();  // Long Ear eats.\n*/!*\n```\n\n它基于 `[[HomeObject]]` 运行机制按照预期执行。一个方法，例如 `longEar.eat`，知道其 `[[HomeObject]]` 并且从其原型中获取父方法。并没有使用 `this`。\n\n### 方法并不是“自由”的\n\n正如我们之前所知道的，函数通常都是“自由”的，并没有绑定到 JavaScript 中的对象。正因如此，它们可以在对象之间复制，并用另外一个 `this` 调用它。\n\n`[[HomeObject]]` 的存在违反了这个原则，因为方法记住了它们的对象。`[[HomeObject]]` 不能被更改，所以这个绑定是永久的。\n\n在 JavaScript 语言中 `[[HomeObject]]` 仅被用于 `super`。所以，如果一个方法不使用 `super`，那么我们仍然可以视它为自由的并且可在对象之间复制。但是用了 `super` 再这样做可能就会出错。\n\n下面是复制后错误的 `super` 结果的示例：\n\n```js run\nlet animal = {\n  sayHi() {\n    alert(`I'm an animal`);\n  }\n};\n\n// rabbit 继承自 animal\nlet rabbit = {\n  __proto__: animal,\n  sayHi() {\n    super.sayHi();\n  }\n};\n\nlet plant = {\n  sayHi() {\n    alert(\"I'm a plant\");\n  }\n};\n\n// tree 继承自 plant\nlet tree = {\n  __proto__: plant,\n*!*\n  sayHi: rabbit.sayHi // (*)\n*/!*\n};\n\n*!*\ntree.sayHi();  // I'm an animal (?!?)\n*/!*\n```\n\n调用 `tree.sayHi()` 显示 \"I'm an animal\"。这绝对是错误的。\n\n原因很简单：\n- 在 `(*)` 行，`tree.sayHi` 方法是从 `rabbit` 复制而来。也许我们只是想避免重复代码？\n- 它的 `[[HomeObject]]` 是 `rabbit`，因为它是在 `rabbit` 中创建的。没有办法修改 `[[HomeObject]]`。\n- `tree.sayHi()` 内具有 `super.sayHi()`。它从 `rabbit` 中上溯，然后从 `animal` 中获取方法。\n\n这是发生的情况示意图：\n\n![](super-homeobject-wrong.svg)\n\n### 方法，不是函数属性\n\n`[[HomeObject]]` 是为类和普通对象中的方法定义的。但是对于对象而言，方法必须确切指定为 `method()`，而不是 `\"method: function()\"`。\n\n这个差别对我们来说可能不重要，但是对 JavaScript 来说却非常重要。\n\n在下面的例子中，使用非方法（non-method）语法进行了比较。未设置 `[[HomeObject]]` 属性，并且继承无效：\n\n```js run\nlet animal = {\n  eat: function() { // 这里是故意这样写的，而不是 eat() {...\n    // ...\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat: function() {\n    super.eat();\n  }\n};\n\n*!*\nrabbit.eat();  // 错误调用 super（因为这里没有 [[HomeObject]]）\n*/!*\n```\n\n## 总结\n\n1. 想要扩展一个类：`class Child extends Parent`：\n    - 这意味着 `Child.prototype.__proto__` 将是 `Parent.prototype`，所以方法会被继承。\n2. 重写一个 constructor：\n    - 在使用 `this` 之前，我们必须在 `Child` 的 constructor 中将父 constructor 调用为 `super()`。\n3. 重写一个方法：\n    - 我们可以在一个 `Child` 方法中使用 `super.method()` 来调用 `Parent` 方法。\n4. 内部：\n    - 方法在内部的 `[[HomeObject]]` 属性中记住了它们的类/对象。这就是 `super` 如何解析父方法的。\n    - 因此，将一个带有 `super` 的方法从一个对象复制到另一个对象是不安全的。\n\n补充：\n- 箭头函数没有自己的 `this` 或 `super`，所以它们能融入到就近的上下文中，像透明似的。",
        "libs": [],
        "children": [
          "class-constructor-error",
          "clock-class-extended"
        ],
        "parent": "classes",
        "updatedAt": 1658330447
      }
    },
    "class-constructor-error": {
      "type": "Task",
      "value": {
        "title": "创建实例时出错",
        "slug": "class-constructor-error",
        "githubPath": "/1-js/09-classes/02-class-inheritance/1-class-constructor-error",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n这里有一份 `Rabbit` 扩展 `Animal` 的代码。\n\n不幸的是，`Rabbit` 对象无法被创建。是哪里出错了呢？请解决它。\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  constructor(name) {  \n    this.name = name;\n    this.created = Date.now();\n  }\n}\n\n*!*\nlet rabbit = new Rabbit(\"White Rabbit\"); // Error: this is not defined\n*/!*\nalert(rabbit.name);\n```",
        "solution": "这是因为子类的 constructor 必须调用 `super()`。\n\n这里是修正后的代码：\n\n```js run\nclass Animal {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  constructor(name) {  \n    *!*\n    super(name);\n    */!*\n    this.created = Date.now();\n  }\n}\n\n*!*\nlet rabbit = new Rabbit(\"White Rabbit\"); // 现在好了\n*/!*\nalert(rabbit.name); // White Rabbit\n```",
        "parent": "class-inheritance",
        "version": 1
      }
    },
    "clock-class-extended": {
      "type": "Task",
      "value": {
        "title": "扩展 clock",
        "slug": "clock-class-extended",
        "githubPath": "/1-js/09-classes/02-class-inheritance/2-clock-class-extended",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们获得了一个 `Clock` 类。到目前为止，它每秒都会打印一次时间。\n\n\n[js src=\"source.view/clock.js\"]\n\n创建一个继承自 `Clock` 的新的类 `ExtendedClock`，并添加参数 `precision` — 每次 \"ticks\" 之间间隔的毫秒数，默认是 `1000`（1 秒）。\n\n- 你的代码应该在 `extended-clock.js` 文件里。\n- 不要修改原有的 `clock.js`。请扩展它。",
        "solution": "[js src=\"solution.view/extended-clock.js\"]",
        "parent": "class-inheritance",
        "version": 1
      }
    },
    "static-properties-methods": {
      "type": "Article",
      "value": {
        "title": "静态属性和静态方法",
        "slug": "static-properties-methods",
        "githubPath": "/1-js/09-classes/03-static-properties-methods",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n我们可以把一个方法作为一个整体赋值给类。这样的方法被称为 **静态的（static）**。\n\n在一个类的声明中，它们以 `static` 关键字开头，如下所示：\n\n```js run\nclass User {\n*!*\n  static staticMethod() {\n*/!*\n    alert(this === User);\n  }\n}\n\nUser.staticMethod(); // true\n```\n\n这实际上跟直接将其作为属性赋值的作用相同：\n\n```js run\nclass User { }\n\nUser.staticMethod = function() {\n  alert(this === User);\n};\n\nUser.staticMethod(); // true\n```\n\n在 `User.staticMethod()` 调用中的 `this` 的值是类构造器 `User` 自身（“点符号前面的对象”规则）。\n\n通常，静态方法用于实现属于整个类，但不属于该类任何特定对象的函数。\n\n例如，我们有对象 `Article`，并且需要一个方法来比较它们。\n\n通常的解决方案就是添加 `Article.compare` 静态方法：\n\n```js run\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n*!*\n  static compare(articleA, articleB) {\n    return articleA.date - articleB.date;\n  }\n*/!*\n}\n\n// 用法\nlet articles = [\n  new Article(\"HTML\", new Date(2019, 1, 1)),\n  new Article(\"CSS\", new Date(2019, 0, 1)),\n  new Article(\"JavaScript\", new Date(2019, 11, 1))\n];\n\n*!*\narticles.sort(Article.compare);\n*/!*\n\nalert( articles[0].title ); // CSS\n```\n\n这里 `Article.compare` 方法代表“上面的”文章，意思是比较它们。它不是文章的方法，而是整个 class 的方法。\n\n另一个例子是所谓的“工厂”方法。\n\n比如说，我们需要通过多种方式来创建一篇文章：\n\n1. 通过用给定的参数来创建（`title`，`date` 等）。\n2. 使用今天的日期来创建一个空的文章。\n3. ……其它方法。\n\n第一种方法我们可以通过 constructor 来实现。对于第二种方式，我们可以创建类的一个静态方法来实现。\n\n例如这里的 `Article.createTodays()`：\n\n```js run\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n*!*\n  static createTodays() {\n    // 记住 this = Article\n    return new this(\"Today's digest\", new Date());\n  }\n*/!*\n}\n\nlet article = Article.createTodays();\n\nalert( article.title ); // Today's digest\n```\n\n现在，每当我们需要创建一个今天的文章时，我们就可以调用 `Article.createTodays()`。再说明一次，它不是一个文章的方法，而是整个 class 的方法。\n\n静态方法也被用于与数据库相关的公共类，可以用于搜索/保存/删除数据库中的条目， 就像这样：\n\n```js\n// 假定 Article 是一个用来管理文章的特殊类\n// 通过 id 来移除文章的静态方法：\nArticle.remove({id: 12345});\n```\n\n````warn header=\"静态方法不适用于单个对象\"\n静态方法可以在类上调用，而不是在单个对象上。\n\n例如，这样的代码无法正常工作：\n\n```js\n// ...\narticle.createTodays(); /// Error: article.createTodays is not a function\n```\n````\n\n## 静态属性\n\n[recent browser=Chrome]\n\n静态的属性也是可能的，它们看起来就像常规的类属性，但前面加有 `static`：\n\n```js run\nclass Article {\n  static publisher = \"Levi Ding\";\n}\n\nalert( Article.publisher ); // Levi Ding\n```\n\n这等同于直接给 `Article` 赋值：\n\n```js\nArticle.publisher = \"Levi Ding\";\n```\n\n## 继承静态属性和方法 [#statics-and-inheritance]\n\n静态属性和方法是可被继承的。\n\n例如，下面这段代码中的 `Animal.compare` 和 `Animal.planet` 是可被继承的，可以通过 `Rabbit.compare` 和 `Rabbit.planet` 来访问：\n\n```js run\nclass Animal {\n  static planet = \"Earth\";\n\n  constructor(name, speed) {\n    this.speed = speed;\n    this.name = name;\n  }\n\n  run(speed = 0) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n*!*\n  static compare(animalA, animalB) {\n    return animalA.speed - animalB.speed;\n  }\n*/!*\n\n}\n\n// 继承于 Animal\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbits = [\n  new Rabbit(\"White Rabbit\", 10),\n  new Rabbit(\"Black Rabbit\", 5)\n];\n\n*!*\nrabbits.sort(Rabbit.compare);\n*/!*\n\nrabbits[0].run(); // Black Rabbit runs with speed 5.\n\nalert(Rabbit.planet); // Earth\n```\n\n现在我们调用 `Rabbit.compare` 时，继承的 `Animal.compare` 将会被调用。\n\n它是如何工作的？再次，使用原型。你可能已经猜到了，`extends` 让 `Rabbit` 的 `[[Prototype]]` 指向了 `Animal`。\n\n![](animal-rabbit-static.svg)\n\n所以，`Rabbit extends Animal` 创建了两个 `[[Prototype]]` 引用：\n\n1. `Rabbit` 函数原型继承自 `Animal` 函数。\n2. `Rabbit.prototype` 原型继承自 `Animal.prototype`。\n\n结果就是，继承对常规方法和静态方法都有效。\n\n这里，让我们通过代码来检验一下：\n\n```js run\nclass Animal {}\nclass Rabbit extends Animal {}\n\n// 对于静态的\nalert(Rabbit.__proto__ === Animal); // true\n\n// 对于常规方法\nalert(Rabbit.prototype.__proto__ === Animal.prototype); // true\n```\n \n## 总结\n\n静态方法被用于实现属于整个类的功能。它与具体的类实例无关。\n\n举个例子， 一个用于进行比较的方法 `Article.compare(article1, article2)` 或一个工厂（factory）方法 `Article.createTodays()`。\n\n在类声明中，它们都被用关键字 `static` 进行了标记。\n\n静态属性被用于当我们想要存储类级别的数据时，而不是绑定到实例。\n\n语法如下所示：\n\n```js\nclass MyClass {\n  static property = ...;\n\n  static method() {\n    ...\n  }\n}\n```\n\n从技术上讲，静态声明与直接给类本身赋值相同：\n\n```js\nMyClass.property = ...\nMyClass.method = ...\n```\n\n静态属性和方法是可被继承的。\n\n对于 `class B extends A`，类 `B` 的 prototype 指向了 `A`：`B.[[Prototype]] = A`。因此，如果一个字段在 `B` 中没有找到，会继续在 `A` 中查找。",
        "libs": [],
        "children": [
          "class-extend-object"
        ],
        "parent": "classes",
        "updatedAt": 1658392543
      }
    },
    "class-extend-object": {
      "type": "Task",
      "value": {
        "title": "类扩展自对象？",
        "slug": "class-extend-object",
        "githubPath": "/1-js/09-classes/03-static-properties-methods/3-class-extend-object",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\n\n正如我们所知道的，所有的对象通常都继承自 `Object.prototype`，并且可以访问“通用”对象方法，例如 `hasOwnProperty` 等。\n\n例如：\n\n```js run\nclass Rabbit {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\n*!*\n// hasOwnProperty 方法来自于 Object.prototype\nalert( rabbit.hasOwnProperty('name') ); // true\n*/!*\n```\n\n但是，如果我们像这样 `\"class Rabbit extends Object\"` 把它明确地写出来，那么结果会与简单的 `\"class Rabbit\"` 有所不同么？\n\n不同之处在哪里？\n\n下面是此类的示例代码（它无法正常运行 —— 为什么？修复它？）：\n\n```js\nclass Rabbit extends Object {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\nalert( rabbit.hasOwnProperty('name') ); // Error\n```",
        "solution": "首先，让我们看看为什么之前的代码无法运行。\n\n如果我们尝试运行它，就会发现原因其实很明显。派生类的 constructor 必须调用 `super()`。否则 `\"this\"` 不会被定义。\n\n下面是修复后的代码：\n\n```js run\nclass Rabbit extends Object {\n  constructor(name) {\n*!*\n    super(); // 需要在继承时调用父类的 constructor\n*/!*\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\nalert( rabbit.hasOwnProperty('name') ); // true\n```\n\n但这还不是全部原因。\n\n即便修复了它，`\"class Rabbit extends Object\"` 和 `class Rabbit` 之间仍存在着一个重要的差异。\n\n我们知道，\"extends\" 语法会设置两个原型：\n\n1. 在构造函数的 `\"prototype\"` 之间设置原型（为了获取实例方法）。\n2. 在构造函数之间会设置原型（为了获取静态方法）。\n\n在 `class Rabbit extends Object` 的例子中，意味着：\n\n```js run\nclass Rabbit extends Object {}\n\nalert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true\nalert( Rabbit.__proto__ === Object ); // (2) true\n```\n\n所以，现在 `Rabbit` 可以通过 `Rabbit` 访问 `Object` 的静态方法，像这样：\n\n```js run\nclass Rabbit extends Object {}\n\n*!*\n// 通常我们调用 Object.getOwnPropertyNames\nalert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // a,b\n*/!*\n```\n\n但是如果我们没有 `extends Object`，那么 `Rabbit.__proto__` 将不会被设置为 `Object`。\n\n下面是示例：\n\n```js run\nclass Rabbit {}\n\nalert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) true\nalert( Rabbit.__proto__ === Object ); // (2) false (!)\nalert( Rabbit.__proto__ === Function.prototype ); // true，所有函数都是默认如此\n\n*!*\n// error，Rabbit 中没有这样的函数\nalert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // Error\n*/!*\n```\n\n所以，在这种情况下，`Rabbit` 没有提供对 `Object` 的静态方法的访问。\n\n顺便说一下，`Function.prototype` 也有一些“通用”函数方法，例如 `call` 和 `bind` 等。在上述的两种情况下它们都是可用的，因为对于内建的 `Object` 构造函数而言，`Object.__proto__ === Function.prototype`。\n\n我们用一张图来解释：\n\n![](rabbit-extends-object.svg)\n\n\n所以，简而言之，这里有两点区别：\n\n| class Rabbit | class Rabbit extends Object  |\n|--------------|------------------------------|\n| --             | 需要在 constructor 中调用 `super()` |\n| `Rabbit.__proto__ === Function.prototype` | `Rabbit.__proto__ === Object` |",
        "parent": "static-properties-methods",
        "version": 1
      }
    },
    "private-protected-properties-methods": {
      "type": "Article",
      "value": {
        "title": "私有的和受保护的属性和方法",
        "slug": "private-protected-properties-methods",
        "githubPath": "/1-js/09-classes/04-private-protected-properties-methods",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n面向对象编程最重要的原则之一 —— 将内部接口与外部接口分隔开来。\n\n在开发比 \"hello world\" 应用程序更复杂的东西时，这是“必须”遵守的做法。\n\n为了理解这一点，让我们脱离开发过程，把目光转向现实世界。\n\n通常，我们使用的设备都非常复杂。但是，将内部接口与外部接口分隔开来可以让我们使用它们且没有任何问题。\n\n## 一个现实生活中的例子\n\n例如，一个咖啡机。从外面看很简单：一个按钮，一个显示器，几个洞……当然，结果就是 —— 很棒的咖啡！:)\n\n![](coffee.jpg)\n\n但是在内部……（一张摘自维修手册的图片）\n\n![](coffee-inside.jpg)\n\n有非常多的细节。但我们可以在完全不了解这些内部细节的情况下使用它。\n\n咖啡机非常可靠，不是吗？一台咖啡机我们可以使用好几年，只有在出现问题时 —— 把它送去维修。\n\n咖啡机的可靠性和简洁性的秘诀 —— 所有细节都经过精心校并 **隐藏** 在内部。\n\n如果我们从咖啡机上取下保护罩，那么使用它将变得复杂得多（要按哪里？），并且很危险（会触电）。\n\n正如我们所看到的，在编程中，对象就像咖啡机。\n\n但是为了隐藏内部细节，我们不会使用保护罩，而是使用语言和约定中的特殊语法。\n\n## 内部接口和外部接口\n\n在面向对象的编程中，属性和方法分为两组：\n\n- **内部接口** —— 可以通过该类的其他方法访问，但不能从外部访问的方法和属性。\n- **外部接口** —— 也可以从类的外部访问的方法和属性。\n\n如果我们继续用咖啡机进行类比 —— 内部隐藏的内容：锅炉管，加热元件等 —— 是咖啡机的内部接口。\n\n内部接口用于对象工作，它的细节相互使用。例如，锅炉管连接到加热元件。\n\n但是从外面看，一台咖啡机被保护壳罩住了，所以没有人可以接触到其内部接口。细节信息被隐藏起来并且无法访问。我们可以通过外部接口使用它的功能。\n\n所以，我们需要使用一个对象时只需知道它的外部接口。我们可能完全不知道它的内部是如何工作的，这太好了。\n\n这是个概括性的介绍。\n\n在 JavaScript 中，有两种类型的对象字段（属性和方法）：\n\n- 公共的：可从任何地方访问。它们构成了外部接口。到目前为止，我们只使用了公共的属性和方法。\n- 私有的：只能从类的内部访问。这些用于内部接口。\n\n在许多其他编程语言中，还存在“受保护”的字段：只能从类的内部和基于其扩展的类的内部访问（例如私有的，但可以从继承的类进行访问）。它们对于内部接口也很有用。从某种意义上讲，它们比私有的属性和方法更为广泛，因为我们通常希望继承类来访问它们。\n\n受保护的字段不是在语言级别的 Javascript 中实现的，但实际上它们非常方便，因为它们是在 Javascript 中模拟的类定义语法。\n\n现在，我们将使用所有这些类型的属性在 Javascript 中制作咖啡机。咖啡机有很多细节，我们不会对它们进行全面模拟以保持简洁（尽管我们可以）。\n\n## 受保护的 \"waterAmount\"\n\n首先，让我们做一个简单的咖啡机类：\n\n```js run\nclass CoffeeMachine {\n  waterAmount = 0; // 内部的水量\n\n  constructor(power) {\n    this.power = power;\n    alert( `Created a coffee-machine, power: ${power}` );\n  }\n\n}\n\n// 创建咖啡机\nlet coffeeMachine = new CoffeeMachine(100);\n\n// 加水\ncoffeeMachine.waterAmount = 200;\n```\n\n现在，属性 `waterAmount` 和 `power` 是公共的。我们可以轻松地从外部将它们 get/set 成任何值。\n\n让我们将 `waterAmount` 属性更改为受保护的属性，以对其进行更多控制。例如，我们不希望任何人将它的值设置为小于零的数。\n\n**受保护的属性通常以下划线 `_` 作为前缀。**\n\n这不是在语言级别强制实施的，但是程序员之间有一个众所周知的约定，即不应该从外部访问此类型的属性和方法。\n\n所以我们的属性将被命名为 `_waterAmount`：\n\n```js run\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  set waterAmount(value) {\n    if (value < 0) {\n      value = 0;\n    }\n    this._waterAmount = value;\n  }\n\n  get waterAmount() {\n    return this._waterAmount;\n  }\n\n  constructor(power) {\n    this._power = power;\n  }\n\n}\n\n// 创建咖啡机\nlet coffeeMachine = new CoffeeMachine(100);\n\n// 加水\ncoffeeMachine.waterAmount = -10; // _waterAmount 将变为 0，而不是 -10\n```\n\n现在访问已受到控制，因此将水量的值设置为小于零的数变得不可能。\n\n## 只读的 \"power\"\n\n对于 `power` 属性，让我们将它设为只读。有时候一个属性必须只能被在创建时进行设置，之后不再被修改。\n\n咖啡机就是这种情况：功率永远不会改变。\n\n要做到这一点，我们只需要设置 getter，而不设置 setter：\n\n```js run\nclass CoffeeMachine {\n  // ...\n\n  constructor(power) {\n    this._power = power;\n  }\n\n  get power() {\n    return this._power;\n  }\n\n}\n\n// 创建咖啡机\nlet coffeeMachine = new CoffeeMachine(100);\n\nalert(`Power is: ${coffeeMachine.power}W`); // 功率是：100W\n\ncoffeeMachine.power = 25; // Error（没有 setter）\n```\n\n````smart header=\"getter/setter 函数\"\n这里我们使用了 getter/setter 语法。\n\n但大多数时候首选 `get.../set...` 函数，像这样：\n\n```js\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  *!*setWaterAmount(value)*/!* {\n    if (value < 0) value = 0;\n    this._waterAmount = value;\n  }\n\n  *!*getWaterAmount()*/!* {\n    return this._waterAmount;\n  }\n}\n\nnew CoffeeMachine().setWaterAmount(100);\n```\n\n这看起来有点长，但函数更灵活。它们可以接受多个参数（即使我们现在还不需要）。\n\n另一方面，get/set 语法更短，所以最终没有严格的规定，而是由你自己来决定。\n````\n\n```smart header=\"受保护的字段是可以被继承的\"\n如果我们继承 `class MegaMachine extends CoffeeMachine`，那么什么都无法阻止我们从新的类中的方法访问 `this._waterAmount` 或 `this._power`。\n\n所以受保护的字段是自然可被继承的。与我们接下来将看到的私有字段不同。\n```\n\n## 私有的 \"#waterLimit\"\n\n[recent browser=none]\n\n这儿有一个马上就会被加到规范中的已完成的 Javascript 提案，它为私有属性和方法提供语言级支持。\n\n私有属性和方法应该以 `#` 开头。它们只在类的内部可被访问。\n\n例如，这儿有一个私有属性 `#waterLimit` 和检查水量的私有方法 `#fixWaterAmount`：\n\n```js run\nclass CoffeeMachine {\n*!*\n  #waterLimit = 200;\n*/!*\n\n*!*\n  #fixWaterAmount(value) {\n    if (value < 0) return 0;\n    if (value > this.#waterLimit) return this.#waterLimit;\n  }\n*/!*\n\n  setWaterAmount(value) {\n    this.#waterLimit = this.#fixWaterAmount(value);\n  }\n}\n\nlet coffeeMachine = new CoffeeMachine();\n\n*!*\n// 不能从类的外部访问类的私有属性和方法\ncoffeeMachine.#fixWaterAmount(123); // Error\ncoffeeMachine.#waterLimit = 1000; // Error\n*/!*\n```\n\n在语言级别，`#` 是该字段为私有的特殊标志。我们无法从外部或从继承的类中访问它。\n\n私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 `#waterAmount` 和公共的 `waterAmount` 字段。\n\n例如，让我们使 `waterAmount` 成为 `#waterAmount` 的一个访问器：\n\n```js run\nclass CoffeeMachine {\n\n  #waterAmount = 0;\n\n  get waterAmount() {\n    return this.#waterAmount;\n  }\n\n  set waterAmount(value) {\n    if (value < 0) value = 0;\n    this.#waterAmount = value;\n  }\n}\n\nlet machine = new CoffeeMachine();\n\nmachine.waterAmount = 100;\nalert(machine.#waterAmount); // Error\n```\n\n与受保护的字段不同，私有字段由语言本身强制执行。这是好事儿。\n\n但是如果我们继承自 `CoffeeMachine`，那么我们将无法直接访问 `#waterAmount`。我们需要依靠 `waterAmount` getter/setter：\n\n```js\nclass MegaCoffeeMachine extends CoffeeMachine {\n  method() {\n*!*\n    alert( this.#waterAmount ); // Error: can only access from CoffeeMachine\n*/!*\n  }\n}\n```\n\n在许多情况下，这种限制太严重了。如果我们扩展 `CoffeeMachine`，则可能有正当理由访问其内部。这就是为什么大多数时候都会使用受保护字段，即使它们不受语言语法的支持。\n\n````warn header=\"私有字段不能通过 this[name] 访问\"\n私有字段很特别。\n\n正如我们所知道的，通常我们可以使用 `this[name]` 访问字段：\n\n```js\nclass User {\n  ...\n  sayHi() {\n    let fieldName = \"name\";\n    alert(`Hello, ${*!*this[fieldName]*/!*}`);\n  }\n}\n```\n\n对于私有字段来说，这是不可能的：`this['#name']` 不起作用。这是确保私有性的语法限制。\n````\n\n## 总结\n\n就面向对象编程（OOP）而言，内部接口与外部接口的划分被称为 [封装](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))。\n\n它具有以下优点：\n\n保护用户，使他们不会误伤自己\n: 想象一下，有一群开发人员在使用一个咖啡机。这个咖啡机是由“最好的咖啡机”公司制造的，工作正常，但是保护罩被拿掉了。因此内部接口暴露了出来。\n\n    所有的开发人员都是文明的 —— 他们按照预期使用咖啡机。但其中的一个人，约翰，他认为自己是最聪明的人，并对咖啡机的内部做了一些调整。然而，咖啡机两天后就坏了。\n\n    这肯定不是约翰的错，而是那个取下保护罩并让约翰进行操作的人的错。\n\n    编程也一样。如果一个 class 的使用者想要改变那些本不打算被从外部更改的东西 —— 后果是不可预测的。\n\n可支持性\n: 编程的情况比现实生活中的咖啡机要复杂得多，因为我们不只是购买一次。我们还需要不断开发和改进代码。\n\n    **如果我们严格界定内部接口，那么这个 class 的开发人员可以自由地更改其内部属性和方法，甚至无需通知用户。**\n\n    如果你是这样的 class 的开发者，那么你会很高兴知道可以安全地重命名私有变量，可以更改甚至删除其参数，因为没有外部代码依赖于它们。\n\n    对于用户来说，当新版本问世时，应用的内部可能被进行了全面检修，但如果外部接口相同，则仍然很容易升级。\n\n隐藏复杂性\n: 人们喜欢使用简单的东西。至少从外部来看是这样。内部的东西则是另外一回事了。\n\n    程序员也不例外。\n\n    **当实施细节被隐藏，并提供了简单且有据可查的外部接口时，总是很方便的。**\n\n为了隐藏内部接口，我们使用受保护的或私有的属性：\n\n- 受保护的字段以 `_` 开头。这是一个众所周知的约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以 `_` 开头的字段。\n- 私有字段以 `#` 开头。JavaScript 确保我们只能从类的内部访问它们。\n\n目前，各个浏览器对私有字段的支持不是很好，但可以用 polyfill 解决。",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1658393767
      }
    },
    "extend-natives": {
      "type": "Article",
      "value": {
        "title": "扩展内建类",
        "slug": "extend-natives",
        "githubPath": "/1-js/09-classes/05-extend-natives",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n内建的类，例如 `Array`，`Map` 等也都是可以扩展的（extendable）。\n\n例如，这里有一个继承自原生 `Array` 的类 `PowerArray`： \n\n```js run\n// 给 PowerArray 新增了一个方法（可以增加更多）\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\nlet filteredArr = arr.filter(item => item >= 10);\nalert(filteredArr); // 10, 50\nalert(filteredArr.isEmpty()); // false\n```\n\n请注意一个非常有趣的事儿。内建的方法例如 `filter`，`map` 等 —— 返回的正是子类 `PowerArray` 的新对象。它们内部使用了对象的 `constructor` 属性来实现这一功能。\n\n在上面的例子中，\n```js\narr.constructor === PowerArray\n```\n\n当 `arr.filter()` 被调用时，它的内部使用的是 `arr.constructor` 来创建新的结果数组，而不是使用原生的 `Array`。这真的很酷，因为我们可以在结果数组上继续使用 `PowerArray` 的方法。\n\n甚至，我们可以定制这种行为。\n\n我们可以给这个类添加一个特殊的静态 getter `Symbol.species`。如果存在，则应返回 JavaScript 在内部用来在 `map` 和 `filter` 等方法中创建新实体的 `constructor`。\n\n如果我们希望像 `map` 或 `filter` 这样的内建方法返回常规数组，我们可以在 `Symbol.species` 中返回 `Array`，就像这样：\n\n```js run\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n\n*!*\n  // 内建方法将使用这个作为 constructor\n  static get [Symbol.species]() {\n    return Array;\n  }\n*/!*\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\n// filter 使用 arr.constructor[Symbol.species] 作为 constructor 创建新数组\nlet filteredArr = arr.filter(item => item >= 10);\n\n*!*\n// filteredArr 不是 PowerArray，而是 Array\n*/!*\nalert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function\n```\n\n正如你所看到的，现在 `.filter` 返回 `Array`。所以扩展的功能不再传递。\n\n```smart header=\"其他集合的工作方式类似\"\n其他集合，例如 `Map` 和 `Set` 的工作方式类似。它们也使用 `Symbol.species`。\n```\n\n### 内建类没有静态方法继承\n\n内建对象有它们自己的静态方法，例如 `Object.keys`，`Array.isArray` 等。\n\n如我们所知道的，原生的类互相扩展。例如，`Array` 扩展自 `Object`。\n\n通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承。这已经在 [](info:static-properties-methods#statics-and-inheritance) 中详细地解释过了。\n\n但内建类却是一个例外。它们相互间不继承静态方法。\n\n例如，`Array` 和 `Date` 都继承自 `Object`，所以它们的实例都有来自 `Object.prototype` 的方法。但 `Array.[[Prototype]]` 并不指向 `Object`，所以它们没有例如 `Array.keys()`（或 `Date.keys()`）这些静态方法。\n\n这里有一张 `Date` 和 `Object` 的结构关系图：\n\n![](object-date-inheritance.svg)\n\n正如你所看到的，`Date` 和 `Object` 之间没有连结。它们是独立的，只有 `Date.prototype` 继承自 `Object.prototype`，仅此而已。\n\n与我们所了解的通过 `extends` 获得的继承相比，这是内建对象之间继承的一个重要区别。",
        "libs": [],
        "children": [],
        "parent": "classes",
        "updatedAt": 1658395180
      }
    },
    "instanceof": {
      "type": "Article",
      "value": {
        "title": "类检查：\"instanceof\"",
        "slug": "instanceof",
        "githubPath": "/1-js/09-classes/06-instanceof",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n`instanceof` 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承。\n\n在许多情况下，可能都需要进行此类检查。例如，它可以被用来构建一个 **多态性（polymorphic）** 的函数，该函数根据参数的类型对参数进行不同的处理。\n\n## instanceof 操作符 [#ref-instanceof]\n\n语法：\n```js\nobj instanceof Class\n```\n\n如果 `obj` 隶属于 `Class` 类（或 `Class` 类的衍生类），则返回 `true`。\n\n例如：\n\n```js run\nclass Rabbit {}\nlet rabbit = new Rabbit();\n\n// rabbit 是 Rabbit class 的对象吗？\n*!*\nalert( rabbit instanceof Rabbit ); // true\n*/!*\n```\n\n它还可以与构造函数一起使用：\n\n```js run\n*!*\n// 这里是构造函数，而不是 class\nfunction Rabbit() {}\n*/!*\n\nalert( new Rabbit() instanceof Rabbit ); // true\n```\n\n……与诸如 `Array` 之类的内建 class 一起使用：\n\n```js run\nlet arr = [1, 2, 3];\nalert( arr instanceof Array ); // true\nalert( arr instanceof Object ); // true\n```\n\n有一点需要留意，`arr` 同时还隶属于 `Object` 类。因为从原型上来讲，`Array` 是继承自 `Object` 的。\n\n通常，`instanceof` 在检查中会将原型链考虑在内。此外，我们还可以在静态方法 `Symbol.hasInstance` 中设置自定义逻辑。\n\n`obj instanceof Class` 算法的执行过程大致如下：\n\n1. 如果这儿有静态方法 `Symbol.hasInstance`，那就直接调用这个方法：\n\n    例如：\n\n    ```js run\n    // 设置 instanceOf 检查\n    // 并假设具有 canEat 属性的都是 animal\n    class Animal {\n      static [Symbol.hasInstance](obj) {\n        if (obj.canEat) return true;\n      }\n    }\n\n    let obj = { canEat: true };\n\n    alert(obj instanceof Animal); // true：Animal[Symbol.hasInstance](obj) 被调用\n    ```\n\n2. 大多数 class 没有 `Symbol.hasInstance`。在这种情况下，标准的逻辑是：使用 `obj instanceOf Class` 检查 `Class.prototype` 是否等于 `obj` 的原型链中的原型之一。\n\n    换句话说就是，一个接一个地比较：\n    ```js\n    obj.__proto__ === Class.prototype?\n    obj.__proto__.__proto__ === Class.prototype?\n    obj.__proto__.__proto__.__proto__ === Class.prototype?\n    ...\n    // 如果任意一个的答案为 true，则返回 true\n    // 否则，如果我们已经检查到了原型链的尾端，则返回 false\n    ```\n\n    在上面那个例子中，`rabbit.__proto__ === Rabbit.prototype`，所以立即就给出了结果。\n\n    而在继承的例子中，匹配将在第二步进行：\n\n    ```js run\n    class Animal {}\n    class Rabbit extends Animal {}\n\n    let rabbit = new Rabbit();\n    *!*\n    alert(rabbit instanceof Animal); // true\n    */!*\n\n    // rabbit.__proto__ === Animal.prototype（无匹配）\n    *!*\n    // rabbit.__proto__.__proto__ === Animal.prototype（匹配！）\n    */!*\n    ```\n\n下图展示了 `rabbit instanceof Animal` 的执行过程中，`Animal.prototype` 是如何参与比较的：\n\n![](instanceof.svg)\n\n这里还要提到一个方法 [objA.isPrototypeOf(objB)](mdn:js/object/isPrototypeOf)，如果 `objA` 处在 `objB` 的原型链中，则返回 `true`。所以，可以将 `obj instanceof Class` 检查改为 `Class.prototype.isPrototypeOf(obj)`。\n\n这很有趣，但是 `Class` 的 constructor 自身是不参与检查的！检查过程只和原型链以及 `Class.prototype` 有关。\n\n创建对象后，如果更改 `prototype` 属性，可能会导致有趣的结果。\n\n就像这样：\n\n```js run\nfunction Rabbit() {}\nlet rabbit = new Rabbit();\n\n// 修改了 prototype\nRabbit.prototype = {};\n\n// ...再也不是 rabbit 了！\n*!*\nalert( rabbit instanceof Rabbit ); // false\n*/!*\n```\n\n## 福利：使用 Object.prototype.toString 方法来揭示类型\n\n大家都知道，一个普通对象被转化为字符串时为 `[object Object]`：\n\n```js run\nlet obj = {};\n\nalert(obj); // [object Object]\nalert(obj.toString()); // 同上\n```\n\n这是通过 `toString` 方法实现的。但是这儿有一个隐藏的功能，该功能可以使 `toString` 实际上比这更强大。我们可以将其作为 `typeof` 的增强版或者 `instanceof` 的替代方法来使用。\n\n听起来挺不可思议？那是自然，精彩马上揭晓。\n\n按照 [规范](https://tc39.github.io/ecma262/#sec-object.prototype.tostring) 所讲，内建的 `toString` 方法可以被从对象中提取出来，并在任何其他值的上下文中执行。其结果取决于该值。\n\n- 对于 number 类型，结果是 `[object Number]`\n- 对于 boolean 类型，结果是 `[object Boolean]`\n- 对于 `null`：`[object Null]`\n- 对于 `undefined`：`[object Undefined]`\n- 对于数组：`[object Array]`\n- ……等（可自定义）\n\n让我们演示一下：\n\n```js run\n// 方便起见，将 toString 方法复制到一个变量中\nlet objectToString = Object.prototype.toString;\n\n// 它是什么类型的？\nlet arr = [];\n\nalert( objectToString.call(arr) ); // [object *!*Array*/!*]\n```\n\n这里我们用到了在 [](info:call-apply-decorators) 一章中讲过的 [call](mdn:js/function/call) 方法来在上下文 `this=arr` 中执行函数 `objectToString`。\n\n在内部，`toString` 的算法会检查 `this`，并返回相应的结果。再举几个例子：\n\n```js run\nlet s = Object.prototype.toString;\n\nalert( s.call(123) ); // [object Number]\nalert( s.call(null) ); // [object Null]\nalert( s.call(alert) ); // [object Function]\n```\n\n### Symbol.toStringTag\n\n可以使用特殊的对象属性 `Symbol.toStringTag` 自定义对象的 `toString` 方法的行为。\n\n例如：\n\n```js run\nlet user = {\n  [Symbol.toStringTag]: \"User\"\n};\n\nalert( {}.toString.call(user) ); // [object User]\n```\n\n对于大多数特定于环境的对象，都有一个这样的属性。下面是一些特定于浏览器的示例：\n\n```js run\n// 特定于环境的对象和类的 toStringTag：\nalert( window[Symbol.toStringTag]); // Window\nalert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest\n\nalert( {}.toString.call(window) ); // [object Window]\nalert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]\n```\n\n正如我们所看到的，输出结果恰好是 `Symbol.toStringTag`（如果存在），只不过被包裹进了 `[object ...]` 里。\n\n这样一来，我们手头上就有了个“磕了药似的 typeof”，不仅能检查原始数据类型，而且适用于内建对象，更可贵的是还支持自定义。\n\n所以，如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 `{}.toString.call` 替代 `instanceof`。\n\n## 总结\n\n让我们总结一下我们知道的类型检查方法：\n\n|               | 用于 |  返回值      |\n|---------------|-------------|---------------|\n| `typeof`      | 原始数据类型 |  string       |\n| `{}.toString` | 原始数据类型，内建对象，包含 `Symbol.toStringTag` 属性的对象 | string |\n| `instanceof`  | 对象     |  true/false   |\n\n正如我们所看到的，从技术上讲，`{}.toString` 是一种“更高级的” `typeof`。\n\n当我们使用类的层次结构（hierarchy），并想要对该类进行检查，同时还要考虑继承时，这种场景下 `instanceof` 操作符确实很出色。",
        "libs": [],
        "children": [
          "strange-instanceof"
        ],
        "parent": "classes",
        "updatedAt": 1644768779
      }
    },
    "strange-instanceof": {
      "type": "Task",
      "value": {
        "title": "不按套路出牌的 instanceof",
        "slug": "strange-instanceof",
        "githubPath": "/1-js/09-classes/06-instanceof/1-strange-instanceof",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n在下面的代码中，为什么 `instanceof` 会返回 `true`？我们可以明显看到，`a` 并不是通过 `B()` 创建的。\n\n```js run\nfunction A() {}\nfunction B() {}\n\nA.prototype = B.prototype = {};\n\nlet a = new A();\n\n*!*\nalert( a instanceof B ); // true\n*/!*\n```",
        "solution": "是的，看起来确实很奇怪。\n\n`instanceof` 并不关心函数，而是关心函数的与原型链匹配的 `prototype`。\n\n并且，这里 `a.__proto__ == B.prototype`，所以 `instanceof` 返回 `true`。\n\n总之，根据 `instanceof` 的逻辑，真正决定类型的是 `prototype`，而不是构造函数。",
        "parent": "instanceof",
        "version": 1
      }
    },
    "mixins": {
      "type": "Article",
      "value": {
        "title": "Mixin 模式",
        "slug": "mixins",
        "githubPath": "/1-js/09-classes/07-mixins",
        "isFolder": false,
        "weight": 7,
        "content": "\n\n在 JavaScript 中，我们只能继承单个对象。每个对象只能有一个 `[[Prototype]]`。并且每个类只可以扩展另外一个类。\n\n但是有些时候这种设定（译注：单继承）会让人感到受限制。例如，我有一个 `StreetSweeper` 类和一个 `Bicycle` 类，现在想要一个它们的 mixin：`StreetSweepingBicycle` 类。\n\n或者，我们有一个 `User` 类和一个 `EventEmitter` 类来实现事件生成（event generation），并且我们想将 `EventEmitter` 的功能添加到 `User` 中，以便我们的用户可以触发事件（emit event）。\n\n有一个概念可以帮助我们，叫做 \"mixins\"。\n\n根据维基百科的定义，[mixin](https://en.wikipedia.org/wiki/Mixin) 是一个包含可被其他类使用而无需继承的方法的类。\n\n换句话说，*mixin* 提供了实现特定行为的方法，但是我们不单独使用它，而是使用它来将这些行为添加到其他类中。\n\n## 一个 Mixin 实例\n\n在 JavaScript 中构造一个 mixin 最简单的方式就是构造一个拥有实用方法的对象，以便我们可以轻松地将这些实用的方法合并到任何类的原型中。\n\n例如，这个名为 `sayHiMixin` 的 mixin 用于给 `User` 添加一些“语言功能”：\n\n```js run\n*!*\n// mixin\n*/!*\nlet sayHiMixin = {\n  sayHi() {\n    alert(`Hello ${this.name}`);\n  },\n  sayBye() {\n    alert(`Bye ${this.name}`);\n  }\n};\n\n*!*\n// 用法：\n*/!*\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// 拷贝方法\nObject.assign(User.prototype, sayHiMixin);\n\n// 现在 User 可以打招呼了\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\n这里没有继承，只有一个简单的方法拷贝。所以 `User` 可以从另一个类继承，还可以包括 mixin 来 \"mix-in“ 其它方法，就像这样：\n\n```js\nclass User extends Person {\n  // ...\n}\n\nObject.assign(User.prototype, sayHiMixin);\n```\n\nMixin 可以在自己内部使用继承。\n\n例如，这里的 `sayHiMixin` 继承自 `sayMixin`：\n\n```js run\nlet sayMixin = {\n  say(phrase) {\n    alert(phrase);\n  }\n};\n\nlet sayHiMixin = {\n  __proto__: sayMixin, // (或者，我们可以在这儿使用 Object.setPrototypeOf 来设置原型)\n\n  sayHi() {\n    *!*\n    // 调用父类方法\n    */!*\n    super.say(`Hello ${this.name}`); // (*)\n  },\n  sayBye() {\n    super.say(`Bye ${this.name}`); // (*)\n  }\n};\n\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// 拷贝方法\nObject.assign(User.prototype, sayHiMixin);\n\n// 现在 User 可以打招呼了\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\n请注意，在 `sayHiMixin` 内部对父类方法 `super.say()` 的调用（在标有 `(*)` 的行）会在 mixin 的原型中查找方法，而不是在 class 中查找。\n\n这是示意图（请参见图中右侧部分）：\n\n![](mixin-inheritance.svg)\n\n这是因为方法 `sayHi` 和 `sayBye` 最初是在 `sayHiMixin` 中创建的。因此，即使复制了它们，但是它们的 `[[HomeObject]]` 内部属性仍引用的是 `sayHiMixin`，如上图所示。\n\n当 `super` 在 `[[HomeObject]].[[Prototype]]` 中寻找父方法时，意味着它搜索的是 `sayHiMixin.[[Prototype]]`，而不是 `User.[[Prototype]]`。\n\n## EventMixin\n\n现在让我们为实际运用构造一个 mixin。\n\n例如，许多浏览器对象的一个重要功能是它们可以生成事件。事件是向任何有需要的人“广播信息”的好方法。因此，让我们构造一个 mixin，使我们能够轻松地将与事件相关的函数添加到任意 class/object 中。\n\n- Mixin 将提供 `.trigger(name, [...data])` 方法，以在发生重要的事情时“生成一个事件”。`name` 参数（arguments）是事件的名称，`[...data]` 是可选的带有事件数据的其他参数（arguments）。\n- 此外还有 `.on(name, handler)` 方法，它为具有给定名称的事件添加了 `handler` 函数作为监听器（listener）。当具有给定 `name` 的事件触发时将调用该方法，并从 `.trigger` 调用中获取参数（arguments）。\n- ……还有 `.off(name, handler)` 方法，它会删除 `handler` 监听器（listener）。\n\n添加完 mixin 后，对象 `user` 将能够在访客登录时生成事件 `\"login\"`。另一个对象，例如 `calendar` 可能希望监听此类事件以便为登录的人加载日历。\n\n或者，当一个菜单项被选中时，`menu` 可以生成 `\"select\"` 事件，其他对象可以分配处理程序以对该事件作出反应。诸如此类。\n\n下面是代码：\n\n```js run\nlet eventMixin = {\n  /**\n   * 订阅事件，用法：\n   *  menu.on('select', function(item) { ... }\n  */\n  on(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * 取消订阅，用法：\n   *  menu.off('select', handler)\n   */\n  off(eventName, handler) {\n    let handlers = this._eventHandlers?.[eventName];\n    if (!handlers) return;\n    for (let i = 0; i < handlers.length; i++) {\n      if (handlers[i] === handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * 生成具有给定名称和数据的事件\n   *  this.trigger('select', data1, data2);\n   */\n  trigger(eventName, ...args) {\n    if (!this._eventHandlers?.[eventName]) {\n      return; // 该事件名称没有对应的事件处理程序（handler）\n    }\n\n    // 调用事件处理程序（handler）\n    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));\n  }\n};\n```\n\n\n1. `.on(eventName, handler)` — 指定函数 `handler` 以在具有对应名称的事件发生时运行。从技术上讲，这儿有一个用于存储每个事件名称对应的处理程序（handler）的 `_eventHandlers` 属性，在这儿该属性就会将刚刚指定的这个 `handler` 添加到列表中。\n2. `.off(eventName, handler)` — 从处理程序列表中删除指定的函数。\n3. `.trigger(eventName, ...args)` — 生成事件：所有 `_eventHandlers[eventName]` 中的事件处理程序（handler）都被调用，并且 `...args` 会被作为参数传递给它们。\n\n用法：\n\n```js run\n// 创建一个 class\nclass Menu {\n  choose(value) {\n    this.trigger(\"select\", value);\n  }\n}\n// 添加带有事件相关方法的 mixin\nObject.assign(Menu.prototype, eventMixin);\n\nlet menu = new Menu();\n\n// 添加一个事件处理程序（handler），在被选择时被调用：\n*!*\nmenu.on(\"select\", value => alert(`Value selected: ${value}`));\n*/!*\n\n// 触发事件 => 运行上述的事件处理程序（handler）并显示：\n// 被选中的值：123\nmenu.choose(\"123\");\n```\n\n现在，如果我们希望任何代码对菜单选择作出反应，我们可以使用 `menu.on(...)` 进行监听。\n\n使用 `eventMixin` 可以轻松地将此类行为添加到我们想要的多个类中，并且不会影响继承链。\n\n## 总结\n\n*Mixin* —— 是一个通用的面向对象编程术语：一个包含其他类的方法的类。\n\n一些其它编程语言允许多重继承。JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin。\n\n我们可以使用 mixin 作为一种通过添加多种行为（例如上文中所提到的事件处理）来扩充类的方法。\n\n如果 Mixins 意外覆盖了现有类的方法，那么它们可能会成为一个冲突点。因此，通常应该仔细考虑 mixin 的命名方法，以最大程度地降低发生这种冲突的可能性。",
        "libs": [],
        "children": [],
        "headHtml": "<script>\nlet eventMixin = {\n\n  /**\n   * Subscribe to event, usage:\n   *  menu.on('select', function(item) { ... }\n  */\n  on(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Cancel the subscription, usage:\n   *  menu.off('select', handler)\n   */\n  off(eventName, handler) {\n    let handlers = this._eventHandlers?.[eventName];\n    if (!handlers) return;\n    for(let i = 0; i < handlers.length; i++) {\n      if (handlers[i] == handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Generate the event and attach the data to it\n   *  this.trigger('select', data1, data2);\n   */\n  trigger(eventName, ...args) {\n    if (!this._eventHandlers || !this._eventHandlers[eventName]) {\n      return; // no handlers for that event name\n    }\n\n    // call the handlers\n    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));\n  }\n};\n</script>\n",
        "parent": "classes",
        "updatedAt": 1658395779
      }
    },
    "error-handling": {
      "type": "Article",
      "value": {
        "title": "错误处理",
        "slug": "error-handling",
        "githubPath": "/1-js/10-error-handling",
        "isFolder": true,
        "weight": 10,
        "content": "",
        "libs": [],
        "children": [
          "try-catch",
          "custom-errors"
        ],
        "parent": "js"
      }
    },
    "try-catch": {
      "type": "Article",
      "value": {
        "title": "错误处理，\"try...catch\"",
        "slug": "try-catch",
        "githubPath": "/1-js/10-error-handling/1-try-catch",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n不管你多么精通编程，有时我们的脚本总还是会出现错误。可能是因为我们的编写出错，或是与预期不同的用户输入，或是错误的服务端响应以及其他数千种原因。\n\n通常，如果发生错误，脚本就会“死亡”（立即停止），并在控制台将错误打印出来。\n\n但是有一种语法结构 `try...catch`，它使我们可以“捕获（catch）”错误，因此脚本可以执行更合理的操作，而不是死掉。\n\n## \"try...catch\" 语法\n\n`try...catch` 结构由两部分组成：`try` 和 `catch`：\n\n```js\ntry {\n\n  // 代码...\n\n} catch (err) {\n\n  // 错误捕获\n\n}\n```\n\n它按照以下步骤执行：\n\n1. 首先，执行 `try {...}` 中的代码。\n2. 如果这里没有错误，则忽略 `catch (err)`：执行到 `try` 的末尾并跳过 `catch` 继续执行。\n3. 如果这里出现错误，则 `try` 执行停止，控制流转向 `catch (err)` 的开头。变量 `err`（我们可以使用任何名称）将包含一个 error 对象，该对象包含了所发生事件的详细信息。\n\n![](try-catch-flow.svg)\n\n所以，`try {...}` 块内的 error 不会杀死脚本 —— 我们有机会在 `catch` 中处理它。\n\n让我们来看一些例子。\n\n- 没有 error 的例子：显示 `alert` `(1)` 和 `(2)`：\n\n    ```js run\n    try {\n\n      alert('开始执行 try 中的内容');  // *!*(1) <--*/!*\n\n      // ...这里没有 error\n\n      alert('try 中的内容执行完毕');   // *!*(2) <--*/!*\n\n    } catch (err) {\n\n      alert('catch 被忽略，因为没有 error'); // (3)\n\n    }\n    ```\n- 包含 error 的例子：显示 `(1)` 和 `(3)` 行的 `alert` 中的内容：\n\n    ```js run\n    try {\n\n      alert('开始执行 try 中的内容');  // *!*(1) <--*/!*\n\n    *!*\n      lalala; // error，变量未定义！\n    */!*\n\n      alert('try 的末尾（未执行到此处）');  // (2)\n\n    } catch (err) {\n\n      alert(`出现了 error！`); // *!*(3) <--*/!*\n\n    }\n    ```\n\n\n````warn header=\"`try...catch` 仅对运行时的 error 有效\"\n要使得 `try...catch` 能工作，代码必须是可执行的。换句话说，它必须是有效的 JavaScript 代码。\n\n如果代码包含语法错误，那么 `try..catch` 将无法正常工作，例如含有不匹配的花括号：\n\n```js run\ntry {\n  {{{{{{{{{{{{\n} catch (err) {\n  alert(\"引擎无法理解这段代码，它是无效的\");\n}\n```\n\nJavaScript 引擎首先会读取代码，然后运行它。在读取阶段发生的错误被称为“解析时间（parse-time）”错误，并且无法恢复（从该代码内部）。这是因为引擎无法理解该代码。\n\n所以，`try...catch` 只能处理有效代码中出现的错误。这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”。\n````\n\n\n````warn header=\"`try...catch` 同步执行\"\n如果在“计划的（scheduled）”代码中发生异常，例如在 `setTimeout` 中，则 `try...catch` 不会捕获到异常：\n\n```js run\ntry {\n  setTimeout(function() {\n    noSuchVariable; // 脚本将在这里停止运行\n  }, 1000);\n} catch (err) {\n  alert( \"不工作\" );\n}\n```\n\n因为 `try...catch` 包裹了计划要执行的函数，该函数本身要稍后才执行，这时引擎已经离开了 `try...catch` 结构。\n\n为了捕获到计划的（scheduled）函数中的异常，那么 `try...catch` 必须在这个函数内：\n```js run\nsetTimeout(function() {\n  try {\n    noSuchVariable; // try...catch 处理 error 了！\n  } catch {\n    alert( \"error 被在这里捕获了！\" );\n  }\n}, 1000);\n```\n````\n\n## Error 对象\n\n发生错误时，JavaScript 会生成一个包含有关此 error 详细信息的对象。然后将该对象作为参数传递给 `catch`：\n\n```js\ntry {\n  // ...\n} catch (err) { // <-- “error 对象”，也可以用其他参数名代替 err\n  // ...\n}\n```\n\n对于所有内建的 error，error 对象具有两个主要属性：\n\n`name`\n: Error 名称。例如，对于一个未定义的变量，名称是 `\"ReferenceError\"`。\n\n`message`\n: 关于 error 的详细文字描述。\n\n还有其他非标准的属性在大多数环境中可用。其中被最广泛使用和支持的是：\n\n`stack`\n: 当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。\n\n例如：\n\n```js run untrusted\ntry {\n*!*\n  lalala; // error, variable is not defined!\n*/!*\n} catch (err) {\n  alert(err.name); // ReferenceError\n  alert(err.message); // lalala is not defined\n  alert(err.stack); // ReferenceError: lalala is not defined at (...call stack)\n\n  // 也可以将一个 error 作为整体显示出来\n  // error 信息被转换为像 \"name: message\" 这样的字符串\n  alert(err); // ReferenceError: lalala is not defined\n}\n```\n\n## 可选的 \"catch\" 绑定\n\n[recent browser=new]\n\n如果我们不需要 error 的详细信息，`catch` 也可以忽略它：\n\n```js\ntry {\n  // ...\n} catch { // <-- 没有 (err)\n  // ...\n}\n```\n\n## 使用 \"try...catch\"\n\n让我们一起探究一下真实场景中 `try...catch` 的用例。\n\n正如我们所知道的，JavaScript 支持 [JSON.parse(str)](mdn:js/JSON/parse) 方法来解析 JSON 编码的值。\n\n通常，它被用来解析从网络、服务器或是其他来源接收到的数据。\n\n我们收到数据后，然后像下面这样调用 `JSON.parse`：\n\n```js run\nlet json = '{\"name\":\"John\", \"age\": 30}'; // 来自服务器的数据\n\n*!*\nlet user = JSON.parse(json); // 将文本表示转换成 JavaScript 对象\n*/!*\n\n// 现在 user 是一个解析自 json 字符串的有自己属性的对象\nalert( user.name ); // John\nalert( user.age );  // 30\n```\n\n你可以在 <info:json> 一章中找到更多关于 JSON 的详细内容。\n\n**如果 `json` 格式错误，`JSON.parse` 就会生成一个 error，因此脚本就会“死亡”。**\n\n我们对此满意吗？当然不！\n\n如果这样做，当拿到的数据出了问题，那么访问者永远都不会知道原因（除非他们打开开发者控制台）。代码执行失败却没有提示信息，这真的是很糟糕的用户体验。\n\n让我们用 `try...catch` 来处理这个 error：\n\n```js run\nlet json = \"{ bad json }\";\n\ntry {\n\n*!*\n  let user = JSON.parse(json); // <-- 当出现 error 时...\n*/!*\n  alert( user.name ); // 不工作\n\n} catch (err) {\n*!*\n  // ...执行会跳转到这里并继续执行\n  alert( \"很抱歉，数据有错误，我们会尝试再请求一次。\" );\n  alert( err.name );\n  alert( err.message );\n*/!*\n}\n```\n\n在这儿，我们将 `catch` 块仅仅用于显示信息，但我们可以做更多的事：发送一个新的网络请求，向访问者建议一个替代方案，将有关错误的信息发送给记录日志的设备，……。所有这些都比代码“死掉”好得多。\n\n## 抛出我们自定义的 error\n\n如果这个 `json` 在语法上是正确的，但是没有所必须的 `name` 属性该怎么办？\n\n像这样：\n\n```js run\nlet json = '{ \"age\": 30 }'; // 不完整的数据\n\ntry {\n\n  let user = JSON.parse(json); // <-- 没有 error\n*!*\n  alert( user.name ); // 没有 name！\n*/!*\n\n} catch (err) {\n  alert( \"doesn't execute\" );\n}\n```\n\n这里 `JSON.parse` 正常执行，但缺少 `name` 属性对我们来说确实是个 error。\n\n为了统一进行 error 处理，我们将使用 `throw` 操作符。\n\n### \"throw\" 操作符\n\n`throw` 操作符会生成一个 error 对象。\n\n语法如下：\n\n```js\nthrow <error object>\n```\n\n技术上讲，我们可以将任何东西用作 error 对象。甚至可以是一个原始类型数据，例如数字或字符串，但最好使用对象，最好使用具有 `name` 和 `message` 属性的对象（某种程度上保持与内建 error 的兼容性）。\n\nJavaScript 中有很多内建的标准 error 的构造器：`Error`，`SyntaxError`，`ReferenceError`，`TypeError` 等。我们也可以使用它们来创建 error 对象。\n\n它们的语法是：\n\n```js\nlet error = new Error(message);\n// 或\nlet error = new SyntaxError(message);\nlet error = new ReferenceError(message);\n// ...\n```\n\n对于内建的 error（不是对于其他任何对象，仅仅是对于 error），`name` 属性刚好就是构造器的名字。`message` 则来自于参数（argument）。\n\n例如：\n\n```js run\nlet error = new Error(\"Things happen o_O\");\n\nalert(error.name); // Error\nalert(error.message); // Things happen o_O\n```\n\n让我们来看看 `JSON.parse` 会生成什么样的 error：\n\n```js run\ntry {\n  JSON.parse(\"{ bad json o_O }\");\n} catch(err) {\n*!*\n  alert(err.name); // SyntaxError\n*/!*\n  alert(err.message); // Unexpected token b in JSON at position 2\n}\n```\n\n正如我们所看到的， 那是一个  `SyntaxError`。\n\n在我们的示例中，缺少 `name` 属性就是一个 error，因为用户必须有一个 `name`。\n\n所以，让我们抛出这个 error。\n\n```js run\nlet json = '{ \"age\": 30 }'; // 不完整的数据\n\ntry {\n\n  let user = JSON.parse(json); // <-- 没有 error\n\n  if (!user.name) {\n*!*\n    throw new SyntaxError(\"数据不全：没有 name\"); // (*)\n*/!*\n  }\n\n  alert( user.name );\n\n} catch(err) {\n  alert( \"JSON Error: \" + err.message ); // JSON Error: 数据不全：没有 name\n}\n```\n\n在 `(*)` 标记的这一行，`throw` 操作符生成了包含着我们所给定的 `message` 的 `SyntaxError`，与 JavaScript 自己生成的方式相同。`try` 的执行立即停止，控制流转向 `catch` 块。\n\n现在，`catch` 成为了所有 error 处理的唯一场所：对于 `JSON.parse` 和其他情况都适用。\n\n## 再次抛出（Rethrowing）\n\n在上面的例子中，我们使用 `try...catch` 来处理不正确的数据。但是在 `try {...}` 块中是否可能发生 **另一个预料之外的 error**？例如编程错误（未定义变量）或其他错误，而不仅仅是这种“不正确的数据”。\n\n例如：\n\n```js run\nlet json = '{ \"age\": 30 }'; // 不完整的数据\n\ntry {\n  user = JSON.parse(json); // <-- 忘记在 user 前放置 \"let\"\n\n  // ...\n} catch (err) {\n  alert(\"JSON Error: \" + err); // JSON Error: ReferenceError: user is not defined\n  // (实际上并没有 JSON Error)\n}\n```\n\n当然，一切皆有可能！程序员也会犯错。即使是被数百万人使用了几十年的开源项目中，也可能突然被发现了一个漏洞，并导致可怕的黑客入侵。\n\n在我们的例子中，`try...catch` 旨在捕获“数据不正确”的 error。但实际上，catch 会捕获到 **所有** 来自于 `try` 的 error。在这儿，它捕获到了一个预料之外的 error，但仍然抛出的是同样的 `\"JSON Error\"` 信息。这是不正确的，并且也会使代码变得更难以调试。\n\n为了避免此类问题，我们可以采用“重新抛出”技术。规则很简单：\n\n**`catch` 应该只处理它知道的 error，并“抛出”所有其他 error。**\n\n“再次抛出（rethrowing）”技术可以被更详细地解释为：\n\n1. Catch 捕获所有 error。\n2. 在 `catch (err) {...}` 块中，我们对 error 对象 `err` 进行分析。\n3. 如果我们不知道如何处理它，那我们就 `throw err`。\n\n通常，我们可以使用 `instanceof` 操作符判断错误类型：\n\n```js run\ntry {\n  user = { /*...*/ };\n} catch (err) {\n*!*\n  if (err instanceof ReferenceError) {\n*/!*\n    alert('ReferenceError'); // 访问一个未定义（undefined）的变量产生了 \"ReferenceError\"\n  }\n}\n```\n\n我们还可以从 `err.name` 属性中获取错误的类名。所有原生的错误都有这个属性。另一种方式是读取 `err.constructor.name`。\n\n在下面的代码中，我们使用“再次抛出”，以达到在 `catch` 中只处理 `SyntaxError` 的目的：\n\n```js run\nlet json = '{ \"age\": 30 }'; // 不完整的数据\ntry {\n\n  let user = JSON.parse(json);\n\n  if (!user.name) {\n    throw new SyntaxError(\"数据不全：没有 name\");\n  }\n\n*!*\n  blabla(); // 预料之外的 error\n*/!*\n\n  alert( user.name );\n\n} catch (err) {\n\n*!*\n  if (err instanceof SyntaxError) {\n    alert( \"JSON Error: \" + err.message );\n  } else {\n    throw err; // 再次抛出 (*)\n  }\n*/!*\n\n}\n```\n\n如果 `(*)` 标记的这行 `catch` 块中的 error 从 `try...catch` 中“掉了出来”，那么它也可以被外部的 `try...catch` 结构（如果存在）捕获到，如果外部不存在这种结构，那么脚本就会被杀死。\n\n所以，`catch` 块实际上只处理它知道该如何处理的 error，并“跳过”所有其他的 error。\n\n下面这个示例演示了这种类型的 error 是如何被另外一级 `try...catch` 捕获的：\n\n```js run\nfunction readData() {\n  let json = '{ \"age\": 30 }';\n\n  try {\n    // ...\n*!*\n    blabla(); // error!\n*/!*\n  } catch (err) {\n    // ...\n    if (!(err instanceof SyntaxError)) {\n*!*\n      throw err; // 再次抛出（不知道如何处理它）\n*/!*\n    }\n  }\n}\n\ntry {\n  readData();\n} catch (err) {\n*!*\n  alert( \"External catch got: \" + err ); // 捕获了它！\n*/!*\n}\n```\n\n上面这个例子中的 `readData` 只知道如何处理 `SyntaxError`，而外部的 `try...catch` 知道如何处理任意的 error。\n\n## try...catch...finally\n\n等一下，以上并不是所有内容。\n\n`try...catch` 结构可能还有一个代码子句（clause）：`finally`。\n\n如果它存在，它在所有情况下都会被执行：\n\n- `try` 之后，如果没有 error，\n- `catch` 之后，如果有 error。\n\n该扩展语法如下所示：\n\n```js\n*!*try*/!* {\n   ... 尝试执行的代码 ...\n} *!*catch*/!* (err) {\n   ... 处理 error ...\n} *!*finally*/!* {\n   ... 总是会执行的代码 ...\n}\n```\n\n试试运行这段代码：\n\n```js run\ntry {\n  alert( 'try' );\n  if (confirm('Make an error?')) BAD_CODE();\n} catch (err) {\n  alert( 'catch' );\n} finally {\n  alert( 'finally' );\n}\n```\n\n这段代码有两种执行方式：\n\n1. 如果你对于 \"Make an error?\" 的回答是 \"Yes\"，那么执行 `try -> catch -> finally`。\n2. 如果你的回答是 \"No\"，那么执行 `try -> finally`。\n\n`finally` 子句（clause）通常用在：当我们开始做某事的时候，希望无论出现什么情况都要完成完成某个任务。\n\n例如，我们想要测量一个斐波那契数字函数 `fib(n)` 执行所需要花费的时间。通常，我们可以在运行它之前开始测量，并在运行完成时结束测量。但是，如果在该函数调用期间出现 error 该怎么办？特别是，下面这段 `fib(n)` 的实现代码在遇到负数或非整数数字时会返回一个 error。\n\n无论如何，`finally` 子句都是一个结束测量的好地方。\n\n在这儿，`finally` 能够保证在两种情况下都能正确地测量时间 —— 成功执行 `fib` 以及 `fib` 中出现 error 时：\n\n```js run\nlet num = +prompt(\"输入一个正整数？\", 35)\n\nlet diff, result;\n\nfunction fib(n) {\n  if (n < 0 || Math.trunc(n) != n) {\n    throw new Error(\"不能是负数，并且必须是整数。\");\n  }\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nlet start = Date.now();\n\ntry {\n  result = fib(num);\n} catch (err) {\n  result = 0;\n*!*\n} finally {\n  diff = Date.now() - start;\n}\n*/!*\n\nalert(result || \"出现了 error\");\n\nalert( `执行花费了 ${diff}ms` );\n```\n\n你可以通过运行上面这段代码并在 `prompt` 弹窗中输入 `35` 来进行检查 —— 代码运行正常，先执行 `try` 然后是 `finally`。如果你输入的是 `-1` —— 将立即出现 error，执行将只花费 `0ms`。以上两种情况下的时间测量都正确地完成了。\n\n换句话说，函数 `fib` 以 `return` 还是 `throw` 完成都无关紧要。在这两种情况下都会执行 `finally` 子句。\n\n\n```smart header=\"变量和 `try...catch...finally` 中的局部变量\"\n请注意，上面代码中的 `result` 和 `diff` 变量都是在 `try...catch` **之前** 声明的。\n\n否则，如果我们使用 `let` 在 `try` 块中声明变量，那么该变量将只在 `try` 块中可见。\n```\n\n````smart header=\"`finally` 和 `return`\"\n`finally` 子句适用于 `try...catch` 的 **任何** 出口。这包括显式的 `return`。\n\n在下面这个例子中，在 `try` 中有一个 `return`。在这种情况下，`finally` 会在控制转向外部代码前被执行。\n\n```js run\nfunction func() {\n\n  try {\n*!*\n    return 1;\n*/!*\n\n  } catch (err) {\n    /* ... */\n  } finally {\n*!*\n    alert( 'finally' );\n*/!*\n  }\n}\n\nalert( func() ); // 先执行 finally 中的 alert，然后执行这个 alert\n```\n````\n\n````smart header=\"`try...finally`\"\n\n没有 `catch` 子句的 `try...finally` 结构也很有用。当我们不想在这儿处理 error（让它们 fall through），但是需要确保我们启动的处理需要被完成。\n\n```js\nfunction func() {\n  // 开始执行需要被完成的操作（比如测量）\n  try {\n    // ...\n  } finally {\n    // 完成前面我们需要完成的那件事，即使 try 中的执行失败了\n  }\n}\n```\n上面的代码中，由于没有 `catch`，所以 `try` 中的 error 总是会使代码执行跳转至函数 `func()` 外。但是，在跳出之前需要执行 `finally` 中的代码。\n````\n\n## 全局 catch\n\n```warn header=\"环境特定\"\n这个部分的内容并不是 JavaScript 核心的一部分。\n```\n\n设想一下，在 `try...catch` 结构外有一个致命的 error，然后脚本死亡了。这个 error 就像编程错误或其他可怕的事儿那样。\n\n有什么办法可以用来应对这种情况吗？我们可能想要记录这个 error，并向用户显示某些内容（通常用户看不到错误信息）等。\n\n规范中没有相关内容，但是代码的执行环境一般会提供这种机制，因为它确实很有用。例如，Node.JS 有 [`process.on(\"uncaughtException\")`](https://nodejs.org/api/process.html#process_event_uncaughtexception)。在浏览器中，我们可以将一个函数赋值给特殊的 [window.onerror](mdn:api/GlobalEventHandlers/onerror) 属性，该函数将在发生未捕获的 error 时执行。\n\n语法如下：\n\n```js\nwindow.onerror = function(message, url, line, col, error) {\n  // ...\n};\n```\n\n`message`\n: error 信息。\n\n`url`\n: 发生 error 的脚本的 URL。\n\n`line`，`col`\n: 发生 error 处的代码的行号和列号。\n\n`error`\n: error 对象。\n\n例如：\n\n```html run untrusted refresh height=1\n<script>\n*!*\n  window.onerror = function(message, url, line, col, error) {\n    alert(`${message}\\n At ${line}:${col} of ${url}`);\n  };\n*/!*\n\n  function readData() {\n    badFunc(); // 啊，出问题了！\n  }\n\n  readData();\n</script>\n```\n\n全局错误处理程序 `window.onerror` 的作用通常不是恢复脚本的执行 —— 如果发生编程错误，恢复脚本的执行几乎是不可能的，它的作用是将错误信息发送给开发者。\n\n也有针对这种情况提供 error 日志的 Web 服务，例如 <https://errorception.com> 或 <http://www.muscula.com>。\n\n它们会像这样运行：\n\n1. 我们注册该服务，并拿到一段 JavaScript 代码（或脚本的 URL），然后插入到页面中。\n2. 该 JavaScript 脚本设置了自定义的 `window.onerror` 函数。\n3. 当发生 error 时，它会发送一个此 error 相关的网络请求到服务提供方。\n4. 我们可以登录到服务方的 Web 界面来查看这些 error。\n\n## 总结\n\n`try...catch` 结构允许我们处理执行过程中出现的 error。从字面上看，它允许“尝试”运行代码并“捕获”其中可能发生的 error。\n\n语法如下：\n\n```js\ntry {\n  // 执行此处代码\n} catch (err) {\n  // 如果发生 error，跳转至此处\n  // err 是一个 error 对象\n} finally {\n  // 无论怎样都会在 try/catch 之后执行\n}\n```\n\n这儿可能会没有 `catch` 或者没有 `finally`，所以 `try...catch` 或 `try...finally` 都是可用的。\n\nError 对象包含下列属性：\n\n- `message` _ 人类可读的 error 信息。\n- `name` —— 具有 error 名称的字符串（Error 构造器的名称）。\n- `stack`（没有标准，但得到了很好的支持）—— Error 发生时的调用栈。\n\n如果我们不需要 error 对象，我们可以通过使用 `catch {` 而不是 `catch (err) {` 来省略它。\n\n我们也可以使用 `throw` 操作符来生成自定义的 error。从技术上讲，`throw` 的参数可以是任何东西，但通常是继承自内建的 `Error` 类的 error 对象。下一章我们会详细介绍扩展 error。\n\n再次抛出（rethrowing）是一种错误处理的重要模式：`catch` 块通常期望并知道如何处理特定的 error 类型，因此它应该再次抛出它不知道的 error。\n\n即使我们没有 `try...catch`，大多数执行环境也允许我们设置“全局” error 处理程序来捕获“掉出（fall out）”的 error。在浏览器中，就是 `window.onerror`。",
        "libs": [],
        "children": [
          "finally-or-code-after"
        ],
        "parent": "error-handling",
        "updatedAt": 1658404485
      }
    },
    "finally-or-code-after": {
      "type": "Task",
      "value": {
        "title": "使用 finally 还是直接放在代码后面？",
        "slug": "finally-or-code-after",
        "githubPath": "/1-js/10-error-handling/1-try-catch/1-finally-or-code-after",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n比较下面两个代码片段。\n\n1. 第一个代码片段，使用 `finally` 在 `try..catch` 之后执行代码：\n\n    ```js\n    try {\n      // 工作\n    } catch (err) {\n      // 处理 error\n    } finally {\n    *!*\n      // 清理工作空间\n    */!*\n    }\n    ```\n2. 第二个代码片段，将清空工作空间的代码放在了 `try...catch` 之后：\n\n    ```js\n    try {\n      // 工作\n    } catch (err) {\n      // 处理 error\n    }\n\n    *!*\n    // 清理工作空间\n    */!*\n    ```\n\n我们肯定需要在工作后进行清理，无论工作过程中是否有 error 都不影响。\n\n在这儿使用 `finally` 更有优势，还是说两个代码片段效果一样？如果在这有这样的优势，如果需要，请举例说明。",
        "solution": "当我们看函数中的代码时，差异就变得很明显了。\n\n如果在这有“跳出” `try..catch` 的行为，那么这两种方式的表现就不同了。\n\n例如，当 `try...catch` 中有 `return` 时。`finally` 子句会在 `try...catch` 的 **任意** 出口处起作用，即使是通过 `return` 语句退出的也是如此：在 `try...catch` 刚刚执行完成后，但在调用代码获得控制权之前。\n\n```js run\nfunction f() {\n  try {\n    alert('start');\n*!*\n    return \"result\";\n*/!*\n  } catch (err) {\n    /// ...\n  } finally {\n    alert('cleanup!');\n  }\n}\n\nf(); // cleanup!\n```\n\n……或者当有 `throw` 时，如下所示：\n\n```js run\nfunction f() {\n  try {\n    alert('start');\n    throw new Error(\"一个 error\");\n  } catch (err) {\n    // ...\n    if(\"无法处理此 error\") {\n*!*\n      throw err;\n*/!*\n    }\n\n  } finally {\n    alert('cleanup!')\n  }\n}\n\nf(); // cleanup!\n```\n\n正是这里的 `finally` 保证了 cleanup。如果我们只是将代码放在函数 `f` 的末尾，则在这些情况下它不会运行。",
        "parent": "try-catch",
        "version": 1
      }
    },
    "custom-errors": {
      "type": "Article",
      "value": {
        "title": "自定义 Error，扩展 Error",
        "slug": "custom-errors",
        "githubPath": "/1-js/10-error-handling/2-custom-errors",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n当我们在开发某些东西时，经常会需要我们自己的 error 类来反映在我们的任务中可能出错的特定任务。对于网络操作中的 error，我们需要 `HttpError`，对于数据库操作中的 error，我们需要 `DbError`，对于搜索操作中的 error，我们需要 `NotFoundError`，等等。\n\n我们自定义的 error 应该支持基本的 error 的属性，例如 `message`，`name`，并且最好还有 `stack`。但是它们也可能会有其他属于它们自己的属性，例如，`HttpError` 对象可能会有一个 `statusCode` 属性，属性值可能为 `404`、`403` 或 `500` 等。\n\nJavaScript 允许将 `throw` 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 `Error` 中继承。但是，如果我们继承，那么就可以使用 `obj instanceof Error` 来识别 error 对象。因此，最好继承它。\n\n随着开发的应用程序的增长，我们自己的 error 自然会形成形成一个层次结构（hierarchy）。例如，`HttpTimeoutError` 可能继承自 `HttpError`，等等。\n\n## 扩展 Error\n\n例如，让我们考虑一个函数 `readUser(json)`，该函数应该读取带有用户数据的 JSON。\n\n这里是一个可用的 `json` 的例子：\n```js\nlet json = `{ \"name\": \"John\", \"age\": 30 }`;\n```\n\n在函数内部，我们将使用 `JSON.parse`。如果它接收到格式不正确的 `json`，就会抛出 `SyntaxError`。但是，即使 `json` 在语法上是正确的，也不意味着该数据是有效的用户数据，对吧？因为它可能丢失了某些必要的数据。例如，对用户来说，必不可少的是 `name` 和 `age` 属性。\n\n我们的函数 `readUser(json)` 不仅会读取 JSON，还会检查（“验证”）数据。如果没有所必须的字段，或者（字段的）格式错误，那么就会出现一个 error。并且这些并不是 `SyntaxError`，因为这些数据在语法上是正确的，这些是另一种错误。我们称之为 `ValidationError`，并为之创建一个类。这种类型的错误也应该包含有关违规字段的信息。\n\n我们的 `ValidationError` 类应该继承自 `Error` 类。\n\n`Error` 类是内建的，但这是其近似代码，所以我们可以了解我们要扩展的内容：\n\n```js\n// JavaScript 自身定义的内建的 Error 类的“伪代码”\nclass Error {\n  constructor(message) {\n    this.message = message;\n    this.name = \"Error\"; // (不同的内建 error 类有不同的名字)\n    this.stack = <call stack>; // 非标准的，但大多数环境都支持它\n  }\n}\n```\n\n现在让我们从其中继承 `ValidationError`，并尝试进行运行：\n\n```js run untrusted\n*!*\nclass ValidationError extends Error {\n*/!*\n  constructor(message) {\n    super(message); // (1)\n    this.name = \"ValidationError\"; // (2)\n  }\n}\n\nfunction test() {\n  throw new ValidationError(\"Whoops!\");\n}\n\ntry {\n  test();\n} catch(err) {\n  alert(err.message); // Whoops!\n  alert(err.name); // ValidationError\n  alert(err.stack); // 一个嵌套调用的列表，每个调用都有对应的行号\n}\n```\n\n请注意：在 `(1)` 行中我们调用了父类的 constructor。JavaScript 要求我们在子类的 constructor 中调用 `super`，所以这是必须的。父类的 constructor 设置了 `message` 属性。\n\n父类的 constructor 还将 `name` 属性的值设置为了 `\"Error\"`，所以在 `(2)` 行中，我们将其重置为了右边的值。\n\n让我们尝试在 `readUser(json)` 中使用它吧：\n\n```js run\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n// 用法\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new ValidationError(\"No field: age\");\n  }\n  if (!user.name) {\n    throw new ValidationError(\"No field: name\");\n  }\n\n  return user;\n}\n\n// try..catch 的工作示例\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n*!*\n    alert(\"Invalid data: \" + err.message); // Invalid data: No field: name\n*/!*\n  } else if (err instanceof SyntaxError) { // (*)\n    alert(\"JSON Syntax Error: \" + err.message);\n  } else {\n    throw err; // 未知的 error，再次抛出 (**)\n  }\n}\n```\n\n上面代码中的 `try..catch` 块既处理我们的 `ValidationError` 又处理来自 `JSON.parse` 的内建 `SyntaxError`。\n\n请看一下我们是如何使用 `instanceof` 来检查 `(*)` 行中的特定错误类型的。\n\n我们也可以看看 `err.name`，像这样：\n\n```js\n// ...\n// instead of (err instanceof SyntaxError)\n} else if (err.name == \"SyntaxError\") { // (*)\n// ...\n```\n\n使用 `instanceof` 的版本要好得多，因为将来我们会对 `ValidationError` 进行扩展，创建它的子类型，例如 `PropertyRequiredError`。而 `instanceof` 检查对于新的继承类也适用。所以这是面向未来的做法。\n\n还有一点很重要，在 `catch` 遇到了未知的错误，它会在 `(**)` 行将该错误再次抛出。`catch` 块只知道如何处理 validation 错误和语法错误，而其他错误（由代码中的拼写错误或其他未知原因导致的）应该被扔出（fall through）。\n\n## 深入继承\n\n`ValidationError` 类是非常通用的。很多东西都可能出错。对象的属性可能缺失或者属性可能有格式错误（例如 `age` 属性的值为一个字符串而不是数字）。让我们针对缺少属性的错误来制作一个更具体的 `PropertyRequiredError` 类。它将携带有关缺少的属性的相关信息。\n\n```js run\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n*!*\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"No property: \" + property);\n    this.name = \"PropertyRequiredError\";\n    this.property = property;\n  }\n}\n*/!*\n\n// 用法\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n\n  return user;\n}\n\n// try..catch 的工作示例\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n*!*\n    alert(\"Invalid data: \" + err.message); // Invalid data: No property: name\n    alert(err.name); // PropertyRequiredError\n    alert(err.property); // name\n*/!*\n  } else if (err instanceof SyntaxError) {\n    alert(\"JSON Syntax Error: \" + err.message);\n  } else {\n    throw err; // 未知 error，将其再次抛出\n  }\n}\n```\n\n这个新的类 `PropertyRequiredError` 使用起来很简单：我们只需要传递属性名：`new PropertyRequiredError(property)`。人类可读的 `message` 是由 constructor 生成的。\n\n请注意，在 `PropertyRequiredError` constructor 中的 `this.name` 是通过手动重新赋值的。这可能会变得有些乏味 —— 在每个自定义 error 类中都要进行 `this.name = <class name>` 赋值操作。我们可以通过创建自己的“基础错误（basic error）”类来避免这种情况，该类进行了 `this.name = this.constructor.name` 赋值。然后让所有我们自定义的 error 都从这个“基础错误”类进行继承。\n\n让我们称之为 `MyError`。\n\n这是带有 `MyError` 以及其他自定义的 error 类的代码，已进行简化：\n\n```js run\nclass MyError extends Error {\n  constructor(message) {\n    super(message);\n*!*\n    this.name = this.constructor.name;\n*/!*\n  }\n}\n\nclass ValidationError extends MyError { }\n\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"No property: \" + property);\n    this.property = property;\n  }\n}\n\n// name 是对的\nalert( new PropertyRequiredError(\"field\").name ); // PropertyRequiredError\n```\n\n现在自定义的 error 短了很多，特别是 `ValidationError`，因为我们摆脱了 constructor 中的 `\"this.name = ...\"` 这一行。\n\n## 包装异常\n\n在上面代码中的函数 `readUser` 的目的就是“读取用户数据”。在这个过程中可能会出现不同类型的 error。目前我们有了 `SyntaxError` 和 `ValidationError`，但是将来，函数 `readUser` 可能会不断壮大，并可能会产生其他类型的 error。\n\n调用 `readUser` 的代码应该处理这些 error。现在它在 `catch` 块中使用了多个 `if` 语句来检查 error 类，处理已知的 error，并再次抛出未知的 error。\n\n该方案是这样的：\n\n```js\ntry {\n  ...\n  readUser()  // 潜在的 error 源\n  ...\n} catch (err) {\n  if (err instanceof ValidationError) {\n    // 处理 validation error\n  } else if (err instanceof SyntaxError) {\n    // 处理 syntax error\n  } else {\n    throw err; // 未知 error，再次抛出它\n  }\n}\n```\n\n在上面的代码中，我们可以看到两种类型的 error，但是可以有更多。\n\n如果 `readUser` 函数会产生多种 error，那么我们应该问问自己：我们是否真的想每次都一一检查所有的 error 类型？\n\n通常答案是 \"No\"：我们希望能够“比它高一个级别”。我们只想知道这里是否是“数据读取异常” —— 为什么发生了这样的 error 通常是无关紧要的（error 信息描述了它）。或者，如果我们有一种方式能够获取 error 的详细信息那就更好了，但前提是我们需要。\n\n我们所描述的这项技术被称为“包装异常”。\n\n1. 我们将创建一个新的类 `ReadError` 来表示一般的“数据读取” error。\n2. 函数`readUser` 将捕获内部发生的数据读取 error，例如 `ValidationError` 和 `SyntaxError`，并生成一个 `ReadError` 来进行替代。\n3. 对象 `ReadError` 会把对原始 error 的引用保存在其 `cause` 属性中。\n\n之后，调用 `readUser` 的代码只需要检查 `ReadError`，而不必检查每种数据读取 error。并且，如果需要更多 error 细节，那么可以检查 `readUser` 的 `cause` 属性。\n\n下面的代码定义了 `ReadError`，并在 `readUser` 和 `try..catch` 中演示了其用法：\n\n```js run\nclass ReadError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = 'ReadError';\n  }\n}\n\nclass ValidationError extends Error { /*...*/ }\nclass PropertyRequiredError extends ValidationError { /* ... */ }\n\nfunction validateUser(user) {\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n}\n\nfunction readUser(json) {\n  let user;\n\n  try {\n    user = JSON.parse(json);\n  } catch (err) {\n*!*\n    if (err instanceof SyntaxError) {\n      throw new ReadError(\"Syntax Error\", err);\n    } else {\n      throw err;\n    }\n*/!*\n  }\n\n  try {\n    validateUser(user);\n  } catch (err) {\n*!*\n    if (err instanceof ValidationError) {\n      throw new ReadError(\"Validation Error\", err);\n    } else {\n      throw err;\n    }\n*/!*\n  }\n\n}\n\ntry {\n  readUser('{bad json}');\n} catch (e) {\n  if (e instanceof ReadError) {\n*!*\n    alert(e);\n    // Original error: SyntaxError: Unexpected token b in JSON at position 1\n    alert(\"Original error: \" + e.cause);\n*/!*\n  } else {\n    throw e;\n  }\n}\n```\n\n在上面的代码中，`readUser` 正如所描述的那样正常工作 —— 捕获语法和验证（validation）错误，并抛出 `ReadError`（对于未知错误将照常再次抛出）。\n\n所以外部代码检查 `instanceof ReadError`，并且它的确是。不必列出所有可能的 error 类型。\n\n这种方法被称为“包装异常（wrapping exceptions）”，因为我们将“低级别”的异常“包装”到了更抽象的 `ReadError` 中。它被广泛应用于面向对象的编程中。\n\n## 总结\n\n- 我们可以正常地从 `Error` 和其他内建的 error 类中进行继承，。我们只需要注意 `name` 属性以及不要忘了调用 `super`。\n- 我们可以使用 `instanceof` 来检查特定的 error。但有时我们有来自第三方库的 error 对象，并且在这儿没有简单的方法来获取它的类。那么可以将 `name` 属性用于这一类的检查。\n- 包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数。在上面的示例中，低级别异常有时会成为该对象的属性，例如 `err.cause`，但这不是严格要求的。",
        "libs": [],
        "children": [
          "format-error"
        ],
        "parent": "error-handling",
        "updatedAt": 1665942585
      }
    },
    "format-error": {
      "type": "Task",
      "value": {
        "title": "继承 SyntaxError",
        "slug": "format-error",
        "githubPath": "/1-js/10-error-handling/2-custom-errors/1-format-error",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个继承自内建类 `SyntaxError` 的类 `FormatError`。\n\n它应该支持 `message`，`name` 和 `stack` 属性。\n\n用例：\n\n```js\nlet err = new FormatError(\"formatting error\");\n\nalert( err.message ); // formatting error\nalert( err.name ); // FormatError\nalert( err.stack ); // stack\n\nalert( err instanceof FormatError ); // true\nalert( err instanceof SyntaxError ); // true（因为它继承自 SyntaxError）\n```",
        "solution": "```js run untrusted\nclass FormatError extends SyntaxError {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\nlet err = new FormatError(\"formatting error\");\n\nalert( err.message ); // formatting error\nalert( err.name ); // FormatError\nalert( err.stack ); // stack\n\nalert( err instanceof SyntaxError ); // true\n```",
        "parent": "custom-errors",
        "version": 1
      }
    },
    "async": {
      "type": "Article",
      "value": {
        "title": "Promise，async/await",
        "slug": "async",
        "githubPath": "/1-js/11-async",
        "isFolder": true,
        "weight": 11,
        "content": "",
        "libs": [],
        "children": [
          "callbacks",
          "promise-basics",
          "promise-chaining",
          "promise-error-handling",
          "promise-api",
          "promisify",
          "microtask-queue",
          "async-await"
        ],
        "parent": "js"
      }
    },
    "callbacks": {
      "type": "Article",
      "value": {
        "title": "简介：回调",
        "slug": "callbacks",
        "githubPath": "/1-js/11-async/01-callbacks",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n```warn header=\"我们在这里的示例中使用了浏览器方法\"\n为了演示回调、promise 和其他抽象概念的使用，我们将使用一些浏览器方法：具体地说，是加载脚本和执行简单的文档操作的方法。\n\n如果你不熟悉这些方法，并且对它们在这些示例中的用法感到疑惑，那么你可能需要阅读本教程 [下一部分](/document) 中的几章。\n\n但是，我们会尽全力使讲解变得更加清晰。在这儿不会有浏览器方面的真正复杂的东西。\n```\n\nJavaScript 主机（host）环境提供了许多函数，这些函数允许我们计划 **异步** 行为（action）。换句话说，我们现在开始执行的行为，但它们会在稍后完成。\n\n例如，`setTimeout` 函数就是一个这样的函数。\n\n这儿有一些实际中的异步行为的示例，例如加载脚本和模块（我们将在后面的章节中介绍）。\n\n让我们看一下函数 `loadScript(src)`，该函数使用给定的 `src` 加载脚本：\n\n```js\nfunction loadScript(src) {\n  // 创建一个 <script> 标签，并将其附加到页面\n  // 这将使得具有给定 src 的脚本开始加载，并在加载完成后运行\n  let script = document.createElement('script');\n  script.src = src;\n  document.head.append(script);\n}\n```\n\n它将一个新的、带有给定 `src` 的、动态创建的标签 `<script src=\"…\">` 插入到文档中。浏览器将自动开始加载它，并在加载完成后执行它。\n\n我们可以像这样使用这个函数：\n\n```js\n// 在给定路径下加载并执行脚本\nloadScript('/my/script.js');\n```\n\n脚本是“异步”调用的，因为它从现在开始加载，但是在这个加载函数执行完成后才运行。\n\n如果在 `loadScript(…)` 下面有任何其他代码，它们不会等到脚本加载完成才执行。\n\n```js\nloadScript('/my/script.js');\n// loadScript 下面的代码\n// 不会等到脚本加载完成才执行\n// ...\n```\n\n假设我们需要在新脚本加载后立即使用它。它声明了新函数，我们想运行它们。\n\n但如果我们在 `loadScript(…)` 调用后立即执行此操作，这将不会有效。\n\n```js\nloadScript('/my/script.js'); // 这个脚本有 \"function newFunction() {…}\"\n\n*!*\nnewFunction(); // 没有这个函数！\n*/!*\n```\n\n自然情况下，浏览器可能没有时间加载脚本。到目前为止，`loadScript` 函数并没有提供跟踪加载完成的方法。脚本加载并最终运行，仅此而已。但我们希望了解脚本何时加载完成，以使用其中的新函数和变量。\n\n让我们添加一个 `callback` 函数作为 `loadScript` 的第二个参数，该函数应在脚本加载完成时执行：\n\n```js\nfunction loadScript(src, *!*callback*/!*) {\n  let script = document.createElement('script');\n  script.src = src;\n\n*!*\n  script.onload = () => callback(script);\n*/!*\n\n  document.head.append(script);\n}\n```\n\n`onload` 事件在 <info:onload-onerror#loading-a-script> 一文中有描述，它通常会在脚本加载和执行完成后执行一个函数。\n\n现在，如果我们想调用该脚本中的新函数，我们应该将其写在回调函数中：\n\n```js\nloadScript('/my/script.js', function() {\n  // 在脚本加载完成后，回调函数才会执行\n  newFunction(); // 现在它工作了\n  ...\n});\n```\n\n这是我们的想法：第二个参数是一个函数（通常是匿名函数），该函数会在行为（action）完成时运行。\n\n这是一个带有真实脚本的可运行的示例：\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.onload = () => callback(script);\n  document.head.append(script);\n}\n\n*!*\nloadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n  alert(`酷，脚本 ${script.src} 加载完成`);\n  alert( _ ); // _ 是所加载的脚本中声明的一个函数\n});\n*/!*\n```\n\n这被称为“基于回调”的异步编程风格。异步执行某项功能的函数应该提供一个 `callback` 参数用于在相应事件完成时调用。（译注：上面这个例子中的相应事件是指脚本加载）\n\n这里我们在 `loadScript` 中就是这么做的，但当然这是一种通用方法。\n\n## 在回调中回调\n\n我们如何依次加载两个脚本：第一个，然后是第二个？\n\n自然的解决方案是将第二个 `loadScript` 调用放入回调中，如下所示：\n\n```js\nloadScript('/my/script.js', function(script) {\n\n  alert(`酷，脚本 ${script.src} 加载完成，让我们继续加载另一个吧`);\n\n*!*\n  loadScript('/my/script2.js', function(script) {\n    alert(`酷，第二个脚本加载完成`);\n  });\n*/!*\n\n});\n```\n\n在外部 `loadScript` 执行完成时，回调就会发起内部的 `loadScript`。\n\n如果我们还想要一个脚本呢？\n\n```js\nloadScript('/my/script.js', function(script) {\n\n  loadScript('/my/script2.js', function(script) {\n\n*!*\n    loadScript('/my/script3.js', function(script) {\n      // ...加载完所有脚本后继续\n    });\n*/!*\n\n  });\n\n});\n```\n\n因此，每一个新行为（action）都在回调内部。这对于几个行为来说还好，但对于许多行为来说就不好了，所以我们很快就会看到其他变体。 \n\n## 处理 Error\n\n在上述示例中，我们并没有考虑出现 error 的情况。如果脚本加载失败怎么办？我们的回调应该能够对此作出反应。\n\n这是 `loadScript` 的改进版本，可以跟踪加载错误：\n\n```js\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n*!*\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n*/!*\n\n  document.head.append(script);\n}\n```\n\n加载成功时，它会调用 `callback(null, script)`，否则调用 `callback(error)`。\n\n用法：\n```js\nloadScript('/my/script.js', function(error, script) {\n  if (error) {\n    // 处理 error\n  } else {\n    // 脚本加载成功\n  }\n});\n```\n\n再次强调，我们在 `loadScript` 中所使用的方案其实很普遍。它被称为“Error 优先回调（error-first callback）”风格。\n\n约定是：\n1. `callback` 的第一个参数是为 error 而保留的。一旦出现 error，`callback(err)` 就会被调用。\n2. 第二个参数（和下一个参数，如果需要的话）用于成功的结果。此时 `callback(null, result1, result2…)` 就会被调用。\n\n因此，单一的 `callback` 函数可以同时具有报告 error 和传递返回结果的作用。\n\n## 厄运金字塔\n\n乍一看，它像是一种可行的异步编程方式。的确如此，对于一个或两个嵌套的调用看起来还不错。\n\n但对于一个接一个的多个异步行为，代码将会变成这样：\n\n```js\nloadScript('1.js', function(error, script) {\n\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', function(error, script) {\n      if (error) {\n        handleError(error);\n      } else {\n        // ...\n        loadScript('3.js', function(error, script) {\n          if (error) {\n            handleError(error);\n          } else {\n  *!*\n            // ...加载完所有脚本后继续 (*)\n  */!*\n          }\n        });\n\n      }\n    });\n  }\n});\n```\n\n在上面这段代码中：\n1. 我们加载 `1.js`，如果没有发生错误。\n2. 我们加载 `2.js`，如果没有发生错误……\n3. 我们加载 `3.js`，如果没有发生错误 —— 做其他操作 `(*)`。\n\n随着调用嵌套的增加，代码层次变得更深，维护难度也随之增加，尤其是我们使用的是可能包含了很多循环和条件语句的真实代码，而不是例子中的 `...`。\n\n有时这些被称为“回调地狱”或“厄运金字塔”。\n\n<!--\nloadScript('1.js', function(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', function(error, script) {\n      if (error) {\n        handleError(error);\n      } else {\n        // ...\n        loadScript('3.js', function(error, script) {\n          if (error) {\n            handleError(error);\n          } else {\n            // ...\n          }\n        });\n      }\n    });\n  }\n});\n-->\n\n![](callback-hell.svg)\n\n嵌套调用的“金字塔”随着每个异步行为会向右增长。很快它就失控了。\n\n所以这种编码方式不是很好。\n\n我们可以通过使每个行为都成为一个独立的函数来尝试减轻这种问题，如下所示：\n\n```js\nloadScript('1.js', step1);\n\nfunction step1(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', step2);\n  }\n}\n\nfunction step2(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('3.js', step3);\n  }\n}\n\nfunction step3(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...加载完所有脚本后继续 (*)\n  }\n}\n```\n\n看到了吗？它的作用相同，但是没有深层的嵌套了，因为我们将每个行为都编写成了一个独立的顶层函数。\n\n它可以工作，但是代码看起来就像是一个被撕裂的表格。你可能已经注意到了，它的可读性很差，在阅读时你需要在各个代码块之间跳转。这很不方便，特别是如果读者对代码不熟悉，他们甚至不知道应该跳转到什么地方。\n\n此外，名为 `step*` 的函数都是一次性使用的，创建它们就是为了避免“厄运金字塔”。没有人会在行为链之外重用它们。因此，这里的命名空间有点混乱。\n\n我们希望还有更好的方法。\n\n幸运的是，有其他方法可以避免此类金字塔。最好的方法之一就是 \"promise\"，我们将在下一章中介绍它。",
        "libs": [],
        "children": [],
        "parent": "async",
        "updatedAt": 1658464510
      }
    },
    "promise-basics": {
      "type": "Article",
      "value": {
        "title": "Promise",
        "slug": "promise-basics",
        "githubPath": "/1-js/11-async/02-promise-basics",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n想象一下，你是一位顶尖歌手，粉丝没日没夜地询问你下首歌什么时候发。\n\n为了从中解放，你承诺（promise）会在单曲发布的第一时间发给他们。你给了粉丝们一个列表。他们可以在上面填写他们的电子邮件地址，以便当歌曲发布后，让所有订阅了的人能够立即收到。即便遇到不测，例如录音室发生了火灾，以致你无法发布新歌，他们也能及时收到相关通知。\n\n每个人都很开心：你不会被任何人催促，粉丝们也不用担心错过歌曲发行。\n\n这是我们在编程中经常遇到的事儿与真实生活的类比：\n\n1. “生产者代码（producing code）”会做一些事儿，并且会需要一些时间。例如，通过网络加载数据的代码。它就像一位“歌手”。\n2. “消费者代码（consuming code）”想要在“生产者代码”完成工作的第一时间就能获得其工作成果。许多函数可能都需要这个结果。这些就是“粉丝”。\n3. **Promise** 是将“生产者代码”和“消费者代码”连接在一起的一个特殊的 JavaScript 对象。用我们的类比来说：这就是就像是“订阅列表”。“生产者代码”花费它所需的任意长度时间来产出所承诺的结果，而 \"promise\" 将在它（译注：指的是“生产者代码”，也就是下文所说的 executor）准备好时，将结果向所有订阅了的代码开放。\n\n这种类比并不十分准确，因为 JavaScipt 的 promise 比简单的订阅列表更加复杂：它们还拥有其他的功能和局限性。但以此开始挺好的。\n\nPromise 对象的构造器（constructor）语法如下：\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // executor（生产者代码，“歌手”）\n});\n```\n\n传递给 `new Promise` 的函数被称为 **executor**。当 `new Promise` 被创建，executor 会自动运行。它包含最终应产出结果的生产者代码。按照上面的类比：executor 就是“歌手”。\n\n它的参数 `resolve` 和 `reject` 是由 JavaScript 自身提供的回调。我们的代码仅在 executor 的内部。\n\n当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：\n\n- `resolve(value)` —— 如果任务成功完成并带有结果 `value`。\n- `reject(error)` —— 如果出现了 error，`error` 即为 error 对象。\n\n所以总结一下就是：executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 `resolve`，如果出现 error 则调用 `reject`。\n\n由 `new Promise` 构造器返回的 `promise` 对象具有以下内部属性：\n\n- `state` —— 最初是 `\"pending\"`，然后在 `resolve` 被调用时变为 `\"fulfilled\"`，或者在 `reject` 被调用时变为 `\"rejected\"`。\n- `result` —— 最初是 `undefined`，然后在 `resolve(value)` 被调用时变为 `value`，或者在 `reject(error)` 被调用时变为 `error`。\n\n所以，executor 最终将 `promise` 移至以下状态之一：\n\n![](promise-resolve-reject.svg)\n\n稍后我们将看到“粉丝”如何订阅这些更改。\n\n下面是一个 promise 构造器和一个简单的 executor 函数，该 executor 函数具有包含时间（即 `setTimeout`）的“生产者代码”：\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  // 当 promise 被构造完成时，自动执行此函数\n\n  // 1 秒后发出工作已经被完成的信号，并带有结果 \"done\"\n  setTimeout(() => *!*resolve(\"done\")*/!*, 1000);\n});\n```\n\n通过运行上面的代码，我们可以看到两件事儿：\n\n1. executor 被自动且立即调用（通过 `new Promise`）。\n2. executor 接受两个参数：`resolve` 和 `reject`。这些函数由 JavaScript 引擎预先定义，因此我们不需要创建它们。我们只需要在准备好（译注：指的是 executor 准备好）时调用其中之一即可。\n\n    经过 1 秒的“处理”后，executor 调用 `resolve(\"done\")` 来产生结果。这将改变 `promise` 对象的状态：\n\n    ![](promise-resolve-1.svg)\n\n这是一个成功完成任务的例子，一个“成功实现了的诺言”。\n\n下面则是一个 executor 以 error 拒绝 promise 的示例：\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // 1 秒后发出工作已经被完成的信号，并带有 error\n  setTimeout(() => *!*reject(new Error(\"Whoops!\"))*/!*, 1000);\n});\n```\n\n对 `reject(...)` 的调用将 promise 对象的状态移至 `\"rejected\"`：\n\n![](promise-reject-1.svg)\n\n总而言之，executor 应该执行一项工作（通常是需要花费一些时间的事儿），然后调用 `resolve` 或 `reject` 来改变对应的 promise 对象的状态。\n\n与最初的 \"pending\" promise 相反，一个 resolved 或 rejected 的 promise 都会被称为 \"settled\"。\n\n````smart header=\"这只能有一个结果或一个 error\"\nexecutor 只能调用一个 `resolve` 或一个 `reject`。任何状态的更改都是最终的。\n\n所有其他的再对 `resolve` 和 `reject` 的调用都会被忽略：\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n*!*\n  resolve(\"done\");\n*/!*\n\n  reject(new Error(\"…\")); // 被忽略\n  setTimeout(() => resolve(\"…\")); // 被忽略\n});\n```\n\n这的宗旨是，一个被 executor 完成的工作只能有一个结果或一个 error。\n\n并且，`resolve/reject` 只需要一个参数（或不包含任何参数），并且将忽略额外的参数。\n````\n\n```smart header=\"以 `Error` 对象 reject\"\n如果什么东西出了问题，executor 应该调用 `reject`。这可以使用任何类型的参数来完成（就像 `resolve` 一样）。但建议使用 `Error` 对象（或继承自 `Error` 的对象）。这样做的理由很快就会显而易见。\n```\n\n````smart header=\"resolve/reject 可以立即进行\"\n实际上，executor 通常是异步执行某些操作，并在一段时间后调用 `resolve/reject`，但这不是必须的。我们还可以立即调用 `resolve` 或 `reject`，就像这样：\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  // 不花时间去做这项工作\n  resolve(123); // 立即给出结果：123\n});\n```\n\n例如，当我们开始做一个任务时，但随后看到一切都已经完成并已被缓存时，可能就会发生这种情况。\n\n这挺好。我们立即就有了一个 resolved 的 promise。\n````\n\n```smart header=\"`state` 和 `result` 都是内部的\"\nPromise 对象的 `state` 和 `result` 属性都是内部的。我们无法直接访问它们。但我们可以对它们使用 `.then`/`.catch`/`.finally` 方法。我们在下面对这些方法进行了描述。\n```\n\n## 消费者：then，catch\n\nPromise 对象充当的是 executor（“生产者代码”或“歌手”）和消费函数（“粉丝”）之间的连接，后者将接收结果或 error。可以通过使用 `.then` 和 `.catch` 方法注册消费函数。\n\n### then\n\n最重要最基础的一个就是 `.then`。\n\n语法如下：\n\n```js\npromise.then(\n  function(result) { *!*/* handle a successful result */*/!* },\n  function(error) { *!*/* handle an error */*/!* }\n);\n```\n\n`.then` 的第一个参数是一个函数，该函数将在 promise resolved 且接收到结果后执行。\n\n`.then` 的第二个参数也是一个函数，该函数将在 promise rejected 且接收到 error 信息后执行。\n\n例如，以下是对成功 resolved 的 promise 做出的反应：\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n// resolve 运行 .then 中的第一个函数\npromise.then(\n*!*\n  result => alert(result), // 1 秒后显示 \"done!\"\n*/!*\n  error => alert(error) // 不运行\n);\n```\n\n第一个函数被运行了。\n\n在 reject 的情况下，运行第二个：\n\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n// reject 运行 .then 中的第二个函数\npromise.then(\n  result => alert(result), // 不运行\n*!*\n  error => alert(error) // 1 秒后显示 \"Error: Whoops!\"\n*/!*\n);\n```\n\n如果我们只对成功完成的情况感兴趣，那么我们可以只为 `.then` 提供一个函数参数：\n\n```js run\nlet promise = new Promise(resolve => {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n*!*\npromise.then(alert); // 1 秒后显示 \"done!\"\n*/!*\n```\n\n### catch\n\n如果我们只对 error 感兴趣，那么我们可以使用 `null` 作为第一个参数：`.then(null, errorHandlingFunction)`。或者我们也可以使用 `.catch(errorHandlingFunction)`，其实是一样的：\n\n\n```js run\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n*!*\n// .catch(f) 与 promise.then(null, f) 一样\npromise.catch(alert); // 1 秒后显示 \"Error: Whoops!\"\n*/!*\n```\n\n`.catch(f)` 调用是 `.then(null, f)` 的完全的模拟，它只是一个简写形式。\n\n## 清理：finally\n\n就像常规 `try {...} catch {...}` 中的 `finally` 子句一样，promise 中也有 `finally`。\n\n调用 `.finally(f)` 类似于 `.then(f, f)`，因为当 promise settled 时 `f` 就会执行：无论 promise 被 resolve 还是 reject。\n\n`finally` 的功能是设置一个处理程序在前面的操作完成后，执行清理/终结。\n\n例如，停止加载指示器，关闭不再需要的连接等。\n\n把它想象成派对的终结者。无论派对是好是坏，有多少朋友参加，我们都需要（或者至少应该）在它之后进行清理。\n\n代码可能看起来像这样：\n\n```js\nnew Promise((resolve, reject) => {\n  /* 做一些需要时间的事，之后调用可能会 resolve 也可能会 reject */\n})\n*!*\n  // 在 promise 为 settled 时运行，无论成功与否\n  .finally(() => stop loading indicator)\n  // 所以，加载指示器（loading indicator）始终会在我们继续之前停止\n*/!*\n  .then(result => show result, err => show error)\n```\n\n请注意，`finally(f)` 并不完全是 `then(f,f)` 的别名。\n\n它们之间有重要的区别：\n\n1. `finally` 处理程序（handler）没有参数。在 `finally` 中，我们不知道 promise 是否成功。没关系，因为我们的任务通常是执行“常规”的完成程序（finalizing procedures）。\n\n    请看上面的例子：如你所见，`finally` 处理程序没有参数，promise 的结果由下一个处理程序处理。\n2. `finally` 处理程序将结果或 error “传递”给下一个合适的处理程序。\n\n    例如，在这结果被从 `finally` 传递给了 `then`：\n\n    ```js run\n    new Promise((resolve, reject) => {\n      setTimeout(() => resolve(\"value\"), 2000)\n    })\n      .finally(() => alert(\"Promise ready\")) // 先触发\n      .then(result => alert(result)); // <-- .then 显示 \"value\"\n    ```\n\n    正如我们所看到的，第一个 promise 返回的 `value` 通过 `finally` 被传递给了下一个 `then`。\n\n    这非常方便，因为 `finally` 并不意味着处理一个 promise 的结果。如前所述，无论结果是什么，它都是进行常规清理的地方。\n\n    下面是一个 promise 返回结果为 error 的示例，让我们看看它是如何通过 `finally` 被传递给 `catch` 的：\n\n    ```js run\n    new Promise((resolve, reject) => {\n      throw new Error(\"error\");\n    })\n      .finally(() => alert(\"Promise ready\")) // 先触发\n      .catch(err => alert(err));  // <-- .catch 显示这个 error\n    ```\n\n3. `finally` 处理程序也不应该返回任何内容。如果它返回了，返回的值会默认被忽略。\n\n    此规则的唯一例外是当 `finally` 处理程序抛出 error 时。此时这个 error（而不是任何之前的结果）会被转到下一个处理程序。\n\n总结：\n\n- `finally` 处理程序没有得到前一个处理程序的结果（它没有参数）。而这个结果被传递给了下一个合适的处理程序。\n- 如果 `finally` 处理程序返回了一些内容，那么这些内容会被忽略。\n- 当 `finally` 抛出 error 时，执行将转到最近的 error 的处理程序。\n\n如果我们正确使用 `finally`（将其用于常规清理），那么这些功能将很有用。\n\n````smart header=\"我们可以对 settled 的 promise 附加处理程序\"\n如果 promise 为 pending 状态，`.then/catch/finally` 处理程序（handler）将等待它的结果。\n\n有时候，当我们向一个 promise 添加处理程序时，它可能已经 settled 了。\n\n在这种情况下，这些处理程序会立即执行：\n\n```js run\n// 下面这 promise 在被创建后立即变为 resolved 状态\nlet promise = new Promise(resolve => resolve(\"done!\"));\n\npromise.then(alert); // done!（现在显示）\n```\n\n请注意这使得 promise 比现实生活中的“订阅列表”方案强大得多。如果歌手已经发布了他们的单曲，然后某个人在订阅列表上进行了注册，则他们很可能不会收到该单曲。实际生活中的订阅必须在活动开始之前进行。\n\nPromise 则更加灵活。我们可以随时添加处理程序（handler）：如果结果已经在了，它们就会执行。\n````\n\n## 示例：loadScript [#loadscript]\n\n接下来，让我们看一下关于 promise 如何帮助我们编写异步代码的更多实际示例。\n\n我们从上一章获得了用于加载脚本的 `loadScript` 函数。\n\n这是基于回调函数的变体，记住它：\n\n```js\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n```\n\n让我们用 promise 重写它。\n\n新函数 `loadScript` 将不需要回调。取而代之的是，它将创建并返回一个在加载完成时 resolve 的 promise 对象。外部代码可以使用 `.then` 向其添加处理程序（订阅函数）：\n\n```js run\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(`Script load error for ${src}`));\n\n    document.head.append(script);\n  });\n}\n```\n\n用法：\n\n```js run\nlet promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\npromise.then(\n  script => alert(`${script.src} is loaded!`),\n  error => alert(`Error: ${error.message}`)\n);\n\npromise.then(script => alert('Another handler...'));\n```\n\n我们立刻就能发现 promise 相较于基于回调的模式的一些好处：\n\n| promise | callback |\n|----------|-----------|\n| promise 允许我们按照自然顺序进行编码。首先，我们运行 `loadScript` 和 `.then` 来处理结果。| 在调用 `loadScript(script, callback)` 时，我们必须有一个 `callback` 函数可供使用。换句话说，在调用 `loadScript` **之前**，我们必须知道如何处理结果。|\n| 我们可以根据需要，在 promise 上多次调用 `.then`。每次调用，我们都会在“订阅列表”中添加一个新的“粉丝”，一个新的订阅函数。在下一章将对此内容进行详细介绍：[](info:promise-chaining)。 | 只能有一个回调。|\n\n\n因此，promise 为我们提供了更好的代码流和灵活性。但其实还有更多相关内容。我们将在下一章看到。",
        "libs": [],
        "children": [
          "re-resolve",
          "delay-promise",
          "animate-circle-promise"
        ],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n",
        "parent": "async",
        "updatedAt": 1658475397
      }
    },
    "re-resolve": {
      "type": "Task",
      "value": {
        "title": "用 promise 重新解决？",
        "slug": "re-resolve",
        "githubPath": "/1-js/11-async/02-promise-basics/01-re-resolve",
        "weight": 1,
        "libs": [],
        "content": "\n\n\n下列这段代码会输出什么？\n\n```js\nlet promise = new Promise(function(resolve, reject) {\n  resolve(1);\n\n  setTimeout(() => resolve(2), 1000);\n});\n\npromise.then(alert);\n```",
        "solution": "输出为：`1`。\n\n第二个对 `resolve` 的调用会被忽略，因为只有第一次对 `reject/resolve` 的调用才会被处理。进一步的调用都会被忽略。",
        "parent": "promise-basics",
        "version": 1
      }
    },
    "delay-promise": {
      "type": "Task",
      "value": {
        "title": "基于 promise 的延时",
        "slug": "delay-promise",
        "githubPath": "/1-js/11-async/02-promise-basics/02-delay-promise",
        "weight": 2,
        "libs": [],
        "content": "\n\n内建函数 `setTimeout` 使用了回调函数。请创建一个基于 promise 的替代方案。\n\n函数 `delay(ms)` 应该返回一个 promise。这个 promise 应该在 `ms` 毫秒后被 resolve，所以我们可以向其中添加 `.then`，像这样：\n\n```js\nfunction delay(ms) {\n  // 你的代码\n}\n\ndelay(3000).then(() => alert('runs after 3 seconds'));\n```",
        "solution": "```js run\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\ndelay(3000).then(() => alert('runs after 3 seconds'));\n```\n\n请注意，在此任务中 `resolve` 是不带参数调用的。我们不从 `delay` 中返回任何值，只是确保延迟即可。",
        "parent": "promise-basics",
        "version": 1
      }
    },
    "animate-circle-promise": {
      "type": "Task",
      "value": {
        "title": "带有 promise 的圆形动画",
        "slug": "animate-circle-promise",
        "githubPath": "/1-js/11-async/02-promise-basics/03-animate-circle-promise",
        "weight": 3,
        "libs": [],
        "content": "\n\n重写任务 <info:task/animate-circle-callback> 的解决方案中的 `showCircle` 函数，以使其返回一个 promise，而不接受回调。\n\n新的用法：\n\n```js\nshowCircle(150, 150, 100).then(div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n```\n\n以任务 <info:task/animate-circle-callback> 的解决方案为基础。",
        "solution": "",
        "parent": "promise-basics",
        "version": 1
      }
    },
    "promise-chaining": {
      "type": "Article",
      "value": {
        "title": "Promise 链",
        "slug": "promise-chaining",
        "githubPath": "/1-js/11-async/03-promise-chaining",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n我们回顾一下 <info:callbacks> 一章中提到的问题：我们有一系列的异步任务要一个接一个地执行 —— 例如，加载脚本。我们如何写出更好的代码呢？\n\nPromise 提供了一些方案来做到这一点。\n\n在本章中，我们将一起学习 promise 链。\n\n它看起来就像这样：\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000); // (*)\n\n}).then(function(result) { // (**)\n\n  alert(result); // 1\n  return result * 2;\n\n}).then(function(result) { // (***)\n\n  alert(result); // 2\n  return result * 2;\n\n}).then(function(result) {\n\n  alert(result); // 4\n  return result * 2;\n\n});\n```\n\n它的想法是通过 `.then` 处理程序（handler）链进行传递 result。\n\n运行流程如下：\n1. 初始 promise 在 1 秒后 resolve `(*)`，\n2. 然后 `.then` 处理程序被调用 `(**)`，它又创建了一个新的 promise（以 `2` 作为值 resolve）。\n3. 下一个 `then` `(***)` 得到了前一个 `then` 的值，对该值进行处理（*2）并将其传递给下一个处理程序。\n4. ……依此类推。\n\n随着 result 在处理程序链中传递，我们可以看到一系列的 `alert` 调用：`1` -> `2` -> `4`。\n\n![](promise-then-chain.svg)\n\n这样之所以是可行的，是因为每个对 `.then` 的调用都会返回了一个新的 promise，因此我们可以在其之上调用下一个 `.then`。\n\n当处理程序返回一个值时，它将成为该 promise 的 result，所以将使用它调用下一个 `.then`。\n\n**新手常犯的一个经典错误：从技术上讲，我们也可以将多个 `.then` 添加到一个 promise 上。但这并不是 promise 链（chaining）。**\n\n例如：\n```js run\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n```\n\n我们在这里所做的只是一个 promise 的几个处理程序。它们不会相互传递 result；相反，它们之间彼此独立运行处理任务。\n\n这是它的一张示意图（你可以将其与上面的链式调用做一下比较）：\n\n![](promise-then-many.svg)\n\n在同一个 promise 上的所有 `.then` 获得的结果都相同 —— 该 promise 的结果。所以，在上面的代码中，所有 `alert` 都显示相同的内容：`1`。\n\n实际上我们极少遇到一个 promise 需要多个处理程序的情况。使用链式调用的频率更高。\n\n## 返回 promise\n\n`.then(handler)` 中所使用的处理程序（handler）可以创建并返回一个 promise。\n\n在这种情况下，其他的处理程序将等待它 settled 后再获得其结果。\n\n例如：\n\n```js run\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000);\n\n}).then(function(result) {\n\n  alert(result); // 1\n\n*!*\n  return new Promise((resolve, reject) => { // (*)\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n*/!*\n\n}).then(function(result) { // (**)\n\n  alert(result); // 2\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n\n}).then(function(result) {\n\n  alert(result); // 4\n\n});\n```\n\n这里第一个 `.then` 显示 `1` 并在 `(*)` 行返回 `new Promise(…)`。1 秒后它会进行 resolve，然后 result（`resolve` 的参数，在这里它是 `result*2`）被传递给第二个 `.then` 的处理程序。这个处理程序位于 `(**)` 行，它显示 `2`，并执行相同的行为。\n\n所以输出与前面的示例相同：1 -> 2 -> 4，但是现在在每次 `alert` 调用之间会有 1 秒钟的延迟。\n\n返回 promise 使我们能够构建异步行为链。\n\n## 示例：loadScript\n\n让我们将本章所讲的这个特性与在 [上一章](info:promise-basics#loadscript) 中定义的 promise 化的 `loadScript` 结合使用，按顺序依次加载脚本：\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/two.js\");\n  })\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/three.js\");\n  })\n  .then(function(script) {\n    // 使用在脚本中声明的函数\n    // 以证明脚本确实被加载完成了\n    one();\n    two();\n    three();\n  });\n```\n\n我们可以用箭头函数来重写代码，让其变得简短一些：\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n  .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n  .then(script => {\n    // 脚本加载完成，我们可以在这儿使用脚本中声明的函数\n    one();\n    two();\n    three();\n  });\n```\n\n\n在这儿，每个 `loadScript` 调用都返回一个 promise，并且在它 resolve 时下一个 `.then` 开始运行。然后，它启动下一个脚本的加载。所以，脚本是一个接一个地加载的。\n\n我们可以向链中添加更多的异步行为。请注意，代码仍然是“扁平”的 —— 它向下增长，而不是向右。这里没有“厄运金字塔”的迹象。\n\n从技术上讲，我们可以向每个 `loadScript` 直接添加 `.then`，就像这样：\n\n```js run\nloadScript(\"/article/promise-chaining/one.js\").then(script1 => {\n  loadScript(\"/article/promise-chaining/two.js\").then(script2 => {\n    loadScript(\"/article/promise-chaining/three.js\").then(script3 => {\n      // 此函数可以访问变量 script1，script2 和 script3\n      one();\n      two();\n      three();\n    });\n  });\n});\n```\n\n这段代码做了相同的事儿：按顺序加载 3 个脚本。但它是“向右增长”的。所以会有和使用回调函数一样的问题。\n\n刚开始使用 promise 的人可能不知道 promise 链，所以他们就这样写了。通常，链式是首选。\n\n有时候直接写 `.then` 也是可以的，因为嵌套的函数可以访问外部作用域。在上面的例子中，嵌套在最深层的那个回调（callback）可以访问所有变量 `script1`，`script2` 和 `script3`。但这是一个例外，而不是一条规则。\n\n\n````smart header=\"Thenables\"\n确切地说，处理程序返回的不完全是一个 promise，而是返回的被称为 \"thenable\" 对象 —— 一个具有方法 `.then` 的任意对象。它会被当做一个 promise 来对待。\n\n这个想法是，第三方库可以实现自己的“promise 兼容（promise-compatible）”对象。它们可以具有扩展的方法集，但也与原生的 promise 兼容，因为它们实现了 `.then` 方法。\n\n这是一个 thenable 对象的示例：\n\n```js run\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve); // function() { native code }\n    // 1 秒后使用 this.num*2 进行 resolve\n    setTimeout(() => resolve(this.num * 2), 1000); // (**)\n  }\n}\n\nnew Promise(resolve => resolve(1))\n  .then(result => {\n*!*\n    return new Thenable(result); // (*)\n*/!*\n  })\n  .then(alert); // 1000ms 后显示 2\n```\n\nJavaScript 检查在 `(*)` 行中由 `.then` 处理程序返回的对象：如果它具有名为 `then` 的可调用方法，那么它将调用该方法并提供原生的函数 `resolve` 和 `reject` 作为参数（类似于 executor），并等待直到其中一个函数被调用。在上面的示例中，`resolve(2)` 在 1 秒后被调用 `(**)`。然后，result 会被进一步沿着链向下传递。\n\n这个特性允许我们将自定义的对象与 promise 链集成在一起，而不必继承自 `Promise`。\n````\n\n\n## 更复杂的示例：fetch\n\n在前端编程中，promise 通常被用于网络请求。那么，让我们一起来看一个相关的扩展示例吧。\n\n我们将使用 [fetch](info:fetch) 方法从远程服务器加载用户信息。它有很多可选的参数，我们在 [单独的一章](info:fetch) 中对其进行了详细介绍，但基本语法很简单：\n\n```js\nlet promise = fetch(url);\n```\n\n执行这条语句，向 `url` 发出网络请求并返回一个 promise。当远程服务器返回 header（是在 **全部响应加载完成前**）时，该 promise 使用一个 `response` 对象来进行 resolve。\n\n为了读取完整的响应，我们应该调用 `response.text()` 方法：当全部文字内容从远程服务器下载完成后，它会返回一个 promise，该 promise 以刚刚下载完成的这个文本作为 result 进行 resolve。\n\n下面这段代码向 `user.json` 发送请求，并从服务器加载该文本：\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  // 当远程服务器响应时，下面的 .then 开始执行\n  .then(function(response) {\n    // 当 user.json 加载完成时，response.text() 会返回一个新的 promise\n    // 该 promise 以加载的 user.json 为 result 进行 resolve\n    return response.text();\n  })\n  .then(function(text) {\n    // ……这是远程文件的内容\n    alert(text); // {\"name\": \"iliakan\", \"isAdmin\": true}\n  });\n```\n\n从 `fetch` 返回的 `response` 对象还包含 `response.json()` 方法，该方法可以读取远程数据并将其解析为 JSON。在我们的例子中，这更加方便，所以我们用这个方法吧。\n\n为了简洁，我们还将使用箭头函数：\n\n```js run\n// 同上，但使用 response.json() 将远程内容解析为 JSON\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => alert(user.name)); // iliakan，获取到了用户名\n```\n\n现在，让我们用加载好的用户信息搞点事情。\n\n例如，我们可以再向 GitHub 发送一个请求，加载用户个人资料并显示头像：\n\n```js run\n// 发送一个对 user.json 的请求\nfetch('/article/promise-chaining/user.json')\n  // 将其加载为 JSON\n  .then(response => response.json())\n  // 发送一个到 GitHub 的请求\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  // 将响应加载为 JSON\n  .then(response => response.json())\n  // 显示头像图片（githubUser.avatar_url）3 秒（也可以加上动画效果）\n  .then(githubUser => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => img.remove(), 3000); // (*)\n  });\n```\n\n这段代码可以工作，具体细节请看注释。但是，这有一个潜在的问题，一个新手使用 promise 时的典型问题。\n\n请看 `(*)` 行：我们如何能在头像显示结束并被移除 **之后** 做点什么？例如，我们想显示一个用于编辑该用户或者其他内容的表单。就目前而言，是做不到的。\n\n为了使链可扩展，我们需要返回一个在头像显示结束时进行 resolve 的 promise。\n\n就像这样：\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n*!*\n  .then(githubUser => new Promise(function(resolve, reject) { // (*)\n*/!*\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n*!*\n      resolve(githubUser); // (**)\n*/!*\n    }, 3000);\n  }))\n  // 3 秒后触发\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n```\n\n也就是说，第 `(*)` 行的 `.then` 处理程序现在返回一个 `new Promise`，只有在 `setTimeout` 中的 `resolve(githubUser)` `(**)` 被调用后才会变为 settled。链中的下一个 `.then` 将一直等待这一时刻的到来。\n\n作为一个好的做法，异步行为应该始终返回一个 promise。这样就可以使得之后我们计划后续的行为成为可能。即使我们现在不打算对链进行扩展，但我们之后可能会需要。\n\n最后，我们可以将代码拆分为可重用的函数：\n\n```js run\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => response.json());\n}\n\nfunction loadGithubUser(name) {\n  return loadJson(`https://api.github.com/users/${name}`);\n}\n\nfunction showAvatar(githubUser) {\n  return new Promise(function(resolve, reject) {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  });\n}\n\n// 使用它们：\nloadJson('/article/promise-chaining/user.json')\n  .then(user => loadGithubUser(user.name))\n  .then(showAvatar)\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n  // ...\n```\n\n## 总结\n\n如果 `.then`（或 `catch/finally` 都可以）处理程序返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。当它被 settled 后，其 result（或 error）将被进一步传递下去。\n\n这是一个完整的流程图：\n\n![](promise-handler-variants.svg)",
        "libs": [],
        "children": [
          "then-vs-catch"
        ],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n\n<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1661942361
      }
    },
    "then-vs-catch": {
      "type": "Task",
      "value": {
        "title": "Promise：then 对比 catch",
        "slug": "then-vs-catch",
        "githubPath": "/1-js/11-async/03-promise-chaining/01-then-vs-catch",
        "weight": 1,
        "libs": [],
        "content": "\n\n这两个代码片段是否相等？换句话说，对于任何处理程序（handler），它们在任何情况下的行为都相同吗？\n\n```js\npromise.then(f1).catch(f2);\n```\n\n对比：\n\n```js\npromise.then(f1, f2);\n```",
        "solution": "简要回答就是：**不，它们不相等**：\n\n不同之处在于，如果 `f1` 中出现 error，那么在这儿它会被 `.catch` 处理：\n\n```js run\npromise\n  .then(f1)\n  .catch(f2);\n```\n\n……在这儿则不会：\n\n```js run\npromise\n  .then(f1, f2);\n```\n\n这是因为 error 是沿着链传递的，而在第二段代码中，`f1` 下面没有链。\n\n换句话说，`.then` 将 result/error 传递给下一个 `.then/.catch`。所以在第一个例子中，在下面有一个 `catch`，而在第二个例子中并没有 `catch`，所以 error 未被处理。",
        "parent": "promise-chaining",
        "version": 1
      }
    },
    "promise-error-handling": {
      "type": "Article",
      "value": {
        "title": "使用 promise 进行错误处理",
        "slug": "promise-error-handling",
        "githubPath": "/1-js/11-async/04-promise-error-handling",
        "isFolder": false,
        "weight": 4,
        "content": "\n\npromise 链在错误（error）处理中十分强大。当一个 promise 被 reject 时，控制权将移交至最近的 rejection 处理程序。这在实际开发中非常方便。\n\n例如，下面代码中所 `fetch` 的 URL 是错的（没有这个网站），`.catch` 对这个 error 进行了处理：\n\n```js run\n*!*\nfetch('https://no-such-server.blabla') // reject\n*/!*\n  .then(response => response.json())\n  .catch(err => alert(err)) // TypeError: Failed to fetch（这里的文字可能有所不同）\n```\n\n正如你所看到的，`.catch` 不必是立即的。它可能在一个或多个 `.then` 之后出现。\n\n或者，可能该网站一切正常，但响应不是有效的 JSON。捕获所有 error 的最简单的方法是，将 `.catch` 附加到链的末尾：\n\n```js run\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubUser => new Promise((resolve, reject) => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  }))\n*!*\n  .catch(error => alert(error.message));\n*/!*\n```\n\n通常情况下，这样的 `.catch` 根本不会被触发。但是如果上述任意一个 promise rejected（网络问题或者无效的 json 或其他），`.catch` 就会捕获它。\n\n## 隐式 try..catch\n\npromise 的执行者（executor）和 promise 的处理程序周围有一个“隐式的 `try..catch`”。如果发生异常，它就会被捕获，并被视为 rejection 进行处理。\n\n例如，下面这段代码：\n\n```js run\nnew Promise((resolve, reject) => {\n*!*\n  throw new Error(\"Whoops!\");\n*/!*\n}).catch(alert); // Error: Whoops!\n```\n\n……与下面这段代码工作上完全相同：\n\n```js run\nnew Promise((resolve, reject) => {\n*!*\n  reject(new Error(\"Whoops!\"));\n*/!*\n}).catch(alert); // Error: Whoops!\n```\n\n在 executor 周围的“隐式 `try..catch`”自动捕获了 error，并将其变为 rejected promise。\n\n这不仅仅发生在 executor 函数中，同样也发生在其处理程序中。如果我们在 `.then` 处理程序中 `throw`，这意味着 promise rejected，因此控制权移交至最近的 error 处理程序。\n\n这是一个例子：\n\n```js run\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n*!*\n  throw new Error(\"Whoops!\"); // reject 这个 promise\n*/!*\n}).catch(alert); // Error: Whoops!\n```\n\n对于所有的 error 都会发生这种情况，而不仅仅是由 `throw` 语句导致的这些 error。例如，一个编程错误：\n\n```js run\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n*!*\n  blabla(); // 没有这个函数\n*/!*\n}).catch(alert); // ReferenceError: blabla is not defined\n```\n\n最后的 `.catch` 不仅会捕获显式的 rejection，还会捕获它上面的处理程序中意外出现的 error。\n\n## 再次抛出（Rethrowing）\n\n正如我们已经注意到的，链尾端的 `.catch` 的表现有点像 `try..catch`。我们可能有许多个 `.then` 处理程序，然后在尾端使用一个 `.catch` 处理上面的所有 error。\n\n在常规的 `try..catch` 中，我们可以分析 error，如果我们无法处理它，可以将其再次抛出。对于 promise 来说，这也是可以的。\n\n如果我们在 `.catch` 中 `throw`，那么控制权就会被移交到下一个最近的 error 处理程序。如果我们处理该 error 并正常完成，那么它将继续到最近的成功的 `.then` 处理程序。\n\n在下面这个例子中，`.catch` 成功处理了 error：\n\n```js run\n// 执行流：catch -> then\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) {\n\n  alert(\"The error is handled, continue normally\");\n\n}).then(() => alert(\"Next successful handler runs\"));\n```\n\n这里 `.catch` 块正常完成。所以下一个成功的 `.then` 处理程序就会被调用。\n\n在下面的例子中，我们可以看到 `.catch` 的另一种情况。`(*)` 行的处理程序捕获了 error，但无法处理它（例如，它只知道如何处理 `URIError`），所以它将其再次抛出：\n\n```js run\n// 执行流：catch -> catch\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) { // (*)\n\n  if (error instanceof URIError) {\n    // 处理它\n  } else {\n    alert(\"Can't handle such error\");\n\n*!*\n    throw error; // 再次抛出此 error 或另外一个 error，执行将跳转至下一个 catch\n*/!*\n  }\n\n}).then(function() {\n  /* 不在这里运行 */\n}).catch(error => { // (**)\n\n  alert(`The unknown error has occurred: ${error}`);\n  // 不会返回任何内容 => 执行正常进行\n\n});\n```\n\n执行从第一个 `.catch` `(*)` 沿着链跳转至下一个 `(**)`。\n\n## 未处理的 rejection\n\n当一个 error 没有被处理会发生什么？例如，我们忘了在链的尾端附加 `.catch`，像这样：\n\n```js untrusted run refresh\nnew Promise(function() {\n  noSuchFunction(); // 这里出现 error（没有这个函数）\n})\n  .then(() => {\n    // 一个或多个成功的 promise 处理程序\n  }); // 尾端没有 .catch！\n```\n\n如果出现 error，promise 的状态将变为 \"rejected\"，然后执行应该跳转至最近的 rejection 处理程序。但上面这个例子中并没有这样的处理程序。因此 error 会“卡住”。没有代码来处理它。\n\n在实际开发中，就像代码中常规的未处理的 error 一样，这意味着某些东西出了问题。\n\n当发生一个常规的 error 并且未被 `try..catch` 捕获时会发生什么？脚本死了，并在控制台中留下了一个信息。对于在 promise 中未被处理的 rejection，也会发生类似的事。\n\nJavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error。如果你运行上面这个代码，你可以在控制台中看到。\n\n在浏览器中，我们可以使用 `unhandledrejection` 事件来捕获这类 error：\n\n```js run\n*!*\nwindow.addEventListener('unhandledrejection', function(event) {\n  // 这个事件对象有两个特殊的属性：\n  alert(event.promise); // [object Promise] —— 生成该全局 error 的 promise\n  alert(event.reason); // Error: Whoops! —— 未处理的 error 对象\n});\n*/!*\n\nnew Promise(function() {\n  throw new Error(\"Whoops!\");\n}); // 没有用来处理 error 的 catch\n```\n\n这个事件是 [HTML 标准](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections) 的一部分。\n\n如果出现了一个 error，并且在这没有 `.catch`，那么 `unhandledrejection` 处理程序就会被触发，并获取具有 error 相关信息的 `event` 对象，所以我们就能做一些后续处理了。\n\n通常此类 error 是无法恢复的，所以我们最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。\n\n在 Node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。\n\n## 总结\n\n- `.catch` 处理 promise 中的各种 error：在 `reject()` 调用中的，或者在处理程序中抛出的 error。\n- 如果给定 `.then` 的第二个参数（即 error 处理程序），那么 `.then` 也会以相同的方式捕获 error。\n- 我们应该将 `.catch` 准确地放到我们想要处理 error，并知道如何处理这些 error 的地方。处理程序应该分析 error（可以自定义 error 类来帮助分析）并再次抛出未知的 error（它们可能是编程错误）。\n- 如果没有办法从 error 中恢复，不使用 `.catch` 也可以。\n- 在任何情况下我们都应该有 `unhandledrejection` 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。",
        "libs": [],
        "children": [
          "error-async"
        ],
        "headHtml": "<script>\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    })\n}\n</script>\n\n<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1658480857
      }
    },
    "error-async": {
      "type": "Task",
      "value": {
        "title": "setTimeout 中的错误",
        "slug": "error-async",
        "githubPath": "/1-js/11-async/04-promise-error-handling/01-error-async",
        "weight": 1,
        "libs": [],
        "content": "\n\n你怎么看？`.catch` 会被触发么？解释你的答案。\n\n```js\nnew Promise(function(resolve, reject) {\n  setTimeout(() => {\n    throw new Error(\"Whoops!\");\n  }, 1000);\n}).catch(alert);\n```",
        "solution": "答案是：**不，它不会被触发**：\n\n```js run\nnew Promise(function(resolve, reject) {\n  setTimeout(() => {\n    throw new Error(\"Whoops!\");\n  }, 1000);\n}).catch(alert);\n```\n\n正如本章所讲，函数代码周围有个“隐式的 `try..catch`”。所以，所有同步错误都会得到处理。\n\n但是这里的错误并不是在 executor 运行时生成的，而是在稍后生成的。因此，promise 无法处理它。",
        "parent": "promise-error-handling",
        "version": 1
      }
    },
    "promise-api": {
      "type": "Article",
      "value": {
        "title": "Promise API",
        "slug": "promise-api",
        "githubPath": "/1-js/11-async/05-promise-api",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n在 `Promise` 类中，有 6 种静态方法。我们在这里简单介绍下它们的使用场景。\n\n## Promise.all\n\n假设我们希望并行执行多个 promise，并等待所有 promise 都准备就绪。\n\n例如，并行下载几个 URL，并等到所有内容都下载完毕后再对它们进行处理。\n\n这就是 `Promise.all` 的用途。\n\n语法：\n\n```js\nlet promise = Promise.all(iterable);\n```\n\n`Promise.all` 接受一个可迭代对象（通常是一个数组项为 promise 的数组），并返回一个新的 promise。\n\n当所有给定的 promise 都 resolve 时，新的 promise 才会 resolve，并且其结果数组将成为新 promise 的结果。\n\n例如，下面的 `Promise.all` 在 3 秒之后 settled，然后它的结果就是一个 `[1, 2, 3]` 数组：\n\n```js run\nPromise.all([\n  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1\n  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3\n]).then(alert); // 1,2,3 当上面这些 promise 准备好时：每个 promise 都贡献了数组中的一个元素\n```\n\n请注意，结果数组中元素的顺序与其在源 promise 中的顺序相同。即使第一个 promise 花费了最长的时间才 resolve，但它仍是结果数组中的第一个。\n\n一个常见的技巧是，将一个任务数据数组映射（map）到一个 promise 数组，然后将其包装到 `Promise.all`。\n\n例如，如果我们有一个存储 URL 的数组，我们可以像这样 fetch 它们：\n\n```js run\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://api.github.com/users/jeresig'\n];\n\n// 将每个 url 映射（map）到 fetch 的 promise 中\nlet requests = urls.map(url => fetch(url));\n\n// Promise.all 等待所有任务都 resolved\nPromise.all(requests)\n  .then(responses => responses.forEach(\n    response => alert(`${response.url}: ${response.status}`)\n  ));\n```\n\n一个更真实的示例，通过 GitHub 用户名来获取一个 GitHub 用户数组中用户的信息（我们也可以通过商品 id 来获取商品数组中的商品信息，逻辑都是一样的）：\n\n```js run\nlet names = ['iliakan', 'remy', 'jeresig'];\n\nlet requests = names.map(name => fetch(`https://api.github.com/users/${name}`));\n\nPromise.all(requests)\n  .then(responses => {\n    // 所有响应都被成功 resolved\n    for(let response of responses) {\n      alert(`${response.url}: ${response.status}`); // 对应每个 url 都显示 200\n    }\n\n    return responses;\n  })\n  // 将响应数组映射（map）到 response.json() 数组中以读取它们的内容\n  .then(responses => Promise.all(responses.map(r => r.json())))\n  // 所有 JSON 结果都被解析：\"users\" 是它们的数组\n  .then(users => users.forEach(user => alert(user.name)));\n```\n\n**如果任意一个 promise 被 reject，由 `Promise.all` 返回的 promise 就会立即 reject，并且带有的就是这个 error。**\n\n例如：\n\n```js run\nPromise.all([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n*!*\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n*/!*\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).catch(alert); // Error: Whoops!\n```\n\n这里的第二个 promise 在两秒后 reject。这立即导致了 `Promise.all` 的 reject，因此 `.catch` 执行了：被 reject 的 error 成为了整个 `Promise.all` 的结果。\n\n```warn header=\"如果出现 error，其他 promise 将被忽略\"\n如果其中一个 promise 被 reject，`Promise.all` 就会立即被 reject，完全忽略列表中其他的 promise。它们的结果也被忽略。\n\n例如，像上面那个例子，如果有多个同时进行的 `fetch` 调用，其中一个失败，其他的 `fetch` 操作仍然会继续执行，但是 `Promise.all` 将不会再关心（watch）它们。它们可能会 settle，但是它们的结果将被忽略。\n\n`Promise.all` 没有采取任何措施来取消它们，因为 promise 中没有“取消”的概念。在 [另一个章节](info:fetch-abort) 中，我们将介绍可以帮助我们解决这个问题（译注：指的是“取消” promise）的 `AbortController`，但它不是 Promise API 的一部分。\n```\n\n````smart header=\"`Promise.all(iterable)` 允许在 `iterable` 中使用非 promise 的“常规”值\"\n通常，`Promise.all(...)` 接受含有 promise 项的可迭代对象（大多数情况下是数组）作为参数。但是，如果这些对象中的任何一个不是 promise，那么它将被“按原样”传递给结果数组。\n\n例如，这里的结果是 `[1, 2, 3]`：\n\n```js run\nPromise.all([\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(1), 1000)\n  }),\n  2,\n  3\n]).then(alert); // 1, 2, 3\n```\n\n所以我们可以在方便的地方将准备好的值传递给 `Promise.all`。\n````\n\n## Promise.allSettled\n\n[recent browser=\"new\"]\n\n如果任意的 promise reject，则 `Promise.all` 整个将会 reject。当我们需要 **所有** 结果都成功时，它对这种“全有或全无”的情况很有用：\n\n```js\nPromise.all([\n  fetch('/template.html'),\n  fetch('/style.css'),\n  fetch('/data.json')\n]).then(render); // render 方法需要所有 fetch 的数据\n```\n\n`Promise.allSettled` 等待所有的 promise 都被 settle，无论结果如何。结果数组具有：\n\n- `{status:\"fulfilled\", value:result}` 对于成功的响应，\n- `{status:\"rejected\", reason:error}` 对于 error。\n\n例如，我们想要获取（fetch）多个用户的信息。即使其中一个请求失败，我们仍然对其他的感兴趣。\n\n让我们使用 `Promise.allSettled`：\n\n```js run\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://no-such-url'\n];\n\nPromise.allSettled(urls.map(url => fetch(url)))\n  .then(results => { // (*)\n    results.forEach((result, num) => {\n      if (result.status == \"fulfilled\") {\n        alert(`${urls[num]}: ${result.value.status}`);\n      }\n      if (result.status == \"rejected\") {\n        alert(`${urls[num]}: ${result.reason}`);\n      }\n    });\n  });\n```\n\n上面的 `(*)` 行中的 `results` 将会是：\n```js\n[\n  {status: 'fulfilled', value: ...response...},\n  {status: 'fulfilled', value: ...response...},\n  {status: 'rejected', reason: ...error object...}\n]\n```\n\n所以，对于每个 promise，我们都得到了其状态（status）和 `value/reason`。\n\n### Polyfill\n\n如果浏览器不支持 `Promise.allSettled`，很容易进行 polyfill：\n\n```js\nif (!Promise.allSettled) {\n  const rejectHandler = reason => ({ status: 'rejected', reason });\n\n  const resolveHandler = value => ({ status: 'fulfilled', value });\n\n  Promise.allSettled = function (promises) {\n    const convertedPromises = promises.map(p => Promise.resolve(p).then(resolveHandler, rejectHandler));\n    return Promise.all(convertedPromises);\n  };\n}\n```\n\n在这段代码中，`promises.map` 获取输入值，并通过 `p => Promise.resolve(p)` 将输入值转换为 promise（以防传递了非 promise 值），然后向每一个 promise 都添加 `.then` 处理程序。\n\n这个处理程序将成功的结果 `value` 转换为 `{status:'fulfilled', value}`，将 error `reason` 转换为 `{status:'rejected', reason}`。这正是 `Promise.allSettled` 的格式。\n\n然后我们就可以使用 `Promise.allSettled` 来获取 **所有** 给定的 promise 的结果，即使其中一些被 reject。\n\n## Promise.race\n\n与 `Promise.all` 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。\n\n语法：\n\n```js\nlet promise = Promise.race(iterable);\n```\n\n例如，这里的结果将是 `1`：\n\n```js run\nPromise.race([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).then(alert); // 1\n```\n\n这里第一个 promise 最快，所以它变成了结果。第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。\n\n\n## Promise.any\n\n与 `Promise.race` 类似，区别在于 `Promise.any` 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回。如果给出的 promise 都 rejected，那么返回的 promise 会带有 [`AggregateError`](mdn:js/AggregateError) —— 一个特殊的 error 对象，在其 `errors` 属性中存储着所有 promise error。\n\n语法如下：\n\n```js\nlet promise = Promise.any(iterable);\n```\n\n例如，这里的结果将是 `1`：\n\n```js run\nPromise.any([\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).then(alert); // 1\n```\n\n这里的第一个 promise 是最快的，但 rejected 了，所以第二个 promise 则成为了结果。在第一个 fulfilled 的 promise “赢得比赛”后，所有进一步的结果都将被忽略。\n\n这是一个所有 promise 都失败的例子：\n\n```js run\nPromise.any([\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Ouch!\")), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Error!\")), 2000))\n]).catch(error => {\n  console.log(error.constructor.name); // AggregateError\n  console.log(error.errors[0]); // Error: Ouch!\n  console.log(error.errors[1]); // Error: Error!\n});\n```\n\n正如你所看到的，我们在 `AggregateError` 错误类型的 error 实例的 `errors` 属性中可以访问到失败的 promise 的 error 对象。\n\n## Promise.resolve/reject\n\n在现代的代码中，很少需要使用 `Promise.resolve` 和 `Promise.reject` 方法，因为 `async/await` 语法（我们会在 [稍后](info:async-await) 讲到）使它们变得有些过时了。\n\n完整起见，以及考虑到那些出于某些原因而无法使用 `async/await` 的人，我们在这里对它们进行介绍。\n\n### Promise.resolve\n\n`Promise.resolve(value)` 用结果 `value` 创建一个 resolved 的 promise。\n\n如同：\n\n```js\nlet promise = new Promise(resolve => resolve(value));\n```\n\n当一个函数被期望返回一个 promise 时，这个方法用于兼容性。（译注：这里的兼容性是指，我们直接从缓存中获取了当前操作的结果 `value`，但是期望返回的是一个 promise，所以可以使用 `Promise.resolve(value)` 将 `value` “封装”进 promise，以满足期望返回一个 promise 的这个需求。）\n\n例如，下面的 `loadCached` 函数获取（fetch）一个 URL 并记住其内容。以便将来对使用相同 URL 的调用，它能立即从缓存中获取先前的内容，但使用 `Promise.resolve` 创建了一个该内容的 promise，所以返回的值始终是一个 promise。\n\n```js\nlet cache = new Map();\n\nfunction loadCached(url) {\n  if (cache.has(url)) {\n*!*\n    return Promise.resolve(cache.get(url)); // (*)\n*/!*\n  }\n\n  return fetch(url)\n    .then(response => response.text())\n    .then(text => {\n      cache.set(url,text);\n      return text;\n    });\n}\n```\n\n我们可以使用 `loadCached(url).then(…)`，因为该函数保证了会返回一个 promise。我们就可以放心地在 `loadCached` 后面使用 `.then`。这就是 `(*)` 行中 `Promise.resolve` 的目的。\n\n### Promise.reject\n\n`Promise.reject(error)` 用 `error` 创建一个 rejected 的 promise。\n\n如同：\n\n```js\nlet promise = new Promise((resolve, reject) => reject(error));\n```\n\n实际上，这个方法几乎从未被使用过。\n\n## 总结\n\n`Promise` 类有 6 种静态方法：\n\n1. `Promise.all(promises)` —— 等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 `Promise.all` 的 error，所有其他 promise 的结果都会被忽略。\n2. `Promise.allSettled(promises)`（ES2020 新增方法）—— 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：\n    - `status`: `\"fulfilled\"` 或 `\"rejected\"`\n    - `value`（如果 fulfilled）或 `reason`（如果 rejected）。\n3. `Promise.race(promises)` —— 等待第一个 settle 的 promise，并将其 result/error 作为结果返回。\n4. `Promise.any(promises)`（ES2021 新增方法）—— 等待第一个 fulfilled 的 promise，并将其结果作为结果返回。如果所有 promise 都 rejected，`Promise.any` 则会抛出 [`AggregateError`](mdn:js/AggregateError) 错误类型的 error 实例。\n5. `Promise.resolve(value)` —— 使用给定 value 创建一个 resolved 的 promise。\n6. `Promise.reject(error)` —— 使用给定 error 创建一个 rejected 的 promise。\n\n以上所有方法，`Promise.all` 可能是在实战中使用最多的。",
        "libs": [],
        "children": [],
        "headHtml": "<script>\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(\"Script load error: \" + src));\n\n    document.head.append(script);\n  });\n}\n</script>\n",
        "parent": "async",
        "updatedAt": 1658504643
      }
    },
    "promisify": {
      "type": "Article",
      "value": {
        "title": "Promisification",
        "slug": "promisify",
        "githubPath": "/1-js/11-async/06-promisify",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n对于一个简单的转换来说 “Promisification” 是一个长单词。它指将一个接受回调的函数转换为一个返回 promise 的函数。\n\n由于许多函数和库都是基于回调的，因此，在实际开发中经常会需要进行这种转换。因为使用 promise 更加方便，所以将基于回调的函数和库 promise 化是有意义的。\n\n为了更好地理解，让我们来看一个例子。\n\n例如，在 <info:callbacks> 一章中我们有 `loadScript(src, callback)`。\n\n```js run\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n\n// 用法：\n// loadScript('path/script.js', (err, script) => {...})\n```\n\n该函数通过给定的 `src` 加载脚本，然后在出现错误时调用 `callback(err)`，或者在加载成功时调用 `callback(null, script)`。这是大家对于使用回调函数的共识，我们之前也学习过。\n\n现在，让我们将其 promise 化吧。\n\n我们将创建一个新的函数 `loadScriptPromise(src)`，与上面的函数作用相同（加载脚本），只是我们创建的这个函数会返回一个 promise 而不是使用回调。\n\n换句话说，我们仅向它传入 `src`（没有 `callback`）并通过该函数的 return 获得一个 promise，当脚本加载成功时，该 promise 将以 `script` 为结果 resolve，否则将以出现的 error 为结果 reject。\n\n代码实现如下：\n```js\nlet loadScriptPromise = function(src) {\n  return new Promise((resolve, reject) => {\n    loadScript(src, (err, script) => {\n      if (err) reject(err);\n      else resolve(script);\n    });\n  });\n};\n\n// 用法：\n// loadScriptPromise('path/script.js').then(...)\n```\n\n正如我们所看到的，新的函数是对原始的 `loadScript` 函数的包装。新函数调用它，并提供了自己的回调来将其转换成 promise `resolve/reject`。\n\n现在 `loadScriptPromise` 非常适用于基于 promise 的代码了。如果我们相比于回调函数，更喜欢 promise（稍后我们将看到更多喜欢 promise 的原因），那么我们将改用它。\n\n在实际开发中，我们可能需要 promise 化很多函数，所以使用一个 helper（辅助函数）很有意义。\n\n我们将其称为 `promisify(f)`：它接受一个需要被 promise 化的函数 `f`，并返回一个包装（wrapper）函数。\n\n```js\nfunction promisify(f) {\n  return function (...args) { // 返回一个包装函数（wrapper-function） (*)\n    return new Promise((resolve, reject) => {\n      function callback(err, result) { // 我们对 f 的自定义的回调 (**)\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      }\n\n      args.push(callback); // 将我们的自定义的回调附加到 f 参数（arguments）的末尾\n\n      f.call(this, ...args); // 调用原始的函数\n    });\n  };\n}\n\n// 用法：\nlet loadScriptPromise = promisify(loadScript);\nloadScriptPromise(...).then(...);\n```\n\n代码看起来可能有些复杂，但其本质与我们在上面写的那个是一样的，就是将 `loadScript` 函数 promise 化。\n\n调用 `promisify(f)` 会返回一个 `f` `(*)` 的包装器。该包装器返回一个 promise，并将调用转发给原始的 `f`，并在我们自定义的回调 `(**)` 中跟踪结果。\n\n在这里，`promisify` 假设原始函数期望一个带有两个参数 `(err, result)` 的回调。这就是我们最常遇到的形式。那么我们自定义的回调的格式是完全正确的，在这种情况下 `promisify` 也可以完美地运行。\n\n但是如果原始的 `f` 期望一个带有更多参数的回调 `callback(err, res1, res2, ...)`，该怎么办呢？\n\n我们可以继续改进我们的辅助函数。让我们写一个更高阶版本的 `promisify`。\n\n- 当它被以 `promisify(f)` 的形式调用时，它应该以与上面那个版本的实现的工作方式类似。\n- 当它被以 `promisify(f, true)` 的形式调用时，它应该返回以回调函数数组为结果 resolve 的 promise。这就是具有很多个参数的回调的结果。\n\n```js\n// promisify(f, true) 来获取结果数组\nfunction promisify(f, manyArgs = false) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      function *!*callback(err, ...results*/!*) { // 我们自定义的 f 的回调\n        if (err) {\n          reject(err);\n        } else {\n          // 如果 manyArgs 被指定，则使用所有回调的结果 resolve\n          *!*resolve(manyArgs ? results : results[0]);*/!*\n        }\n      }\n\n      args.push(callback);\n\n      f.call(this, ...args);\n    });\n  };\n}\n\n// 用法：\nf = promisify(f, true);\nf(...).then(arrayOfResults => ..., err => ...);\n```\n\n正如你所看到的，它与上面那个实现基本相同，只是根据 `manyArgs` 是否为真来决定仅使用一个还是所有参数调用 `resolve`。\n\n对于一些更奇特的回调格式，例如根本没有 `err` 的格式：`callback(result)`，我们可以手动 promise 化这样的函数，而不使用 helper。\n\n也有一些具有更灵活一点的 promisification 函数的模块（module），例如 [es6-promisify](https://github.com/digitaldesignlabs/es6-promisify)。在 Node.js 中，有一个内建的 promise 化函数 `util.promisify`。\n\n```smart\nPromisification 是一种很好的方法，特别是在你使用 `async/await` 的时候（请看下一章），但不是回调的完全替代。\n\n请记住，一个 promise 可能只有一个结果，但从技术上讲，一个回调可能被调用很多次。\n\n因此，promisification 仅适用于调用一次回调的函数。进一步的调用将被忽略。\n```",
        "libs": [],
        "children": [],
        "parent": "async",
        "updatedAt": 1658505863
      }
    },
    "microtask-queue": {
      "type": "Article",
      "value": {
        "title": "微任务（Microtask）",
        "slug": "microtask-queue",
        "githubPath": "/1-js/11-async/07-microtask-queue",
        "isFolder": false,
        "weight": 7,
        "content": "\n\npromise 的处理程序 `.then`、`.catch` 和 `.finally` 都是异步的。\n\n即便一个 promise 立即被 resolve，`.then`、`.catch` 和 `.finally` **下面** 的代码也会在这些处理程序之前被执行。\n\n示例代码如下：\n\n```js run\nlet promise = Promise.resolve();\n\npromise.then(() => alert(\"promise done!\"));\n\nalert(\"code finished\"); // 这个 alert 先显示\n```\n\n如果你运行它，你会首先看到 `code finished`，然后才是 `promise done`。\n\n这很奇怪，因为这个 promise 肯定是一开始就完成的。\n\n为什么 `.then` 会在之后才被触发？这是怎么回事？\n\n## 微任务队列（Microtask queue）\n\n异步任务需要适当的管理。为此，ECMA 标准规定了一个内部队列 `PromiseJobs`，通常被称为“微任务队列（microtask queue）”（V8 术语）。\n\n如 [规范](https://tc39.github.io/ecma262/#sec-jobs-and-job-queues) 中所述：\n\n- 队列（queue）是先进先出的：首先进入队列的任务会首先运行。\n- 只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务。\n\n或者，简单地说，当一个 promise 准备就绪时，它的 `.then/catch/finally` 处理程序就会被放入队列中：但是它们不会立即被执行。当 JavaScript 引擎执行完当前的代码，它会从队列中获取任务并执行它。\n\n这就是为什么在上面那个示例中 \"code finished\" 会先显示。\n\n![](promiseQueue.svg)\n\npromise 的处理程序总是会经过这个内部队列。\n\n如果有一个包含多个 `.then/catch/finally` 的链，那么它们中的每一个都是异步执行的。也就是说，它会首先进入队列，然后在当前代码执行完成并且先前排队的处理程序都完成时才会被执行。\n\n**如果执行顺序对我们很重要该怎么办？我们怎么才能让 `code finished` 在 `promise done` 之后出现呢？**\n\n很简单，只需要像下面这样使用 `.then` 将其放入队列：\n\n```js run\nPromise.resolve()\n  .then(() => alert(\"promise done!\"))\n  .then(() => alert(\"code finished\"));\n```\n\n现在代码就是按照预期执行的。\n\n## 未处理的 rejection\n\n还记得 <info:promise-error-handling> 一章中的 `unhandledrejection` 事件吗？\n\n现在，我们可以确切地看到 JavaScript 是如何发现未处理的 rejection 的。\n\n**如果一个 promise 的 error 未被在微任务队列的末尾进行处理，则会出现“未处理的 rejection”。**\n\n正常来说，如果我们预期可能会发生错误，我们会在 promise 链上添加 `.catch` 来处理 error：\n\n```js run\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\n*!*\npromise.catch(err => alert('caught'));\n*/!*\n\n// 不会运行：error 已经被处理\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\n但是如果我们忘记添加 `.catch`，那么，微任务队列清空后，JavaScript 引擎会触发下面这事件：\n\n```js run\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\n\n// Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\n如果我们迟一点再处理这个 error 会怎样？例如：\n\n```js run\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\n*!*\nsetTimeout(() => promise.catch(err => alert('caught')), 1000);\n*/!*\n\n// Error: Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n```\n\n现在，如果我们运行上面这段代码，我们会先看到 `Promise Failed!`，然后才是 `caught`。\n\n如果我们并不了解微任务队列，我们可能会想：“为什么 `unhandledrejection` 处理程序会运行？我们已经捕获（catch）并处理了 error！”\n\n但是现在我们知道了，当微任务队列中的任务都完成时，才会生成 `unhandledrejection`：引擎会检查 promise，如果 promise 中的任意一个出现 \"rejected\" 状态，`unhandledrejection` 事件就会被触发。\n\n在上面这个例子中，被添加到 `setTimeout` 中的 `.catch` 也会被触发。只是会在 `unhandledrejection` 事件出现之后才会被触发，所以它并没有改变什么（没有发挥作用）。\n\n## 总结\n\nPromise 处理始终是异步的，因为所有 promise 行为都会通过内部的 \"promise jobs\" 队列，也被称为“微任务队列”（V8 术语）。\n\n因此，`.then/catch/finally` 处理程序总是在当前代码完成后才会被调用。\n\n如果我们需要确保一段代码在 `.then/catch/finally` 之后被执行，我们可以将它添加到链式调用的 `.then` 中。\n\n在大多数 JavaScript 引擎中（包括浏览器和 Node.js），微任务（microtask）的概念与“事件循环（event loop）”和“宏任务（macrotasks）”紧密相关。由于这些概念跟 promise 没有直接关系，所以我们将在本教程另外一部分的 <info:event-loop> 一章中对它们进行介绍。",
        "libs": [],
        "children": [],
        "parent": "async",
        "updatedAt": 1658506486
      }
    },
    "async-await": {
      "type": "Article",
      "value": {
        "title": "async/await",
        "slug": "async-await",
        "githubPath": "/1-js/11-async/08-async-await",
        "isFolder": false,
        "weight": 8,
        "content": "\n\nasync/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。\n\n## async function\n\n让我们以 `async` 这个关键字开始。它可以被放置在一个函数前面，如下所示：\n\n```js\nasync function f() {\n  return 1;\n}\n```\n\n在函数前面的 \"async\" 这个单词表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。\n\n例如，下面这个函数返回一个结果为 `1` 的 resolved promise，让我们测试一下：\n\n```js run\nasync function f() {\n  return 1;\n}\n\nf().then(alert); // 1\n```\n\n……我们也可以显式地返回一个 promise，结果是一样的：\n\n```js run\nasync function f() {\n  return Promise.resolve(1);\n}\n\nf().then(alert); // 1\n```\n\n所以说，`async` 确保了函数返回一个 promise，也会将非 promise 的值包装进去。很简单，对吧？但不仅仅这些。还有另外一个叫 `await` 的关键词，它只在 `async` 函数内工作，也非常酷。\n\n## await\n\n语法如下：\n\n```js\n// 只在 async 函数内工作\nlet value = await promise;\n```\n\n关键字 `await` 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。\n\n这里的例子就是一个 1 秒后 resolve 的 promise：\n```js run\nasync function f() {\n\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"done!\"), 1000)\n  });\n\n*!*\n  let result = await promise; // 等待，直到 promise resolve (*)\n*/!*\n\n  alert(result); // \"done!\"\n}\n\nf();\n```\n\n这个函数在执行的时候，“暂停”在了 `(*)` 那一行，并在 promise settle 时，拿到 `result` 作为结果继续往下执行。所以上面这段代码在一秒后显示 \"done!\"。\n\n让我们强调一下：`await` 实际上会暂停函数的执行，直到 promise 状态变为 settled，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。\n\n相比于 `promise.then`，它只是获取 promise 的结果的一个更优雅的语法。并且也更易于读写。\n\n````warn header=\"不能在普通函数中使用 `await`\"\n如果我们尝试在非 async 函数中使用 `await`，则会报语法错误：\n\n```js run\nfunction f() {\n  let promise = Promise.resolve(1);\n*!*\n  let result = await promise; // Syntax error\n*/!*\n}\n```\n\n如果我们忘记在函数前面写 `async` 关键字，我们可能会得到一个这个错误。就像前面说的，`await` 只在 `async` 函数中有效。\n````\n\n让我们拿 <info:promise-chaining> 那一章的 `showAvatar()` 例子，并将其改写成 `async/await` 的形式：\n\n1. 我们需要用 `await` 替换掉 `.then` 的调用。\n2. 另外，我们需要在函数前面加上 `async` 关键字，以使它们能工作。\n\n```js run\nasync function showAvatar() {\n\n  // 读取我们的 JSON\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n\n  // 读取 github 用户信息\n  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);\n  let githubUser = await githubResponse.json();\n\n  // 显示头像\n  let img = document.createElement('img');\n  img.src = githubUser.avatar_url;\n  img.className = \"promise-avatar-example\";\n  document.body.append(img);\n\n  // 等待 3 秒\n  await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n\n  img.remove();\n\n  return githubUser;\n}\n\nshowAvatar();\n```\n\n简洁明了，是吧？比之前可强多了。\n\n````smart header=\"现代浏览器在 modules 里允许顶层的 `await`\"\n在现代浏览器中，当我们处于一个 module 中时，那么在顶层使用 `await` 也是被允许的。我们将在 <info:modules-intro> 中详细学习 modules。\n\n例如：\n\n```js run module\n// 我们假设此代码在 module 中的顶层运行\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();\n\nconsole.log(user);\n```\n\n如果我们没有使用 modules，或者必须兼容 [旧版本浏览器](https://caniuse.com/mdn-javascript_operators_await_top_level) ，那么这儿还有一个通用的方法：包装到匿名的异步函数中。\n\n像这样：\n\n```js\n(async () => {\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n  ...\n})();\n```\n````\n\n````smart header=\"`await` 接受 \\\"thenables\\\"\"\n像 `promise.then` 那样，`await` 允许我们使用 thenable 对象（那些具有可调用的 `then` 方法的对象）。这里的想法是，第三方对象可能不是一个 promise，但却是 promise 兼容的：如果这些对象支持 `.then`，那么就可以对它们使用 `await`。\n\n这有一个用于演示的 `Thenable` 类，下面的 `await` 接受了该类的实例：\n\n```js run\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve);\n    // 1000ms 后使用 this.num*2 进行 resolve\n    setTimeout(() => resolve(this.num * 2), 1000); // (*)\n  }\n}\n\nasync function f() {\n  // 等待 1 秒，之后 result 变为 2\n  let result = await new Thenable(1);\n  alert(result);\n}\n\nf();\n```\n\n如果 `await` 接收了一个非 promise 的但是提供了 `.then` 方法的对象，它就会调用这个 `.then` 方法，并将内建的函数 `resolve` 和 `reject` 作为参数传入（就像它对待一个常规的 `Promise` executor 时一样）。然后 `await` 等待直到这两个函数中的某个被调用（在上面这个例子中发生在 `(*)` 行），然后使用得到的结果继续执行后续任务。\n````\n\n````smart header=\"Class 中的 async 方法\"\n要声明一个 class 中的 async 方法，只需在对应方法前面加上 `async` 即可：\n\n```js run\nclass Waiter {\n*!*\n  async wait() {\n*/!*\n    return await Promise.resolve(1);\n  }\n}\n\nnew Waiter()\n  .wait()\n  .then(alert); // 1（alert 等同于 result => alert(result)）\n```\n这里的含义是一样的：它确保了方法的返回值是一个 promise 并且可以在方法中使用 `await`。\n\n````\n## Error 处理\n\n如果一个 promise 正常 resolve，`await promise` 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 `throw` 语句那样。\n\n这个代码：\n\n```js\nasync function f() {\n*!*\n  await Promise.reject(new Error(\"Whoops!\"));\n*/!*\n}\n```\n\n……和下面是一样的：\n\n```js\nasync function f() {\n*!*\n  throw new Error(\"Whoops!\");\n*/!*\n}\n```\n\n在真实开发中，promise 可能需要一点时间后才 reject。在这种情况下，在 `await` 抛出（throw）一个 error 之前会有一个延时。\n\n我们可以用 `try..catch` 来捕获上面提到的那个 error，与常规的 `throw` 使用的是一样的方式：\n\n```js run\nasync function f() {\n\n  try {\n    let response = await fetch('http://no-such-url');\n  } catch(err) {\n*!*\n    alert(err); // TypeError: failed to fetch\n*/!*\n  }\n}\n\nf();\n```\n\n如果有 error 发生，执行控制权马上就会被移交至 `catch` 块。我们也可以用 `try` 包装多行 `await` 代码：\n\n```js run\nasync function f() {\n\n  try {\n    let response = await fetch('/no-user-here');\n    let user = await response.json();\n  } catch(err) {\n    // 捕获到 fetch 和 response.json 中的错误\n    alert(err);\n  }\n}\n\nf();\n```\n\n如果我们没有 `try..catch`，那么由异步函数 `f()` 的调用生成的 promise 将变为 rejected。我们可以在函数调用后面添加 `.catch` 来处理这个 error：\n\n```js run\nasync function f() {\n  let response = await fetch('http://no-such-url');\n}\n\n// f() 变成了一个 rejected 的 promise\n*!*\nf().catch(alert); // TypeError: failed to fetch // (*)\n*/!*\n```\n\n如果我们忘了在这添加 `.catch`，那么我们就会得到一个未处理的 promise error（可以在控制台中查看）。我们可以使用在 <info:promise-error-handling> 一章中所讲的全局事件处理程序 `unhandledrejection` 来捕获这类 error。\n\n\n```smart header=\"`async/await` 和 `promise.then/catch`\"\n当我们使用 `async/await` 时，几乎就不会用到 `.then` 了，因为 `await` 为我们处理了等待。并且我们使用常规的 `try..catch` 而不是 `.catch`。这通常（但不总是）更加方便。\n\n但是当我们在代码的顶层时，也就是在所有 `async` 函数之外，我们在语法上就不能使用 `await` 了，所以这时候通常的做法是添加 `.then/catch` 来处理最终的结果（result）或掉出来的（falling-through）error，例如像上面那个例子中的 `(*)` 行那样。\n```\n\n````smart header=\"`async/await` 可以和 `Promise.all` 一起使用\"\n当我们需要同时等待多个 promise 时，我们可以用 `Promise.all` 把它们包装起来，然后使用 `await`：\n\n```js\n// 等待结果数组\nlet results = await Promise.all([\n  fetch(url1),\n  fetch(url2),\n  ...\n]);\n```\n\n如果出现 error，也会正常传递，从失败了的 promise 传到 `Promise.all`，然后变成我们能通过使用 `try..catch` 在调用周围捕获到的异常（exception）。\n\n````\n\n## 总结\n\n函数前面的关键字 `async` 有两个作用：\n\n1. 让这个函数总是返回一个 promise。\n2. 允许在该函数内使用 `await`。\n\nPromise 前的关键字 `await` 使 JavaScript 引擎等待该 promise settle，然后：\n\n1. 如果有 error，就会抛出异常 —— 就像那里调用了 `throw error` 一样。\n2. 否则，就返回结果。\n\n这两个关键字一起提供了一个很好的用来编写异步代码的框架，这种代码易于阅读也易于编写。\n\n有了 `async/await` 之后，我们就几乎不需要使用 `promise.then/catch`，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法。并且，当我们需要同时等待需要任务时，`Promise.all` 是很好用的。",
        "libs": [],
        "children": [
          "rewrite-async",
          "rewrite-async-2",
          "async-from-regular"
        ],
        "headHtml": "<style>\n.promise-avatar-example {\n  border-radius: 50%;\n  position: fixed;\n  left: 10px;\n  top: 10px;\n}\n</style>\n",
        "parent": "async",
        "updatedAt": 1658579377
      }
    },
    "rewrite-async": {
      "type": "Task",
      "value": {
        "title": "用 async/await 来重写",
        "slug": "rewrite-async",
        "githubPath": "/1-js/11-async/08-async-await/01-rewrite-async",
        "weight": 1,
        "libs": [],
        "content": "\n\n重写下面这个来自 <info:promise-chaining> 一章的示例代码，使用 `async/await` 而不是 `.then/catch`：\n\n```js run\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new Error(response.status);\n      }\n    });\n}\n\nloadJson('https://javascript.info/no-such-user.json')\n  .catch(alert); // Error: 404\n```",
        "solution": "解析在代码下面：\n\n```js run\nasync function loadJson(url) { // (1)\n  let response = await fetch(url); // (2)\n\n  if (response.status == 200) {\n    let json = await response.json(); // (3)\n    return json;\n  }\n\n  throw new Error(response.status);\n}\n\nloadJson('https://javascript.info/no-such-user.json')\n  .catch(alert); // Error: 404 (4)\n```\n\n解析：\n\n1. 将函数 `loadJson` 变为 `async`。\n2. 将函数中所有的 `.then` 都替换为 `await`。\n3. 我们可以返回 `return response.json()` 而不用等待它，像这样:\n\n    ```js\n    if (response.status == 200) {\n      return response.json(); // (3)\n    }\n    ```\n\n    然后外部的代码就必须 `await` 这个 promise resolve。在本例中它无关紧要。\n4. `loadJson` 抛出的 error 被 `.catch` 处理了。在这儿我们我们不能使用 `await loadJson(…)`，因为我们不是在一个 `async` 函数中。",
        "parent": "async-await",
        "version": 1
      }
    },
    "rewrite-async-2": {
      "type": "Task",
      "value": {
        "title": "使用 async/await 重写 \"rethrow\"",
        "slug": "rewrite-async-2",
        "githubPath": "/1-js/11-async/08-async-await/02-rewrite-async-2",
        "weight": 2,
        "libs": [],
        "content": "\n\n下面你可以看到 \"rethrow\" 的例子。让我们来用 `async/await` 重写它，而不是使用 `.then/catch`。\n\n同时，我们可以在 `demoGithubUser` 中使用循环以摆脱递归：在 `async/await` 的帮助下很容易实现。\n\n```js run\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    });\n}\n\n// 询问用户名，直到 github 返回一个合法的用户\nfunction demoGithubUser() {\n  let name = prompt(\"Enter a name?\", \"iliakan\");\n\n  return loadJson(`https://api.github.com/users/${name}`)\n    .then(user => {\n      alert(`Full name: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n      if (err instanceof HttpError && err.response.status == 404) {\n        alert(\"No such user, please reenter.\");\n        return demoGithubUser();\n      } else {\n        throw err;\n      }\n    });\n}\n\ndemoGithubUser();\n```",
        "solution": "这里没有什么技巧。只需要将 `demoGithubUser` 中的 `.catch` 替换为 `try...catch`，然后在需要的地方加上 `async/await` 即可：\n\n```js run\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nasync function loadJson(url) {\n  let response = await fetch(url);\n  if (response.status == 200) {\n    return response.json();\n  } else {\n    throw new HttpError(response);\n  }\n}\n\n// 询问用户名，直到 github 返回一个合法的用户\nasync function demoGithubUser() {\n\n  let user;\n  while(true) {\n    let name = prompt(\"Enter a name?\", \"iliakan\");\n\n    try {\n      user = await loadJson(`https://api.github.com/users/${name}`);\n      break; // 没有 error，退出循环\n    } catch(err) {\n      if (err instanceof HttpError && err.response.status == 404) {\n        // 循环将在 alert 后继续\n        alert(\"No such user, please reenter.\");\n      } else {\n        // 未知的 error，再次抛出（rethrow）\n        throw err;\n      }\n    }      \n  }\n\n\n  alert(`Full name: ${user.name}.`);\n  return user;\n}\n\ndemoGithubUser();\n```",
        "parent": "async-await",
        "version": 1
      }
    },
    "async-from-regular": {
      "type": "Task",
      "value": {
        "title": "在非 async 函数中调用 async 函数",
        "slug": "async-from-regular",
        "githubPath": "/1-js/11-async/08-async-await/03-async-from-regular",
        "weight": 3,
        "libs": [],
        "content": "\n\n我们有一个名为 `f` 的“普通”函数。你会怎样调用 `async` 函数 `wait()` 并在 `f` 中使用其结果？\n\n```js\nasync function wait() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  return 10;\n}\n\nfunction f() {\n  // ……这里你应该怎么写？\n  // 我们需要调用 async wait() 并等待以拿到结果 10\n  // 记住，我们不能使用 \"await\"\n}\n```\n\nP.S. 这个任务其实很简单，但是对于 async/await 新手开发者来说，这个问题却很常见。",
        "solution": "在这种情况下，知道其内部工作原理会很有帮助。\n\n只需要把 `async` 调用当作 promise 对待，并在它的后面加上 `.then` 即可：\n```js run\nasync function wait() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  return 10;\n}\n\nfunction f() {\n  // 1 秒后显示 10\n*!*\n  wait().then(result => alert(result));\n*/!*\n}\n\nf();\n```",
        "parent": "async-await",
        "version": 1
      }
    },
    "generators-iterators": {
      "type": "Article",
      "value": {
        "title": "Generator，高级 iteration",
        "slug": "generators-iterators",
        "githubPath": "/1-js/12-generators-iterators",
        "isFolder": true,
        "weight": 12,
        "content": "",
        "libs": [],
        "children": [
          "generators",
          "async-iterators-generators"
        ],
        "parent": "js"
      }
    },
    "generators": {
      "type": "Article",
      "value": {
        "title": "generator",
        "slug": "generators",
        "githubPath": "/1-js/12-generators-iterators/1-generators",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n常规函数只会返回一个单一值（或者不返回任何值）。\n\n而 generator 可以按需一个接一个地返回（\"yield\"）多个值。它们可与 [iterable](info:iterable) 完美配合使用，从而可以轻松地创建数据流。\n\n## generator 函数\n\n要创建一个 generator，我们需要一个特殊的语法结构：`function*`，即所谓的 \"generator function\"。\n\n它看起来像这样：\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n```\n\ngenerator 函数与常规函数的行为不同。在此类函数被调用时，它不会运行其代码。而是返回一个被称为 \"generator object\" 的特殊对象，来管理执行流程。\n\n我们来看一个例子：\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\n// \"generator function\" 创建了一个 \"generator object\"\nlet generator = generateSequence();\n*!*\nalert(generator); // [object Generator]\n*/!*\n```\n\n到目前为止，上面这段代码中的 **函数体** 代码还没有开始执行：\n\n![](generateSequence-1.svg)\n\n一个 generator 的主要方法就是 `next()`。当被调用时（译注：指 `next()` 方法），它会恢复上图所示的运行，执行直到最近的 `yield <value>` 语句（`value` 可以被省略，默认为 `undefined`）。然后函数执行暂停，并将产出的（yielded）值返回到外部代码。\n\n`next()` 的结果始终是一个具有两个属性的对象：\n- `value`: 产出的（yielded）的值。\n- `done`: 如果 generator 函数已执行完成则为 `true`，否则为 `false`。\n\n例如，我们可以创建一个 generator 并获取其第一个产出的（yielded）值：\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\n*!*\nlet one = generator.next();\n*/!*\n\nalert(JSON.stringify(one)); // {value: 1, done: false}\n```\n\n截至目前，我们只获得了第一个值，现在函数执行处在第二行：\n\n![](generateSequence-2.svg)\n\n让我们再次调用 `generator.next()`。代码恢复执行并返回下一个 `yield` 的值：\n\n```js\nlet two = generator.next();\n\nalert(JSON.stringify(two)); // {value: 2, done: false}\n```\n\n![](generateSequence-3.svg)\n\n如果我们第三次调用 `generator.next()`，代码将会执行到 `return` 语句，此时就完成这个函数的执行：\n\n```js\nlet three = generator.next();\n\nalert(JSON.stringify(three)); // {value: 3, *!*done: true*/!*}\n```\n\n![](generateSequence-4.svg)\n\n现在 generator 执行完成。我们通过 `done:true` 可以看出来这一点，并且将 `value:3` 处理为最终结果。\n\n再对 `generator.next()` 进行新的调用不再有任何意义。如果我们这样做，它将返回相同的对象：`{done: true}`。\n\n```smart header=\"`function* f(…)` 或 `function *f(…)`？\"\n这两种语法都是对的。\n\n但是通常更倾向于第一种语法，因为星号 `*` 表示它是一个 generator 函数，它描述的是函数种类而不是名称，因此 `*` 应该和 `function` 关键字紧贴一起。\n```\n\n## generator 是可迭代的\n\n当你看到 `next()` 方法，或许你已经猜到了 generator 是 [可迭代（iterable）](info:iterable)的。\n\n我们可以使用 `for..of` 循环遍历它所有的值：\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1，然后是 2\n}\n```\n\n`for..of` 写法是不是看起来比 `.next().value` 优雅多了？\n\n……但是请注意：上面这个例子会先显示 `1`，然后是 `2`，然后就没了。它不会显示 `3`！\n\n这是因为当 `done: true` 时，`for..of` 循环会忽略最后一个 `value`。因此，如果我们想要通过 `for..of` 循环显示所有的结果，我们必须使用 `yield` 返回它们：\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n*!*\n  yield 3;\n*/!*\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1，然后是 2，然后是 3\n}\n```\n\n因为 generator 是可迭代的，我们可以使用 iterator 的所有相关功能，例如：spread 语法 `...`：\n\n```js run\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nlet sequence = [0, ...generateSequence()];\n\nalert(sequence); // 0, 1, 2, 3\n```\n\n在上面这段代码中，`...generateSequence()` 将可迭代的 generator 对象转换为了一个数组（关于 spread 语法的更多细节请见 [](info:rest-parameters-spread#spread-syntax)）。\n\n## 使用 generator 进行迭代\n\n在前面的 [](info:iterable) 一章中，我们创建了一个可迭代的 `range` 对象，它返回 `from..to` 的值。\n\n现在，我们回忆一下代码：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for..of range 在一开始就调用一次这个方法\n  [Symbol.iterator]() {\n    // ...它返回 iterator object：\n    // 后续的操作中，for..of 将只针对这个对象，并使用 next() 向它请求下一个值\n    return {\n      current: this.from,\n      last: this.to,\n\n      // for..of 循环在每次迭代时都会调用 next()\n      next() {\n        // 它应该以对象 {done:.., value :...} 的形式返回值\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n// 迭代整个 range 对象，返回从 `range.from` 到 `range.to` 范围的所有数字\nalert([...range]); // 1,2,3,4,5\n```\n\n我们可以通过提供一个 generator 函数作为 `Symbol.iterator`，来使用 generator 进行迭代：\n\n下面是一个相同的 `range`，但紧凑得多：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // [Symbol.iterator]: function*() 的简写形式\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nalert( [...range] ); // 1,2,3,4,5\n```\n\n之所以代码正常工作，是因为 `range[Symbol.iterator]()` 现在返回一个 generator，而 generator 方法正是 `for..of` 所期望的：\n- 它具有 `.next()` 方法\n- 它以 `{value: ..., done: true/false}` 的形式返回值\n\n当然，这不是巧合。generator 被添加到 JavaScript 语言中是有对 iterator 的考量的，以便更容易地实现 iterator。\n\n带有 generator 的变体比原来的 `range` 迭代代码简洁得多，并且保持了相同的功能。\n\n```smart header=\"generator 可以永远产出（yield）值\"\n在上面的示例中，我们生成了有限序列，但是我们也可以创建一个生成无限序列的 generator，它可以一直产出（yield）值。例如，无序的伪随机数序列。\n\n这种情况下肯定需要在 generator 的 `for..of` 循环中添加一个 `break`（或者 `return`）。否则循环将永远重复下去并挂起。\n```\n\n## generator 组合\n\ngenerator 组合（composition）是 generator 的一个特殊功能，它允许透明地（transparently）将 generator 彼此“嵌入（embed）”到一起。\n\n例如，我们有一个生成数字序列的函数：\n\n```js\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n```\n\n现在，我们想重用它来生成一个更复杂的序列：\n- 首先是数字 `0..9`（字符代码为 48..57），\n- 接下来是大写字母 `A..Z`（字符代码为 65..90）\n- 接下来是小写字母 `a...z`（字符代码为 97..122）\n\n我们可以对这个序列进行应用，例如，我们可以从这个序列中选择字符来创建密码（也可以添加语法字符），但让我们先生成它。\n\n在常规函数中，要合并其他多个函数的结果，我们需要调用它们，存储它们的结果，最后再将它们合并到一起。\n\n对于 generator 而言，我们可以使用 `yield*` 这个特殊的语法来将一个 generator “嵌入”（组合）到另一个 generator 中：\n\n组合的 generator 的例子：\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generatePasswordCodes() {\n\n*!*\n  // 0..9\n  yield* generateSequence(48, 57);\n\n  // A..Z\n  yield* generateSequence(65, 90);\n\n  // a..z\n  yield* generateSequence(97, 122);\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generatePasswordCodes()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\n`yield*` 指令将执行 **委托** 给另一个 generator。这个术语意味着 `yield* gen` 在 generator `gen` 上进行迭代，并将其产出（yield）的值透明地（transparently）转发到外部。就好像这些值就是由外部的 generator yield 的一样。\n\n执行结果与我们内联嵌套 generator 中的代码获得的结果相同：\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generateAlphaNum() {\n\n*!*\n  // yield* generateSequence(48, 57);\n  for (let i = 48; i <= 57; i++) yield i;\n\n  // yield* generateSequence(65, 90);\n  for (let i = 65; i <= 90; i++) yield i;\n\n  // yield* generateSequence(97, 122);\n  for (let i = 97; i <= 122; i++) yield i;\n*/!*\n\n}\n\nlet str = '';\n\nfor(let code of generateAlphaNum()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n```\n\ngenerator 组合（composition）是将一个 generator 流插入到另一个 generator 流的自然的方式。它不需要使用额外的内存来存储中间结果。\n\n## \"yield\" 是一条双向路\n\n目前看来，generator 和可迭代对象类似，都具有用来生成值的特殊语法。但实际上，generator 更加强大且灵活。\n\n这是因为 `yield` 是一条双向路（two-way street）：它不仅可以向外返回结果，而且还可以将外部的值传递到 generator 内。\n\n调用 `generator.next(arg)`，我们就能将参数 `arg` 传递到 generator 内部。这个 `arg` 参数会变成 `yield` 的结果。\n\n我们来看一个例子：\n\n```js run\nfunction* gen() {\n*!*\n  // 向外部代码传递一个问题并等待答案\n  let result = yield \"2 + 2 = ?\"; // (*)\n*/!*\n\n  alert(result);\n}\n\nlet generator = gen();\n\nlet question = generator.next().value; // <-- yield 返回的 value\n\ngenerator.next(4); // --> 将结果传递到 generator 中  \n```\n\n![](genYield2.svg)\n\n1. 第一次调用 `generator.next()` 应该是不带参数的（如果带参数，那么该参数会被忽略）。它开始执行并返回第一个 `yield \"2 + 2 = ?\"` 的结果。此时，generator 执行暂停，而停留在 `(*)` 行上。\n2. 然后，正如上面图片中显示的那样，`yield` 的结果进入调用代码中的 `question` 变量。\n3. 在 `generator.next(4)`，generator 恢复执行，并获得了 `4` 作为结果：`let result = 4`。\n\n请注意，外部代码不必立即调用 `next(4)`。外部代码可能需要一些时间。这没问题：generator 将等待它。\n\n例如：\n\n```js\n// 一段时间后恢复 generator\nsetTimeout(() => generator.next(4), 1000);\n```\n\n我们可以看到，与常规函数不同，generator 和调用 generator 的代码可以通过在 `next/yield` 中传递值来交换结果。\n\n为了讲得更浅显易懂，我们来看另一个例子，其中包含了许多调用：\n\n```js run\nfunction* gen() {\n  let ask1 = yield \"2 + 2 = ?\";\n\n  alert(ask1); // 4\n\n  let ask2 = yield \"3 * 3 = ?\"\n\n  alert(ask2); // 9\n}\n\nlet generator = gen();\n\nalert( generator.next().value ); // \"2 + 2 = ?\"\n\nalert( generator.next(4).value ); // \"3 * 3 = ?\"\n\nalert( generator.next(9).done ); // true\n```\n\n执行图：\n\n![](genYield2-2.svg)\n\n1. 第一个 `.next()` 启动了 generator 的执行……执行到达第一个 `yield`。\n2. 结果被返回到外部代码中。\n3. 第二个 `.next(4)` 将 `4` 作为第一个 `yield` 的结果传递回 generator 并恢复 generator 的执行。\n4. ……执行到达第二个 `yield`，它变成了 generator 调用的结果。\n5. 第三个 `next(9)` 将 `9` 作为第二个 `yield` 的结果传入 generator 并恢复 generator 的执行，执行现在到达了函数的最底部，所以返回 `done: true`。\n\n这个过程就像“乒乓球”游戏。每个 `next(value)`（除了第一个）传递一个值到 generator 中，该值变成了当前 `yield` 的结果，然后获取下一个 `yield` 的结果。\n\n## generator.throw\n\n正如我们在上面的例子中观察到的那样，外部代码可能会将一个值传递到 generator，作为 `yield` 的结果。\n\n……但是它也可以在那里发起（抛出）一个 error。这很自然，因为 error 本身也是一种结果。\n\n要向 `yield` 传递一个 error，我们应该调用 `generator.throw(err)`。在这种情况下，`err` 将被抛到对应的 `yield` 所在的那一行。\n\n例如，`\"2 + 2?\"` 的 yield 导致了一个 error：\n\n```js run\nfunction* gen() {\n  try {\n    let result = yield \"2 + 2 = ?\"; // (1)\n\n    alert(\"The execution does not reach here, because the exception is thrown above\");\n  } catch(e) {\n    alert(e); // 显示这个 error\n  }\n}\n\nlet generator = gen();\n\nlet question = generator.next().value;\n\n*!*\ngenerator.throw(new Error(\"The answer is not found in my database\")); // (2)\n*/!*\n```\n\n在 `(2)` 行引入到 generator 的 error 导致了在 `(1)` 行中的 `yield` 出现了一个异常。在上面这个例子中，`try..catch` 捕获并显示了这个 error。\n\n如果我们没有捕获它，那么就会像其他的异常一样，它将从 generator “掉出”到调用代码中。\n\n调用代码的当前行是 `generator.throw` 所在的那一行，标记为 `(2)`。所以我们可以在这里捕获它，就像这样：\n\n```js run\nfunction* generate() {\n  let result = yield \"2 + 2 = ?\"; // 这行出现 error\n}\n\nlet generator = generate();\n\nlet question = generator.next().value;\n\n*!*\ntry {\n  generator.throw(new Error(\"The answer is not found in my database\"));\n} catch(e) {\n  alert(e); // 显示这个 error\n}\n*/!*\n```\n\n如果我们没有在那里捕获这个 error，那么，通常，它会掉入外部调用代码（如果有），如果在外部也没有被捕获，则会杀死脚本。\n\n## generator.return\n\n`generator.return(value)` 完成 generator 的执行并返回给定的 `value`。\n\n```js\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst g = gen();\n\ng.next();        // { value: 1, done: false }\ng.return('foo'); // { value: \"foo\", done: true }\ng.next();        // { value: undefined, done: true }\n```\n\n如果我们在已完成的 generator 上再次使用 `generator.return()`，它将再次返回该值（[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return)）。\n\n通常我们不使用它，因为大多数时候我们想要获取所有的返回值，但是当我们想要在特定条件下停止 generator 时它会很有用。\n\n## 总结\n\n- generator 是通过 generator 函数 `function* f(…) {…}` 创建的。\n- 在 generator（仅在）内部，存在 `yield` 操作。\n- 外部代码和 generator 可能会通过 `next/yield` 调用交换结果。\n\n在现代 JavaScript 中，generator 很少被使用。但有时它们会派上用场，因为函数在执行过程中与调用代码交换数据的能力是非常独特的。而且，当然，它们非常适合创建可迭代对象。\n\n并且，在下一章我们将会学习 async generator，它们被用于在 `for await ... of` 循环中读取异步生成的数据流（例如，通过网络分页提取 (paginated fetches over a network)）。\n\n在 Web 编程中，我们经常使用数据流，因此这是另一个非常重要的使用场景。",
        "libs": [],
        "children": [
          "pseudo-random-generator"
        ],
        "parent": "generators-iterators",
        "updatedAt": 1658583201
      }
    },
    "pseudo-random-generator": {
      "type": "Task",
      "value": {
        "title": "伪随机 generator",
        "slug": "pseudo-random-generator",
        "githubPath": "/1-js/12-generators-iterators/1-generators/01-pseudo-random-generator",
        "weight": 1,
        "libs": [],
        "content": "\n\n在很多地方我们都需要随机数据。\n\n其中之一就是测试。我们可能需要随机数据：文本，数字等，以便很好地进行测试。\n\n在 JavaScript 中，我们可以使用 `Math.random()`。但是如果什么地方出现了问题，我们希望能使用完全相同的数据进行重复测试。\n\n为此，我们可以使用所谓的“种子伪随机（seeded pseudo-random）generator”。它们将“种子（seed）”作为第一个值，然后使用公式生成下一个值。以便相同的种子（seed）可以产出（yield）相同的序列，因此整个数据流很容易复现。我们只需要记住种子并重复它即可。\n\n这样的公式的一个示例如下，它可以生成一些均匀分布的值：\n\n```\nnext = previous * 16807 % 2147483647\n```\n\n如果我们使用 `1` 作为种子，生成的值将会是：\n1. `16807`\n2. `282475249`\n3. `1622650073`\n4. ……等……\n\n这里的任务是创建一个 generator 函数 `pseudoRandom(seed)`，它将 `seed` 作为参数并使用此公式创建 generator。\n\n使用范例：\n\n```js\nlet generator = pseudoRandom(1);\n\nalert(generator.next().value); // 16807\nalert(generator.next().value); // 282475249\nalert(generator.next().value); // 1622650073\n```",
        "solution": "```js run demo\nfunction* pseudoRandom(seed) {\n  let value = seed;\n\n  while(true) {\n    value = value * 16807 % 2147483647\n    yield value;\n  }\n\n};\n\nlet generator = pseudoRandom(1);\n\nalert(generator.next().value); // 16807\nalert(generator.next().value); // 282475249\nalert(generator.next().value); // 1622650073\n```\n\n请注意，也可以使用常规函数来完成相同的操作，就像这样：\n\n```js run\nfunction pseudoRandom(seed) {\n  let value = seed;\n\n  return function() {\n    value = value * 16807 % 2147483647;\n    return value;\n  }\n}\n\nlet generator = pseudoRandom(1);\n\nalert(generator()); // 16807\nalert(generator()); // 282475249\nalert(generator()); // 1622650073\n```\n\n这也可以工作。但是这样我们就失去了使用 `for..of` 来进行迭代以及使用 generator 组合（composition）的能力，这些可能在其他地方很有用。",
        "solutionJs": "function* pseudoRandom(seed) {\n  let value = seed;\n\n  while(true) {\n    value = value * 16807 % 2147483647\n    yield value;\n  }\n\n};\n",
        "parent": "generators",
        "version": 1
      }
    },
    "async-iterators-generators": {
      "type": "Article",
      "value": {
        "title": "异步迭代和 generator",
        "slug": "async-iterators-generators",
        "githubPath": "/1-js/12-generators-iterators/2-async-iterators-generators",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n异步迭代允许我们对按需通过异步请求而得到的数据进行迭代。例如，我们通过网络分段（chunk-by-chunk）下载数据时。异步生成器（generator）使这一步骤更加方便。\n\n首先，让我们来看一个简单的示例以掌握语法，然后再看一个实际用例。\n\n## 回顾可迭代对象\n\n让我们回顾一下可迭代对象的相关内容。\n\n假设我们有一个对象，例如下面的 `range`：\n```js\nlet range = {\n  from: 1,\n  to: 5\n};\n```\n\n我们想对它使用 `for..of` 循环，例如 `for(value of range)`，来获取从 `1` 到 `5` 的值。\n\n换句话说，我们想向对象 `range` 添加 **迭代能力**。\n\n这可以通过使用一个名为 `Symbol.iterator` 的特殊方法来实现：\n\n- 当循环开始时，该方法被 `for..of` 结构调用，并且它应该返回一个带有 `next` 方法的对象。\n- 对于每次迭代，都会为下一个值调用 `next()` 方法。\n- `next()` 方法应该以 `{done: true/false, value:<loop value>}` 的格式返回一个值，其中 `done:true` 表示循环结束。\n\n这是可迭代的 `range` 的一个实现：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n*!*\n  [Symbol.iterator]() { // 在 for..of 循环开始时被调用一次\n*/!*\n    return {\n      current: this.from,\n      last: this.to,\n\n*!*\n      next() { // 每次迭代时都会被调用，来获取下一个值\n*/!*\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1，然后 2，然后 3，然后 4，然后 5\n}\n```\n\n如果有任何不清楚的，你可以阅读 [](info:iterable) 一章，其中详细讲解了关于常规迭代器（iterator）的所有内容。\n\n## 异步可迭代对象\n\n当值是以异步的形式出现时，例如在 `setTimeout` 或者另一种延迟之后，就需要异步迭代。\n\n最常见的场景是，对象需要发送一个网络请求以传递下一个值，稍后我们将看到一个它的真实示例。\n\n要使对象异步迭代：\n\n1. 使用 `Symbol.asyncIterator` 取代 `Symbol.iterator`。\n2. `next()` 方法应该返回一个 `promise`（带有下一个值，并且状态为 `fulfilled`）。\n    - 关键字 `async` 可以实现这一点，我们可以简单地使用 `async next()`。\n3. 我们应该使用 `for await (let item of iterable)` 循环来迭代这样的对象。\n    - 注意关键字 `await`。\n\n作为开始的示例，让我们创建一个可迭代的 `range` 对象，与前面的那个类似，不过现在它将异步地每秒返回一个值。\n\n我们需要做的就是对上面代码中的部分代码进行替换：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n*!*\n  [Symbol.asyncIterator]() { // (1)\n*/!*\n    return {\n      current: this.from,\n      last: this.to,\n\n*!*\n      async next() { // (2)\n*/!*\n\n*!*\n        // 注意：我们可以在 async next 内部使用 \"await\"\n        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)\n*/!*\n\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n(async () => {\n\n*!*\n  for await (let value of range) { // (4)\n    alert(value); // 1,2,3,4,5\n  }\n*/!*\n\n})()\n```\n\n正如我们所看到的，其结构与常规的 iterator 类似:\n\n1. 为了使一个对象可以异步迭代，它必须具有方法 `Symbol.asyncIterator` `(1)`。\n2. 这个方法必须返回一个带有 `next()` 方法的对象，`next()` 方法会返回一个 promise `(2)`。\n3. 这个 `next()` 方法可以不是 `async` 的，它可以是一个返回值是一个 `promise` 的常规的方法，但是使用 `async` 关键字可以允许我们在方法内部使用 `await`，所以会更加方便。这里我们只是用于延迟 1 秒的操作 `(3)`。\n4. 我们使用 `for await(let value of range)` `(4)` 来进行迭代，也就是在 `for` 后面添加 `await`。它会调用一次 `range[Symbol.asyncIterator]()` 方法一次，然后调用它的 `next()` 方法获取值。\n  \n这是一个对比 Iterator 和异步 iterator 之间差异的表格：\n\n|       | Iterator  | 异步 iterator |\n|-------|-----------|-----------------|\n| 提供 iterator 的对象方法 | `Symbol.iterator` | `Symbol.asyncIterator` |\n| `next()` 返回的值是     | 任意值             | `Promise` |\n| 要进行循环，使用         | `for..of`         | `for await..of` |\n\n````warn header=\"Spread 语法 `...` 无法异步工作\"\n需要常规的同步 iterator 的功能，无法与异步 iterator 一起使用。\n\n例如，spread 语法无法工作：\n```js\nalert( [...range] ); // Error, no Symbol.iterator\n```\n\n这很正常，因为它期望找到 `Symbol.iterator`，而不是 `Symbol.asyncIterator`。\n\n`for..of` 的情况和这个一样：没有 `await` 关键字时，则期望找到的是 `Symbol.iterator`。\n````\n\n## 回顾 generator\n\n现在，让我们回顾一下 generator，它使我们能够写出更短的迭代代码。在大多数时候，当我们想要创建一个可迭代对象时，我们会使用 generator。\n\n简单起见，这里省略了一些解释，即 generator 是“生成（yield）值的函数”。关于此的详细说明请见 [](info:generators) 一章。\n\nGenerator 是标有 `function*`（注意星号）的函数，它使用 `yield` 来生成值，并且我们可以使用 `for..of` 循环来遍历它们。\n\n下面这例子生成了从 `start` 到 `end` 的一系列值：\n\n```js run\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nfor(let value of generateSequence(1, 5)) {\n  alert(value); // 1，然后 2，然后 3，然后 4，然后 5\n}\n```\n\n正如我们所知道的，要使一个对象可迭代，我们需要给它添加 `Symbol.iterator`。\n\n```js\nlet range = {\n  from: 1,\n  to: 5,\n*!*\n  [Symbol.iterator]() {\n    return <带有 next 方法的对象，以使对象 range 可迭代>\n  }\n*/!*\n}\n```\n\n对于 `Symbol.iterator` 来说，一个通常的做法是返回一个 generator，这样可以使代码更短，如下所示：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // [Symbol.iterator]: function*() 的一种简写\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1，然后 2，然后 3，然后 4，然后 5\n}\n```\n\n如果你想了解更多详细内容，请阅读 [](info:generators) 一章。\n\n在常规的 generator 中，我们无法使用 `await`。所有的值都必须按照 `for..of` 构造的要求同步地出现。\n\n如果我们想要异步地生成值该怎么办？例如，对于来自网络请求的值。\n\n让我们再回到异步 generator，来使这个需求成为可能。\n\n## 异步 generator (finally)\n\n对于大多数的实际应用程序，当我们想创建一个异步生成一系列值的对象时，我们都可以使用异步 generator。\n\n语法很简单：在 `function*` 前面加上 `async`。这即可使 generator 变为异步的。\n\n然后使用 `for await (...)` 来遍历它，像这样：\n\n```js run\n*!*async*/!* function* generateSequence(start, end) {\n\n  for (let i = start; i <= end; i++) {\n\n*!*\n    // 哇，可以使用 await 了！\n    await new Promise(resolve => setTimeout(resolve, 1000));\n*/!*\n\n    yield i;\n  }\n\n}\n\n(async () => {\n\n  let generator = generateSequence(1, 5);\n  for *!*await*/!* (let value of generator) {\n    alert(value); // 1，然后 2，然后 3，然后 4，然后 5（在每个 alert 之间有延迟）\n  }\n\n})();\n```\n\n因为此 generator 是异步的，所以我们可以在其内部使用 `await`，依赖于 `promise`，执行网络请求等任务。\n\n````smart header=\"引擎盖下的差异\"\n如果你还记得我们在前面章节中所讲的关于 generator 的细节知识，那你应该知道，从技术上讲，异步 generator 和常规的 generator 在内部是有区别的。\n\n对于异步 generator，`generator.next()` 方法是异步的，它返回 promise。\n\n在一个常规的 generator 中，我们使用 `result = generator.next()` 来获得值。但在一个异步 generator 中，我们应该添加 `await` 关键字，像这样：\n\n```js\nresult = await generator.next(); // result = {value: ..., done: true/false}\n```\n这就是为什么异步 generator 可以与 `for await...of` 一起工作。\n````\n\n### 异步的可迭代对象 range\n\n常规的 generator 可用作 `Symbol.iterator` 以使迭代代码更短。\n\n与之类似，异步 generator 可用作 `Symbol.asyncIterator` 来实现异步迭代。\n\n例如，我们可以通过将同步的 `Symbol.iterator` 替换为异步的 `Symbol.asyncIterator`，来使对象 `range` 异步地生成值，每秒生成一个：\n\n```js run\nlet range = {\n  from: 1,\n  to: 5,\n\n  // 这一行等价于 [Symbol.asyncIterator]: async function*() {\n*!*\n  async *[Symbol.asyncIterator]() {\n*/!*\n    for(let value = this.from; value <= this.to; value++) {\n\n      // 在 value 之间暂停一会儿，等待一些东西\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      yield value;\n    }\n  }\n};\n\n(async () => {\n\n  for *!*await*/!* (let value of range) {\n    alert(value); // 1，然后 2，然后 3，然后 4，然后 5\n  }\n\n})();\n```\n\n现在，value 之间的延迟为 1 秒。\n\n```smart\n从技术上讲，我们可以把 `Symbol.iterator` 和 `Symbol.asyncIterator` 都添加到对象中，因此它既可以是同步的（`for..of`）也可以是异步的（`for await..of`）可迭代对象。\n\n但是实际上，这将是一件很奇怪的事情。\n```\n\n## 实际的例子：分页的数据\n\n到目前为止，我们已经了解了一些基本示例，以加深理解。现在，我们来看一个实际的用例。\n\n目前，有很多在线服务都是发送的分页的数据（paginated data）。例如，当我们需要一个用户列表时，一个请求只返回一个预设数量的用户（例如 100 个用户）—— “一页”，并提供了指向下一页的 URL。\n\n这种模式非常常见。不仅可用于获取用户列表，这种模式还可以用于任意东西。\n\n例如，GitHub 允许使用相同的分页提交（paginated fashion）的方式找回 commit：\n\n- 我们应该以 `https://api.github.com/repos/<repo>/commits` 格式创建进行 `fetch` 的网络请求。\n- 它返回一个包含 30 条 commit 的 JSON，并在返回的 `Link` header 中提供了指向下一页的链接。\n- 然后我们可以将该链接用于下一个请求，以获取更多 commit，以此类推。\n\n对于我们的代码，我们希望有一种更简单的获取 commit 的方式。\n\n让我们创建一个函数 `fetchCommits(repo)`，用来在任何我们有需要的时候发出请求，来为我们获取 commit。并且，该函数能够关注到所有分页内容。对于我们来说，它将是一个简单的 `for await..of` 异步迭代。\n\n因此，其用法将如下所示：\n\n```js\nfor await (let commit of fetchCommits(\"username/repository\")) {\n  // 处理 commit\n}\n```\n\n通过异步 generator，我们可以轻松实现上面所描述的函数，如下所示：\n\n```js\nasync function* fetchCommits(repo) {\n  let url = `https://api.github.com/repos/${repo}/commits`;\n\n  while (url) {\n    const response = await fetch(url, { // (1)\n      headers: {'User-Agent': 'Our script'}, // github 需要任意的 user-agent header\n    });\n\n    const body = await response.json(); // (2) 响应的是 JSON（array of commits）\n\n    // (3) 前往下一页的 URL 在 header 中，提取它\n    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel=\"next\"/);\n    nextPage = nextPage?.[1];\n\n    url = nextPage;\n\n    for(let commit of body) { // (4) 一个接一个地 yield commit，直到最后一页\n      yield commit;\n    }\n  }\n}\n```\n\n关于其工作原理的进一步解释：\n\n1. 我们使用浏览器的 [fetch](info:fetch) 方法来下载 commit。\n\n    - 初始 URL 是 `https://api.github.com/repos/<repo>/commits`，并且下一页的 URL 将在响应的 `Link` header 中。\n    - `fetch` 方法允许我们提供授权和其他 header，如果需要 —— 这里 GitHub 需要的是 `User-Agent`。\n2. commit 被以 JSON 的格式返回。\n3. 我们应该从响应（response）的 `Link` header 中获取前往下一页的 URL。它有一个特殊的格式，所以我们对它使用正则表达式（我们将在 [正则表达式](info:regular-expressions) 一章中学习它）。\n    - 前往下一页的 URL 看起来可能就像这样 `https://api.github.com/repositories/93253246/commits?page=2`。这是由 GitHub 自己生成的。\n4. 然后，我们将接收到的所有 commit 一个一个地 yield 出来，当所有 commit 都 yield 完成时，将触发下一个 `while(url)` 迭代，并发出下一个请求。\n\n这是一个使用示例（在控制台中显示 commit 的作者）\n\n```js run\n(async () => {\n\n  let count = 0;\n\n  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {\n\n    console.log(commit.author.login);\n\n    if (++count == 100) { // 让我们在获取了 100 个 commit 时停止\n      break;\n    }\n  }\n\n})();\n\n// 注意：如果你在外部沙箱中运行它，你需要把上面的 fetchCommits 函数粘贴到这儿。\n```\n\n这就是我们想要的。\n\n从外部看不到分页请求（paginated requests）的内部机制。对我们来说，它只是一个返回 commit 的异步 generator。\n\n## 总结\n\n常规的 iterator 和 generator 可以很好地处理那些不需要花费时间来生成的的数据。\n\n当我们期望异步地，有延迟地获取数据时，可以使用它们的异步版本，并且使用 `for await..of` 替代 `for..of`。\n\n异步 iterator 与常规 iterator 在语法上的区别：\n\n|       | Iterable  | 异步 Iterable |\n|-------|-----------|-----------------|\n| 提供 iterator 的对象方法 | `Symbol.iterator` | `Symbol.asyncIterator` |\n| `next()` 返回的值是     | `{value:…, done: true/false}`             | resolve 成 `{value:…, done: true/false}` 的 `Promise` |\n\n异步 generator 与常规 generator 在语法上的区别：\n\n|       | Generator | 异步 generator |\n|-------|-----------|-----------------|\n| 声明方式 | `function*` | `async function*` |\n| `next()` 返回的值是          | `{value:…, done: true/false}`         | resolve 成 `{value:…, done: true/false}` 的 `Promise`  |\n\n在 Web 开发中，我们经常会遇到数据流，它们分段流动（flows chunk-by-chunk）。例如，下载或上传大文件。\n\n我们可以使用异步 generator 来处理此类数据。值得注意的是，在一些环境，例如浏览器环境下，还有另一个被称为 Streams 的 API，它提供了特殊的接口来处理此类数据流，转换数据并将数据从一个数据流传递到另一个数据流（例如，从一个地方下载并立即发送到其他地方）。",
        "libs": [],
        "children": [],
        "headHtml": "<script>\n  async function* fetchCommits(repo) {\n    let url = `https://api.github.com/repos/${repo}/commits`;\n\n    while (url) {\n      const response = await fetch(url, {\n        headers: {'User-Agent': 'Our script'}, // github requires user-agent header\n      });\n\n      const body = await response.json(); // parses response as JSON (array of commits)\n\n      // the URL of the next page is in the headers, extract it\n      let nextPage = response.headers.get('Link').match(/<(.*?)>; rel=\"next\"/);\n      nextPage = nextPage?.[1];\n\n      url = nextPage;\n\n      // yield commits one by one, when they finish - fetch a new page url\n      for(let commit of body) {\n        yield commit;\n      }\n    }\n  }\n</script>\n",
        "parent": "generators-iterators",
        "updatedAt": 1645023568
      }
    },
    "modules": {
      "type": "Article",
      "value": {
        "title": "模块",
        "slug": "modules",
        "githubPath": "/1-js/13-modules",
        "isFolder": true,
        "weight": 13,
        "content": "",
        "libs": [],
        "children": [
          "modules-intro",
          "import-export",
          "modules-dynamic-imports"
        ],
        "parent": "js"
      }
    },
    "modules-intro": {
      "type": "Article",
      "value": {
        "title": "模块 (Module) 简介",
        "slug": "modules-intro",
        "githubPath": "/1-js/13-modules/01-modules-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n随着我们的应用越来越大，我们想要将其拆分成多个文件，即所谓的“模块（module）”。一个模块可以包含用于特定目的的类或函数库。\n\n很长一段时间，JavaScript 都没有语言级（language-level）的模块语法。这不是一个问题，因为最初的脚本又小又简单，所以没必要将其模块化。\n\n但是最终脚本变得越来越复杂，因此社区发明了许多种方法来将代码组织到模块中，使用特殊的库按需加载模块。\n\n列举一些（出于历史原因）：\n\n- [AMD](https://en.wikipedia.org/wiki/Asynchronous_module_definition) —— 最古老的模块系统之一，最初由 [require.js](http://requirejs.org/) 库实现。\n- [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) —— 为 Node.js 服务器创建的模块系统。\n- [UMD](https://github.com/umdjs/umd) —— 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容。\n\n现在，它们都在慢慢成为历史的一部分，但我们仍然可以在旧脚本中找到它们。\n\n语言级的模块系统在 2015 年的时候出现在了标准（ES6）中，此后逐渐发展，现在已经得到了所有主流浏览器和 Node.js 的支持。因此，我们将从现在开始学习现代 JavaScript 模块（module）。\n\n## 什么是模块？\n\n一个模块（module）就是一个文件。一个脚本就是一个模块。就这么简单。\n\n模块可以相互加载，并可以使用特殊的指令 `export` 和 `import` 来交换功能，从另一个模块调用一个模块的函数：\n\n- `export` 关键字标记了可以从当前模块外部访问的变量和函数。\n- `import` 关键字允许从其他模块导入功能。\n\n例如，我们有一个 `sayHi.js` 文件导出了一个函数：\n\n```js\n// 📁 sayHi.js\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n```\n\n……然后另一个文件可能导入并使用了这个函数：\n\n```js\n// 📁 main.js\nimport { sayHi } from './sayHi.js';\n\nalert(sayHi); // function...\nsayHi('John'); // Hello, John!\n```\n\n`import` 指令通过相对于当前文件的路径 `./sayHi.js` 加载模块，并将导入的函数 `sayHi` 分配（assign）给相应的变量。\n\n让我们在浏览器中运行一下这个示例。\n\n由于模块支持特殊的关键字和功能，因此我们必须通过使用 `<script type=\"module\">` 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。\n\n像这样：\n\n[codetabs src=\"say\" height=\"140\" current=\"index.html\"]\n\n浏览器会自动获取并解析（evaluate）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。\n\n```warn header=\"模块只通过 HTTP(s) 工作，而非本地\"\n如果你尝试通过 `file://` 协议在本地打开一个网页，你会发现 `import/export` 指令不起作用。你可以使用本地 Web 服务器，例如 [static-server](https://www.npmjs.com/package/static-server#getting-started)，或者使用编辑器的“实时服务器”功能，例如 VS Code 的 [Live Server Extension](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) 来测试模块。\n```\n\n## 模块核心功能\n\n与“常规”脚本相比，模块有什么不同呢？\n\n下面是一些核心的功能，对浏览器和服务端的 JavaScript 来说都有效。\n\n### 始终使用 \"use strict\"\n\n模块始终在严格模式下运行。例如，对一个未声明的变量赋值将产生错误（译注：在浏览器控制台可以看到 error 信息）。\n\n```html run\n<script type=\"module\">\n  a = 5; // error\n</script>\n```\n\n### 模块级作用域\n\n每个模块都有自己的顶级作用域（top-level scope）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。\n\n在下面这个例子中，我们导入了两个脚本，`hello.js` 尝试使用在 `user.js` 中声明的变量 `user`。它失败了，因为它是一个单独的模块（你在控制台中可以看到报错）：\n\n[codetabs src=\"scopes\" height=\"140\" current=\"index.html\"]\n\n模块应该 `export` 它们想要被外部访问的内容，并 `import` 它们所需要的内容。\n\n- `user.js` 应该导出 `user` 变量。\n- `hello.js` 应该从 `user.js` 模块中导入它。\n\n换句话说，对于模块，我们使用导入/导出而不是依赖全局变量。\n\n这是正确的变体：\n\n[codetabs src=\"scopes-working\" height=\"140\" current=\"hello.js\"]\n\n在浏览器中，对于 HTML 页面，每个 `<script type=\"module\">` 都存在独立的顶级作用域。\n\n下面是同一页面上的两个脚本，都是 `type=\"module\"`。它们看不到彼此的顶级变量：\n\n```html run\n<script type=\"module\">\n  // 变量仅在这个 module script 内可见\n  let user = \"John\";\n</script>\n\n<script type=\"module\">\n  *!*\n  alert(user); // Error: user is not defined\n  */!*\n</script>\n```\n\n```smart\n在浏览器中，我们可以通过将变量显式地分配给 `window` 的一个属性，使其成为窗口级别的全局变量。例如 `window.user = \"John\"`。\n\n这样所有脚本都会看到它，无论脚本是否带有 `type=\"module\"`。\n\n也就是说，创建这种全局变量并不是一个好的方式。请尽量避免这样做。\n```\n\n### 模块代码仅在第一次导入时被解析\n\n如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时。然后将其导出（export）的内容提供给进一步的导入（importer）。\n\n只执行一次会产生很重要的影响，我们应该意识到这一点。\n\n让我们看几个例子。\n\n首先，如果执行一个模块中的代码会带来副作用（side-effect），例如显示一条消息，那么多次导入它只会触发一次显示 —— 即第一次：\n\n```js\n// 📁 alert.js\nalert(\"Module is evaluated!\");\n```\n\n```js\n// 在不同的文件中导入相同的模块\n\n// 📁 1.js\nimport `./alert.js`; // Module is evaluated!\n\n// 📁 2.js\nimport `./alert.js`; // (什么都不显示)\n```\n\n第二次导入什么也没显示，因为模块已经执行过了。\n\n这里有一条规则：顶层模块代码应该用于初始化，创建模块特定的内部数据结构。如果我们需要多次调用某些东西 —— 我们应该将其以函数的形式导出，就像我们在上面使用 `sayHi` 那样。\n\n现在，让我们看一个更复杂的例子。\n\n我们假设一个模块导出了一个对象：\n\n```js\n// 📁 admin.js\nexport let admin = {\n  name: \"John\"\n};\n```\n\n如果这个模块被导入到多个文件中，模块仅在第一次被导入时被解析，并创建 `admin` 对象，然后将其传入到所有的导入。\n\n所有的导入都只获得了一个唯一的 `admin` 对象：\n\n```js\n// 📁 1.js\nimport { admin } from './admin.js';\nadmin.name = \"Pete\";\n\n// 📁 2.js\nimport { admin } from './admin.js';\nalert(admin.name); // Pete\n\n*!*\n// 1.js 和 2.js 引用的是同一个 admin 对象\n// 在 1.js 中对对象做的更改，在 2.js 中也是可见的\n*/!*\n```\n\n正如你所看到的，当在 `1.js` 中修改了导入的 `admin` 中的 `name` 属性时，我们在 `2.js` 中可以看到新的 `admin.name`。\n\n这正是因为该模块只执行了一次。生成导出，然后这些导出在导入之间共享，因此如果更改了 `admin` 对象，在其他导入中也会看到。\n\n**这种行为实际上非常方便，因为它允许我们“配置”模块。**\n\n换句话说，模块可以提供需要配置的通用功能。例如身份验证需要凭证。那么模块可以导出一个配置对象，期望外部代码可以对其进行赋值。\n\n这是经典的使用模式：\n1. 模块导出一些配置方法，例如一个配置对象。\n2. 在第一次导入时，我们对其进行初始化，写入其属性。可以在应用顶级脚本中进行此操作。\n3. 进一步地导入使用模块。\n\n例如，`admin.js` 模块可能提供了某些功能（例如身份验证），但希望凭证可以从模块之外赋值到 `config` 对象：\n\n```js\n// 📁 admin.js\nexport let config = { };\n\nexport function sayHi() {\n  alert(`Ready to serve, ${config.user}!`);\n}\n```\n\n这里，`admin.js` 导出了 `config` 对象（最初是空的，但也可能有默认属性）。\n\n然后，在 `init.js` 中，我们应用的第一个脚本，我们从 `init.js` 导入了 `config` 并设置了 `config.user`：\n\n```js\n// 📁 init.js\nimport { config } from './admin.js';\nconfig.user = \"Pete\";\n```\n\n……现在模块 `admin.js` 已经是被配置过的了。\n\n其他导入可以调用它，它会正确显示当前用户：\n\n```js\n// 📁 another.js\nimport { sayHi } from './admin.js';\n\nsayHi(); // Ready to serve, *!*Pete*/!*!\n```\n\n\n### import.meta\n\n`import.meta` 对象包含关于当前模块的信息。\n\n它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。\n\n```html run height=0\n<script type=\"module\">\n  alert(import.meta.url); // 脚本的 URL\n  // 对于内联脚本来说，则是当前 HTML 页面的 URL\n</script>\n```\n\n### 在一个模块中，\"this\" 是 undefined\n\n这是一个小功能，但为了完整性，我们应该提到它。\n\n在一个模块中，顶级 `this` 是 undefined。\n\n将其与非模块脚本进行比较会发现，非模块脚本的顶级 `this` 是全局对象：\n\n```html run height=0\n<script>\n  alert(this); // window\n</script>\n\n<script type=\"module\">\n  alert(this); // undefined\n</script>\n```\n\n## 浏览器特定功能\n\n与常规脚本相比，拥有 `type=\"module\"` 标识的脚本有一些特定于浏览器的差异。\n\n如果你是第一次阅读或者你不打算在浏览器中使用 JavaScript，那么你可以跳过本节内容。\n\n### 模块脚本是延迟的\n\n模块脚本 **总是** 被延迟的，与 `defer` 特性（在 [](info:script-async-defer) 一章中描述的）对外部脚本和内联脚本（inline script）的影响相同。\n\n也就是说：\n  - 下载外部模块脚本 `<script type=\"module\" src=\"...\">` 不会阻塞 HTML 的处理，它们会与其他资源并行加载。\n  - 模块脚本会等到 HTML 文档完全准备就绪（即使它们很小并且比 HTML 加载速度更快），然后才会运行。\n  - 保持脚本的相对顺序：在文档中排在前面的脚本先执行。\n\n它的一个副作用是，模块脚本总是会“看到”已完全加载的 HTML 页面，包括在它们下方的 HTML 元素。\n\n例如：\n\n```html run\n<script type=\"module\">\n*!*\n  alert(typeof button); // object：脚本可以“看见”下面的 button\n*/!*\n  // 因为模块是被延迟的（deferred，所以模块脚本会在整个页面加载完成后才运行\n</script>\n\n相较于下面这个常规脚本：\n\n<script>\n*!*\n  alert(typeof button); // button 为 undefined，脚本看不到下面的元素\n*/!*\n  // 常规脚本会立即运行，常规脚本的运行是在在处理页面的其余部分之前进行的\n</script>\n\n<button id=\"button\">Button</button>\n```\n\n请注意：上面的第二个脚本实际上要先于前一个脚本运行！所以我们会先看到 `undefined`，然后才是 `object`。\n\n这是因为模块脚本是被延迟的，所以要等到 HTML 文档被处理完成才会执行它。而常规脚本则会立即运行，所以我们会先看到常规脚本的输出。\n\n当使用模块脚本时，我们应该知道 HTML 页面在加载时就会显示出来，在 HTML 页面加载完成后才会执行 JavaScript 模块，因此用户可能会在 JavaScript 应用程序准备好之前看到该页面。某些功能那时可能还无法正使用。我们应该放置“加载指示器（loading indicator）”，否则，请确保不会使用户感到困惑。\n\n### Async 适用于内联脚本（inline script）\n\n对于非模块脚本，`async` 特性（attribute）仅适用于外部脚本。异步脚本会在准备好后立即运行，独立于其他脚本或 HTML 文档。\n\n对于模块脚本，它也适用于内联脚本。\n\n例如，下面的内联脚本具有 `async` 特性，因此它不会等待任何东西。\n\n它执行导入（fetch `./analytics.js`），并在导入完成时运行，即使 HTML 文档还未完成，或者其他脚本仍在等待处理中。\n\n这对于不依赖任何其他东西的功能来说是非常棒的，例如计数器，广告，文档级事件监听器。\n\n```html\n<!-- 所有依赖都获取完成（analytics.js）然后脚本开始运行 -->\n<!-- 不会等待 HTML 文档或者其他 <script> 标签 -->\n<script *!*async*/!* type=\"module\">\n  import {counter} from './analytics.js';\n\n  counter.count();\n</script>\n```\n\n### 外部脚本\n\n具有 `type=\"module\"` 的外部脚本（external script）在两个方面有所不同：\n\n1. 具有相同 `src` 的外部脚本仅运行一次：\n    ```html\n    <!-- 脚本 my.js 被加载完成（fetched）并只被运行一次 -->\n    <script type=\"module\" src=\"my.js\"></script>\n    <script type=\"module\" src=\"my.js\"></script>\n    ```\n\n2. 从另一个源（例如另一个网站）获取的外部脚本需要 [CORS](mdn:Web/HTTP/CORS) header，如我们在 <info:fetch-crossorigin> 一章中所讲的那样。换句话说，如果一个模块脚本是从另一个源获取的，则远程服务器必须提供表示允许获取的 header `Access-Control-Allow-Origin`。\n    ```html\n    <!-- another-site.com 必须提供 Access-Control-Allow-Origin -->\n    <!-- 否则，脚本将无法执行 -->\n    <script type=\"module\" src=\"*!*http://another-site.com/their.js*/!*\"></script>\n    ```\n\n    默认这样做可以确保更好的安全性。\n\n### 不允许裸模块（\"bare\" module）\n\n在浏览器中，`import` 必须给出相对或绝对的 URL 路径。没有任何路径的模块被称为“裸（bare）”模块。在 `import` 中不允许这种模块。\n\n例如，下面这个 `import` 是无效的：\n```js\nimport {sayHi} from 'sayHi'; // Error，“裸”模块\n// 模块必须有一个路径，例如 './sayHi.js' 或者其他任何路径\n```\n\n某些环境，像 Node.js 或者打包工具（bundle tool）允许没有任何路径的裸模块，因为它们有自己的查找模块的方法和钩子（hook）来对它们进行微调。但是浏览器尚不支持裸模块。\n\n### 兼容性，\"nomodule\"\n\n旧时的浏览器不理解 `type=\"module\"`。未知类型的脚本会被忽略。对此，我们可以使用 `nomodule` 特性来提供一个后备：\n\n```html run\n<script type=\"module\">\n  alert(\"Runs in modern browsers\");\n</script>\n\n<script nomodule>\n  alert(\"Modern browsers know both type=module and nomodule, so skip this\")\n  alert(\"Old browsers ignore script with unknown type=module, but execute this.\");\n</script>\n```\n\n## 构建工具\n\n在实际开发中，浏览器模块很少被以“原始”形式进行使用。通常，我们会使用一些特殊工具，例如 [Webpack](https://webpack.js.org/)，将它们打包在一起，然后部署到生产环境的服务器。\n\n使用打包工具的一个好处是 —— 它们可以更好地控制模块的解析方式，允许我们使用裸模块和更多的功能，例如 CSS/HTML 模块等。\n\n构建工具做以下这些事儿：\n\n1. 从一个打算放在 HTML 中的 `<script type=\"module\">` “主”模块开始。\n2. 分析它的依赖：它的导入，以及它的导入的导入等。\n3. 使用所有模块构建一个文件（或者多个文件，这是可调的），并用打包函数（bundler function）替代原生的 `import` 调用，以使其正常工作。还支持像 HTML/CSS 模块等“特殊”的模块类型。\n4. 在处理过程中，可能会应用其他转换和优化：\n    - 删除无法访问的代码。\n    - 删除未使用的导出（\"tree-shaking\"）。\n    - 删除特定于开发的像 `console` 和 `debugger` 这样的语句。\n    - 可以使用 [Babel](https://babeljs.io/) 将前沿的现代的 JavaScript 语法转换为具有类似功能的旧的 JavaScript 语法。\n    - 压缩生成的文件（删除空格，用短的名字替换变量等）。\n\n如果我们使用打包工具，那么脚本会被打包进一个单一文件（或者几个文件），在这些脚本中的 `import/export` 语句会被替换成特殊的打包函数（bundler function）。因此，最终打包好的脚本中不包含任何 `import/export`，它也不需要 `type=\"module\"`，我们可以将其放入常规的 `<script>`：\n\n```html\n<!-- 假设我们从诸如 Webpack 这类的打包工具中获得了 \"bundle.js\" 脚本 -->\n<script src=\"bundle.js\"></script>\n```\n\n关于构建工具说了这么多，但其实原生模块也是可以用的。所以，我们在这儿将不会使用 Webpack：你可以稍后再配置它。\n\n## 总结\n\n下面总结一下模块的核心概念：\n\n1. 一个模块就是一个文件。浏览器需要使用 `<script type=\"module\">` 以使 `import/export` 可以工作。模块（译注：相较于常规脚本）有几点差别：\n    - 默认是延迟解析的（deferred）。\n    - Async 可用于内联脚本。\n    - 要从另一个源（域/协议/端口）加载外部脚本，需要 CORS header。\n    - 重复的外部脚本会被忽略\n2. 模块具有自己的本地顶级作用域，并可以通过 `import/export` 交换功能。\n3. 模块始终使用 `use strict`。\n4. 模块代码只执行一次。导出仅创建一次，然后会在导入之间共享。\n\n当我们使用模块时，每个模块都会实现特定功能并将其导出。然后我们使用 `import` 将其直接导入到需要的地方即可。浏览器会自动加载并解析脚本。\n\n在生产环境中，出于性能和其他原因，开发者经常使用诸如 [Webpack](https://webpack.js.org) 之类的打包工具将模块打包到一起。\n\n在下一章里，我们将会看到更多关于模块的例子，以及如何进行导入/导出。",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1658589703
      }
    },
    "import-export": {
      "type": "Article",
      "value": {
        "title": "导出和导入",
        "slug": "import-export",
        "githubPath": "/1-js/13-modules/02-import-export",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n导出（export）和导入（import）指令有几种语法变体。\n\n在上一节，我们看到了一个简单的用法，现在让我们来探索更多示例吧。\n\n## 在声明前导出\n\n我们可以通过在声明之前放置 `export` 来标记任意声明为导出，无论声明的是变量，函数还是类都可以。\n\n例如，这里的所有导出均有效：\n\n```js\n// 导出数组\n*!*export*/!* let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n// 导出 const 声明的变量\n*!*export*/!* const MODULES_BECAME_STANDARD_YEAR = 2015;\n\n// 导出类\n*!*export*/!* class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n```\n\n````smart header=\"导出 class/function 后没有分号\"\n注意，在类或者函数前的 `export` 不会让它们变成 [函数表达式](info:function-expressions)。尽管被导出了，但它仍然是一个函数声明。\n\n大部分 JavaScript 样式指南都不建议在函数和类声明后使用分号。\n\n这就是为什么在 `export class` 和 `export function` 的末尾不需要加分号：\n\n```js\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n} *!* // 在这里没有分号 ; */!*\n```\n\n````\n\n## 导出与声明分开\n\n另外，我们还可以将 `export` 分开放置。\n\n下面的例子中，我们先声明函数，然后再导出它们：\n\n```js  \n// 📁 say.js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nfunction sayBye(user) {\n  alert(`Bye, ${user}!`);\n}\n\n*!*\nexport {sayHi, sayBye}; // 导出变量列表\n*/!*\n```\n\n……从技术上讲，我们也可以把 `export` 放在函数上面。\n\n## Import *\n\n通常，我们把要导入的东西列在花括号 `import {...}` 中，就像这样：\n\n```js\n// 📁 main.js\n*!*\nimport {sayHi, sayBye} from './say.js';\n*/!*\n\nsayHi('John'); // Hello, John!\nsayBye('John'); // Bye, John!\n```\n\n但是如果有很多要导入的内容，我们可以使用 `import * as <obj>` 将所有内容导入为一个对象，例如：\n\n```js\n// 📁 main.js\n*!*\nimport * as say from './say.js';\n*/!*\n\nsay.sayHi('John');\nsay.sayBye('John');\n```\n\n乍一看，“通通导入”看起来很酷，写起来也很短，但是我们通常为什么要明确列出我们需要导入的内容？\n\n这里有几个原因。\n\n1. 现代的构建工具（[webpack](https://webpack.js.org/) 和其他工具）将模块打包到一起并对其进行优化，以加快加载速度并删除未使用的代码。\n\n    比如说，我们向我们的项目里添加一个第三方库 `say.js`，它具有许多函数：\n    ```js\n    // 📁 say.js\n    export function sayHi() { ... }\n    export function sayBye() { ... }\n    export function becomeSilent() { ... }\n    ```\n\n    现在，如果我们只在我们的项目里使用了 `say.js` 中的一个函数：\n    ```js\n    // 📁 main.js\n    import {sayHi} from './say.js';\n    ```\n    ……那么，优化器（optimizer）就会检测到它，并从打包好的代码中删除那些未被使用的函数，从而使构建更小。这就是所谓的“摇树（tree-shaking）”。\n\n2. 明确列出要导入的内容会使得名称较短：`sayHi()` 而不是 `say.sayHi()`。\n3. 导入的显式列表可以更好地概述代码结构：使用的内容和位置。它使得代码支持重构，并且重构起来更容易。\n\n## Import \"as\"\n\n我们也可以使用 `as` 让导入具有不同的名字。\n\n例如，简洁起见，我们将 `sayHi` 导入到局部变量 `hi`，将 `sayBye` 导入到 `bye`：\n\n```js\n// 📁 main.js\n*!*\nimport {sayHi as hi, sayBye as bye} from './say.js';\n*/!*\n\nhi('John'); // Hello, John!\nbye('John'); // Bye, John!\n```\n\n## Export \"as\"\n\n导出也具有类似的语法。\n\n我们将函数导出为 `hi` 和 `bye`：\n\n```js\n// 📁 say.js\n...\nexport {sayHi as hi, sayBye as bye};\n```\n\n现在 `hi` 和 `bye` 是在外面使用时的正式名称：\n\n```js\n// 📁 main.js\nimport * as say from './say.js';\n\nsay.*!*hi*/!*('John'); // Hello, John!\nsay.*!*bye*/!*('John'); // Bye, John!\n```\n\n## Export default\n\n在实际中，主要有两种模块。\n\n- 包含库或函数包的模块，像上面的 `say.js`。\n- 声明单个实体的模块，例如模块 `user.js` 仅导出 `class User`。\n\n大部分情况下，开发者倾向于使用第二种方式，以便每个“东西”都存在于它自己的模块中。\n\n当然，这需要大量文件，因为每个东西都需要自己的模块，但这根本不是问题。实际上，如果文件具有良好的命名，并且文件夹结构得当，那么代码导航（navigation）会变得更容易。\n\n模块提供了一个特殊的默认导出 `export default` 语法，以使“一个模块只做一件事”的方式看起来更好。\n\n将 `export default` 放在要导出的实体前：\n\n```js\n// 📁 user.js\nexport *!*default*/!* class User { // 只需要添加 \"default\" 即可\n  constructor(name) {\n    this.name = name;\n  }\n}\n```\n\n每个文件应该只有一个 `export default`：\n\n……然后将其导入而不需要花括号：\n\n```js\n// 📁 main.js\nimport *!*User*/!* from './user.js'; // 不需要花括号 {User}，只需要写成 User 即可\n\nnew User('John');\n```\n\n不用花括号的导入看起来很酷。刚开始使用模块时，一个常见的错误就是忘记写花括号。所以，请记住，`import` 命名的导出时需要花括号，而 `import` 默认的导出时不需要花括号。\n\n| 命名的导出 | 默认的导出 |\n|--------------|----------------|\n| `export class User {...}` | `export default class User {...}` |\n| `import {User} from ...` | `import User from ...`|\n\n从技术上讲，我们可以在一个模块中同时有默认的导出和命名的导出，但是实际上人们通常不会混合使用它们。模块要么是命名的导出要么是默认的导出。\n\n由于每个文件最多只能有一个默认的导出，因此导出的实体可能没有名称。\n\n例如，下面这些都是完全有效的默认的导出：\n\n```js\nexport default class { // 没有类名\n  constructor() { ... }\n}\n```\n\n```js\nexport default function(user) { // 没有函数名\n  alert(`Hello, ${user}!`);\n}\n```\n\n```js\n// 导出单个值，而不使用变量\nexport default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n```\n\n不指定名称是可以的，因为每个文件只有一个 `export default`，因此不带花括号的 `import` 知道要导入的内容是什么。\n\n如果没有 `default`，这样的导出将会出错：\n\n```js\nexport class { // Error!（非默认的导出需要名称）\n  constructor() {}\n}\n```\n\n### \"default\" 名称\n\n在某些情况下，`default` 关键词被用于引用默认的导出。\n\n例如，要将函数与其定义分开导出：\n\n```js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// 就像我们在函数之前添加了 \"export default\" 一样\nexport {sayHi as default};\n```\n\n或者，另一种情况，假设模块 `user.js` 导出了一个主要的默认的导出和一些命名的导出（这种情况很少见，但确实会发生）：\n\n```js\n// 📁 user.js\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n```\n\n这是导入默认的导出以及命名的导出的方法：\n\n```js\n// 📁 main.js\nimport {*!*default as User*/!*, sayHi} from './user.js';\n\nnew User('John');\n```\n\n如果我们将所有东西 `*` 作为一个对象导入，那么 `default` 属性正是默认的导出：\n\n```js\n// 📁 main.js\nimport * as user from './user.js';\n\nlet User = user.default; // 默认的导出\nnew User('John');\n```\n\n### 我应该使用默认的导出吗？\n\n命名的导出是明确的。它们确切地命名了它们要导出的内容，因此我们能从它们获得这些信息，这是一件好事。\n\n命名的导出会强制我们使用正确的名称进行导入：\n\n```js\nimport {User} from './user.js';\n// 导入 {MyUser} 不起作用，导入名字必须为 {User}\n```\n\n……对于默认的导出，我们总是在导入时选择名称：\n\n```js\nimport User from './user.js'; // 有效\nimport MyUser from './user.js'; // 也有效\n// 使用任何名称导入都没有问题\n```\n\n因此，团队成员可能会使用不同的名称来导入相同的内容，这不好。\n\n通常，为了避免这种情况并使代码保持一致，可以遵从这条规则，即导入的变量应与文件名相对应，例如：\n\n```js\nimport User from './user.js';\nimport LoginForm from './loginForm.js';\nimport func from '/path/to/func.js';\n...\n```\n\n但是，一些团队仍然认为这是默认的导出的严重缺陷。因此，他们更倾向于始终使用命名的导出。即使只导出一个东西，也仍然使用命名的导出，而不是默认的导出。\n\n这也使得重新导出（见下文）更容易。\n\n## 重新导出\n\n“重新导出（Re-export）”语法 `export ... from ...` 允许导入内容，并立即将其导出（可能是用的是其他的名字），就像这样：\n\n```js\nexport {sayHi} from './say.js'; // 重新导出 sayHi\n\nexport {default as User} from './user.js'; // 重新导出 default\n```\n\n为什么要这样做？我们看一个实际开发中的用例。\n\n想象一下，我们正在编写一个 \"package\"：一个包含大量模块的文件夹，其中一些功能是导出到外部的（像 NPM 这样的工具允许我们发布和分发这样的 package，但我们不是必须要去使用它们），并且其中一些模块仅仅是供其他 package 中的模块内部使用的 \"helpers\"。\n\n文件结构可能是这样的：\n```\nauth/\n    index.js  \n    user.js\n    helpers.js\n    tests/\n        login.js\n    providers/\n        github.js\n        facebook.js\n        ...\n```\n\n我们希望通过单个入口暴露包的功能。\n\n换句话说，想要使用我们的包的人，应该只从“主文件” `auth/index.js` 导入。\n\n像这样：\n\n```js\nimport {login, logout} from 'auth/index.js'\n```\n\n“主文件”，`auth/index.js` 导出了我们希望在包中提供的所有功能。\n\n这样做是因为，其他使用我们包的开发者不应该干预其内部结构，不应该搜索我们包的文件夹中的文件。我们只在 `auth/index.js` 中导出必要的部分，并保持其他内容“不可见”。\n\n由于实际导出的功能分散在 package 中，所以我们可以将它们导入到 `auth/index.js`，然后再从中导出它们：\n\n```js\n// 📁 auth/index.js\n\n// 导入 login/logout 然后立即导出它们\nimport {login, logout} from './helpers.js';\nexport {login, logout};\n\n// 将默认导出导入为 User，然后导出它\nimport User from './user.js';\nexport {User};\n...\n```\n\n现在使用我们 package 的人可以 `import {login} from \"auth/index.js\"`。\n\n语法 `export ... from ...` 只是下面这种导入-导出的简写：\n\n```js\n// 📁 auth/index.js\n// 重新导出 login/logout\nexport {login, logout} from './helpers.js';\n\n// 将默认导出重新导出为 User\nexport {default as User} from './user.js';\n...\n```\n\n`export ... from` 与 `import/export` 相比的显着区别是重新导出的模块在当前文件中不可用。所以在上面的 `auth/index.js` 示例中，我们不能使用重新导出的 `login/logout` 函数。\n\n### 重新导出默认导出\n\n重新导出时，默认导出需要单独处理。\n\n假设我们有一个 `user.js` 脚本，其中写了 `export default class User`，并且我们想重新导出类 `User`：\n\n```js\n// 📁 user.js\nexport default class User {\n  // ...\n}\n```\n\n我们可能会遇到两个问题：\n\n1. `export User from './user.js'` 无效。这会导致一个语法错误。\n\n    要重新导出默认导出，我们必须明确写出 `export {default as User}`，就像上面的例子中那样。\n\n2. `export * from './user.js'` 重新导出只导出了命名的导出，但是忽略了默认的导出。\n\n    如果我们想将命名的导出和默认的导出都重新导出，那么需要两条语句：\n    ```js\n    export * from './user.js'; // 重新导出命名的导出\n    export {default} from './user.js'; // 重新导出默认的导出\n    ```\n\n重新导出一个默认导出的这种奇怪现象，是某些开发者不喜欢默认导出，而是喜欢命名的导出的原因之一。\n\n## 总结\n\n这是我们在本节和前面章节中介绍的所有 `export` 类型：\n\n你可以阅读并回忆它们的含义来进行自查：\n\n- 在声明一个 class/function/.. 之前：\n  - `export [default] class/function/variable ...`\n- 独立的导出：\n  - `export {x [as y], ...}`.\n- 重新导出：\n  - `export {x [as y], ...} from \"module\"`\n  - `export * from \"module\"`（不会重新导出默认的导出）。\n  - `export {default [as y]} from \"module\"`（重新导出默认的导出）。\n\n导入：\n\n- 导入命名的导出：\n  - `import {x [as y], ...} from \"module\"`\n- 导入默认的导出：\n  - `import x from \"module\"`\n  - `import {default as x} from \"module\"`\n- 导入所有：\n  - `import * as obj from \"module\"`\n- 导入模块（其代码，并运行），但不要将其任何导出赋值给变量：\n  - `import \"module\"`\n\n我们把 `import/export` 语句放在脚本的顶部或底部，都没关系。\n\n因此，从技术上讲，下面这样的代码没有问题：\n```js\nsayHi();\n\n// ...\n\nimport {sayHi} from './say.js'; // 在文件底部导入\n```\n\n在实际开发中，导入通常位于文件的开头，但是这只是为了更加方便。\n\n**请注意在 `{...}` 中的 import/export 语句无效。**\n\n像这样的有条件的导入是无效的：\n```js\nif (something) {\n  import {sayHi} from \"./say.js\"; // Error: import must be at top level\n}\n```\n\n……但是，如果我们真的需要根据某些条件来进行导入呢？或者在某些合适的时间？例如，根据请求（request）加载模块，什么时候才是真正需要呢？\n\n我们将在下一章节中学习动态导入。",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1656826156
      }
    },
    "modules-dynamic-imports": {
      "type": "Article",
      "value": {
        "title": "动态导入",
        "slug": "modules-dynamic-imports",
        "githubPath": "/1-js/13-modules/03-modules-dynamic-imports",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n我们在前面章节中介绍的导出和导入语句称为“静态”导入。语法非常简单且严格。\n\n首先，我们不能动态生成 `import` 的任何参数。\n\n模块路径必须是原始类型字符串，不能是函数调用，下面这样的 `import` 行不通：\n\n```js\nimport ... from *!*getModuleName()*/!*; // Error, only from \"string\" is allowed\n```\n\n其次，我们无法根据条件或者在运行时导入：\n\n```js\nif(...) {\n  import ...; // Error, not allowed!\n}\n\n{\n  import ...; // Error, we can't put import in any block\n}\n```\n\n这是因为 `import`/`export` 旨在提供代码结构的主干。这是非常好的事儿，因为这样便于分析代码结构，可以收集模块，可以使用特殊工具将收集的模块打包到一个文件中，可以删除未使用的导出（\"tree-shaken\"）。这些只有在 `import`/`export` 结构简单且固定的情况下才能够实现。\n\n但是，我们如何才能动态地按需导入模块呢？\n\n## import() 表达式\n\n`import(module)` 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。\n\n我们可以在代码中的任意位置动态地使用它。例如：\n\n```js\nlet modulePath = prompt(\"Which module to load?\");\n\nimport(modulePath)\n  .then(obj => <module object>)\n  .catch(err => <loading error, e.g. if no such module>)\n```\n\n或者，如果在异步函数中，我们可以使用 `let module = await import(modulePath)`。\n\n例如，如果我们有以下模块 `say.js`：\n\n```js\n// 📁 say.js\nexport function hi() {\n  alert(`Hello`);\n}\n\nexport function bye() {\n  alert(`Bye`);\n}\n```\n\n……那么，可以像下面这样进行动态导入：\n\n```js\nlet {hi, bye} = await import('./say.js');\n\nhi();\nbye();\n```\n\n或者，如果 `say.js` 有默认的导出：\n\n```js\n// 📁 say.js\nexport default function() {\n  alert(\"Module loaded (export default)!\");\n}\n```\n\n……那么，为了访问它，我们可以使用模块对象的 `default` 属性：\n\n```js\nlet obj = await import('./say.js');\nlet say = obj.default;\n// or, in one line: let {default: say} = await import('./say.js');\n\nsay();\n```\n\n这是一个完整的示例：\n\n[codetabs src=\"say\" current=\"index.html\"]\n\n```smart\n动态导入在常规脚本中工作时，它们不需要 `script type=\"module\"`.\n```\n\n```smart\n尽管 `import()` 看起来像一个函数调用，但它只是一种特殊语法，只是恰好使用了括号（类似于 `super()`）。\n\n因此，我们不能将 `import` 复制到一个变量中，或者对其使用 `call/apply`。因为它不是一个函数。\n```",
        "libs": [],
        "children": [],
        "parent": "modules",
        "updatedAt": 1660558368
      }
    },
    "js-misc": {
      "type": "Article",
      "value": {
        "title": "杂项",
        "slug": "js-misc",
        "githubPath": "/1-js/99-js-misc",
        "isFolder": true,
        "weight": 99,
        "content": "",
        "libs": [],
        "children": [
          "proxy",
          "eval",
          "currying-partials",
          "reference-type",
          "bigint",
          "unicode"
        ],
        "parent": "js"
      }
    },
    "proxy": {
      "type": "Article",
      "value": {
        "title": "Proxy 和 Reflect",
        "slug": "proxy",
        "githubPath": "/1-js/99-js-misc/01-proxy",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n一个 `Proxy` 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。\n\nProxy 被用于了许多库和某些浏览器框架。在本文中，我们将看到许多实际应用。\n\n## Proxy\n\n语法：\n\n```js\nlet proxy = new Proxy(target, handler)\n```\n\n- `target` —— 是要包装的对象，可以是任何东西，包括函数。\n- `handler` —— 代理配置：带有“捕捉器”（\"traps\"，即拦截操作的方法）的对象。比如 `get` 捕捉器用于读取 `target` 的属性，`set` 捕捉器用于写入 `target` 的属性，等等。\n\n对 `proxy` 进行操作，如果在 `handler` 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。\n\n首先，让我们创建一个没有任何捕捉器的代理（Proxy）：\n\n```js run\nlet target = {};\nlet proxy = new Proxy(target, {}); // 空的 handler 对象\n\nproxy.test = 5; // 写入 proxy 对象 (1)\nalert(target.test); // 5，test 属性出现在了 target 中！\n\nalert(proxy.test); // 5，我们也可以从 proxy 对象读取它 (2)\n\nfor(let key in proxy) alert(key); // test，迭代也正常工作 (3)\n```\n\n由于没有捕捉器，所有对 `proxy` 的操作都直接转发给了 `target`。\n\n1. 写入操作 `proxy.test=` 会将值写入 `target`。\n2. 读取操作 `proxy.test` 会从 `target` 返回对应的值。\n3. 迭代 `proxy` 会从 `target` 返回对应的值。\n\n我们可以看到，没有任何捕捉器，`proxy` 是一个 `target` 的透明包装器（wrapper）。\n\n![](proxy.svg)\n\n`Proxy` 是一种特殊的“奇异对象（exotic object）”。它没有自己的属性。如果 `handler` 为空，则透明地将操作转发给 `target`。\n\n要激活更多功能，让我们添加捕捉器。\n\n我们可以用它们拦截什么？\n\n对于对象的大多数操作，JavaScript 规范中有一个所谓的“内部方法”，它描述了最底层的工作方式。例如 `[[Get]]`，用于读取属性的内部方法，`[[Set]]`，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。\n\nProxy 捕捉器会拦截这些方法的调用。它们在 [proxy 规范](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots) 和下表中被列出。\n\n对于每个内部方法，此表中都有一个捕捉器：可用于添加到 `new Proxy` 的 `handler` 参数中以拦截操作的方法名称：\n\n| 内部方法 | Handler 方法 | 何时触发 |\n|-----------------|----------------|-------------|\n| `[[Get]]` | `get` | 读取属性 |\n| `[[Set]]` | `set` | 写入属性 |\n| `[[HasProperty]]` | `has` | `in` 操作符 |\n| `[[Delete]]` | `deleteProperty` | `delete` 操作符 |\n| `[[Call]]` | `apply` | 函数调用 |\n| `[[Construct]]` | `construct` | `new` 操作符 |\n| `[[GetPrototypeOf]]` | `getPrototypeOf` | [Object.getPrototypeOf](mdn:/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) |\n| `[[SetPrototypeOf]]` | `setPrototypeOf` | [Object.setPrototypeOf](mdn:/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) |\n| `[[IsExtensible]]` | `isExtensible` | [Object.isExtensible](mdn:/JavaScript/Reference/Global_Objects/Object/isExtensible) |\n| `[[PreventExtensions]]` | `preventExtensions` | [Object.preventExtensions](mdn:/JavaScript/Reference/Global_Objects/Object/preventExtensions) |\n| `[[DefineOwnProperty]]` | `defineProperty` | [Object.defineProperty](mdn:/JavaScript/Reference/Global_Objects/Object/defineProperty), [Object.defineProperties](mdn:/JavaScript/Reference/Global_Objects/Object/defineProperties) |\n| `[[GetOwnProperty]]` | `getOwnPropertyDescriptor` | [Object.getOwnPropertyDescriptor](mdn:/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor), `for..in`, `Object.keys/values/entries` |\n| `[[OwnPropertyKeys]]` | `ownKeys` | [Object.getOwnPropertyNames](mdn:/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames), [Object.getOwnPropertySymbols](mdn:/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols), `for..in`, `Object.keys/values/entries` |\n\n```warn header=\"不变量（Invariant）\"\nJavaScript 强制执行某些不变量 —— 内部方法和捕捉器必须满足的条件。\n\n其中大多数用于返回值：\n- `[[Set]]` 如果值已成功写入，则必须返回 `true`，否则返回 `false`。\n- `[[Delete]]` 如果已成功删除该值，则必须返回 `true`，否则返回 `false`。\n- ……依此类推，我们将在下面的示例中看到更多内容。\n\n还有其他一些不变量，例如：\n- 应用于代理（proxy）对象的 `[[GetPrototypeOf]]`，必须返回与应用于被代理对象的 `[[GetPrototypeOf]]` 相同的值。换句话说，读取代理对象的原型必须始终返回被代理对象的原型。\n\n捕捉器可以拦截这些操作，但是必须遵循上面这些规则。\n\n不变量确保语言功能的正确和一致的行为。完整的不变量列表在 [规范](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots) 中。如果你不做奇怪的事情，你可能就不会违反它们。\n```\n\n让我们来看看它们是如何在实际示例中工作的。\n\n## 带有 \"get\" 捕捉器的默认值\n\n最常见的捕捉器是用于读取/写入的属性。\n\n要拦截读取操作，`handler` 应该有 `get(target, property, receiver)` 方法。\n\n读取属性时触发该方法，参数如下：\n\n- `target` —— 是目标对象，该对象被作为第一个参数传递给 `new Proxy`，\n- `property` —— 目标属性名，\n- `receiver` —— 如果目标属性是一个 getter 访问器属性，则 `receiver` 就是本次读取属性所在的 `this` 对象。通常，这就是 `proxy` 对象本身（或者，如果我们从 proxy 继承，则是从该 proxy 继承的对象）。现在我们不需要此参数，因此稍后我们将对其进行详细介绍。\n\n让我们用 `get` 来实现一个对象的默认值。\n\n我们将创建一个对不存在的数组项返回 `0` 的数组。\n\n通常，当人们尝试获取不存在的数组项时，他们会得到 `undefined`，但是我们在这将常规数组包装到代理（proxy）中，以捕获读取操作，并在没有要读取的属性的时返回 `0`：\n\n```js run\nlet numbers = [0, 1, 2];\n\nnumbers = new Proxy(numbers, {\n  get(target, prop) {\n    if (prop in target) {\n      return target[prop];\n    } else {\n      return 0; // 默认值\n    }\n  }\n});\n\n*!*\nalert( numbers[1] ); // 1\nalert( numbers[123] ); // 0（没有这个数组项）\n*/!*\n```\n\n正如我们所看到的，使用 `get` 捕捉器很容易实现。\n\n我们可以用 `Proxy` 来实现“默认”值的任何逻辑。\n\n想象一下，我们有一本词典，上面有短语及其翻译：\n\n```js run\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\nalert( dictionary['Hello'] ); // Hola\nalert( dictionary['Welcome'] ); // undefined\n```\n\n现在，如果没有我们要读取的短语，那么从 `dictionary` 读取它将返回 `undefined`。但实际上，返回一个未翻译的短语通常比 `undefined` 要好。因此，让我们在这种情况下返回一个未翻译的短语来替代 `undefined`。\n\n为此，我们将把 `dictionary` 包装进一个拦截读取操作的代理：\n\n```js run\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\ndictionary = new Proxy(dictionary, {\n*!*\n  get(target, phrase) { // 拦截读取属性操作\n*/!*\n    if (phrase in target) { //如果词典中有该短语\n      return target[phrase]; // 返回其翻译\n    } else {\n      // 否则返回未翻译的短语\n      return phrase;\n    }\n  }\n});\n\n// 在词典中查找任意短语！\n// 最坏的情况也只是它们没有被翻译。\nalert( dictionary['Hello'] ); // Hola\n*!*\nalert( dictionary['Welcome to Proxy']); // Welcome to Proxy（没有被翻译）\n*/!*\n```\n\n````smart\n请注意代理如何覆盖变量：\n\n```js\ndictionary = new Proxy(dictionary, ...);\n```\n\n代理应该在所有地方都完全替代目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。\n````\n\n## 使用 \"set\" 捕捉器进行验证\n\n假设我们想要一个专门用于数字的数组。如果添加了其他类型的值，则应该抛出一个错误。\n\n当写入属性时 `set` 捕捉器被触发。\n\n`set(target, property, value, receiver)`：\n\n- `target` —— 是目标对象，该对象被作为第一个参数传递给 `new Proxy`，\n- `property` —— 目标属性名称，\n- `value` —— 目标属性的值，\n- `receiver` —— 与 `get` 捕捉器类似，仅与 setter 访问器属性相关。\n\n如果写入操作（setting）成功，`set` 捕捉器应该返回 `true`，否则返回 `false`（触发 `TypeError`）。\n\n让我们用它来验证新值：\n\n```js run\nlet numbers = [];\n\nnumbers = new Proxy(numbers, { // (*)\n*!*\n  set(target, prop, val) { // 拦截写入属性操作\n*/!*\n    if (typeof val == 'number') {\n      target[prop] = val;\n      return true;\n    } else {\n      return false;\n    }\n  }\n});\n\nnumbers.push(1); // 添加成功\nnumbers.push(2); // 添加成功\nalert(\"Length is: \" + numbers.length); // 2\n\n*!*\nnumbers.push(\"test\"); // TypeError（proxy 的 'set' 返回 false）\n*/!*\n\nalert(\"This line is never reached (error in the line above)\");\n```\n\n请注意：数组的内建方法依然有效！值被使用 `push` 方法添加到数组。当值被添加到数组后，数组的 `length` 属性会自动增加。我们的代理对象 proxy 不会破坏任何东西。\n\n我们不必重写诸如 `push` 和 `unshift` 等添加元素的数组方法，就可以在其中添加检查，因为在内部它们使用代理所拦截的 `[[Set]]` 操作。\n\n因此，代码简洁明了。\n\n```warn header=\"别忘了返回 `true`\"\n如上所述，要保持不变量。\n\n对于 `set` 操作，它必须在成功写入时返回 `true`。\n\n如果我们忘记这样做，或返回任何假（falsy）值，则该操作将触发 `TypeError`。\n```\n\n## 使用 \"ownKeys\" 和 \"getOwnPropertyDescriptor\" 进行迭代\n\n`Object.keys`，`for..in` 循环和大多数其他遍历对象属性的方法都使用内部方法 `[[OwnPropertyKeys]]`（由 `ownKeys` 捕捉器拦截) 来获取属性列表。\n\n这些方法在细节上有所不同：\n- `Object.getOwnPropertyNames(obj)` 返回非 symbol 键。\n- `Object.getOwnPropertySymbols(obj)` 返回 symbol 键。\n- `Object.keys/values()` 返回带有 `enumerable` 标志的非 symbol 键/值（属性标志在 <info:property-descriptors> 一章有详细讲解)。\n- `for..in` 循环遍历所有带有 `enumerable` 标志的非 symbol 键，以及原型对象的键。\n\n……但是所有这些都从该列表开始。\n\n在下面这个示例中，我们使用 `ownKeys` 捕捉器拦截 `for..in` 对 `user` 的遍历，并使用 `Object.keys` 和 `Object.values` 来跳过以下划线 `_` 开头的属性：\n\n```js run\nlet user = {\n  name: \"John\",\n  age: 30,\n  _password: \"***\"\n};\n\nuser = new Proxy(user, {\n*!*\n  ownKeys(target) {\n*/!*\n    return Object.keys(target).filter(key => !key.startsWith('_'));\n  }\n});\n\n// \"ownKeys\" 过滤掉了 _password\nfor(let key in user) alert(key); // name，然后是 age\n\n// 对这些方法的效果相同：\nalert( Object.keys(user) ); // name,age\nalert( Object.values(user) ); // John,30\n```\n\n到目前为止，它仍然有效。\n\n尽管如此，但如果我们返回对象中不存在的键，`Object.keys` 并不会列出这些键：\n\n```js run\nlet user = { };\n\nuser = new Proxy(user, {\n*!*\n  ownKeys(target) {\n*/!*\n    return ['a', 'b', 'c'];\n  }\n});\n\nalert( Object.keys(user) ); // <empty>\n```\n\n为什么？原因很简单：`Object.keys` 仅返回带有 `enumerable` 标志的属性。为了检查它，该方法会对每个属性调用内部方法 `[[GetOwnProperty]]` 来获取 [它的描述符（descriptor）](info:property-descriptors)。在这里，由于没有属性，其描述符为空，没有 `enumerable` 标志，因此它被略过。\n\n为了让 `Object.keys` 返回一个属性，我们需要它要么存在于带有 `enumerable` 标志的对象，要么我们可以拦截对 `[[GetOwnProperty]]` 的调用（捕捉器 `getOwnPropertyDescriptor` 可以做到这一点)，并返回带有 `enumerable: true` 的描述符。\n\n这是关于此的一个例子：\n\n```js run\nlet user = { };\n\nuser = new Proxy(user, {\n  ownKeys(target) { // 一旦要获取属性列表就会被调用\n    return ['a', 'b', 'c'];\n  },\n\n  getOwnPropertyDescriptor(target, prop) { // 被每个属性调用\n    return {\n      enumerable: true,\n      configurable: true\n      /* ...其他标志，可能是 \"value:...\" */\n    };\n  }\n\n});\n\nalert( Object.keys(user) ); // a, b, c\n```\n\n让我们再次注意：如果该属性在对象中不存在，那么我们只需要拦截 `[[GetOwnProperty]]`。\n\n## 具有 \"deleteProperty\" 和其他捕捉器的受保护属性\n\n有一个普遍的约定，即以下划线 `_` 开头的属性和方法是内部的。不应从对象外部访问它们。\n\n从技术上讲，我们也是能访问到这样的属性的：\n\n```js run\nlet user = {\n  name: \"John\",\n  _password: \"secret\"\n};\n\nalert(user._password); // secret\n```\n\n让我们使用代理来防止对以 `_` 开头的属性的任何访问。\n\n我们将需要以下捕捉器：\n- `get` 读取此类属性时抛出错误，\n- `set` 写入属性时抛出错误，\n- `deleteProperty` 删除属性时抛出错误，\n- `ownKeys` 在使用 `for..in` 和像 `Object.keys` 这样的的方法时排除以 `_` 开头的属性。\n\n代码如下：\n\n```js run\nlet user = {\n  name: \"John\",\n  _password: \"***\"\n};\n\nuser = new Proxy(user, {\n*!*\n  get(target, prop) {\n*/!*\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    }\n    let value = target[prop];\n    return (typeof value === 'function') ? value.bind(target) : value; // (*)\n  },\n*!*\n  set(target, prop, val) { // 拦截属性写入\n*/!*\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      target[prop] = val;\n      return true;\n    }\n  },\n*!*\n  deleteProperty(target, prop) { // 拦截属性删除\n*/!*\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      delete target[prop];\n      return true;\n    }\n  },\n*!*\n  ownKeys(target) { // 拦截读取属性列表\n*/!*\n    return Object.keys(target).filter(key => !key.startsWith('_'));\n  }\n});\n\n// \"get\" 不允许读取 _password\ntry {\n  alert(user._password); // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"set\" 不允许写入 _password\ntry {\n  user._password = \"test\"; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"deleteProperty\" 不允许删除 _password\ntry {\n  delete user._password; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"ownKeys\" 将 _password 过滤出去\nfor(let key in user) alert(key); // name\n```\n\n请注意在 `(*)` 行中 `get` 捕捉器的重要细节：\n\n```js\nget(target, prop) {\n  // ...\n  let value = target[prop];\n*!*\n  return (typeof value === 'function') ? value.bind(target) : value; // (*)\n*/!*\n}\n```\n\n为什么我们需要一个函数去调用 `value.bind(target)`？\n\n原因是对象方法（例如 `user.checkPassword()`）必须能够访问 `_password`：\n\n```js\nuser = {\n  // ...\n  checkPassword(value) {\n    //对象方法必须能读取 _password\n    return value === this._password;\n  }\n}\n```\n\n\n对 `user.checkPassword()` 的调用会将被代理的对象 `user` 作为 `this`（点符号之前的对象会成为 `this`），因此，当它尝试访问 `this._password` 时，`get` 捕捉器将激活（在任何属性读取时，它都会被触发）并抛出错误。\n\n因此，我们在 `(*)` 行中将对象方法的上下文绑定到原始对象 `target`。然后，它们将来的调用将使用 `target` 作为 `this`，不会触发任何捕捉器。\n\n该解决方案通常可行，但并不理想，因为一个方法可能会将未被代理的对象传递到其他地方，然后我们就会陷入困境：原始对象在哪里，被代理的对象在哪里？\n\n此外，一个对象可能会被代理多次（多个代理可能会对该对象添加不同的“调整”），并且如果我们将未包装的对象传递给方法，则可能会产生意想不到的后果。\n\n因此，在任何地方都不应使用这种代理。\n\n```smart header=\"类的私有属性\"\n现代 JavaScript 引擎原生支持 class 中的私有属性，这些私有属性以 `#` 为前缀。它们在 <info:private-protected-properties-methods> 一章中有详细描述。无需代理（proxy）。\n\n但是，此类属性有其自身的问题。特别是，它们是不可继承的。\n```\n\n## 带有 \"has\" 捕捉器的 \"in range\"\n\n让我们来看更多示例。\n\n我们有一个 range 对象：\n\n```js\nlet range = {\n  start: 1,\n  end: 10\n};\n```\n\n我们想使用 `in` 操作符来检查一个数字是否在 `range` 范围内。\n\n`has` 捕捉器会拦截 `in` 调用。\n\n`has(target, property)`\n\n- `target` —— 是目标对象，被作为第一个参数传递给 `new Proxy`，\n- `property` —— 属性名称。\n\n示例如下\n\n```js run\nlet range = {\n  start: 1,\n  end: 10\n};\n\nrange = new Proxy(range, {\n*!*\n  has(target, prop) {\n*/!*\n    return prop >= target.start && prop <= target.end;\n  }\n});\n\n*!*\nalert(5 in range); // true\nalert(50 in range); // false\n*/!*\n```\n\n漂亮的语法糖，不是吗？而且实现起来非常简单。\n\n## 包装函数：\"apply\" [#proxy-apply]\n\n我们也可以将代理（proxy）包装在函数周围。\n\n`apply(target, thisArg, args)` 捕捉器能使代理以函数的方式被调用：\n\n- `target` 是目标对象（在 JavaScript 中，函数就是一个对象），\n- `thisArg` 是 `this` 的值。\n- `args` 是参数列表。\n\n例如，让我们回忆一下我们在 <info:call-apply-decorators> 一章中所讲的 `delay(f, ms)` 装饰器。\n\n在该章中，我们没有用 proxy 来实现它。调用 `delay(f, ms)` 会返回一个函数，该函数会在 `ms` 毫秒后把所有调用转发给 `f`。\n\n这是以前的基于函数的实现：\n\n```js run\nfunction delay(f, ms) {\n  // 返回一个包装器（wrapper），该包装器将在时间到了的时候将调用转发给函数 f\n  return function() { // (*)\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// 在进行这个包装后，sayHi 函数会被延迟 3 秒后被调用\nsayHi = delay(sayHi, 3000);\n\nsayHi(\"John\"); // Hello, John! (after 3 seconds)\n```\n\n正如我们所看到的那样，大多数情况下它都是可行的。包装函数 `(*)` 在到达延迟的时间后后执行调用。\n\n但是包装函数不会转发属性读取/写入操作或者任何其他操作。进行包装后，就失去了对原始函数属性的访问，例如 `name`，`length` 和其他属性：\n\n```js run\nfunction delay(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n*!*\nalert(sayHi.length); // 1（函数的 length 是函数声明中的参数个数）\n*/!*\n\nsayHi = delay(sayHi, 3000);\n\n*!*\nalert(sayHi.length); // 0（在包装器声明中，参数个数为 0)\n*/!*\n```\n\n`Proxy` 的功能要强大得多，因为它可以将所有东西转发到目标对象。\n\n让我们使用 `Proxy` 来替换掉包装函数：\n\n```js run\nfunction delay(f, ms) {\n  return new Proxy(f, {\n    apply(target, thisArg, args) {\n      setTimeout(() => target.apply(thisArg, args), ms);\n    }\n  });\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nsayHi = delay(sayHi, 3000);\n\n*!*\nalert(sayHi.length); // 1 (*) proxy 将“获取 length”的操作转发给目标对象\n*/!*\n\nsayHi(\"John\"); // Hello, John!（3 秒后）\n```\n\n结果是相同的，但现在不仅仅调用，而且代理上的所有操作都能被转发到原始函数。所以在 `(*)` 行包装后的 `sayHi.length` 会返回正确的结果。\n\n我们得到了一个“更丰富”的包装器。\n\n还存在其他捕捉器：完整列表在本文的开头。它们的使用模式与上述类似。\n\n## Reflect\n\n`Reflect` 是一个内建对象，可简化 `Proxy` 的创建。\n\n前面所讲过的内部方法，例如 `[[Get]]` 和 `[[Set]]` 等，都只是规范性的，不能直接调用。\n\n`Reflect` 对象使调用这些内部方法成为了可能。它的方法是内部方法的最小包装。\n\n以下是执行相同操作和 `Reflect` 调用的示例：\n\n| 操作 |  `Reflect` 调用 | 内部方法 |\n|-----------------|----------------|-------------|\n| `obj[prop]` | `Reflect.get(obj, prop)` | `[[Get]]` |\n| `obj[prop] = value` | `Reflect.set(obj, prop, value)` | `[[Set]]` |\n| `delete obj[prop]` | `Reflect.deleteProperty(obj, prop)` | `[[Delete]]` |\n| `new F(value)` | `Reflect.construct(F, value)` | `[[Construct]]` |\n| ... | ... | ... |\n\n例如：\n\n```js run\nlet user = {};\n\nReflect.set(user, 'name', 'John');\n\nalert(user.name); // John\n```\n\n尤其是，`Reflect` 允许我们将操作符（`new`，`delete`，……）作为函数（`Reflect.construct`，`Reflect.deleteProperty`，……）执行调用。这是一个有趣的功能，但是这里还有一点很重要。\n\n**对于每个可被 `Proxy` 捕获的内部方法，在 `Reflect` 中都有一个对应的方法，其名称和参数与 `Proxy` 捕捉器相同。**\n\n所以，我们可以使用 `Reflect` 来将操作转发给原始对象。\n\n在下面这个示例中，捕捉器 `get` 和 `set` 均透明地（好像它们都不存在一样）将读取/写入操作转发到对象，并显示一条消息：\n\n```js run\nlet user = {\n  name: \"John\",\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    alert(`GET ${prop}`);\n*!*\n    return Reflect.get(target, prop, receiver); // (1)\n*/!*\n  },\n  set(target, prop, val, receiver) {\n    alert(`SET ${prop}=${val}`);\n*!*\n    return Reflect.set(target, prop, val, receiver); // (2)\n*/!*\n  }\n});\n\nlet name = user.name; // 显示 \"GET name\"\nuser.name = \"Pete\"; // 显示 \"SET name=Pete\"\n```\n\n这里：\n\n- `Reflect.get` 读取一个对象属性。\n- `Reflect.set` 写入一个对象属性，如果写入成功则返回 `true`，否则返回 `false`。\n\n这样，一切都很简单：如果一个捕捉器想要将调用转发给对象，则只需使用相同的参数调用 `Reflect.<method>` 就足够了。\n\n在大多数情况下，我们可以不使用 `Reflect` 完成相同的事情，例如，用于读取属性的 `Reflect.get(target, prop, receiver)` 可以被替换为 `target[prop]`。尽管有一些细微的差别。\n\n### 代理一个 getter\n\n让我们看一个示例，来说明为什么 `Reflect.get` 更好。此外，我们还将看到为什么 `get/set` 有第三个参数 `receiver`，而且我们之前从来没有使用过它。\n\n我们有一个带有 `_name` 属性和 getter 的对象 `user`。\n\n这是对 `user` 对象的一个代理：\n\n```js run\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\n*!*\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop];\n  }\n});\n*/!*\n\nalert(userProxy.name); // Guest\n```\n\n其 `get` 捕捉器在这里是“透明的”，它返回原来的属性，不会做任何其他的事。这对于我们的示例而言就足够了。\n\n一切似乎都很好。但是让我们将示例变得稍微复杂一点。\n\n另一个对象 `admin` 从 `user` 继承后，我们可以观察到错误的行为：\n\n```js run\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop]; // (*) target = user\n  }\n});\n\n*!*\nlet admin = {\n  __proto__: userProxy,\n  _name: \"Admin\"\n};\n\n// 期望输出：Admin\nalert(admin.name); // 输出：Guest (?!?)\n*/!*\n```\n\n读取 `admin.name` 应该返回 `\"Admin\"`，而不是 `\"Guest\"`！\n\n发生了什么？或许我们在继承方面做错了什么？\n\n但是，如果我们移除代理，那么一切都会按预期进行。\n\n问题实际上出在代理中，在 `(*)` 行。\n\n1. 当我们读取 `admin.name` 时，由于 `admin` 对象自身没有对应的的属性，搜索将转到其原型。\n2. 原型是 `userProxy`。\n3. 从代理读取 `name` 属性时，`get` 捕捉器会被触发，并从原始对象返回 `target[prop]` 属性，在 `(*)` 行。\n\n    当调用 `target[prop]` 时，若 `prop` 是一个 getter，它将在 `this=target` 上下文中运行其代码。因此，结果是来自原始对象 `target` 的 `this._name`，即来自 `user`。\n\n为了解决这种情况，我们需要 `get` 捕捉器的第三个参数 `receiver`。它保证将正确的 `this` 传递给 getter。在我们的例子中是 `admin`。\n\n如何把上下文传递给 getter？对于一个常规函数，我们可以使用 `call/apply`，但这是一个 getter，它不能“被调用”，只能被访问。\n\n`Reflect.get` 可以做到。如果我们使用它，一切都会正常运行。\n\n这是更正后的变体：\n\n```js run\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) { // receiver = admin\n*!*\n    return Reflect.get(target, prop, receiver); // (*)\n*/!*\n  }\n});\n\n\nlet admin = {\n  __proto__: userProxy,\n  _name: \"Admin\"\n};\n\n*!*\nalert(admin.name); // Admin\n*/!*\n```\n\n现在 `receiver` 保留了对正确 `this` 的引用（即 `admin`），该引用是在 `(*)` 行中被通过 `Reflect.get` 传递给 getter 的。\n\n我们可以把捕捉器重写得更短：\n\n```js\nget(target, prop, receiver) {\n  return Reflect.get(*!*...arguments*/!*);\n}\n```\n\n\n`Reflect` 调用的命名与捕捉器的命名完全相同，并且接受相同的参数。它们是以这种方式专门设计的。\n\n因此，`return Reflect...` 提供了一个安全的方式，可以轻松地转发操作，并确保我们不会忘记与此相关的任何内容。\n\n## Proxy 的局限性\n\n代理提供了一种独特的方法，可以在最底层更改或调整现有对象的行为。但是，它并不完美。有局限性。\n\n### 内建对象：内部插槽（Internal slot）\n\n许多内建对象，例如 `Map`，`Set`，`Date`，`Promise` 等，都使用了所谓的“内部插槽”。\n\n它们类似于属性，但仅限于内部使用，仅用于规范目的。例如，`Map` 将项目（item）存储在 `[[MapData]]` 中。内建方法可以直接访问它们，而不通过 `[[Get]]/[[Set]]` 内部方法。所以 `Proxy` 无法拦截它们。\n\n为什么要在意这些呢？毕竟它们是内部的！\n\n好吧，问题在这儿。在类似这样的内建对象被代理后，代理对象没有这些内部插槽，因此内建方法将会失败。\n\n例如：\n\n```js run\nlet map = new Map();\n\nlet proxy = new Proxy(map, {});\n\n*!*\nproxy.set('test', 1); // Error\n*/!*\n```\n\n在内部，一个 `Map` 将所有数据存储在其 `[[MapData]]` 内部插槽中。代理对象没有这样的插槽。[内建方法 `Map.prototype.set`](https://tc39.es/ecma262/#sec-map.prototype.set) 方法试图访问内部属性 `this.[[MapData]]`，但由于 `this=proxy`，在 `proxy` 中无法找到它，只能失败。\n\n幸运的是，这有一种解决方法：\n\n```js run\nlet map = new Map();\n\nlet proxy = new Proxy(map, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n*!*\n    return typeof value == 'function' ? value.bind(target) : value;\n*/!*\n  }\n});\n\nproxy.set('test', 1);\nalert(proxy.get('test')); // 1（工作了！）\n```\n\n现在它正常工作了，因为 `get` 捕捉器将函数属性（例如 `map.set`）绑定到了目标对象（`map`）本身。\n\n与前面的示例不同，`proxy.set(...)` 内部 `this` 的值并不是 `proxy`，而是原始的 `map`。因此，当`set` 捕捉器的内部实现尝试访问 `this.[[MapData]]` 内部插槽时，它会成功。\n\n```smart header=\"`Array` 没有内部插槽\"\n一个值得注意的例外：内建 `Array` 没有使用内部插槽。那是出于历史原因，因为它出现于很久以前。\n\n所以，代理数组时没有这种问题。\n```\n\n### 私有字段\n\n类的私有字段也会发生类似的情况。\n\n例如，`getName()` 方法访问私有的 `#name` 属性，并在代理后中断：\n\n```js run\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {});\n\n*!*\nalert(user.getName()); // Error\n*/!*\n```\n\n原因是私有字段是通过内部插槽实现的。JavaScript 在访问它们时不使用 `[[Get]]/[[Set]]`。\n\n在调用 `getName()` 时，`this` 的值是代理后的 `user`，它没有带有私有字段的插槽。\n\n再次，带有 `bind` 方法的解决方案使它恢复正常：\n\n```js run\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n    return typeof value == 'function' ? value.bind(target) : value;\n  }\n});\n\nalert(user.getName()); // Guest\n```\n\n如前所述，该解决方案也有缺点：它将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能。\n\n### Proxy != target\n\n代理和原始对象是不同的对象。这很自然，对吧？\n\n所以，如果我们使用原始对象作为键，然后对其进行代理，之后却无法找到代理了：\n\n```js run\nlet allUsers = new Set();\n\nclass User {\n  constructor(name) {\n    this.name = name;\n    allUsers.add(this);\n  }\n}\n\nlet user = new User(\"John\");\n\nalert(allUsers.has(user)); // true\n\nuser = new Proxy(user, {});\n\n*!*\nalert(allUsers.has(user)); // false\n*/!*\n```\n\n如我们所见，进行代理后，我们在 `allUsers` 中找不到 `user`，因为代理是一个不同的对象。\n\n```warn header=\"Proxy 无法拦截严格相等性检查 `===`\"\nProxy 可以拦截许多操作符，例如 `new`（使用 `construct`），`in`（使用 `has`），`delete`（使用 `deleteProperty`）等。\n\n但是没有办法拦截对于对象的严格相等性检查。一个对象只严格等于其自身，没有其他值。\n\n因此，比较对象是否相等的所有操作和内建类都会区分对象和代理。这里没有透明的替代品。\n```\n\n## 可撤销 Proxy\n\n一个 **可撤销** 的代理是可以被禁用的代理。\n\n假设我们有一个资源，并且想随时关闭对该资源的访问。\n\n我们可以做的是将它包装成可一个撤销的代理，没有任何捕捉器。这样的代理会将操作转发给对象，并且我们可以随时将其禁用。\n\n语法为：\n\n```js\nlet {proxy, revoke} = Proxy.revocable(target, handler)\n```\n\n该调用返回一个带有 `proxy` 和 `revoke` 函数的对象以将其禁用。\n\n这是一个例子：\n\n```js run\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\n// 将 proxy 传递到其他某处，而不是对象...\nalert(proxy.data); // Valuable data\n\n// 稍后，在我们的代码中\nrevoke();\n\n// proxy 不再工作（revoked）\nalert(proxy.data); // Error\n```\n\n对 `revoke()` 的调用会从代理中删除对目标对象的所有内部引用，因此它们之间再无连接。\n\n最初，`revoke` 与 `proxy` 是分开的，因此我们可以传递 `proxy`，同时将 `revoke` 留在当前范围内。\n\n我们也可以通过设置 `proxy.revoke = revoke` 来将 `revoke` 绑定到 `proxy`。\n\n另一种选择是创建一个 `WeakMap`，其中 `proxy` 作为键，相应的 `revoke` 作为值，这样可以轻松找到 `proxy` 所对应的 `revoke`：\n\n```js run\n*!*\nlet revokes = new WeakMap();\n*/!*\n\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\nrevokes.set(proxy, revoke);\n\n// ...我们代码中的其他位置...\nrevoke = revokes.get(proxy);\nrevoke();\n\nalert(proxy.data); // Error（revoked）\n```\n\n此处我们使用 `WeakMap` 而不是 `Map`，因为它不会阻止垃圾回收。如果一个代理对象变得“不可访问”（例如，没有变量再引用它），则 `WeakMap` 允许将其与它的 `revoke` 一起从内存中清除，因为我们不再需要它了。\n\n## 参考资料\n\n- 规范：[Proxy](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots)。\n- MDN：[Proxy](mdn:/JavaScript/Reference/Global_Objects/Proxy)。\n\n## 总结\n\n`Proxy` 是对象的包装器，将代理上的操作转发到对象，并可以选择捕获其中一些操作。\n\n它可以包装任何类型的对象，包括类和函数。\n\n语法为：\n\n```js\nlet proxy = new Proxy(target, {\n  /* trap */\n});\n```\n\n……然后，我们应该在所有地方使用 `proxy` 而不是 `target`。代理没有自己的属性或方法。如果提供了捕捉器（trap），它将捕获操作，否则会将其转发给 `target` 对象。\n\n我们可以捕获：\n- 读取（`get`），写入（`set`），删除（`deleteProperty`）属性（甚至是不存在的属性）。\n- 函数调用（`apply` 捕捉器）。\n- `new` 操作（`construct` 捕捉器）。\n- 许多其他操作（完整列表请见本文开头部分和 [docs](mdn:/JavaScript/Reference/Global_Objects/Proxy)）。\n\n这使我们能够创建“虚拟”属性和方法，实现默认值，可观察对象，函数装饰器等。\n\n我们还可以将对象多次包装在不同的代理中，并用多个各个方面的功能对其进行装饰。\n\n[Reflect](mdn:/JavaScript/Reference/Global_Objects/Reflect) API 旨在补充 [Proxy](mdn:/JavaScript/Reference/Global_Objects/Proxy)。对于任意 `Proxy` 捕捉器，都有一个带有相同参数的 `Reflect` 调用。我们应该使用它们将调用转发给目标对象。\n\nProxy 有一些局限性：\n\n- 内建对象具有“内部插槽”，对这些对象的访问无法被代理。请参阅上文中的解决方法。\n- 私有类字段也是如此，因为它们也是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象作为 `this` 才能访问它们。\n- 对象的严格相等性检查 `===` 无法被拦截。\n- 性能：基准测试（benchmark）取决于引擎，但通常使用最简单的代理访问属性所需的时间也要长几倍。实际上，这仅对某些“瓶颈”对象来说才重要。",
        "libs": [],
        "children": [
          "error-nonexisting",
          "array-negative",
          "observable"
        ],
        "parent": "js-misc",
        "updatedAt": 1661136694
      }
    },
    "error-nonexisting": {
      "type": "Task",
      "value": {
        "title": "读取不存在的属性时出错",
        "slug": "error-nonexisting",
        "githubPath": "/1-js/99-js-misc/01-proxy/01-error-nonexisting",
        "weight": 1,
        "libs": [],
        "content": "\n\n通常，尝试读取不存在的属性会返回 `undefined`。\n\n创建一个代理，在尝试读取不存在的属性时，该代理抛出一个错误。\n\n这可以帮助及早发现编程错误。\n\n编写一个函数 `wrap(target)`，该函数接受一个 `target` 对象，并返回添加此方面功能的代理（proxy）。\n\n其工作方式应如下：\n\n```js\nlet user = {\n  name: \"John\"\n};\n\nfunction wrap(target) {\n  return new Proxy(target, {\n*!*\n      /* 你的代码 */\n*/!*\n  });\n}\n\nuser = wrap(user);\n\nalert(user.name); // John\n*!*\nalert(user.age); // ReferenceError: Property doesn't exist: \"age\"\n*/!*\n```",
        "solution": "```js run\nlet user = {\n  name: \"John\"\n};\n\nfunction wrap(target) {\n  return new Proxy(target, {\n    get(target, prop, receiver) {\n      if (prop in target) {\n        return Reflect.get(target, prop, receiver);\n      } else {\n        throw new ReferenceError(`Property doesn't exist: \"${prop}\"`)\n      }\n    }\n  });\n}\n\nuser = wrap(user);\n\nalert(user.name); // John\nalert(user.age); // ReferenceError: Property doesn't exist: \"age\"\n```",
        "parent": "proxy",
        "version": 1
      }
    },
    "array-negative": {
      "type": "Task",
      "value": {
        "title": "访问 array[-1]",
        "slug": "array-negative",
        "githubPath": "/1-js/99-js-misc/01-proxy/02-array-negative",
        "weight": 2,
        "libs": [],
        "content": "\n\n在某些编程语言中，我们可以使用从尾端算起的负值索引访问数组元素。\n\n像这样：\n\n```js\nlet array = [1, 2, 3];\n\narray[-1]; // 3，最后一个元素\narray[-2]; // 2，从尾端开始向前移动一步\narray[-3]; // 1，从尾端开始向前移动两步\n```\n\n换句话说，`array[-N]` 与 `array[array.length - N]` 相同。\n\n创建一个 proxy 来实现该行为。\n\n其工作方式应如下：\n\n```js\nlet array = [1, 2, 3];\n\narray = new Proxy(array, {\n  /* 你的代码 */\n});\n\nalert( array[-1] ); // 3\nalert( array[-2] ); // 2\n\n// 其他数组功能应保持“原样”\n```",
        "solution": "```js run\nlet array = [1, 2, 3];\n\narray = new Proxy(array, {\n  get(target, prop, receiver) {\n    if (prop < 0) {\n      // 即使我们像 arr[1] 这样访问它\n      // prop 是一个字符串，所以我们需要将其转换成数字\n      prop = +prop + target.length;\n    }\n    return Reflect.get(target, prop, receiver);\n  }\n});\n\n\nalert(array[-1]); // 3\nalert(array[-2]); // 2\n```",
        "parent": "proxy",
        "version": 1
      }
    },
    "observable": {
      "type": "Task",
      "value": {
        "title": "可观察的（Observable）",
        "slug": "observable",
        "githubPath": "/1-js/99-js-misc/01-proxy/03-observable",
        "weight": 3,
        "libs": [],
        "content": "\n\n创建一个函数 `makeObservable(target)`，该函数通过返回一个代理“使得对象可观察”。\n\n其工作方式如下：\n\n```js run\nfunction makeObservable(target) {\n  /* 你的代码 */\n}\n\nlet user = {};\nuser = makeObservable(user);\n\nuser.observe((key, value) => {\n  alert(`SET ${key}=${value}`);\n});\n\nuser.name = \"John\"; // alerts: SET name=John\n```\n\n换句话说，`makeObservable` 返回的对象就像原始对象一样，但是具有 `observe(handler)` 方法，该方法可以将 `handler` 函数设置为在任何属性被更改时，都会被调用的函数。\n\n每当有属性被更改时，都会使用属性的名称和属性值调用 `handler(key, value)` 函数。\n\nP.S. 在本任务中，你可以只关注属性写入。其他的操作可以通过类似的方式实现。",
        "solution": "该解决方案包括两部分：\n\n1. 无论 `.observe(handler)` 何时被调用，我们都需要在某个地方记住 handler，以便以后可以调用它。我们可以使用 Symbol 作为属性键，将 handler 直接存储在对象中。\n2. 我们需要一个带有 `set` 陷阱的 proxy 来在发生任何更改时调用 handler。 \n\n```js run\nlet handlers = Symbol('handlers');\n\nfunction makeObservable(target) {\n  // 1. 初始化 handler 存储\n  target[handlers] = [];\n\n  // 将 handler 函数存储到数组中，以便于之后调用\n  target.observe = function(handler) {\n    this[handlers].push(handler);\n  };\n\n  // 2. 创建一个 proxy 以处理更改\n  return new Proxy(target, {\n    set(target, property, value, receiver) {\n      let success = Reflect.set(...arguments); // 将操作转发给对象\n      if (success) { // 如果在设置属性时没有出现 error\n        // 调用所有 handler\n        target[handlers].forEach(handler => handler(property, value));\n      }\n      return success;\n    }\n  });\n}\n\nlet user = {};\n\nuser = makeObservable(user);\n\nuser.observe((key, value) => {\n  alert(`SET ${key}=${value}`);\n});\n\nuser.name = \"John\";\n```",
        "parent": "proxy",
        "version": 1
      }
    },
    "eval": {
      "type": "Article",
      "value": {
        "title": "Eval：执行代码字符串",
        "slug": "eval",
        "githubPath": "/1-js/99-js-misc/02-eval",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n内建函数 `eval` 允许执行一个代码字符串。\n\n语法如下：\n\n```js\nlet result = eval(code);\n```\n\n例如：\n\n```js run\nlet code = 'alert(\"Hello\")';\neval(code); // Hello\n```\n\n代码字符串可能会比较长，包含换行符、函数声明和变量等。\n\n`eval` 的结果是最后一条语句的结果。\n\n例如：\n```js run\nlet value = eval('1+1');\nalert(value); // 2\n```\n\n```js run\nlet value = eval('let i = 0; ++i');\nalert(value); // 1\n```\n\n`eval` 内的代码在当前词法环境（lexical environment）中执行，因此它能访问外部变量：\n\n```js run no-beautify\nlet a = 1;\n\nfunction f() {\n  let a = 2;\n\n*!*\n  eval('alert(a)'); // 2\n*/!*\n}\n\nf();\n```\n\n它也可以更改外部变量：\n\n```js untrusted refresh run\nlet x = 5;\neval(\"x = 10\");\nalert(x); // 10，值被更改了\n```\n\n严格模式下，`eval` 有属于自己的词法环境。因此我们不能从外部访问在 `eval` 中声明的函数和变量：\n\n```js untrusted refresh run\n// 提示：本教程所有可运行的示例都默认启用了严格模式 'use strict'\n\neval(\"let x = 5; function f() {}\");\n\nalert(typeof x); // undefined（没有这个变量）\n// 函数 f 也不可从外部进行访问\n```\n\n如果不启用严格模式，`eval` 没有属于自己的词法环境，因此我们可以从外部访问变量 `x` 和函数 `f`。\n\n## 使用 \"eval\"\n\n现代编程中，已经很少使用 `eval` 了。人们经常说“eval 是魔鬼”。\n\n原因很简单：很久很久以前，JavaScript 是一种非常弱的语言，很多东西只能通过 `eval` 来完成。不过那已经是十年前的事了。\n\n如今几乎找不到使用 `eval` 的理由了。如果有人在使用它，那这是一个很好的使用现代语言结构或 [JavaScript Module](info:modules) 来替换它们的机会。\n\n请注意，`eval` 访问外部变量的能力会产生副作用。\n\n代码压缩工具（在把 JS 投入生产环境前对其进行压缩的工具）将局部变量重命名为更短的变量（例如 `a` 和 `b` 等），以使代码体积更小。这通常是安全的，但在使用了 `eval` 的情况下就不一样了，因为局部变量可能会被 `eval` 中的代码访问到。因此压缩工具不会对所有可能会被从 `eval` 中访问的变量进行重命名。这样会导致代码压缩率降低。\n\n在 `eval` 中使用外部局部变量也被认为是一个坏的编程习惯，因为这会使代码维护变得更加困难。\n\n有两种方法可以完全避免此类问题。\n\n**如果 `eval` 中的代码没有使用外部变量，请以 `window.eval(...)` 的形式调用 `eval`：** \n\n通过这种方式，该代码便会在全局作用域内执行：\n\n```js untrusted refresh run\nlet x = 1;\n{\n  let x = 5;\n  window.eval('alert(x)'); // 1（全局变量）\n}\n```\n\n**如果 `eval` 中的代码需要访问局部变量，我们可以使用 `new Function` 替代 `eval`，并将它们作为参数传递：** \n\n```js run\nlet f = new Function('a', 'alert(a)');\n\nf(5); // 5\n```\n\n我们在 <info:new-function> 一章中对 `new Function` 构造器进行了详细说明。`new Function` 从字符串创建一个函数，并且也是在全局作用域中的。所以它无法访问局部变量。但是，正如上面的示例一样，将它们作为参数进行显式传递要清晰得多。\n\n## 总结\n\n调用 `eval(code)` 会运行代码字符串，并返回最后一条语句的结果。\n- 在现代 JavaScript 编程中，很少使用它，通常也不需要使用它。\n- 可以访问外部局部变量。这被认为是一个不好的编程习惯。\n- 要在全局作用域中 `eval` 代码，可以使用 `window.eval(code)` 进行替代。\n- 此外，如果你的代码需要从外部作用域获取数据，请使用 `new Function`，并将数据作为参数传递给函数。",
        "libs": [],
        "children": [
          "eval-calculator"
        ],
        "parent": "js-misc",
        "updatedAt": 1607090457
      }
    },
    "eval-calculator": {
      "type": "Task",
      "value": {
        "title": "Eval-计算器",
        "slug": "eval-calculator",
        "githubPath": "/1-js/99-js-misc/02-eval/1-eval-calculator",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\n\n创建一个计算器，提示用户输入一个算术表达式，并返回其计算结果。\n\n在本题中，你不需要检查表达式是否正确。只需要计算并返回结果。\n\n[demo]",
        "solution": "让我们使用 `eval` 来计算数学表达式：\n\n```js demo run\nlet expr = prompt(\"Type an arithmetic expression?\", '2*3+2');\n\nalert( eval(expr) );\n```\n\n用户可以输入任意文本或代码。\n\n安全起见，并限制其仅进行算术运算，我们可以使用 [正则表达式](info:regular-expressions) 来检查 `expr`，以限制输入的内容只能包含数字和运算符。",
        "parent": "eval",
        "version": 1
      }
    },
    "currying-partials": {
      "type": "Article",
      "value": {
        "title": "柯里化（Currying）",
        "slug": "currying-partials",
        "githubPath": "/1-js/99-js-misc/03-currying-partials",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n[柯里化（Currying）](https://en.wikipedia.org/wiki/Currying)是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。\n\n柯里化是一种函数的转换，它是指将一个函数从可调用的 `f(a, b, c)` 转换为可调用的 `f(a)(b)(c)`。\n\n柯里化不会调用函数。它只是对函数进行转换。\n\n让我们先来看一个例子，以更好地理解我们正在讲的内容，然后再进行一个实际应用。\n\n我们将创建一个辅助函数 `curry(f)`，该函数将对两个参数的函数 `f` 执行柯里化。换句话说，对于两个参数的函数 `f(a, b)` 执行 `curry(f)` 会将其转换为以 `f(a)(b)` 形式运行的函数：\n\n```js run\n*!*\nfunction curry(f) { // curry(f) 执行柯里化转换\n  return function(a) {\n    return function(b) {\n      return f(a, b);\n    };\n  };\n}\n*/!*\n\n// 用法\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1)(2) ); // 3\n```\n\n正如你所看到的，实现非常简单：只有两个包装器（wrapper）。\n\n- `curry(func)` 的结果就是一个包装器 `function(a)`。\n- 当它被像 `curriedSum(1)` 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 `function(b)`。\n- 然后这个包装器被以 `2` 为参数调用，并且，它将该调用传递给原始的 `sum` 函数。\n\n柯里化更高级的实现，例如 lodash 库的 [_.curry](https://lodash.com/docs#curry)，会返回一个包装器，该包装器允许函数被正常调用或者以部分应用函数（partial）的方式调用：\n\n```js run\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry\n\nalert( curriedSum(1, 2) ); // 3，仍可正常调用\nalert( curriedSum(1)(2) ); // 3，以部分应用函数的方式调用\n```\n\n## 柯里化？目的是什么？\n\n要了解它的好处，我们需要一个实际中的例子。\n\n例如，我们有一个用于格式化和输出信息的日志（logging）函数 `log(date, importance, message)`。在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log），在这儿我们仅使用 `alert`：\n\n```js\nfunction log(date, importance, message) {\n  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\n}\n```\n\n让我们将它柯里化！\n\n```js\nlog = _.curry(log);\n```\n\n柯里化之后，`log` 仍正常运行：\n\n```js\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c)\n```\n\n……但是也可以以柯里化形式运行：\n\n```js\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\n```\n\n现在，我们可以轻松地为当前日志创建便捷函数：\n\n```js\n// logNow 会是带有固定第一个参数的日志的部分应用函数\nlet logNow = log(new Date());\n\n// 使用它\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\n```\n\n现在，`logNow` 是具有固定第一个参数的 `log`，换句话说，就是更简短的“部分应用函数（partially applied function）”或“部分函数（partial）”。\n\n我们可以更进一步，为当前的调试日志（debug log）提供便捷函数：\n\n```js\nlet debugNow = logNow(\"DEBUG\");\n\ndebugNow(\"message\"); // [HH:mm] DEBUG message\n```\n\n所以：\n1. 柯里化之后，我们没有丢失任何东西：`log` 依然可以被正常调用。\n2. 我们可以轻松地生成部分应用函数，例如用于生成今天的日志的部分应用函数。\n\n## 高级柯里化实现\n\n如果你想了解更多细节，下面是用于多参数函数的“高级”柯里化实现，我们也可以把它用于上面的示例。\n\n它非常短：\n\n```js\nfunction curry(func) {\n\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  };\n\n}\n```\n\n用例：\n\n```js\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1, 2, 3) ); // 6，仍然可以被正常调用\nalert( curriedSum(1)(2,3) ); // 6，对第一个参数的柯里化\nalert( curriedSum(1)(2)(3) ); // 6，全柯里化\n```\n\n新的 `curry` 可能看上去有点复杂，但是它很容易理解。\n\n`curry(func)` 调用的结果是如下所示的包装器 `curried`：\n\n```js\n// func 是要转换的函数\nfunction curried(...args) {\n  if (args.length >= func.length) { // (1)\n    return func.apply(this, args);\n  } else {\n    return function(...args2) { // (2)\n      return curried.apply(this, args.concat(args2));\n    }\n  }\n};\n```\n\n当我们运行它时，这里有两个 `if` 执行分支：\n\n1. 如果传入的 `args` 长度与原始函数所定义的（`func.length`）相同或者更长，那么只需要使用 `func.apply` 将调用传递给它即可。\n2. 否则，获取一个部分应用函数：我们目前还没调用 `func`。取而代之的是，返回另一个包装器 `pass`，它将重新应用 `curried`，将之前传入的参数与新的参数一起传入。\n\n然后，如果我们再次调用它，我们将得到一个新的部分应用函数（如果没有足够的参数），或者最终的结果。\n\n```smart header=\"只允许确定参数长度的函数\"\n柯里化要求函数具有固定数量的参数。\n\n使用 rest 参数的函数，例如 `f(...args)`，不能以这种方式进行柯里化。\n```\n\n```smart header=\"比柯里化多一点\"\n根据定义，柯里化应该将 `sum(a, b, c)` 转换为 `sum(a)(b)(c)`。\n\n但是，如前所述，JavaScript 中大多数的柯里化实现都是高级版的：它们使得函数可以被多参数变体调用。\n```\n\n## 总结\n\n**柯里化** 是一种转换，将 `f(a,b,c)` 转换为可以被以 `f(a)(b)(c)` 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回部分应用函数。\n\n柯里化让我们能够更容易地获取部分应用函数。就像我们在日志记录示例中看到的那样，普通函数 `log(date, importance, message)` 在被柯里化之后，当我们调用它的时候传入一个参数（如 `log(date)`）或两个参数（`log(date, importance)`）时，它会返回部分应用函数。",
        "libs": [
          "lodash"
        ],
        "children": [],
        "parent": "js-misc",
        "updatedAt": 1669556092
      }
    },
    "reference-type": {
      "type": "Article",
      "value": {
        "title": "Reference Type",
        "slug": "reference-type",
        "githubPath": "/1-js/99-js-misc/04-reference-type",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n```warn header=\"深入的语言特性\"\n本文所讲的是一个高阶主题，能帮你更好地理解一些边缘情况。\n\n这仅是锦上添花。许多经验丰富的的开发者不甚了了也过得不错。如果你想了解代码运行的本质，那就继续读下去吧。\n```\n\n一个动态执行的方法调用可能会丢失 `this`。\n\n例如：\n\n```js run\nlet user = {\n  name: \"John\",\n  hi() { alert(this.name); },\n  bye() { alert(\"Bye\"); }\n};\n\nuser.hi(); // 正常运行\n\n// 现在让我们基于 name 来选择调用 user.hi 或 user.bye\n*!*\n(user.name == \"John\" ? user.hi : user.bye)(); // Error!\n*/!*\n```\n\n在最后一行有个在 `user.hi` 和 `user.bye` 中做选择的条件（三元）运算符。当前情形下的结果是 `user.hi`。\n\n接着该方法被通过 `()` 立刻调用。但是并不能正常工作！\n\n如你所见，此处调用导致了一个错误，因为在该调用中 `\"this\"` 的值变成了 `undefined`。\n\n这样是能工作的（对象.方法）：\n```js\nuser.hi();\n```\n\n这就无法工作了（被评估的方法）：\n```js\n(user.name == \"John\" ? user.hi : user.bye)(); // Error!\n```\n\n为什么呢？欲知缘何，且让我们深入 `obj.method()` 调用运行的本质。\n\n## Reference type 解读\n\n仔细看的话，我们可能注意到 `obj.method()` 语句中的两个操作：\n\n1. 首先，点 `'.'` 取了属性 `obj.method` 的值。\n2. 接着 `()` 执行了它。\n\n那么，`this` 的信息是怎么从第一部分传递到第二部分的呢？\n\n如果我们将这些操作放在不同的行，`this` 必定是会丢失的：\n\n```js run\nlet user = {\n  name: \"John\",\n  hi() { alert(this.name); }\n};\n\n*!*\n// 把获取方法和调用方法拆成两行\nlet hi = user.hi;\nhi(); // 报错了，因为 this 的值是 undefined\n*/!*\n```\n\n这里 `hi = user.hi` 把函数赋值给了一个变量，接下来在最后一行它是完全独立的，所以这里没有 `this`。\n\n**为确保 `user.hi()` 调用正常运行，JavaScript 玩了个小把戏 —— 点 `'.'` 返回的不是一个函数，而是一个特殊的 [Reference Type](https://tc39.github.io/ecma262/#sec-reference-specification-type) 的值。**\n\nReference Type 是 ECMA 中的一个“规范类型”。我们不能直接使用它，但它被用在 JavaScript 语言内部。\n\nReference Type 的值是一个三个值的组合 `(base, name, strict)`，其中：\n\n- `base` 是对象。\n- `name` 是属性名。\n- `strict` 在 `use strict` 模式下为 true。\n\n对属性 `user.hi` 访问的结果不是一个函数，而是一个 Reference Type 的值。对于 `user.hi`，在严格模式下是：\n\n```js\n// Reference Type 的值\n(user, \"hi\", true)\n```\n\n当 `()` 被在 Reference Type 上调用时，它们会接收到关于对象和对象的方法的完整信息，然后可以设置正确的 `this`（在此处 `=user`）。\n\nReference Type 是一个特殊的“中间人”内部类型，目的是从 `.` 传递信息给 `()` 调用。\n\n任何例如赋值 `hi = user.hi` 等其他的操作，都会将 Reference Type 作为一个整体丢弃掉，而会取 `user.hi`（一个函数）的值并继续传递。所以任何后续操作都“丢失”了 `this`。\n\n因此，`this` 的值仅在函数直接被通过点符号 `obj.method()` 或方括号 `obj['method']()` 语法（此处它们作用相同）调用时才被正确传递。还有很多种解决这个问题的方式，例如 [func.bind()](/bind#solution-2-bind)。\n\n## 总结\n\nReference Type 是语言内部的一个类型。\n\n读取一个属性，例如在 `obj.method()` 中，`.` 返回的准确来说不是属性的值，而是一个特殊的 \"Reference Type\" 值，其中储存着属性的值和它的来源对象。\n\n这是为了随后的方法调用 `()` 获取来源对象，然后将 `this` 设为它。\n\n对于所有其它操作，Reference Type 会自动变成属性的值（在我们这个情况下是一个函数）。\n\n这整个机制对我们是不可见的。它仅在一些微妙的情况下才重要，例如使用表达式从对象动态地获取一个方法时。",
        "libs": [],
        "children": [
          "check-syntax",
          "why-this"
        ],
        "parent": "js-misc",
        "updatedAt": 1651426345
      }
    },
    "check-syntax": {
      "type": "Task",
      "value": {
        "title": "检查语法",
        "slug": "check-syntax",
        "githubPath": "/1-js/99-js-misc/04-reference-type/2-check-syntax",
        "weight": 2,
        "libs": [],
        "importance": 2,
        "content": "\n\n这段代码的结果是什么？\n\n\n```js no-beautify\nlet user = {\n  name: \"John\",\n  go: function() { alert(this.name) }\n}\n\n(user.go)()\n```\n\n提示：有一个陷阱哦 :)",
        "solution": "**错误**!\n\n试一下：\n\n```js run\nlet user = {\n  name: \"John\",\n  go: function() { alert(this.name) }\n}\n\n(user.go)() // error!\n```\n\n大多数浏览器中的错误信息并不能说明是什么出现了问题。\n\n**出现此错误是因为在 `user = {...}` 后面漏了一个分号。**\n\nJavaScript 不会在括号 `(user.go)()` 前自动插入分号，所以解析的代码如下：\n\n```js no-beautify\nlet user = { go:... }(user.go)()\n```\n\n然后我们还可以看到，这样的联合表达式在语法上是将对象 `{ go: ... }` 作为参数为 `(user.go)` 的函数。这发生在 `let user` 的同一行上，因此 `user` 对象是甚至还没有被定义，因此出现了错误。\n\n如果我们插入该分号，一切都变得正常：\n\n```js run\nlet user = {\n  name: \"John\",\n  go: function() { alert(this.name) }\n}*!*;*/!*\n\n(user.go)() // John\n```\n\n要注意的是，`(user.go)` 外边这层括号在这没有任何作用。通常用它们来设置操作的顺序，但在这里点符号 `.` 总是会先执行，所以并没有什么影响。分号是唯一重要的。",
        "parent": "reference-type",
        "version": 1
      }
    },
    "why-this": {
      "type": "Task",
      "value": {
        "title": "解释 \"this\" 的值",
        "slug": "why-this",
        "githubPath": "/1-js/99-js-misc/04-reference-type/3-why-this",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\n\n在下面的代码中，我们试图连续调用 `obj.go()` 方法 4 次。\n\n但是前两次和后两次调用的结果不同，为什么呢？\n\n```js run no-beautify\nlet obj, method;\n\nobj = {\n  go: function() { alert(this); }\n};\n\nobj.go();               // (1) [object Object]\n\n(obj.go)();             // (2) [object Object]\n\n(method = obj.go)();    // (3) undefined\n\n(obj.go || obj.stop)(); // (4) undefined\n```",
        "solution": "这里是解析。\n\n1. 它是一个常规的方法调用。\n\n2. 同样，括号没有改变执行的顺序，点符号总是先执行。\n\n3. 这里我们有一个更复杂的 `(expression)()` 调用。这个调用就像被分成了两行（代码）一样：\n\n    ```js no-beautify\n    f = obj.go; // 计算函数表达式\n    f();        // 调用\n    ```\n\n    这里的 `f()` 是作为一个没有（设定）`this` 的函数执行的。\n\n4. 与 `(3)` 相类似，在括号 `()` 的左边也有一个表达式。\n\n要解释 `(3)` 和 `(4)` 得到这种结果的原因，我们需要回顾一下属性访问器（点符号或方括号）返回的是引用类型的值。\n\n除了方法调用之外的任何操作（如赋值 `=` 或 `||`），都会把它转换为一个不包含允许设置 `this` 信息的普通值。",
        "parent": "reference-type",
        "version": 1
      }
    },
    "bigint": {
      "type": "Article",
      "value": {
        "title": "BigInt",
        "slug": "bigint",
        "githubPath": "/1-js/99-js-misc/05-bigint",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n[recent caniuse=\"bigint\"]\n\n`BigInt` 是一种特殊的数字类型，它提供了对任意长度整数的支持。\n\n创建 bigint 的方式有两种：在一个整数字面量后面加 `n` 或者调用 `BigInt` 函数，该函数从字符串、数字等中生成 bigint。\n\n```js\nconst bigint = 1234567890123456789012345678901234567890n;\n\nconst sameBigint = BigInt(\"1234567890123456789012345678901234567890\");\n\nconst bigintFromNumber = BigInt(10); // 与 10n 相同\n```\n\n## 数学运算符\n\n`BigInt` 大多数情况下可以像常规数字类型一样使用，例如：\n\n```js run\nalert(1n + 2n); // 3\n\nalert(5n / 2n); // 2\n```\n\n请注意：除法 `5/2` 的结果向零进行舍入，舍入后得到的结果没有了小数部分。对 bigint 的所有操作，返回的结果也是 bigint。\n\n我们不可以把 bigint 和常规数字类型混合使用：\n\n```js run\nalert(1n + 2); // Error: Cannot mix BigInt and other types\n```\n\n如果有需要，我们应该显式地转换它们：使用 `BigInt()` 或者 `Number()`，像这样：\n\n```js run\nlet bigint = 1n;\nlet number = 2;\n\n// 将 number 转换为 bigint\nalert(bigint + BigInt(number)); // 3\n\n// 将 bigint 转换为 number\nalert(Number(bigint) + number); // 3\n```\n\n转换操作始终是静默的，绝不会报错，但是如果 bigint 太大而数字类型无法容纳，则会截断多余的位，因此我们应该谨慎进行此类转换。\n\n````smart header=\"BigInt 不支持一元加法\"\n一元加法运算符 `+value`，是大家熟知的将 `value` 转换成数字类型的方法。\n\n为了避免混淆，在 bigint 中不支持一元加法：\n```js run\nlet bigint = 1n;\n\nalert( +bigint ); // error\n```\n所以我们应该用 `Number()` 来将一个 bigint 转换成一个数字类型。\n````\n\n## 比较运算符\n\n比较运算符，例如 `<` 和 `>`，使用它们来对 bigint 和 number 类型的数字进行比较没有问题：\n\n```js run\nalert( 2n > 1n ); // true\n\nalert( 2n > 1 ); // true\n```\n\n但是请注意，由于 number 和 bigint 属于不同类型，它们可能在进行 `==` 比较时相等，但在进行 `===`（严格相等）比较时不相等：\n\n```js run\nalert( 1 == 1n ); // true\n\nalert( 1 === 1n ); // false\n```\n\n## 布尔运算\n\n当在 `if` 或其他布尔运算中时，bigint 的行为类似于 number。\n\n例如，在 `if` 中，bigint `0n` 为假，其他值为 `true`：\n\n```js run\nif (0n) {\n  // 永远不会执行\n}\n```\n\n布尔运算符，例如 `||`，`&&` 和其他运算符，处理 bigint 的方式也类似于 number：\n\n```js run\nalert( 1n || 2 ); // 1（1n 被认为是真）\n\nalert( 0n || 2 ); // 2（0n 被认为是假）\n```\n\n## Polyfill\n\nPolyfilling bigint 比较棘手。原因是许多 JavaScript 运算符，比如 `+` 和 `-` 等，在对待 bigint 的行为上与常规 number 相比有所不同。\n\n例如，bigint 的除法总是返回 bigint（如果需要，会进行舍入）。\n\n想要模拟这种行为，polyfill 需要分析代码，并用其函数替换所有此类运算符。但是这样做很麻烦，并且会耗费很多性能。\n\n所以，目前并没有一个众所周知的好用的 polyfill。\n\n不过，[JSBI](https://github.com/GoogleChromeLabs/jsbi) 库的开发者提出了另一种解决方案。\n\n该库使用自己的方法实现了大的数字。我们可以使用它们替代原生的 bigint：\n\n| 运算 | 原生 `BigInt` | JSBI |\n|-----------|-----------------|------|\n| 从 Number 创建 | `a = BigInt(789)` | `a = JSBI.BigInt(789)` |\n| 加法 | `c = a + b` | `c = JSBI.add(a, b)` |\n| 减法 | `c = a - b` | `c = JSBI.subtract(a, b)` |\n| ... | ... | ... |\n\n……然后，对于那些支持 bigint 的浏览器，可以使用 polyfill（Babel 插件）将 JSBI 调用转换为原生的 bigint。\n\n换句话说，这个方法建议我们在写代码时使用 JSBI 替代原生的 bigint。但是 JSBI 在内部像使用 bigint 一样使用 number，并最大程度按照规范进行模拟，所以代码已经是准备好转换成 bigint 的了（bigint-ready）。\n\n对于不支持 bigint 的引擎，我们可以“按原样”使用此类 JSBI 代码，对于那些支持 bigint 的引擎 —— polyfill 会将调用转换为原生的 bigint。\n\n## 参考\n\n- [MDN 文档对 BigInt 的介绍](mdn:/JavaScript/Reference/Global_Objects/BigInt)。\n- [ECMA262 规范](https://tc39.es/ecma262/#sec-bigint-objects)。",
        "libs": [],
        "children": [],
        "parent": "js-misc",
        "updatedAt": 1658751439
      }
    },
    "unicode": {
      "type": "Article",
      "value": {
        "title": "Unicode —— 字符串内幕",
        "slug": "unicode",
        "githubPath": "/1-js/99-js-misc/06-unicode",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n```warn header=\"进阶知识\"\n本节将更深入地介绍字符串的内部原理。如果你打算处理表情符号（emoji）、罕见的数学或象形文字字符，或其他罕见字符，这些知识将对你很有用。\n```\n\n正如我们所知，JavaScript 的字符串是基于 [Unicode](https://en.wikipedia.org/wiki/Unicode) 的：每个字符由 1-4 个字节的字节序列表示。\n\nJavaScript 允许我们通过下述三种表示方式之一将一个字符以其十六进制 Unicode 编码的方式插入到字符串中：\n\n- `\\xXX`\n\n    `XX` 必须是介于 `00` 与 `FF` 之间的两位十六进制数，`\\xXX` 表示 Unicode 编码为 `XX` 的字符。\n\n    因为 `\\xXX` 符号只支持两位十六进制数，所以它只能用于前 256 个 Unicode 字符。\n\n    这前 256 个字符包括拉丁字母、最基本的语法字符和其他一些字符。例如，`\"\\x7A\"` 表示 `\"z\"` (Unicode 编码为 `U+007A`)。\n\n    ```js run\n    alert( \"\\x7A\" ); // z\n    alert( \"\\xA9\" ); // © (版权符号)\n    ```\n\n- `\\uXXXX`\n    `XXXX` 必须是 4 位十六进制数，值介于 `0000` 和 `FFFF` 之间。此时，`\\uXXXX` 便表示 Unicode 编码为 `XXXX` 的字符。\n\n    Unicode 值大于 `U+FFFF` 的字符也可以用这种方法来表示，但在这种情况下，我们要用到代理对（我们将在本章的后面讨论它）。\n\n    ```js run\n    alert( \"\\u00A9\" ); // ©, 等同于 \\xA9，只是使用了四位十六进制数表示而已\n    alert( \"\\u044F\" ); // я（西里尔字母）\n    alert( \"\\u2191\" ); // ↑（上箭头符号）\n    ```\n\n- `\\u{X…XXXXXX}`\n\n    `X…XXXXXX` 必须是介于 `0` 和 `10FFFF`（Unicode 定义的最高码位）之间的 1 到 6 个字节的十六进制值。这种表示方式让我们能够轻松地表示所有现有的 Unicode 字符。\n\n    ```js run\n    alert( \"\\u{20331}\" ); // 佫, 一个不常见的中文字符（长 Unicode）\n    alert( \"\\u{1F60D}\" ); // 😍, 一个微笑符号（另一个长 Unicode）\n    ```\n\n## 代理对\n\n所有常用字符都有对应的 2 字节长度的编码（4 位十六进制数）。大多数欧洲语言的字母、数字、以及基本统一的 CJK 表意文字集（CJK —— 来自中文、日文和韩文书写系统）中的字母，均有对应的 2 字节长度的 Unicode 编码。\n\n最初，JavaScript 是基于 UTF-16 编码的，只允许每个字符占 2 个字节长度。但 2 个字节只允许 65536 种组合，这对于表示 Unicode 里每个可能符的号来说，是不够的。\n\n因此，需要使用超过 2 个字节长度来表示的稀有符号，我们则使用一对 2 字节长度的字符编码，它被称为“代理对”（surrogate pair）。\n\n这种做也有副作用 —— 这些符号的长度为 `2`：\n\n```js run\nalert( '𝒳'.length ); // 2, 大写的数学符号 X\nalert( '😂'.length ); // 2, 笑哭的表情\nalert( '𩷶'.length ); // 2, 一个少见的中文字符\n```\n\n这是因为在 JavaScript 被创造出来的时候，代理对这个概念并不存在，因此语言并没有正确处理它们！\n\n虽然上面的每个字符串都只有一个字符，但其 `length` 属性显示其长度为 `2`。\n\n如何获取这些符号，也是一个棘手的问题：因为编程语言的大部分功能都将代理对当作两个字符对待。\n\n举个例子，我们可以在输出中看到两个奇怪的字符：\n\n```js run\nalert( '𝒳'[0] ); // 显示出了一个奇怪的符号...\nalert( '𝒳'[1] ); // ...代理对的片段\n```\n\n代理对的片段失去彼此就没有意义。所以上面示例中 `alert()` 打印出的内容其实就是没有任何意义的垃圾信息。\n\n从技术上讲，可以通过代理对的编码来检测代理对：如果一个字符的编码在 `0xd800..0xdbff` 这个范围中，那么它就是代理对的前一个部分。下一个字符（第二部分）的编码必须在 `0xdc00..0xdfff` 范围中。这两个范围中的编码是规范中专为代理对预留的。\n\n基于此，JavaScript 新增了 [String.fromCodePoint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) 和 [str.codePointAt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt) 这两个方法来处理代理对。\n\n它们本质上与 [String.fromCharCode](mdn:js/String/fromCharCode) 和 [str.charCodeAt](mdn:js/String/charCodeAt) 相同，但它们可以正确地处理代理对。\n\n在这里可以看出它们的区别：\n\n```js run\n// charCodeAt 不会考虑代理对，所以返回了 𝒳 前半部分的编码:\n\nalert( '𝒳'.charCodeAt(0).toString(16) ); // d835\n\n// codePointAt 可以正确处理代理对\nalert( '𝒳'.codePointAt(0).toString(16) ); // 1d4b3，读取到了完整的代理对\n```\n\n也就是说，如果我们从 `𝒳` 的位置 1 开始获取对应的编码（这么做是不对的），那么这两个方法都只会返回此代理对的后半部分：\n\n```js run\nalert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3\nalert( '𝒳'.codePointAt(1).toString(16) ); // dcb3\n// 无意义的代理对后半部分\n```\n\n你稍后可以在 <info:iterable> 一章中找到更多处理代理对的方式。可能也有专门处理代理对的库，但没有足够流行到可以让我们在这里推荐的库。\n\n````warn header=\"注意：在任意点拆分字符串是很危险的\"\n我们不能随意在任意位置对字符串进行拆分，例如通过 `str.slice(0, 4)` 获取一个字符串，并期待它是一个有效的字符串：\n\n```js run\nalert( 'hi 😂'.slice(0, 4) ); //  hi [?]\n```\n\n在这里，我们看到一个没有意义的垃圾字符被打印了出来（笑哭表情代理对的前半部分）。\n\n如果你期望可靠地使用代理对，请注意这一点。这可能并不是什么大问题，但至少你应该知道发生了什么。\n````\n\n## 变音符号和规范化\n\n很多语言都有由基础字符及其上方/下方的标记所组成的符号。\n\n举个例子，字母 `a` 就是这些字符 `àáâäãåā` 的基础字符。\n\n大多数常见的“复合”字符在 Unicode 表中都有自己的编码。但不是所有这些字符都有自己的编码，因为可能的组合形式太多了。\n\n为了支持任意的组合，Unicode 标准允许我们使用多个 Unicode 字符：基础字符后跟着一个或多个“装饰”它的“标记”字符。\n\n例如，如果我们在 `S` 后附加上特殊的“上方的点”字符（编码为 `\\u0307`），则显示为 Ṡ。\n\n```js run\nalert( 'S\\u0307' ); // Ṡ\n```\n\n如果我们需要在字母上方（或下方）添加一个额外的标记 —— 很简单，只需添加必要的标记字符即可。\n\n例如，如果我们继续在后面附加一个“下方的点”符号（编码 `\\u0323`），那么我们将得到一个“上下都有一个点符号的 S”：`Ṩ`。\n\n就像这样：\n\n```js run\nalert( 'S\\u0307\\u0323' ); // Ṩ\n```\n\n这提供了极大的灵活性，但也带来了一个有趣的问题：两个字符可能在视觉上看起来相同，但却使用的是不同的 Unicode 组合。\n\n举个例子：\n\n```js run\nlet s1 = 'S\\u0307\\u0323'; // Ṩ, S + 上方点符号 + 下方点符号\nlet s2 = 'S\\u0323\\u0307'; // Ṩ, S + 下方点符号 + 上方点符号\n\nalert( `s1: ${s1}, s2: ${s2}` );\n\nalert( s1 == s2 ); // 尽管这两个字符在我们看来是相通的，但结果却是 false\n```\n\n“Unicode 规范化”算法可以解决这个问题，该算法将每个字符串转换为单一的“规范的”形式。\n\n可以借助 [str.normalize()](mdn:js/String/normalize) 实现这一点。\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize() == \"S\\u0323\\u0307\".normalize() ); // true\n```\n\n有意思的是，在我们这个例子中，`normalize()` 将 3 个字符的序列合并为了一个字符：`\\u1e68`（带有上下两个点的 S）。\n\n```js run\nalert( \"S\\u0307\\u0323\".normalize().length ); // 1\n\nalert( \"S\\u0307\\u0323\".normalize() == \"\\u1e68\" ); // true\n```\n\n但实际并非总是如此。出现这种情况的原因是符号 `Ṩ` 是“足够常见的”，所以 Unicode 创建者将其囊括在了 Unicode 主表中，并为其提供了对应的编码。\n\n如果你想了解关于 Unicode 规范化规则和变体的更多信息，可以参阅 Unicode 标准的附录中的内容：[Unicode 规范化形式](https://www.unicode.org/reports/tr15/)。但就实用而言，本节中的信息就已经足够了。",
        "libs": [],
        "children": [],
        "parent": "js-misc",
        "updatedAt": 1672042061
      }
    },
    "ui": {
      "type": "Article",
      "value": {
        "title": "浏览器：文档，事件，接口",
        "slug": "ui",
        "githubPath": "/2-ui",
        "isFolder": true,
        "weight": 2,
        "content": "\n\n学习如何管理浏览器页面：添加元素，操纵元素的大小和位置，动态创建接口并与访问者互动。",
        "libs": [],
        "children": [
          "document",
          "events",
          "event-details",
          "forms-controls",
          "loading",
          "ui-misc"
        ]
      }
    },
    "document": {
      "type": "Article",
      "value": {
        "title": "Document",
        "slug": "document",
        "githubPath": "/2-ui/1-document",
        "isFolder": true,
        "weight": 1,
        "content": "\n\n在这里，我们将学习如何使用 JavaScript 来操纵网页。",
        "libs": [],
        "children": [
          "browser-environment",
          "dom-nodes",
          "dom-navigation",
          "searching-elements-dom",
          "basic-dom-node-properties",
          "dom-attributes-and-properties",
          "modifying-document",
          "styles-and-classes",
          "size-and-scroll",
          "size-and-scroll-window",
          "coordinates"
        ],
        "parent": "ui"
      }
    },
    "browser-environment": {
      "type": "Article",
      "value": {
        "title": "浏览器环境，规格",
        "slug": "browser-environment",
        "githubPath": "/2-ui/1-document/01-browser-environment",
        "isFolder": false,
        "weight": 1,
        "content": "\n\nJavaScript 语言最初是为 Web 浏览器创建的。此后，它已经演变成了一种具有多种用途和平台的语言。\n\n平台可以是一个浏览器，一个 Web 服务器，或其他 **主机（host）**，甚至可以是一个“智能”咖啡机，如果它能运行 JavaScript 的话。它们每个都提供了特定于平台的功能。JavaScript 规范将其称为 **主机环境**。\n\n主机环境提供了自己的对象和语言核心以外的函数。Web 浏览器提供了一种控制网页的方法。Node.JS 提供了服务器端功能，等等。\n\n下面是 JavaScript 在浏览器中运行时的鸟瞰示意图：\n\n![](windowObjects.svg)\n\n有一个叫做 `window` 的“根”对象。它有两个角色：\n\n1. 首先，它是 JavaScript 代码的全局对象，如 <info:global-object> 一章所述。\n2. 其次，它代表“浏览器窗口”，并提供了控制它的方法。\n\n例如，我们可以将它用作全局对象：\n\n```js run global\nfunction sayHi() {\n  alert(\"Hello\");\n}\n\n// 全局函数是全局对象的方法：\nwindow.sayHi();\n```\n\n并且我们可以将它用作浏览器窗口，以查看窗口高度：\n\n```js run\nalert(window.innerHeight); // 内部窗口高度\n```\n\n还有更多窗口特定的方法和属性，我们稍后会介绍。\n\n## 文档对象模型（DOM）\n\n文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象。\n\n`document` 对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。\n\n例如：\n```js run\n// 将背景颜色修改为红色\ndocument.body.style.background = \"red\";\n\n// 在 1 秒后将其修改回来\nsetTimeout(() => document.body.style.background = \"\", 1000);\n```\n\n在这里，我们使用了 `document.body.style`，但还有很多很多其他的东西。规范中有属性和方法的详细描述：[DOM Living Standard](https://dom.spec.whatwg.org)。\n\n```smart header=\"DOM 不仅仅用于浏览器\"\nDOM 规范解释了文档的结构，并提供了操作文档的对象。有的非浏览器设备也使用 DOM。\n\n例如，下载 HTML 文件并对其进行处理的服务器端脚本也可以使用 DOM。但它们可能仅支持部分规范中的内容。\n```\n\n```smart header=\"用于样式的 CSSOM\"\n另外也有一份针对 CSS 规则和样式表的、单独的规范 [CSS Object Model (CSSOM)](https://www.w3.org/TR/cssom-1/)，这份规范解释了如何将 CSS 表示为对象，以及如何读写这些对象。\n\n当我们修改文档的样式规则时，CSSOM 与 DOM 是一起使用的。但实际上，很少需要 CSSOM，因为我们很少需要从 JavaScript 中修改 CSS 规则（我们通常只是添加/移除一些 CSS 类，而不是直接修改其中的 CSS 规则），但这也是可行的。\n```\n\n## 浏览器对象模型（BOM）\n\n浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。\n\n例如：\n\n- [navigator](mdn:api/Window/navigator) 对象提供了有关浏览器和操作系统的背景信息。navigator 有许多属性，但是最广为人知的两个属性是：`navigator.userAgent` —— 关于当前浏览器，`navigator.platform` —— 关于平台（有助于区分 Windows/Linux/Mac 等）。\n- [location](mdn:api/Window/location) 对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL。\n\n这是我们可以如何使用 `location` 对象的方法：\n\n```js run\nalert(location.href); // 显示当前 URL\nif (confirm(\"Go to Wikipedia?\")) {\n  location.href = \"https://wikipedia.org\"; // 将浏览器重定向到另一个 URL\n}\n```\n\n函数 `alert/confirm/prompt` 也是 BOM 的一部分：它们与文档（document）没有直接关系，但它代表了与用户通信的纯浏览器方法。\n\n```smart header=\"规范\"\nBOM 是通用 [HTML 规范](https://html.spec.whatwg.org) 的一部分。\n\n是的，你没听错。在 <https://html.spec.whatwg.org> 中的 HTML 规范不仅是关于“HTML 语言”（标签，特性）的，还涵盖了一堆对象、方法和浏览器特定的 DOM 扩展。这就是“广义的 HTML”。此外，某些部分也有其他的规范，它们被列在 <https://spec.whatwg.org> 中。\n```\n\n## 总结\n\n说到标准，我们有：\n\nDOM 规范\n: 描述文档的结构、操作和事件，详见 <https://dom.spec.whatwg.org>。\n\nCSSOM 规范\n: 描述样式表和样式规则，对它们进行的操作，以及它们与文档的绑定，详见 <https://www.w3.org/TR/cssom-1/>。\n\nHTML 规范\n: 描述 HTML 语言（例如标签）以及 BOM（浏览器对象模型）— 各种浏览器函数：`setTimeout`，`alert`，`location` 等，详见 <https://html.spec.whatwg.org>。它采用了 DOM 规范，并使用了许多其他属性和方法对其进行了扩展。\n\n此外，某些类被分别描述在 <https://spec.whatwg.org/>。\n\n请注意这些链接，因为要学的东西太多了，所以不可能涵盖并记住所有内容。\n\n当你想要了解某个属性或方法时，Mozilla 手册 <https://developer.mozilla.org/en-US/> 是一个很好的资源，但对应的规范可能会更好：它更复杂，且阅读起来需要更长的时间，但是会使你的基本知识更加全面，更加完整。\n\n要查找某些内容时，你通常可以使用互联网搜索 \"WHATWG [term]\" 或 \"MDN [term]\"，例如 <https://google.com?q=whatwg+localstorage>，<https://google.com?q=mdn+localstorage>。\n\n现在，我们开始学习 DOM，因为文档在 UI 中扮演着核心角色。",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1658752071
      }
    },
    "dom-nodes": {
      "type": "Article",
      "value": {
        "title": "DOM 树",
        "slug": "dom-nodes",
        "githubPath": "/2-ui/1-document/02-dom-nodes",
        "isFolder": false,
        "weight": 2,
        "content": "\n\nHTML 文档的主干是标签（tag）。\n\n根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象。\n\n所有这些对象都可以通过 JavaScript 来访问，我们可以使用它们来修改页面。\n\n例如，`document.body` 是表示 `<body>` 标签的对象。\n\n运行这段代码会使 `<body>` 保持 3 秒红色状态:\n\n```js run\ndocument.body.style.background = 'red'; // 将背景设置为红色\n\nsetTimeout(() => document.body.style.background = '', 3000); // 恢复回去\n```\n\n在这，我们使用了 `style.background` 来修改 `document.body` 的背景颜色，但是还有很多其他的属性，例如：\n\n- `innerHTML` —— 节点的 HTML 内容。\n- `offsetWidth` —— 节点宽度（以像素度量）\n- ……等。\n\n很快，我们将学习更多操作 DOM 的方法，但首先我们需要了解 DOM 的结构。\n\n## DOM 的例子\n\n让我们从下面这个简单的文档（document）开始：\n\n```html run no-beautify\n<!DOCTYPE HTML>\n<html>\n<head>\n  <title>About elk</title>\n</head>\n<body>\n  The truth about elk.\n</body>\n</html>\n```\n\nDOM 将 HTML 表示为标签的树形结构。它看起来如下所示：\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node1 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"},{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"About elk\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n\"},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  The truth about elk.\\n\"}]}]}\n\ndrawHtmlTree(node1, 'div.domtree', 690, 320);\n</script>\n\n```online\n在上面的图片中，你可以点击元素（element）节点，它们的子节点会打开/折叠。\n```\n\n每个树的节点都是一个对象。\n\n标签被称为 **元素节点**（或者仅仅是元素），并形成了树状结构：`<html>` 在根节点，`<head>` 和 `<body>` 是其子项，等。\n\n元素内的文本形成 **文本节点**，被标记为 `＃text`。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。\n\n例如，`<title>` 标签里面有文本 `\"About elk\"`。\n\n请注意文本节点中的特殊字符：\n\n- 换行符：`↵`（在 JavaScript 中为 `\\n`）\n- 空格：`␣`\n\n空格和换行符都是完全有效的字符，就像字母和数字。它们形成文本节点并成为 DOM 的一部分。所以，例如，在上面的示例中，`<head>` 标签中的 `<title>` 标签前面包含了一些空格，并且该文本变成了一个 `#text` 节点（它只包含一个换行符和一些空格）。\n\n只有两个顶级排除项：\n1. 由于历史原因，`<head>` 之前的空格和换行符均被忽略。\n2. 如果我们在 `</body>` 之后放置一些东西，那么它会被自动移动到 `body` 内，并处于 `body` 中的最下方，因为 HTML 规范要求所有内容必须位于 `<body>` 内。所以 `</body>` 之后不能有空格。\n\n在其他情况下，一切都很简单 —— 如果文档中有空格（就像任何字符一样），那么它们将成为 DOM 中的文本节点，而如果我们删除它们，则不会有任何空格。\n\n这是没有空格的文本节点：\n\n```html no-beautify\n<!DOCTYPE HTML>\n<html><head><title>About elk</title></head><body>The truth about elk.</body></html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node2 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[{\"name\":\"TITLE\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"About elk\"}]}]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"The truth about elk.\"}]}]}\n\ndrawHtmlTree(node2, 'div.domtree', 690, 210);\n</script>\n\n```smart header=\"字符串开头/结尾处的空格，以及只有空格的文本节点，通常会被工具隐藏\"\n与 DOM 一起使用的浏览器工具（即将介绍）通常不会在文本的开始/结尾显示空格，并且在标签之间也不会显示空文本节点（换行符）。\n\n开发者工具通过这种方式节省屏幕空间。\n\n在本教程中，如果这些空格和空文本节点无关紧要时，我们在后面出现的关于 DOM 的示意图中会忽略它们。这样的空格通常不会影响文档的显示方式。\n```\n\n## 自动修正\n\n如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。\n\n例如，顶级标签总是 `<html>`。即使它不存在于文档中 — 它也会出现在 DOM 中，因为浏览器会创建它。对于 `<body>` 也是一样。\n\n例如，如果一个 HTML 文件中只有一个单词 \"Hello\"，浏览器则会把它包装到 `<html>` 和 `<body>` 中，并且会添加所需的 `<head>`，DOM 将会变成下面这样：\n\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node3 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Hello\"}]}]}\n\ndrawHtmlTree(node3, 'div.domtree', 690, 150);\n</script>\n\n在生成 DOM 时，浏览器会自动处理文档中的错误，关闭标签等。\n\n一个没有关闭标签的文档：\n\n```html no-beautify\n<p>Hello\n<li>Mom\n<li>and\n<li>Dad\n```\n\n……将成为一个正常的 DOM，因为浏览器在读取标签时会填补缺失的部分：\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node4 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"P\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Hello\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Mom\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"and\"}]},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"Dad\"}]}]}]}\n\ndrawHtmlTree(node4, 'div.domtree', 690, 360);\n</script>\n\n````warn header=\"表格永远有 `<tbody>`\"\n表格是一个有趣的“特殊的例子”。按照 DOM 规范，它们必须具有 `<tbody>` 标签，但 HTML 文本可能会忽略它。然后浏览器在创建 DOM 时，自动地创建了 `<tbody>`。\n\n对于 HTML：\n\n```html no-beautify\n<table id=\"table\"><tr><td>1</td></tr></table>\n```\n\nDOM 结构会变成：\n<div class=\"domtree\"></div>\n\n<script>\nlet node5 = {\"name\":\"TABLE\",\"nodeType\":1,\"children\":[{\"name\":\"TBODY\",\"nodeType\":1,\"children\":[{\"name\":\"TR\",\"nodeType\":1,\"children\":[{\"name\":\"TD\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"1\"}]}]}]}]};\n\ndrawHtmlTree(node5,  'div.domtree', 600, 200);\n</script>\n\n看到了吗？`<tbody>` 出现了。我们应该记住这一点，以免在使用表格时，对这种情况感到惊讶。\n````\n\n## 其他节点类型\n\n除了元素和文本节点外，还有一些其他的节点类型。\n\n例如，注释：\n\n```html\n<!DOCTYPE HTML>\n<html>\n<body>\n  The truth about elk.\n  <ol>\n    <li>An elk is a smart</li>\n*!*\n    <!-- comment -->\n*/!*\n    <li>...and cunning animal!</li>\n  </ol>\n</body>\n</html>\n```\n\n<div class=\"domtree\"></div>\n\n<script>\nlet node6 = {\"name\":\"HTML\",\"nodeType\":1,\"children\":[{\"name\":\"HEAD\",\"nodeType\":1,\"children\":[]},{\"name\":\"BODY\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  The truth about elk.\\n  \"},{\"name\":\"OL\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"An elk is a smart\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"#comment\",\"nodeType\":8,\"content\":\"comment\"},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n    \"},{\"name\":\"LI\",\"nodeType\":1,\"children\":[{\"name\":\"#text\",\"nodeType\":3,\"content\":\"...and cunning animal!\"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n  \"}]},{\"name\":\"#text\",\"nodeType\":3,\"content\":\"\\n\\n\\n\"}]}]};\n\ndrawHtmlTree(node6, 'div.domtree', 690, 500);\n</script>\n\n在这里我们可以看到一个新的树节点类型 —— **comment 节点**，被标记为 `#comment`，它在两个文本节点之间。\n\n我们可能会想 —— 为什么要将注释添加到 DOM 中？它不会对视觉展现产生任何影响吗。但是有一条规则 —— 如果一些内容存在于 HTML 中，那么它也必须在 DOM 树中。\n\n**HTML 中的所有内容，甚至注释，都会成为 DOM 的一部分。**\n\n甚至 HTML 开头的 `<!DOCTYPE...>` 指令也是一个 DOM 节点。它在 DOM 树中位于 `<html>` 之前。很少有人知道这一点。我们不会触及那个节点，我们甚至不会在图表中绘制它，但它确实就在那里。\n\n表示整个文档的 `document` 对象，在形式上也是一个 DOM 节点。\n\n一共有 [12 种节点类型](https://dom.spec.whatwg.org/#node)。实际上，我们通常用到的是其中的 4 种：\n\n1. `document` —— DOM 的“入口点”。\n2. 元素节点 —— HTML 标签，树构建块。\n3. 文本节点 —— 包含文本。\n4. 注释 —— 有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它。\n\n## 自己看看\n\n要在实际中查看 DOM 结构，请尝试 [Live DOM Viewer](http://software.hixie.ch/utilities/js/live-dom-viewer/)。只需输入文档，它将立即显示为 DOM。\n\n探索 DOM 的另一种方式是使用浏览器开发工具。实际上，这就是我们在开发中所使用的。\n\n你可以打开这个网页 [elks.html](elks.html)，然后打开浏览器开发工具，并切换到元素（Elements）选项卡。\n\n它看起来像这样：\n\n![](elk.svg)\n\n你可以看到 DOM，点击元素，查看它们的细节等。\n\n请注意，开发者工具中的 DOM 结构是经过简化的。文本节点仅以文本形式显示。并且根本没有“空白”（只有空格）的文本节点。这其实挺好，因为大多数情况下，我们只关心元素节点。\n\n点击左上角的 <span class=\"devtools\" style=\"background-position:-328px -124px\"></span> 按钮可以让我们使用鼠标（或其他指针设备）从网页中选择一个节点并“检查（inspect）”它（在元素选项卡中滚动到该节点）。当我们有一个巨大的 HTML 页面（和相应的巨大 DOM），并希望查看其中的一个特定元素的位置时，这很有用。\n\n另一种方法是在网页上右键单击，然后在上下文菜单中选择“检查（Inspect）”。\n\n![](inspect.svg)\n\n在工具的右侧部分有以下子选项卡：\n- **Styles** —— 我们可以看到按规则应用于当前元素的 CSS 规则，包括内建规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。\n- **Computed** —— 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。\n- **Event Listeners** —— 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。\n- ……等。\n\n学习它们的最佳方式就是多点一点看一下。大多数值都是可以就地编辑的。\n\n## 与控制台交互\n\n在我们处理 DOM 时，我们可能还希望对其应用 JavaScript。例如：获取一个节点并运行一些代码来修改它，以查看结果。以下是在元素（Elements）选项卡和控制台（Console）之间切换的一些技巧。\n\n首先：\n\n- 在元素（Elements）选项卡中选择第一个 `<li>`。\n- 按下 `key:Esc` —— 它将在元素（Elements）选项卡下方打开控制台（Console）。\n\n现在最后选中的元素可以通过 `$0` 来进行操作，在之前的选择中则是 `$1`。\n\n我们可以对它们执行一些命令。例如，`$0.style.background = 'red'` 使选定的列表项（list item）变成红色，像这样：\n\n![](domconsole0.svg)\n\n这就是在控制台（Console）中获取元素（Elements）选项卡中的节点的方法。\n\n还有一种方式。如果存在引用 DOM 节点的变量，那么我们可以在控制台（Console）中使用命令 `inspect(node)`，来在元素（Elements）选项卡中查看它。\n\n或者我们可以直接在控制台（Console）中输出 DOM 节点，并“就地”探索它，例如下面的 `document.body`：\n\n![](domconsole1.svg)\n\n当然，这是出于调试目的。从下一章开始，我们将使用 JavaScript 访问和修改 DOM。\n\n浏览器开发者工具对于开发有很大的帮助：我们可以探索 DOM，尝试一些东西，并找出问题所在。\n\n## 总结\n\nHTML/XML 文档在浏览器内均被表示为 DOM 树。\n\n- 标签（tag）成为元素节点，并形成文档结构。\n- 文本（text）成为文本节点。\n- ……等，HTML 中的所有东西在 DOM 中都有它的位置，甚至对注释也是如此。\n\n我们可以使用开发者工具来检查（inspect）DOM 并手动修改它。\n\n在这里，我们介绍了基础知识，入门最常用和最重要的行为。在 <https://developers.google.cn/web/tools/chrome-devtools> 上有关于 Chrome 开发者工具的详细文档说明。学习这些工具的最佳方式就是到处点一点看一看，阅读菜单：大多数选项都很明显。而后，当你大致了解它们后，请阅读文档并学习其余内容。\n\nDOM 节点具有允许我们在它们之间移动，修改它们，在页面中移动等的属性和方法。在下一章中，我们将介绍它们。",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [],
        "headHtml": "<style>\nspan.devtools {\n  display: inline-block;\n  background-image: url(/article/dom-nodes/toolbarButtonGlyphs.svg);\n  height:16px;\n  width:16px;\n}\n</style>\n",
        "parent": "document",
        "updatedAt": 1658756779
      }
    },
    "dom-navigation": {
      "type": "Article",
      "value": {
        "title": "遍历 DOM",
        "slug": "dom-navigation",
        "githubPath": "/2-ui/1-document/03-dom-navigation",
        "isFolder": false,
        "weight": 3,
        "content": "\n\nDOM 让我们可以对元素和它们中的内容做任何事，但是首先我们需要获取到对应的 DOM 对象。\n\n对 DOM 的所有操作都是以 `document` 对象开始。它是 DOM 的主“入口点”。从它我们可以访问任何节点。\n\n这里是一张描述对象间链接的图片，通过这些链接我们可以在 DOM 节点之间移动。\n\n![](dom-links.svg)\n\n让我们更详细地讨论它们吧。\n\n## 在最顶层：documentElement 和 body\n\n最顶层的树节点可以直接作为 `document` 的属性来使用：\n\n`<html>` = `document.documentElement`\n: 最顶层的 document 节点是 `document.documentElement`。这是对应 `<html>` 标签的 DOM 节点。\n\n`<body>` = `document.body`\n: 另一个被广泛使用的 DOM 节点是 `<body>` 元素 —— `document.body`。\n\n`<head>` = `document.head`\n: `<head>` 标签可以通过 `document.head` 访问。\n\n````warn header=\"这里有个问题：`document.body` 的值可能是 `null`\"\n脚本无法访问在运行时不存在的元素。\n\n尤其是，如果一个脚本是在 `<head>` 中，那么脚本是访问不到 `document.body` 元素的，因为浏览器还没有读到它。\n\n所以，下面例子中的第一个 `alert` 显示 `null`：\n\n```html run\n<html>\n\n<head>\n  <script>\n*!*\n    alert( \"From HEAD: \" + document.body ); // null，这里目前还没有 <body>\n*/!*\n  </script>\n</head>\n\n<body>\n\n  <script>\n    alert( \"From BODY: \" + document.body ); // HTMLBodyElement，现在存在了\n  </script>\n\n</body>\n</html>\n```\n````\n\n```smart header=\"在 DOM 的世界中，`null` 就意味着“不存在”\"\n在 DOM 中，`null` 值就意味着“不存在”或者“没有这个节点”。 \n```\n\n## 子节点：childNodes，firstChild，lastChild\n\n从现在开始，我们将使用下面这两个术语：\n\n- **子节点（或者叫作子）** —— 对应的是直系的子元素。换句话说，它们被完全嵌套在给定的元素中。例如，`<head>` 和 `<body>` 就是 `<html>` 元素的子元素。\n- **子孙元素** —— 嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。\n\n例如，这里 `<body>` 有子元素 `<div>` 和 `<ul>`（以及一些空白的文本节点）：\n\n```html run\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>\n      <b>Information</b>\n    </li>\n  </ul>\n</body>\n</html>\n```\n\n……`<body>` 元素的子孙元素不仅包含直接的子元素 `<div>` 和 `<ul>`，还包含像 `<li>`（`<ul>` 的子元素）和 `<b>`（`<li>` 的子元素）这样的元素 — 整个子树。\n\n**`childNodes` 集合列出了所有子节点，包括文本节点。**\n\n下面这个例子显示了 `document.body` 的子元素：\n\n```html run\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>Information</li>\n  </ul>\n\n  <div>End</div>\n\n  <script>\n*!*\n    for (let i = 0; i < document.body.childNodes.length; i++) {\n      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT\n    }\n*/!*\n  </script>\n  ...more stuff...\n</body>\n</html>\n```\n\n请注意这里的一个有趣的细节。如果我们运行上面这个例子，所显示的最后一个元素是 `<script>`。实际上，文档下面还有很多东西，但是在这个脚本运行的时候，浏览器还没有读到下面的内容，所以这个脚本也就看不到它们。\n\n**`firstChild` 和 `lastChild` 属性是访问第一个和最后一个子元素的快捷方式。**\n\n它们只是简写。如果元素存在子节点，那么下面的脚本运行结果将是 true：\n```js\nelem.childNodes[0] === elem.firstChild\nelem.childNodes[elem.childNodes.length - 1] === elem.lastChild\n```\n\n这里还有一个特别的函数 `elem.hasChildNodes()` 用于检查节点是否有子节点。\n\n### DOM 集合\n\n正如我们看到的那样，`childNodes` 看起来就像一个数组。但实际上它并不是一个数组，而是一个 **集合** —— 一个类数组的可迭代对象。\n\n这个性质会导致两个重要的结果：\n\n1. 我们可以使用 `for..of` 来迭代它：\n  ```js\n  for (let node of document.body.childNodes) {\n    alert(node); // 显示集合中的所有节点\n  }\n  ```\n  这是因为集合是可迭代的（提供了所需要的 `Symbol.iterator` 属性）。\n\n2. 无法使用数组的方法，因为它不是一个数组：\n  ```js run\n  alert(document.body.childNodes.filter); // undefined（这里没有 filter 方法！）\n  ```\n\n集合的性质所得到的第一个结果很不错。第二个结果也还可以忍受，因为如果我们想要使用数组的方法的话，我们可以使用 `Array.from` 方法来从集合创建一个“真”数组：\n\n  ```js run\n  alert( Array.from(document.body.childNodes).filter ); // function\n  ```\n\n```warn header=\"DOM 集合是只读的\"\nDOM 集合，甚至可以说本章中列出的 **所有** 导航（navigation）属性都是只读的。\n\n我们不能通过类似 `childNodes[i] = ...` 的操作来替换一个子节点。\n\n修改子节点需要使用其它方法。我们将会在下一章中看到它们。\n```\n\n```warn header=\"DOM 集合是实时的\"\n除小部分例外，几乎所有的 DOM 集合都是 **实时** 的。换句话说，它们反映了 DOM 的当前状态。\n\n如果我们保留一个对 `elem.childNodes` 的引用，然后向 DOM 中添加/移除节点，那么这些节点的更新会自动出现在集合中。\n```\n\n````warn header=\"不要使用 `for..in` 来遍历集合\"\n可以使用 `for..of` 对集合进行迭代。但有时候人们会尝试使用 `for..in` 来迭代集合。\n\n请不要这么做。`for..in` 循环遍历的是所有可枚举的（enumerable）属性。集合还有一些“额外的”很少被用到的属性，通常这些属性也是我们不期望得到的：\n\n```html run\n<body>\n<script>\n  // 显示 0，1，length，item，values 及其他。\n  for (let prop in document.body.childNodes) alert(prop);\n</script>\n</body>\n````\n\n## 兄弟节点和父节点\n\n**兄弟节点（sibling）** 是指有同一个父节点的节点。\n\n例如，`<head>` 和 `<body>` 就是兄弟节点：\n\n```html\n<html>\n  <head>...</head><body>...</body>\n</html>\n```\n\n- `<body>` 可以说是 `<head>` 的“下一个”或者“右边”兄弟节点。\n- `<head>` 可以说是 `<body>` 的“前一个”或者“左边”兄弟节点。\n\n下一个兄弟节点在 `nextSibling` 属性中，上一个是在 `previousSibling` 属性中。\n\n可以通过 `parentNode` 来访问父节点。\n\n例如：\n\n```js run\n// <body> 的父节点是 <html>\nalert( document.body.parentNode === document.documentElement ); // true\n\n// <head> 的后一个是 <body>\nalert( document.head.nextSibling ); // HTMLBodyElement\n\n// <body> 的前一个是 <head>\nalert( document.body.previousSibling ); // HTMLHeadElement\n```\n\n## 纯元素导航\n\n上面列出的导航（navigation）属性引用 **所有** 节点。例如，在 `childNodes` 中我们可以看到文本节点，元素节点，甚至包括注释节点（如果它们存在的话）。 \n\n但是对于很多任务来说，我们并不想要文本节点或注释节点。我们希望操纵的是代表标签的和形成页面结构的元素节点。\n\n所以，让我们看看更多只考虑 **元素节点** 的导航链接（navigation link）：\n\n![](dom-links-elements.svg)\n\n这些链接和我们在上面提到过的类似，只是在词中间加了 `Element`：\n\n- `children` —— 仅那些作为元素节点的子代的节点。\n- `firstElementChild`，`lastElementChild` —— 第一个和最后一个子元素。\n- `previousElementSibling`，`nextElementSibling` —— 兄弟元素。\n- `parentElement` —— 父元素。\n\n````smart header=\"为什么是 `parentElement`? 父节点可以不是一个元素吗？\"\n`parentElement` 属性返回的是“元素类型”的父节点，而 `parentNode` 返回的是“任何类型”的父节点。这些属性通常来说是一样的：它们都是用于获取父节点。\n\n唯一的例外就是 `document.documentElement`：\n\n```js run\nalert( document.documentElement.parentNode ); // document\nalert( document.documentElement.parentElement ); // null\n```\n\n因为根节点 `document.documentElement`（`<html>`）的父节点是 `document`。但 `document` 不是一个元素节点，所以 `parentNode` 返回了 `document`，但 `parentElement` 返回的是 `null`。\n\n当我们想从任意节点 `elem` 到 `<html>` 而不是到 `document` 时，这个细节可能很有用：\n```js\nwhile(elem = elem.parentElement) { // 向上，直到 <html>\n  alert( elem );\n}\n```\n````\n\n让我们修改上面的一个示例：用 `children` 来替换 `childNodes`。现在它只显示元素：\n\n```html run\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>Information</li>\n  </ul>\n\n  <div>End</div>\n\n  <script>\n*!*\n    for (let elem of document.body.children) {\n      alert(elem); // DIV, UL, DIV, SCRIPT\n    }\n*/!*\n  </script>\n  ...\n</body>\n</html>\n```\n\n## 更多链接：表格 [#dom-navigation-tables]\n\n到现在，我们已经描述了基本的导航（navigation）属性。\n\n方便起见，某些类型的 DOM 元素可能会提供特定于其类型的其他属性。\n\n表格（Table）是一个很好的例子，它代表了一个特别重要的情况：\n\n**`<table>`** 元素支持 (除了上面给出的，之外) 以下属性:\n- `table.rows` —— `<tr>` 元素的集合。\n- `table.caption/tHead/tFoot` —— 引用元素 `<caption>`，`<thead>`，`<tfoot>`。\n- `table.tBodies` —— `<tbody>` 元素的集合（根据标准还有很多元素，但是这里至少会有一个 —— 即使没有被写在 HTML 源文件中，浏览器也会将其放入 DOM 中）。\n\n**`<thead>`，`<tfoot>`，`<tbody>`** 元素提供了 `rows` 属性：\n- `tbody.rows` —— 表格内部 `<tr>` 元素的集合。\n\n**`<tr>`：**\n- `tr.cells` —— 在给定 `<tr>` 中的 `<td>` 和 `<th>` 单元格的集合。\n- `tr.sectionRowIndex` —— 给定的 `<tr>` 在封闭的 `<thead>/<tbody>/<tfoot>` 中的位置（索引）。\n- `tr.rowIndex` —— 在整个表格中 `<tr>` 的编号（包括表格的所有行）。\n\n**`<td>` 和 `<th>`：**\n- `td.cellIndex` —— 在封闭的 `<tr>` 中单元格的编号。\n\n用法示例：\n\n```html run height=100\n<table id=\"table\">\n  <tr>\n    <td>one</td><td>two</td>\n  </tr>\n  <tr>\n    <td>three</td><td>four</td>\n  </tr>\n</table>\n\n<script>\n  // 获取带有 \"two\" 的 td（第一行，第二列）\n  let td = table.*!*rows[0].cells[1]*/!*;\n  td.style.backgroundColor = \"red\"; // highlight it\n</script>\n```\n\n规范：[tabular data](https://html.spec.whatwg.org/multipage/tables.html)。\n\nHTML 表单（form）还有其它导航（navigation）属性。稍后当我们开始使用表单（form）时，我们将对其进行研究。\n\n## 总结\n\n给定一个 DOM 节点，我们可以使用导航（navigation）属性访问其直接的邻居。\n\n这些属性主要分为两组：\n\n- 对于所有节点：`parentNode`，`childNodes`，`firstChild`，`lastChild`，`previousSibling`，`nextSibling`。\n- 仅对于元素节点：`parentElement`，`children`，`firstElementChild`，`lastElementChild`，`previousElementSibling`，`nextElementSibling`。\n\n某些类型的 DOM 元素，例如 table，提供了用于访问其内容的其他属性和集合。",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [
          "dom-children",
          "navigation-links-which-null",
          "select-diagonal-cells"
        ],
        "headHtml": "<style>\n#travel-dom-comment {\n  font-style: italic;\n}\n#travel-dom-control ul {\n  margin: 6px 0;\n}\n</style>",
        "parent": "document",
        "updatedAt": 1658834291
      }
    },
    "dom-children": {
      "type": "Task",
      "value": {
        "title": "DOM 子节点",
        "slug": "dom-children",
        "githubPath": "/2-ui/1-document/03-dom-navigation/1-dom-children",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n对于这个页面：\n\n```html\n<html>\n<body>\n  <div>Users:</div>\n  <ul>\n    <li>John</li>\n    <li>Pete</li>\n  </ul>\n</body>\n</html>\n```\n\n对于以下各项，请给出至少一种访问方式：\n- `<div>` DOM 节点？\n- `<ul>` DOM 节点？\n-  第二个 `<li>` 节点（即包含 Pete 的节点）？",
        "solution": "这里有很多种方法，例如：\n\n\n获取 `<div>` DOM 节点：\n\n```js\ndocument.body.firstElementChild\n// 或\ndocument.body.children[0]\n// 或（第一个节点是空格，所以我们应该获取的是第二个）\ndocument.body.childNodes[1]\n```\n\n获取 `<ul>` DOM 节点：\n\n```js\ndocument.body.lastElementChild\n// 或\ndocument.body.children[1]\n```\n\n获取第二个 `<li>`（即包含 Pete 的节点）：\n\n```js\n// 获取 <ul>，然后获取它的最后一个子元素\ndocument.body.lastElementChild.lastElementChild\n```",
        "parent": "dom-navigation",
        "version": 1
      }
    },
    "navigation-links-which-null": {
      "type": "Task",
      "value": {
        "title": "兄弟节点问题",
        "slug": "navigation-links-which-null",
        "githubPath": "/2-ui/1-document/03-dom-navigation/3-navigation-links-which-null",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n如果 `elem` 是任意一个 DOM 元素节点……\n\n- `elem.lastChild.nextSibling` 值一直都是 `null`，这个判定是不是真的？\n- `elem.children[0].previousSibling` 值一直都是 `null`，这个判定是不是真的？",
        "solution": "1. 是的，这是真的。`elem.lastChild` 就是最后一个节点，它没有 `nextSibling`。\n2. 不，这是错的，因为  `elem.children[0]` 是元素中的第一个子元素。但是在它前面可能存在非元素的节点。所以 `previousSibling` 可能是一个文本节点。\n\n请注意，对于这两种情况，如果没有子节点，那么就会报错。\n\n如果这里没有子节点，那么 `elem.lastChild` 是 `null`，所以我们就访问不到 `elem.lastChild.nextSibling`。并且 `elem.children` 是空的（像一个空数组一样 `[]`）。",
        "parent": "dom-navigation",
        "version": 1
      }
    },
    "select-diagonal-cells": {
      "type": "Task",
      "value": {
        "title": "选择所有对角单元格",
        "slug": "select-diagonal-cells",
        "githubPath": "/2-ui/1-document/03-dom-navigation/4-select-diagonal-cells",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写代码来把表格中的对角单元格都绘制成红色。\n\n你需要用代码从 `<table>` 中获取所有的对角单元格 `<td>`，然后绘制它们：\n\n```js\n// td 表示的是对单元格的引用\ntd.style.backgroundColor = 'red';\n```\n\n结果应该如下所示：\n\n[iframe src=\"solution\" height=180]",
        "solution": "我们将使用 `rows` 和 `cells` 属性来获取表格中的对角单元格。",
        "parent": "dom-navigation",
        "version": 1
      }
    },
    "searching-elements-dom": {
      "type": "Article",
      "value": {
        "title": "搜索：getElement*，querySelector*",
        "slug": "searching-elements-dom",
        "githubPath": "/2-ui/1-document/04-searching-elements-dom",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n当元素彼此靠得近时，DOM 导航属性（navigation property）非常有用。如果不是，那该怎么办？如何去获取页面上的任意元素？\n\n还有其他搜索方法。\n\n## document.getElementById 或者只使用 id\n\n如果一个元素有 `id` 特性（attribute），那我们就可以使用 `document.getElementById(id)` 方法获取该元素，无论它在哪里。\n\n例如：\n\n```html run\n<div id=\"elem\">\n  <div id=\"elem-content\">Element</div>\n</div>\n\n<script>\n  // 获取该元素\n*!*\n  let elem = document.getElementById('elem');\n*/!*\n\n  // 将该元素背景改为红色\n  elem.style.background = 'red';\n</script>\n```\n\n此外，还有一个通过 `id` 命名的全局变量，它引用了元素：\n\n```html run\n<div id=\"*!*elem*/!*\">\n  <div id=\"*!*elem-content*/!*\">Element</div>\n</div>\n\n<script>\n  // elem 是对带有 id=\"elem\" 的 DOM 元素的引用 \n  elem.style.background = 'red';\n\n  // id=\"elem-content\" 内有连字符，所以它不能成为一个变量\n  // ...但是我们可以通过使用方括号 window['elem-content'] 来访问它\n</script>\n```\n\n……除非我们声明一个具有相同名称的 JavaScript 变量，否则它具有优先权：\n\n```html run untrusted height=0\n<div id=\"elem\"></div>\n\n<script>\n  let elem = 5; // 现在 elem 是 5，而不是对 <div id=\"elem\"> 的引用\n\n  alert(elem); // 5\n</script>\n```\n\n```warn header=\"请不要使用以 id 命名的全局变量来访问元素\"\n[在规范中](http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem) 对此行为进行了描述，所以它是一种标准。但这是注意考虑到兼容性才支持的。\n\n浏览器尝试通过混合 JavaScript 和 DOM 的命名空间来帮助我们。对于内联到 HTML 中的简单脚本来说，这还行，但是通常来说，这不是一件好事。因为这可能会造成命名冲突。另外，当人们阅读 JavaScript 代码且看不到对应的 HTML 时，变量的来源就会不明显。\n\n在本教程中，我们只会在元素来源非常明显时，为了简洁起见，才会使用 `id` 直接引用对应的元素。\n\n在实际开发中，`document.getElementById` 是首选方法。\n```\n\n```smart header=\"`id` 必须是唯一的\"\n`id` 必须是唯一的。在文档中，只能有一个元素带有给定的 `id`。\n\n如果有多个元素都带有同一个 `id`，那么使用它的方法的行为是不可预测的，例如 `document.getElementById` 可能会随机返回其中一个元素。因此，请遵守规则，保持 `id` 的唯一性。\n```\n\n```warn header=\"只有 `document.getElementById`，没有 `anyElem.getElementById`\"\n`getElementById` 方法只能被在 `document` 对象上调用。它会在整个文档中查找给定的 `id`。\n```\n\n## querySelectorAll [#querySelectorAll]\n\n到目前为止，最通用的方法是 `elem.querySelectorAll(css)`，它返回 `elem` 中与给定 CSS 选择器匹配的所有元素。\n\n在这里，我们查找所有为最后一个子元素的 `<li>` 元素：\n\n```html run\n<ul>\n  <li>The</li>\n  <li>test</li>\n</ul>\n<ul>\n  <li>has</li>\n  <li>passed</li>\n</ul>\n<script>\n*!*\n  let elements = document.querySelectorAll('ul > li:last-child');\n*/!*\n\n  for (let elem of elements) {\n    alert(elem.innerHTML); // \"test\", \"passed\"\n  }\n</script>\n```\n\n这个方法确实功能强大，因为可以使用任何 CSS 选择器。\n\n```smart header=\"也可以使用伪类\"\nCSS 选择器的伪类，例如 `:hover` 和 `:active` 也都是被支持的。例如，`document.querySelectorAll(':hover')` 将会返回鼠标指针正处于其上方的元素的集合（按嵌套顺序：从最外层 `<html>` 到嵌套最多的元素）。\n```\n\n## querySelector [#querySelector]\n\n`elem.querySelector(css)` 调用会返回给定 CSS 选择器的第一个元素。\n\n换句话说，结果与 `elem.querySelectorAll(css)[0]` 相同，但是后者会查找 **所有** 元素，并从中选取一个，而 `elem.querySelector` 只会查找一个。因此它在速度上更快，并且写起来更短。\n\n## matches\n\n之前的方法是搜索 DOM。\n\n[elem.matches(css)](https://dom.spec.whatwg.org/#dom-element-matches) 不会查找任何内容，它只会检查 `elem` 是否与给定的 CSS 选择器匹配。它返回 `true` 或 `false`。\n\n当我们遍历元素（例如数组或其他内容）并试图过滤那些我们感兴趣的元素时，这个方法会很有用。\n\n例如：\n\n```html run\n<a href=\"http://example.com/file.zip\">...</a>\n<a href=\"http://ya.ru\">...</a>\n\n<script>\n  // 不一定是 document.body.children，还可以是任何集合\n  for (let elem of document.body.children) {\n*!*\n    if (elem.matches('a[href$=\"zip\"]')) {\n*/!*\n      alert(\"The archive reference: \" + elem.href );\n    }\n  }\n</script>\n```\n\n## closest\n\n元素的祖先（ancestor）是：父级，父级的父级，它的父级等。祖先们一起组成了从元素到顶端的父级链。\n\n`elem.closest(css)` 方法会查找与 CSS 选择器匹配的最近的祖先。`elem` 自己也会被搜索。\n\n换句话说，方法 `closest` 在元素中得到了提升，并检查每个父级。如果它与选择器匹配，则停止搜索并返回该祖先。\n\n例如：\n\n```html run\n<h1>Contents</h1>\n\n<div class=\"contents\">\n  <ul class=\"book\">\n    <li class=\"chapter\">Chapter 1</li>\n    <li class=\"chapter\">Chapter 2</li>\n  </ul>\n</div>\n\n<script>\n  let chapter = document.querySelector('.chapter'); // LI\n\n  alert(chapter.closest('.book')); // UL\n  alert(chapter.closest('.contents')); // DIV\n\n  alert(chapter.closest('h1')); // null（因为 h1 不是祖先）\n</script>\n```\n\n## getElementsBy*\n\n还有其他通过标签，类等查找节点的方法。\n\n如今，它们大多已经成为了历史，因为 `querySelector` 功能更强大，写起来更短。\n\n因此，这里我们介绍它们只是为了完整起见，而你仍然可以在旧脚本中找到这些方法。\n\n- `elem.getElementsByTagName(tag)` 查找具有给定标签的元素，并返回它们的集合。`tag` 参数也可以是对于“任何标签”的星号 `\"*\"`。\n- `elem.getElementsByClassName(className)` 返回具有给定CSS类的元素。\n- `document.getElementsByName(name)` 返回在文档范围内具有给定 `name` 特性的元素。很少使用。\n\n例如：\n```js\n// 获取文档中的所有 div\nlet divs = document.getElementsByTagName('div');\n```\n\n让我们查找 table 中的所有 `input` 标签：\n\n```html run height=50\n<table id=\"table\">\n  <tr>\n    <td>Your age:</td>\n\n    <td>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"young\" checked> less than 18\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"mature\"> from 18 to 50\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"senior\"> more than 60\n      </label>\n    </td>\n  </tr>\n</table>\n\n<script>\n*!*\n  let inputs = table.getElementsByTagName('input');\n*/!*\n\n  for (let input of inputs) {\n    alert( input.value + ': ' + input.checked );\n  }\n</script>\n```\n\n```warn header=\"不要忘记字母 `\\\"s\\\"`！\"\n新手开发者有时会忘记字符 `\"s\"`。也就是说，他们会调用 `getElementByTagName` 而不是 <code>getElement<b>s</b>ByTagName</code>。\n\n`getElementById` 中没有字母 `\"s\"`，是因为它只返回单个元素。但是 `getElementsByTagName` 返回的是元素的集合，所以里面有 `\"s\"`。\n```\n\n````warn header=\"它返回的是一个集合，不是一个元素！\"\n新手的另一个普遍的错误是写：\n\n```js\n// 行不通\ndocument.getElementsByTagName('input').value = 5;\n```\n\n这是行不通的，因为它需要的是一个 input 的 **集合**，并将值赋（assign）给它，而不是赋值给其中的一个元素。\n\n我们应该遍历集合或通过对应的索引来获取元素，然后赋值，如下所示：\n\n```js\n// 应该可以运行（如果有 input）\ndocument.getElementsByTagName('input')[0].value = 5;\n```\n````\n\n查找 `.article` 元素：\n\n```html run height=50\n<form name=\"my-form\">\n  <div class=\"article\">Article</div>\n  <div class=\"long article\">Long article</div>\n</form>\n\n<script>\n  // 按 name 特性查找\n  let form = document.getElementsByName('my-form')[0];\n\n  // 在 form 中按 class 查找\n  let articles = form.getElementsByClassName('article');\n  alert(articles.length); // 2, found two elements with class \"article\"\n</script>\n```\n\n## 实时的集合\n\n所有的 `\"getElementsBy*\"` 方法都会返回一个 **实时的（live）** 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。\n\n在下面的例子中，有两个脚本。\n\n1. 第一个创建了对 `<div>` 的集合的引用。截至目前，它的长度是 `1`。\n2. 第二个脚本在浏览器再遇到一个 `<div>` 时运行，所以它的长度是 `2`。\n\n```html run\n<div>First div</div>\n\n<script>\n  let divs = document.getElementsByTagName('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n*!*\n  alert(divs.length); // 2\n*/!*\n</script>\n```\n\n相反，`querySelectorAll` 返回的是一个 **静态的** 集合。就像元素的固定数组。\n\n如果我们使用它，那么两个脚本都会输出 `1`：\n\n\n```html run\n<div>First div</div>\n\n<script>\n  let divs = document.querySelectorAll('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n*!*\n  alert(divs.length); // 1\n*/!*\n</script>\n```\n\n现在我们可以很容易地看到不同之处。在文档中出现新的 `div` 后，静态集合并没有增加。\n\n## 总结\n\n有 6 种主要的方法，可以在 DOM 中搜索元素节点：\n\n<table>\n<thead>\n<tr>\n<td>方法名</td>\n<td>搜索方式</td>\n<td>可以在元素上调用？</td>\n<td>实时的？</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>querySelector</code></td>\n<td>CSS-selector</td>\n<td>✔</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>querySelectorAll</code></td>\n<td>CSS-selector</td>\n<td>✔</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>getElementById</code></td>\n<td><code>id</code></td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td><code>getElementsByName</code></td>\n<td><code>name</code></td>\n<td>-</td>\n<td>✔</td>\n</tr>\n<tr>\n<td><code>getElementsByTagName</code></td>\n<td>tag or <code>'*'</code></td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n<tr>\n<td><code>getElementsByClassName</code></td>\n<td>class</td>\n<td>✔</td>\n<td>✔</td>\n</tr>\n</tbody>\n</table>\n\n目前为止，最常用的是 `querySelector` 和 `querySelectorAll`，但是 `getElement(s)By*` 可能会偶尔有用，或者可以在旧脚本中找到。\n\n此外：\n\n- `elem.matches(css)` 用于检查 `elem` 与给定的 CSS 选择器是否匹配。\n- `elem.closest(css)` 用于查找与给定 CSS 选择器相匹配的最近的祖先。`elem` 本身也会被检查。\n\n让我们在这里提一下另一种用来检查子级与父级之间关系的方法，因为它有时很有用：\n- 如果 `elemB` 在 `elemA` 内（`elemA` 的后代）或者 `elemA==elemB`，`elemA.contains(elemB)` 将返回 true。",
        "libs": [],
        "children": [
          "find-elements"
        ],
        "parent": "document",
        "updatedAt": 1657705346
      }
    },
    "find-elements": {
      "type": "Task",
      "value": {
        "title": "搜索元素",
        "slug": "find-elements",
        "githubPath": "/2-ui/1-document/04-searching-elements-dom/1-find-elements",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\n\n这是带有表格（table）和表单（form）的文档。\n\n如何查找？……\n\n1. 带有 `id=\"age-table\"` 的表格。\n2. 表格内的所有 `label` 元素（应该有三个）。\n3. 表格中的第一个 `td`（带有 \"Age\" 字段）。\n4. 带有 `name=\"search\"` 的 `form`。\n5. 表单中的第一个 `input`。\n6. 表单中的最后一个 `input`。\n\n在一个单独的窗口中打开 [table.html](table.html) 页面，并对此页面使用浏览器开发者工具。",
        "solution": "实现的方式有很多种。\n\n以下列举的是其中一些方法：\n\n```js\n// 1. 带有 id=\"age-table\" 的表格。\nlet table = document.getElementById('age-table')\n\n// 2. 表格内的所有 label 元素\ntable.getElementsByTagName('label')\n// 或\ndocument.querySelectorAll('#age-table label')\n\n// 3. 表格中的第一个 td（带有 \"Age\" 字段）\ntable.rows[0].cells[0]\n// 或\ntable.getElementsByTagName('td')[0]\n// 或\ntable.querySelector('td')\n\n// 4. 带有 name=\"search\" 的 form。\n// 假设文档中只有一个 name=\"search\" 的元素\nlet form = document.getElementsByName('search')[0]\n// 或者，专门对于 form\ndocument.querySelector('form[name=\"search\"]')\n\n// 5. 表单中的第一个 input\nform.getElementsByTagName('input')[0]\n// 或\nform.querySelector('input')\n\n// 6. 表单中的最后一个 input\nlet inputs = form.querySelectorAll('input') // 查找所有 input\ninputs[inputs.length-1] // 取出最后一个\n```",
        "parent": "searching-elements-dom",
        "version": 1
      }
    },
    "basic-dom-node-properties": {
      "type": "Article",
      "value": {
        "title": "节点属性：type，tag 和 content",
        "slug": "basic-dom-node-properties",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n让我们更深入地了解一下 DOM 节点。\n\n在本章中，我们将更深入地了解它们是什么，并学习它们最常用的属性。\n\n## DOM 节点类\n\n不同的 DOM 节点可能有不同的属性。例如，标签 `<a>` 相对应的元素节点具有链接相关的（link-related）属性，标签 `<input>` 相对应的元素节点具有与输入相关的属性，等。文本节点与元素节点不同。但是所有这些标签对应的 DOM 节点之间也存在共有的属性和方法，因为所有类型的 DOM 节点都形成了一个单一层次的结构（single hierarchy）。\n\n每个 DOM 节点都属于相应的内建类。\n\n层次结构（hierarchy）的根节点是 [EventTarget](https://dom.spec.whatwg.org/#eventtarget)，[Node](https://dom.spec.whatwg.org/#interface-node) 继承自它，其他 DOM 节点继承自 Node。\n\n下图做了进一步说明：\n\n![](dom-class-hierarchy.svg)\n\n类如下所示：\n\n- [EventTarget](https://dom.spec.whatwg.org/#eventtarget) —— 是一切的根“抽象（abstract）”类。\n\n    该类的对象从未被创建。它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”，我们会在之后学习它。\n\n- [Node](http://dom.spec.whatwg.org/#interface-node) —— 也是一个“抽象”类，充当 DOM 节点的基础。\n\n    它提供了树的核心功能：`parentNode`，`nextSibling`，`childNodes` 等（它们都是 getter）。`Node` 类的对象从未被创建。但是还有一些继承自它的其他类（因此继承了 `Node` 的功能）。\n\n- [Document](https://dom.spec.whatwg.org/#interface-document) 由于历史原因通常被 `HTMLDocument` 继承（尽管最新的规范没有规定）—— 是一个整体的文档。\n\n    全局变量 `document` 就是属于这个类。它作为 DOM 的入口。\n\n- [CharacterData](https://dom.spec.whatwg.org/#interface-characterdata) —— 一个“抽象”类，被下述类继承：\n    - [Text](https://dom.spec.whatwg.org/#interface-text) —— 对应于元素内部文本的类，例如 `<p>Hello</p>` 中的 `Hello`。\n    - [Comment](https://dom.spec.whatwg.org/#interface-comment) —— 注释类。它们不会被展示出来，但每个注释都会成为 DOM 中的一员。\n\n- [Element](http://dom.spec.whatwg.org/#interface-element) —— 是 DOM 元素的基础类。\n\n    它提供了元素级导航（navigation），如 `nextElementSibling`，`children`，以及搜索方法，如 `getElementsByTagName` 和 `querySelector`。\n\n    浏览器不仅支持 HTML，还支持 XML 和 SVG。因此，`Element` 类充当的是更具体的类的基础：`SVGElement`，`XMLElement`（我们在这里不需要它）和 `HTMLElement`。\n\n- 最后，[HTMLElement](https://html.spec.whatwg.org/multipage/dom.html#htmlelement) —— 是所有 HTML 元素的基础类。我们大部分时候都会用到它。\n\n    它会被更具体的 HTML 元素继承：\n    - [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) —— `<input>` 元素的类，\n    - [HTMLBodyElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement) —— `<body>` 元素的类，\n    - [HTMLAnchorElement](https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement) —— `<a>` 元素的类，\n    - ……等。\n\n还有很多其他标签具有自己的类，可能还具有特定的属性和方法，而一些元素，如 `<span>`、`<section>`、`<article>` 等，没有任何特定的属性，所以它们是 `HTMLElement` 类的实例。\n\n因此，给定节点的全部属性和方法都是继承链的结果。\n\n例如，我们考虑一下 `<input>` 元素的 DOM 对象。它属于 [HTMLInputElement](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) 类。\n\n它获取属性和方法，并将其作为下列类（按继承顺序列出）的叠加：\n\n- `HTMLInputElement` —— 该类提供特定于输入的属性，\n- `HTMLElement` —— 它提供了通用（common）的 HTML 元素方法（以及 getter 和 setter）\n- `Element` —— 提供通用（generic）元素方法，\n- `Node` —— 提供通用 DOM 节点属性，\n- `EventTarget` —— 为事件（包括事件本身）提供支持，\n- ……最后，它继承自 `Object`，因为像 `hasOwnProperty` 这样的“普通对象”方法也是可用的。\n\n我们可以通过回调来查看 DOM 节点类名，因为对象通常都具有 `constructor` 属性。它引用类的 constructor，`constructor.name` 就是它的名称：\n\n```js run\nalert( document.body.constructor.name ); // HTMLBodyElement\n```\n\n……或者我们可以对其使用 `toString` 方法：\n\n```js run\nalert( document.body ); // [object HTMLBodyElement]\n```\n\n我们还可以使用 `instanceof` 来检查继承：\n\n```js run\nalert( document.body instanceof HTMLBodyElement ); // true\nalert( document.body instanceof HTMLElement ); // true\nalert( document.body instanceof Element ); // true\nalert( document.body instanceof Node ); // true\nalert( document.body instanceof EventTarget ); // true\n```\n\n正如我们所看到的，DOM 节点是常规的 JavaScript 对象。它们使用基于原型的类进行继承。\n\n在浏览器中，使用 `console.dir(elem)` 输出元素来查看也是非常容易的。在控制台中，你可以看到 `HTMLElement.prototype` 和 `Element.prototype` 等。\n\n```smart header=\"`console.dir(elem)` 与 `console.log(elem)`\"\n大多数浏览器在其开发者工具中都支持这两个命令：`console.log` 和 `console.dir`。它们将它们的参数输出到控制台中。对于 JavaScript 对象，这些命令通常做的是相同的事。\n\n但对于 DOM 元素，它们是不同的：\n\n- `console.log(elem)` 显示元素的 DOM 树。\n- `console.dir(elem)` 将元素显示为 DOM 对象，非常适合探索其属性。\n\n你可以在 `document.body` 上尝试一下。\n```\n\n````smart header=\"规范中的 IDL\"\n在规范中，DOM 类不是使用 JavaScript 来描述的，而是一种特殊的 [接口描述语言（Interface description language）](https://en.wikipedia.org/wiki/Interface_description_language)，简写为 IDL，它通常很容易理解。\n\n在 IDL 中，所有属性以其类型开头。例如，`DOMString` 和 `boolean` 等。\n\n以下是摘录（excerpt），并附有注释：\n\n```js\n// 定义 HTMLInputElement\n*!*\n// 冒号 \":\" 表示 HTMLInputElement 继承自 HTMLElement\n*/!*\ninterface HTMLInputElement: HTMLElement {\n  // 接下来是 <input> 元素的属性和方法\n\n*!*\n  // \"DOMString\" 表示属性的值是字符串\n*/!*\n  attribute DOMString accept;\n  attribute DOMString alt;\n  attribute DOMString autocomplete;\n  attribute DOMString value;\n\n*!*\n  // 布尔值属性（true/false）\n  attribute boolean autofocus;\n*/!*\n  ...\n*!*\n  // 现在方法：\"void\" 表示方法没有返回值\n*/!*\n  void select();\n  ...\n}\n```\n````\n\n## \"nodeType\" 属性\n\n`nodeType` 属性提供了另一种“过时的”用来获取 DOM 节点类型的方法。\n\n它有一个数值型值（numeric value）：\n- 对于元素节点 `elem.nodeType == 1`，\n- 对于文本节点 `elem.nodeType == 3`，\n- 对于 document 对象 `elem.nodeType == 9`，\n- 在 [规范](https://dom.spec.whatwg.org/#node) 中还有一些其他值。\n\n例如：\n\n```html run\n<body>\n  <script>\n  let elem = document.body;\n\n  // 让我们检查一下：elem 中的节点类型是什么？\n  alert(elem.nodeType); // 1 => element\n\n  // 它的第一个子节点的类型是……\n  alert(elem.firstChild.nodeType); // 3 => text\n\n  // 对于 document 对象，类型是 9\n  alert( document.nodeType ); // 9\n  </script>\n</body>\n```\n\n在现代脚本中，我们可以使用 `instanceof` 和其他基于类的检查方法来查看节点类型，但有时 `nodeType` 可能更简单。我们只能读取 `nodeType` 而不能修改它。\n\n## 标签：nodeName 和 tagName\n\n给定一个 DOM 节点，我们可以从 `nodeName` 或者 `tagName` 属性中读取它的标签名：\n\n例如：\n\n```js run\nalert( document.body.nodeName ); // BODY\nalert( document.body.tagName ); // BODY\n```\n\ntagName 和 nodeName 之间有什么不同吗？\n\n当然，差异就体现在它们的名字上，但确实有些微妙。\n\n- `tagName` 属性仅适用于 `Element` 节点。\n- `nodeName` 是为任意 `Node` 定义的：\n    - 对于元素，它的意义与 `tagName` 相同。\n    - 对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串。\n\n换句话说，`tagName` 仅受元素节点支持（因为它起源于 `Element` 类），而 `nodeName` 则可以说明其他节点类型。\n\n例如，我们比较一下 `document` 的 `tagName` 和 `nodeName`，以及一个注释节点：\n\n\n```html run\n<body><!-- comment -->\n\n  <script>\n    // for comment\n    alert( document.body.firstChild.tagName ); // undefined（不是一个元素）\n    alert( document.body.firstChild.nodeName ); // #comment\n\n    // for document\n    alert( document.tagName ); // undefined（不是一个元素）\n    alert( document.nodeName ); // #document\n  </script>\n</body>\n```\n\n如果我们只处理元素，那么 `tagName` 和 `nodeName` 这两种方法，我们都可以使用，没有区别。\n\n```smart header=\"标签名称始终是大写的，除非是在 XML 模式下\"\n浏览器有两种处理文档（document）的模式：HTML 和 XML。通常，HTML 模式用于网页。只有在浏览器接收到带有 `Content-Type: application/xml+xhtml` header 的 XML-document 时，XML 模式才会被启用。\n\n在 HTML 模式下，`tagName/nodeName` 始终是大写的：它是 `BODY`，而不是 `<body>` 或 `<BoDy>`。\n\n在 XML 模式中，大小写保持为“原样”。如今，XML 模式很少被使用。\n```\n\n\n## innerHTML：内容\n\n[innerHTML](https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin) 属性允许将元素中的 HTML 获取为字符串形式。\n\n我们也可以修改它。因此，它是更改页面最有效的方法之一。\n\n下面这个示例显示了 `document.body` 中的内容，然后将其完全替换：\n\n```html run\n<body>\n  <p>A paragraph</p>\n  <div>A div</div>\n\n  <script>\n    alert( document.body.innerHTML ); // 读取当前内容\n    document.body.innerHTML = 'The new BODY!'; // 替换它\n  </script>\n\n</body>\n```\n\n我们可以尝试插入无效的 HTML，浏览器会修复我们的错误：\n\n```html run\n<body>\n\n  <script>\n    document.body.innerHTML = '<b>test'; // 忘记闭合标签\n    alert( document.body.innerHTML ); // <b>test</b>（被修复了）\n  </script>\n\n</body>\n```\n\n```smart header=\"脚本不会执行\"\n如果 `innerHTML` 将一个 `<script>` 标签插入到 document 中 —— 它会成为 HTML 的一部分，但是不会执行。\n```\n\n### 小心：\"innerHTML+=\" 会进行完全重写\n\n我们可以使用 `elem.innerHTML+=\"more html\"` 将 HTML 附加到元素上。\n\n就像这样：\n\n```js\nchatDiv.innerHTML += \"<div>Hello<img src='smile.gif'/> !</div>\";\nchatDiv.innerHTML += \"How goes?\";\n```\n\n但我们必须非常谨慎地使用它，因为我们所做的 **不是** 附加内容，而且完全地重写。\n\n从技术上来说，下面这两行代码的作用相同：\n\n```js\nelem.innerHTML += \"...\";\n// 进行写入的一种更简短的方式：\n*!*\nelem.innerHTML = elem.innerHTML + \"...\"\n*/!*\n```\n\n换句话说，`innerHTML+=` 做了以下工作：\n\n1. 移除旧的内容。\n2. 然后写入新的 `innerHTML`（新旧结合）。\n\n**因为内容已“归零”并从头开始重写，因此所有的图片和其他资源都将重写加载。**\n\n在上面的 `chatDiv` 示例中，`chatDiv.innerHTML+=\"How goes?\"` 重建了 HTML 内容并重新加载了 `smile.gif`（希望它是缓存的）。如果 `chatDiv` 有许多其他文本和图片，那么就很容易看到重新加载（译注：是指在有很多内容时，重新加载会耗费更多的时间，所以你就很容易看见页面重载的过程）。\n\n并且还会有其他副作用。例如，如果现有的文本被用鼠标选中了，那么大多数浏览器都会在重写 `innerHTML` 时删除选定状态。如果这里有一个带有用户输入的文本的 `<input>`，那么这个被输入的文本将会被移除。诸如此类。\n\n幸运的是，除了 `innerHTML`，还有其他可以添加 HTML 的方法，我们很快就会学到。\n\n## outerHTML：元素的完整 HTML\n\n`outerHTML` 属性包含了元素的完整 HTML。就像 `innerHTML` 加上元素本身一样。\n\n下面是一个示例：\n\n```html run\n<div id=\"elem\">Hello <b>World</b></div>\n\n<script>\n  alert(elem.outerHTML); // <div id=\"elem\">Hello <b>World</b></div>\n</script>\n```\n\n**注意：与 `innerHTML` 不同，写入 `outerHTML` 不会改变元素。而是在 DOM 中替换它。**\n\n是的，听起来很奇怪，它确实很奇怪，这就是为什么我们在这里对此做了一个单独的注释。看一下。\n\n考虑下面这个示例：\n\n```html run\n<div>Hello, world!</div>\n\n<script>\n  let div = document.querySelector('div');\n\n*!*\n  // 使用 <p>...</p> 替换 div.outerHTML\n*/!*\n  div.outerHTML = '<p>A new element</p>'; // (*)\n\n*!*\n  // 蛤！'div' 还是原来那样！\n*/!*\n  alert(div.outerHTML); // <div>Hello, world!</div> (**)\n</script>\n```\n\n看起来真的很奇怪，对吧？\n\n在 `(*)` 行，我们使用 `<p>A new element</p>` 替换 `div`。在外部文档（DOM）中我们可以看到的是新内容而不是 `<div>`。但是正如我们在 `(**)` 行所看到的，旧的 `div` 变量并没有被改变。\n\n`outerHTML` 赋值不会修改 DOM 元素（在这个例子中是被 'div' 引用的对象），而是将其从 DOM 中删除并在其位置插入新的 HTML。\n\n所以，在 `div.outerHTML=...` 中发生的事情是：\n- `div` 被从文档（document）中移除。\n- 另一个 HTML 片段 `<p>A new element</p>` 被插入到其位置上。\n- `div` 仍拥有其旧的值。新的 HTML 没有被赋值给任何变量。\n\n在这儿很容易出错：修改 `div.outerHTML` 然后继续使用 `div`，就好像它包含的是新内容一样。但事实并非如此。这样的东西对于 `innerHTML` 是正确的，但是对于 `outerHTML` 却不正确。\n\n我们可以向 `elem.outerHTML` 写入内容，但是要记住，它不会改变我们所写的元素（'elem'）。而是将新的 HTML 放在其位置上。我们可以通过查询 DOM 来获取对新元素的引用。\n\n## nodeValue/data：文本节点内容\n\n`innerHTML` 属性仅对元素节点有效。\n\n其他节点类型，例如文本节点，具有它们的对应项：`nodeValue` 和 `data` 属性。这两者在实际使用中几乎相同，只有细微规范上的差异。因此，我们将使用 `data`，因为它更短。\n\n读取文本节点和注释节点的内容的示例：\n\n```html run height=\"50\"\n<body>\n  Hello\n  <!-- Comment -->\n  <script>\n    let text = document.body.firstChild;\n*!*\n    alert(text.data); // Hello\n*/!*\n\n    let comment = text.nextSibling;\n*!*\n    alert(comment.data); // Comment\n*/!*\n  </script>\n</body>\n```\n\n对于文本节点，我们可以想象读取或修改它们的原因，但是注释呢？\n\n有时，开发者会将信息或模板说明嵌入到 HTML 中的注释中，如下所示：\n\n```html\n<!-- if isAdmin -->\n  <div>Welcome, Admin!</div>\n<!-- /if -->\n```\n\n……然后，JavaScript 可以从 `data` 属性中读取它，并处理嵌入的指令。\n\n## textContent：纯文本\n\n`textContent` 提供了对元素内的 **文本** 的访问权限：仅文本，去掉所有 `<tags>`。\n\n例如：\n\n```html run\n<div id=\"news\">\n  <h1>Headline!</h1>\n  <p>Martians attack people!</p>\n</div>\n\n<script>\n  // Headline! Martians attack people!\n  alert(news.textContent);\n</script>\n```\n\n正如我们所看到，只返回文本，就像所有 `<tags>` 都被剪掉了一样，但实际上其中的文本仍然存在。\n\n在实际开发中，用到这样的文本读取的场景非常少。\n\n**写入 `textContent` 要有用得多，因为它允许以“安全方式”写入文本。**\n\n假设我们有一个用户输入的任意字符串，我们希望将其显示出来。\n\n- 使用 `innerHTML`，我们将其“作为 HTML”插入，带有所有 HTML 标签。\n- 使用 `textContent`，我们将其“作为文本”插入，所有符号（symbol）均按字面意义处理。\n\n比较两者：\n\n```html run\n<div id=\"elem1\"></div>\n<div id=\"elem2\"></div>\n\n<script>\n  let name = prompt(\"What's your name?\", \"<b>Winnie-the-Pooh!</b>\");\n\n  elem1.innerHTML = name;\n  elem2.textContent = name;\n</script>\n```\n\n1. 第一个 `<div>` 获取 name “作为 HTML”：所有标签都变成标签，所以我们可以看到粗体的 name。\n2. 第二个 `<div>` 获取 name “作为文本”，因此我们可以从字面上看到 `<b>Winnie-the-Pooh!</b>`。\n\n在大多数情况下，我们期望来自用户的文本，并希望将其视为文本对待。我们不希望在我们的网站中出现意料不到的 HTML。对 `textContent` 的赋值正好可以做到这一点。\n\n## \"hidden\" 属性\n\n\"hidden\" 特性（attribute）和 DOM 属性（property）指定元素是否可见。\n\n我们可以在 HTML 中使用它，或者使用 JavaScript 对其进行赋值，如下所示：\n\n```html run height=\"80\"\n<div>Both divs below are hidden</div>\n\n<div hidden>With the attribute \"hidden\"</div>\n\n<div id=\"elem\">JavaScript assigned the property \"hidden\"</div>\n\n<script>\n  elem.hidden = true;\n</script>\n```\n\n从技术上来说，`hidden` 与 `style=\"display:none\"` 做的是相同的事。但 `hidden` 写法更简洁。\n\n这里有一个 blinking 元素：\n\n\n```html run height=50\n<div id=\"elem\">A blinking element</div>\n\n<script>\n  setInterval(() => elem.hidden = !elem.hidden, 1000);\n</script>\n```\n\n## 更多属性\n\nDOM 元素还有其他属性，特别是那些依赖于 class 的属性：\n\n- `value` —— `<input>`，`<select>` 和 `<textarea>`（`HTMLInputElement`，`HTMLSelectElement`……）的 value。\n- `href` —— `<a href=\"...\">`（`HTMLAnchorElement`）的 href。\n- `id` —— 所有元素（`HTMLElement`）的 \"id\" 特性（attribute）的值。\n- ……以及更多其他内容……\n\n例如：\n\n```html run height=\"80\"\n<input type=\"text\" id=\"elem\" value=\"value\">\n\n<script>\n  alert(elem.type); // \"text\"\n  alert(elem.id); // \"elem\"\n  alert(elem.value); // value\n</script>\n```\n\n大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性，我们可以像这样访问它。\n\n如果我们想知道给定类的受支持属性的完整列表，我们可以在规范中找到它们。例如，在 <https://html.spec.whatwg.org/#htmlinputelement> 中记录了 `HTMLInputElement`。\n\n或者，如果我们想要快速获取它们，或者对具体的浏览器规范感兴趣 — 我们总是可以使用 `console.dir(elem)` 输出元素并读取其属性。或者在浏览器的开发者工具的元素（Elements）标签页中探索“DOM 属性”。\n\n## 总结\n\n每个 DOM 节点都属于一个特定的类。这些类形成层次结构（hierarchy）。完整的属性和方法集是继承的结果。\n\n主要的 DOM 节点属性有：\n\n`nodeType`\n: 我们可以使用它来查看节点是文本节点还是元素节点。它具有一个数值型值（numeric value）：`1` 表示元素，`3` 表示文本节点，其他一些则代表其他节点类型。只读。\n\n`nodeName/tagName`\n: 用于元素名，标签名（除了 XML 模式，都要大写）。对于非元素节点，`nodeName` 描述了它是什么。只读。\n\n`innerHTML`\n: 元素的 HTML 内容。可以被修改。\n\n`outerHTML`\n: 元素的完整 HTML。对 `elem.outerHTML` 的写入操作不会触及 `elem` 本身。而是在外部上下文中将其替换为新的 HTML。\n\n`nodeValue/data`\n: 非元素节点（文本、注释）的内容。两者几乎一样，我们通常使用 `data`。可以被修改。\n\n`textContent`\n: 元素内的文本：HTML 减去所有 `<tags>`。写入文本会将文本放入元素内，所有特殊字符和标签均被视为文本。可以安全地插入用户生成的文本，并防止不必要的 HTML 插入。\n\n`hidden`\n: 当被设置为 `true` 时，执行与 CSS `display:none` 相同的事。\n\nDOM 节点还具有其他属性，具体有哪些属性则取决于它们的类。例如，`<input>` 元素（`HTMLInputElement`）支持 `value`，`type`，而 `<a>` 元素（`HTMLAnchorElement`）则支持 `href` 等。大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性。\n\n然而，但是 HTML 特性（attribute）和 DOM 属性（property）并不总是相同的，我们将在下一章中看到。",
        "libs": [],
        "children": [
          "tree-info",
          "lastchild-nodetype-inline",
          "tag-in-comment",
          "where-document-in-hierarchy"
        ],
        "parent": "document",
        "updatedAt": 1658838826
      }
    },
    "lastchild-nodetype-inline": {
      "type": "Task",
      "value": {
        "title": "nodeType 中是什么？",
        "slug": "lastchild-nodetype-inline",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/2-lastchild-nodetype-inline",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面这个脚本会显示什么？\n\n```html\n<html>\n\n<body>\n  <script>\n    alert(document.body.lastChild.nodeType);\n  </script>\n</body>\n\n</html>\n```",
        "solution": "这里有一个陷阱。\n\n在 `<script>` 执行时，最后一个 DOM 节点就是 `<script>`，因为浏览器还没有处理页面的其余部分。\n\n所以结果是 `1`（元素节点）。\n\n```html run height=60\n<html>\n\n<body>\n  <script>\n    alert(document.body.lastChild.nodeType);\n  </script>\n</body>\n\n</html>\n```",
        "parent": "basic-dom-node-properties",
        "version": 1
      }
    },
    "tree-info": {
      "type": "Task",
      "value": {
        "title": "计数后代",
        "slug": "tree-info",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/2-tree-info",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n这里有一个树结构嵌套的 `ul/li`。\n\n编写代码，为每个 `<li>` 显示：\n\n1. 里面的文本内容是什么（没有子树）\n2. 嵌套的 `<li>` 的数量 —— 所有后代，包括深层嵌套的后代。\n\n[demo src=\"solution\"]",
        "solution": "我们使用循环遍历 `<li>`：\n\n```js\nfor (let li of document.querySelectorAll('li')) {\n  ...\n}\n```\n\n循环时，我们需要获取每个 `li` 中的文本。\n\n我们可以从 `li` 的第一个子节点读取文本，即文本节点：\n\n```js\nfor (let li of document.querySelectorAll('li')) {\n  let title = li.firstChild.data;\n\n  // title 是在 <li> 中的任何其他节点之前的文本\n}\n```\n\n然后我们就可以使用 `li.getElementsByTagName('li')` 来获取后代的数目了。",
        "parent": "basic-dom-node-properties",
        "version": 1
      }
    },
    "tag-in-comment": {
      "type": "Task",
      "value": {
        "title": "注释中的标签",
        "slug": "tag-in-comment",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/3-tag-in-comment",
        "weight": 3,
        "libs": [],
        "importance": 3,
        "content": "\n\n这段代码会显示什么？\n\n```html\n<script>\n  let body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // 这里会显示什么？\n</script>\n```",
        "solution": "答案：**`BODY`**。\n\n```html run\n<script>\n  let body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // BODY\n</script>\n```\n\n让我们一步一步来看看发生了什么：\n\n1. `<body>` 中的内容被注释所取代。注释为 `<!--BODY-->`，因为 `body.tagName == \"BODY\"`。正如我们所记得的，在 HTML 模式下，`tagName` 总是大写的。\n2. 现在这个注释是唯一的子节点，所以我们在 `body.firstChild` 中获取了它。\n3. 注释的 `data` 属性是它的内容（在 `<!--...-->` 内的)：`\"BODY\"`。",
        "parent": "basic-dom-node-properties",
        "version": 1
      }
    },
    "where-document-in-hierarchy": {
      "type": "Task",
      "value": {
        "title": "层次结构中的 \"document\" 在哪里？",
        "slug": "where-document-in-hierarchy",
        "githubPath": "/2-ui/1-document/05-basic-dom-node-properties/4-where-document-in-hierarchy",
        "weight": 4,
        "libs": [],
        "importance": 4,
        "content": "\n\n`document` 属于哪一类？\n\n它位于 DOM 层次结构（hierarchy）中的什么位置？\n\n它继承自 `Node` 还是 `Element`，或者可能是 `HTMLElement`？",
        "solution": "我们可以通过输出它，来看看它是属于哪个类的，像这样：\n\n```js run\nalert(document); // [object HTMLDocument]\n```\n\n或者：\n\n```js run\nalert(document.constructor.name); // HTMLDocument\n```\n\n因此，`document` 是 `HTMLDocument` 类的一个实例。\n\n它位于 DOM 层次结构（hierarchy）中的什么位置？\n\n是的，我们可以浏览规范，但是手动找出它会更快。\n\n我们通过 `__proto__` 来遍历原型链。\n\n正如我们所知道的，类的方法在 constructor 的 `prototype` 中。例如，`HTMLDocument.prototype` 有用于文档（document）的方法。\n\n此外，在 `prototype` 中还有一个对构造函数的引用：\n\n```js run\nalert(HTMLDocument.prototype.constructor === HTMLDocument); // true\n```\n\n为了以字符串的形式获取一个类的 name，我们可以使用 `constructor.name`。让我们对整个 `document` 的原型链执行该操作，直到 class `Node`：\n\n```js run\nalert(HTMLDocument.prototype.constructor.name); // HTMLDocument\nalert(HTMLDocument.prototype.__proto__.constructor.name); // Document\nalert(HTMLDocument.prototype.__proto__.__proto__.constructor.name); // Node\n```\n\n这就是层次结构。\n\n我们还可以使用 `console.dir(document)` 来检查对象，并通过打开 `__proto__` 来查看这些名称。控制台将它们从 `constructor` 内部取出来。",
        "parent": "basic-dom-node-properties",
        "version": 1
      }
    },
    "dom-attributes-and-properties": {
      "type": "Article",
      "value": {
        "title": "特性和属性（Attributes and properties）",
        "slug": "dom-attributes-and-properties",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象。对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）。（译注：attribute 和 property 两词意思相近，为作区分，全文将 attribute 译为“特性”，property 译为“属性”，请读者注意区分。）\n\n例如，如果标签是 `<body id=\"page\">`，那么 DOM 对象就会有 `body.id=\"page\"`。\n\n但特性—属性映射并不是一一对应的！在本章，我们将带领你一起分清楚这两个概念，了解如何使用它们，了解它们何时相同何时不同。\n\n## DOM 属性\n\n我们已经见过了内建 DOM 属性。它们数量庞大。但是从技术上讲，没有人会限制我们，如果我们觉得这些 DOM 还不够，我们可以添加我们自己的。\n\nDOM 节点是常规的 JavaScript 对象。我们可以更改它们。\n\n例如，让我们在 `document.body` 中创建一个新的属性：\n\n```js run\ndocument.body.myData = {\n  name: 'Caesar',\n  title: 'Imperator'\n};\n\nalert(document.body.myData.title); // Imperator\n```\n\n我们也可以像下面这样添加一个方法：\n\n```js run\ndocument.body.sayTagName = function() {\n  alert(this.tagName);\n};\n\ndocument.body.sayTagName(); // BODY（这个方法中的 \"this\" 的值是 document.body）\n```\n\n我们还可以修改内建属性的原型，例如修改 `Element.prototype` 为所有元素添加一个新方法：\n\n```js run\nElement.prototype.sayHi = function() {\n  alert(`Hello, I'm ${this.tagName}`);\n};\n\ndocument.documentElement.sayHi(); // Hello, I'm HTML\ndocument.body.sayHi(); // Hello, I'm BODY\n```\n\n所以，DOM 属性和方法的行为就像常规的 Javascript 对象一样：\n\n- 它们可以有很多值。\n- 它们是大小写敏感的（要写成 `elem.nodeType`，而不是 `elem.NoDeTyPe`）。\n\n## HTML 特性\n\n在 HTML 中，标签可能拥有特性（attributes）。当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 **标准的** 特性并以此创建 DOM 属性。\n\n所以，当一个元素有 `id` 或其他 **标准的** 特性，那么就会生成对应的 DOM 属性。但是非 **标准的** 特性则不会。\n\n例如：\n```html run\n<body id=\"test\" something=\"non-standard\">\n  <script>\n    alert(document.body.id); // test\n*!*\n    // 非标准的特性没有获得对应的属性\n    alert(document.body.something); // undefined\n*/!*\n  </script>\n</body>\n```\n\n请注意，一个元素的标准的特性对于另一个元素可能是未知的。例如 `\"type\"` 是 `<input>` 的一个标准的特性（[HTMLInputElement](https://html.spec.whatwg.org/#htmlinputelement)），但对于 `<body>`（[HTMLBodyElement](https://html.spec.whatwg.org/#htmlbodyelement)）来说则不是。规范中对相应元素类的标准的属性进行了详细的描述。\n\n这里我们可以看到：\n```html run\n<body id=\"body\" type=\"...\">\n  <input id=\"input\" type=\"text\">\n  <script>\n    alert(input.type); // text\n*!*\n    alert(body.type); // undefined：DOM 属性没有被创建，因为它不是一个标准的特性\n*/!*\n  </script>\n</body>\n```\n\n所以，如果一个特性不是标准的，那么就没有相对应的 DOM 属性。那我们有什么方法来访问这些特性吗？\n\n当然。所有特性都可以通过使用以下方法进行访问：\n\n- `elem.hasAttribute(name)` —— 检查特性是否存在。\n- `elem.getAttribute(name)` —— 获取这个特性值。\n- `elem.setAttribute(name, value)` —— 设置这个特性值。\n- `elem.removeAttribute(name)` —— 移除这个特性。\n\n这些方法操作的实际上是 HTML 中的内容。\n\n我们也可以使用 `elem.attributes` 读取所有特性：属于内建 [Attr](https://dom.spec.whatwg.org/#attr) 类的对象的集合，具有 `name` 和 `value` 属性。\n\n下面是一个读取非标准的特性的示例：\n\n```html run\n<body something=\"non-standard\">\n  <script>\n*!*\n    alert(document.body.getAttribute('something')); // non-standard\n*/!*\n  </script>\n</body>\n```\n\nHTML 特性有以下几个特征：\n\n- 它们的名字是大小写不敏感的（`id` 与 `ID` 相同）。\n- 它们的值总是字符串类型的。\n\n下面是一个使用特性的扩展示例：\n\n```html run\n<body>\n  <div id=\"elem\" about=\"Elephant\"></div>\n\n  <script>\n    alert( elem.getAttribute('About') ); // (1) 'Elephant'，读取\n\n    elem.setAttribute('Test', 123); // (2) 写入\n\n    alert( elem.outerHTML ); // (3) 查看特性是否在 HTML 中（在）\n\n    for (let attr of elem.attributes) { // (4) 列出所有\n      alert( `${attr.name} = ${attr.value}` );\n    }\n  </script>\n</body>\n```\n\n请注意：\n\n1. `getAttribute('About')` —— 这里的第一个字母是大写的，但是在 HTML 中，它们都是小写的。但这没有影响：特性的名称是大小写不敏感的。\n2. 我们可以将任何东西赋值给特性，但是这些东西会变成字符串类型的。所以这里我们的值为 `\"123\"`。\n3. 所有特性，包括我们设置的那个特性，在 `outerHTML` 中都是可见的。\n4. `attributes` 集合是可迭代对象，该对象将所有元素的特性（标准和非标准的）作为 `name` 和 `value` 属性存储在对象中。\n\n## 属性—特性同步\n\n当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。\n\n在下面这个示例中，`id` 被修改为特性，我们可以看到对应的属性也发生了变化。然后反过来也是同样的效果：\n\n```html run\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // 特性 => 属性\n  input.setAttribute('id', 'id');\n  alert(input.id); // id（被更新了）\n\n  // 属性 => 特性\n  input.id = 'newId';\n  alert(input.getAttribute('id')); // newId（被更新了）\n</script>\n```\n\n但这里也有些例外，例如 `input.value` 只能从特性同步到属性，反过来则不行：\n\n```html run\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // 特性 => 属性\n  input.setAttribute('value', 'text');\n  alert(input.value); // text\n\n*!*\n  // 这个操作无效，属性 => 特性\n  input.value = 'newValue';\n  alert(input.getAttribute('value')); // text（没有被更新！）\n*/!*\n</script>\n```\n\n在上面这个例子中：\n- 改变特性值 `value` 会更新属性。\n- 但是属性的更改不会影响特性。\n\n这个“功能”在实际中会派上用场，因为用户行为可能会导致 `value` 的更改，然后在这些操作之后，如果我们想从 HTML 中恢复“原始”值，那么该值就在特性中。\n\n## DOM 属性是多类型的\n\nDOM 属性不总是字符串类型的。例如，`input.checked` 属性（对于 checkbox 的）是布尔型的。\n\n```html run\n<input id=\"input\" type=\"checkbox\" checked> checkbox\n\n<script>\n  alert(input.getAttribute('checked')); // 特性值是：空字符串\n  alert(input.checked); // 属性值是：true\n</script>\n```\n\n还有其他的例子。`style` 特性是字符串类型的，但 `style` 属性是一个对象：\n\n```html run\n<div id=\"div\" style=\"color:red;font-size:120%\">Hello</div>\n\n<script>\n  // 字符串\n  alert(div.getAttribute('style')); // color:red;font-size:120%\n\n  // 对象\n  alert(div.style); // [object CSSStyleDeclaration]\n  alert(div.style.color); // red\n</script>\n```\n\n尽管大多数 DOM 属性都是字符串类型的。\n\n有一种非常少见的情况，即使一个 DOM 属性是字符串类型的，但它可能和 HTML 特性也是不同的。例如，`href` DOM 属性一直是一个 **完整的** URL，即使该特性包含一个相对路径或者包含一个 `#hash`。\n\n这里有一个例子：\n\n```html height=30 run\n<a id=\"a\" href=\"#hello\">link</a>\n<script>\n  // 特性\n  alert(a.getAttribute('href')); // #hello\n\n  // 属性\n  alert(a.href ); // http://site.com/page#hello 形式的完整 URL \n</script>\n```\n\n如果我们需要 `href` 特性的值，或者其他与 HTML 中所写的完全相同的特性，则可以使用 `getAttribute`。\n\n\n## 非标准的特性，dataset\n\n当编写 HTML 时，我们会用到很多标准的特性。但是非标准的，自定义的呢？首先，让我们看看它们是否有用？用来做什么？\n\n有时，非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素。\n\n像这样：\n\n```html run\n<!-- 标记这个 div 以在这显示 \"name\" -->\n<div *!*show-info=\"name\"*/!*></div>\n<!-- 标记这个 div 以在这显示 \"age\" -->\n<div *!*show-info=\"age\"*/!*></div>\n\n<script>\n  // 这段代码找到带有标记的元素，并显示需要的内容\n  let user = {\n    name: \"Pete\",\n    age: 25\n  };\n\n  for(let div of document.querySelectorAll('[show-info]')) {\n    // 在字段中插入相应的信息\n    let field = div.getAttribute('show-info');\n    div.innerHTML = user[field]; // 首先 \"name\" 变为 Pete，然后 \"age\" 变为 25\n  }\n</script>\n```\n\n它们还可以用来设置元素的样式。\n\n例如，这里使用 `order-state` 特性来设置订单状态：\n\n```html run\n<style>\n  /* 样式依赖于自定义特性 \"order-state\" */\n  .order[order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div class=\"order\" order-state=\"new\">\n  A new order.\n</div>\n\n<div class=\"order\" order-state=\"pending\">\n  A pending order.\n</div>\n\n<div class=\"order\" order-state=\"canceled\">\n  A canceled order.\n</div>\n```\n\n为什么使用特性比使用 `.order-state-new`，`.order-state-pending`，`.order-state-canceled` 这些样式类要好？\n\n因为特性值更容易管理。我们可以轻松地更改状态：\n\n```js\n// 比删除旧的或者添加一个新的类要简单一些\ndiv.setAttribute('order-state', 'canceled');\n```\n\n但是自定义的特性也存在问题。如果我们出于我们的目的使用了非标准的特性，之后它被引入到了标准中并有了其自己的用途，该怎么办？HTML 语言是在不断发展的，并且更多的特性出现在了标准中，以满足开发者的需求。在这种情况下，自定义的属性可能会产生意料不到的影响。\n\n为了避免冲突，存在 [data-*](https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes) 特性。\n\n**所有以 \"data-\" 开头的特性均被保留供程序员使用。它们可在 `dataset` 属性中使用。**\n\n例如，如果一个 `elem` 有一个名为 `\"data-about\"` 的特性，那么可以通过 `elem.dataset.about` 取到它。\n\n像这样：\n\n```html run\n<body data-about=\"Elephants\">\n<script>\n  alert(document.body.dataset.about); // Elephants\n</script>\n```\n\n像 `data-order-state` 这样的多词特性可以以驼峰式进行调用：`dataset.orderState`。\n\n这里是 \"order state\" 那个示例的重构版：\n\n```html run\n<style>\n  .order[data-order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[data-order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[data-order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div id=\"order\" class=\"order\" data-order-state=\"new\">\n  A new order.\n</div>\n\n<script>\n  // 读取\n  alert(order.dataset.orderState); // new\n\n  // 修改\n  order.dataset.orderState = \"pending\"; // (*)\n</script>\n```\n\n使用 `data-*` 特性是一种合法且安全的传递自定义数据的方式。\n\n请注意，我们不仅可以读取数据，还可以修改数据属性（data-attributes）。然后 CSS 会更新相应的视图：在上面这个例子中的最后一行 `(*)` 将颜色更改为了蓝色。\n\n## 总结\n\n- 特性（attribute）—— 写在 HTML 中的内容。\n- 属性（property）—— DOM 对象中的内容。\n\n简略的对比：\n\n|            | 属性 | 特性 |\n|------------|------------|------------|\n|类型|任何值，标准的属性具有规范中描述的类型|字符串|\n|名字|名字（name）是大小写敏感的|名字（name）是大小写不敏感的|\n\n操作特性的方法：\n\n- `elem.hasAttribute(name)` —— 检查是否存在这个特性。\n- `elem.getAttribute(name)` —— 获取这个特性值。\n- `elem.setAttribute(name, value)` —— 设置这个特性值。\n- `elem.removeAttribute(name)` —— 移除这个特性。\n- `elem.attributes` —— 所有特性的集合。\n\n在大多数情况下，最好使用 DOM 属性。仅当 DOM 属性无法满足开发需求，并且我们真的需要特性时，才使用特性，例如：\n\n- 我们需要一个非标准的特性。但是如果它以 `data-` 开头，那么我们应该使用 `dataset`。\n- 我们想要读取 HTML 中“所写的”值。对应的 DOM 属性可能不同，例如 `href` 属性一直是一个 **完整的** URL，但是我们想要的是“原始的”值。",
        "libs": [],
        "children": [
          "get-user-attribute",
          "yellow-links"
        ],
        "parent": "document",
        "updatedAt": 1665942342
      }
    },
    "get-user-attribute": {
      "type": "Task",
      "value": {
        "title": "获取特性",
        "slug": "get-user-attribute",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties/1-get-user-attribute",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写代码，从文档（document）中获取带有 `data-widget-name` 特性（attribute）的元素，并读取它的值。\n\n```html run\n<!DOCTYPE html>\n<html>\n<body>\n\n  <div data-widget-name=\"menu\">Choose the genre</div>\n\n  <script>\n    /* your code */\n  </script>\n</body>\n</html>\n```",
        "solution": "```html run height=100\n<!DOCTYPE html>\n<html>\n<body>\n\n  <div data-widget-name=\"menu\">Choose the genre</div>\n\n  <script>\n    // 获取它\n    let elem = document.querySelector('[data-widget-name]');\n\n    // 读取值\n    alert(elem.dataset.widgetName);\n    // 或\n    alert(elem.getAttribute('data-widget-name'));\n  </script>\n</body>\n</html>\n```",
        "parent": "dom-attributes-and-properties",
        "version": 1
      }
    },
    "yellow-links": {
      "type": "Task",
      "value": {
        "title": "将外部链接设为橙色",
        "slug": "yellow-links",
        "githubPath": "/2-ui/1-document/06-dom-attributes-and-properties/2-yellow-links",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\n\n通过修改 `style` 属性，将所有外部链接变为橙色。\n\n如果一个链接是外部的：\n- 其 `href` 中包含 `://`\n- 但不是以 `http://internal.com` 开头。\n\n例如：\n\n```html run\n<a name=\"list\">the list</a>\n<ul>\n  <li><a href=\"http://google.com\">http://google.com</a></li>\n  <li><a href=\"/tutorial\">/tutorial.html</a></li>\n  <li><a href=\"local/path\">local/path</a></li>\n  <li><a href=\"ftp://ftp.com/my.zip\">ftp://ftp.com/my.zip</a></li>\n  <li><a href=\"http://nodejs.org\">http://nodejs.org</a></li>\n  <li><a href=\"http://internal.com/test\">http://internal.com/test</a></li>\n</ul>\n\n<script>\n  // 为单个链接设置样式\n  let link = document.querySelector('a');\n  link.style.color = 'orange';\n</script>\n```\n\n结果应该是：\n\n[iframe border=1 height=180 src=\"solution\"]",
        "solution": "首先，我们需要找到所有外部链接。\n\n这里有两种方式。\n\n第一种是使用 `document.querySelectorAll('a')` 找到所有链接，然后过滤出我们需要的部分：\n\n```js\nlet links = document.querySelectorAll('a');\n\nfor (let link of links) {\n*!*\n  let href = link.getAttribute('href');\n*/!*\n  if (!href) continue; // 没有特性\n\n  if (!href.includes('://')) continue; // 没有协议\n\n  if (href.startsWith('http://internal.com')) continue; // 内部的\n\n  link.style.color = 'orange';\n}\n```\n\n请注意：我们用的是 `link.getAttribute('href')`。而不是 `link.href`，因为我们需要的是来自 HTML 的值。\n\n……另一种更简单的方法，是使用 CSS 选择器进行检查：\n\n```js\n// 查找所有 href 中包含 :// 的链接\n// 但 href 不是以 http://internal.com 开头\nlet selector = 'a[href*=\"://\"]:not([href^=\"http://internal.com\"])';\nlet links = document.querySelectorAll(selector);\n\nlinks.forEach(link => link.style.color = 'orange');\n```",
        "parent": "dom-attributes-and-properties",
        "version": 1
      }
    },
    "modifying-document": {
      "type": "Article",
      "value": {
        "title": "修改文档（document）",
        "slug": "modifying-document",
        "githubPath": "/2-ui/1-document/07-modifying-document",
        "isFolder": false,
        "weight": 7,
        "content": "\n\nDOM 修改是创建“实时”页面的关键。\n\n在这里，我们将会看到如何“即时”创建新元素并修改现有页面内容。\n\n## 例子：展示一条消息\n\n让我们使用一个示例进行演示。我们将在页面上添加一条比 `alert` 更好看的消息。\n\n它的外观如下：\n\n```html autorun height=\"80\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n*!*\n<div class=\"alert\">\n  <strong>Hi there!</strong> You've read an important message.\n</div>\n*/!*\n```\n\n这是一个 HTML 示例。现在，让我们使用 JavaScript 创建一个相同的 `div`（假设样式已经在 HTML/CSS 文件中）。\n\n## 创建一个元素\n\n要创建 DOM 节点，这里有两种方法：\n\n`document.createElement(tag)`\n: 用给定的标签创建一个新 **元素节点（element node）**：\n\n    ```js\n    let div = document.createElement('div');\n    ```\n\n`document.createTextNode(text)`\n: 用给定的文本创建一个 **文本节点**：\n\n    ```js\n    let textNode = document.createTextNode('Here I am');\n    ```\n\n大多数情况下，我们需要为此消息创建像 `div` 这样的元素节点。\n\n### 创建一条消息\n\n创建一个消息 `div` 分为 3 个步骤：\n\n```js\n// 1. 创建 <div> 元素\nlet div = document.createElement('div');\n\n// 2. 将元素的类设置为 \"alert\"\ndiv.className = \"alert\";\n\n// 3. 填充消息内容\ndiv.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n```\n\n我们已经创建了该元素。但到目前为止，它还只是在一个名为 `div` 的变量中，尚未在页面中。所以我们无法在页面上看到它。\n\n## 插入方法\n\n为了让 `div` 显示出来，我们需要将其插入到 `document` 中的某处。例如，通过 `document.body` 将其插入到 `<body>` 元素里。\n\n对此有一个特殊的方法 `append`：`document.body.append(div)`。\n\n这是完整代码：\n\n```html run height=\"80\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert\";\n  div.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n\n*!*\n  document.body.append(div);\n*/!*\n</script>\n```\n\n在这个例子中，我们对 `document.body` 调用了 `append` 方法。不过我们可以在其他任何元素上调用 `append` 方法，以将另外一个元素放入到里面。例如，通过调用 `div.append(anotherElement)`，我们便可以在 `<div>` 末尾添加一些内容。\n\n这里是更多的元素插入方法，指明了不同的插入位置：\n\n- `node.append(...nodes or strings)` —— 在 `node` **末尾** 插入节点或字符串，\n- `node.prepend(...nodes or strings)` —— 在 `node` **开头** 插入节点或字符串，\n- `node.before(...nodes or strings)` —— 在 `node` **前面** 插入节点或字符串，\n- `node.after(...nodes or strings)` —— 在 `node` **后面** 插入节点或字符串，\n- `node.replaceWith(...nodes or strings)` —— 将 `node` 替换为给定的节点或字符串。\n\n这些方法的参数可以是一个要插入的任意的 DOM 节点列表，或者文本字符串（会被自动转换成文本节点）。\n\n让我们在实际应用中看一看。\n\n下面是使用这些方法将列表项添加到列表中，以及将文本添加到列表前面和后面的示例：\n\n```html autorun\n<ol id=\"ol\">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  ol.before('before'); // 将字符串 \"before\" 插入到 <ol> 前面\n  ol.after('after'); // 将字符串 \"after\" 插入到 <ol> 后面\n\n  let liFirst = document.createElement('li');\n  liFirst.innerHTML = 'prepend';\n  ol.prepend(liFirst); // 将 liFirst 插入到 <ol> 的最开始\n\n  let liLast = document.createElement('li');\n  liLast.innerHTML = 'append';\n  ol.append(liLast); // 将 liLast 插入到 <ol> 的最末尾\n</script>\n```\n\n这张图片直观地显示了这些方法所做的工作：\n\n![](before-prepend-append-after.svg)\n\n因此，最终列表将为：\n\n```html\nbefore\n<ol id=\"ol\">\n  <li>prepend</li>\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n  <li>append</li>\n</ol>\nafter\n```\n\n如上所述，这些方法可以在单个调用中插入多个节点列表和文本片段。\n\n例如，在这里插入了一个字符串和一个元素：\n\n```html run\n<div id=\"div\"></div>\n<script>\n  div.before('<p>Hello</p>', document.createElement('hr'));\n</script>\n```\n\n请注意：这里的文字都被“作为文本”插入，而不是“作为 HTML 代码”。因此像 `<`、`>` 这样的符号都会被作转义处理来保证正确显示。\n\n所以，最终的 HTML 为：\n\n```html run\n*!*\n&lt;p&gt;Hello&lt;/p&gt;\n*/!*\n<hr>\n<div id=\"div\"></div>\n```\n\n换句话说，字符串被以一种安全的方式插入到页面中，就像 `elem.textContent` 所做的一样。\n\n所以，这些方法只能用来插入 DOM 节点或文本片段。\n\n但如果我们想要将内容“作为 HTML 代码插入”，让内容中的所有标签和其他东西都像使用 `elem.innerHTML` 所表现的效果一样，那应该怎么办呢？\n\n## insertAdjacentHTML/Text/Element\n\n为此，我们可以使用另一个非常通用的方法：`elem.insertAdjacentHTML(where, html)`。\n\n该方法的第一个参数是代码字（code word），指定相对于 `elem` 的插入位置。必须为以下之一：\n\n- `\"beforebegin\"` —— 将 `html` 插入到 `elem` 之前，\n- `\"afterbegin\"` —— 将 `html` 插入到 `elem` 开头，\n- `\"beforeend\"` —— 将 `html` 插入到 `elem` 末尾，\n- `\"afterend\"` —— 将 `html` 插入到 `elem` 之后。\n\n第二个参数是 HTML 字符串，该字符串会被“作为 HTML” 插入。\n\n例如：\n\n```html run\n<div id=\"div\"></div>\n<script>\n  div.insertAdjacentHTML('beforebegin', '<p>Hello</p>');\n  div.insertAdjacentHTML('afterend', '<p>Bye</p>');\n</script>\n```\n\n……将导致：\n\n```html run\n<p>Hello</p>\n<div id=\"div\"></div>\n<p>Bye</p>\n```\n\n这就是我们可以在页面上附加任意 HTML 的方式。\n\n这是插入变体的示意图：\n\n![](insert-adjacent.svg)\n\n我们很容易就会注意到这张图片和上一张图片的相似之处。插入点实际上是相同的，但此方法插入的是 HTML。\n\n这个方法有两个兄弟：\n\n- `elem.insertAdjacentText(where, text)` —— 语法一样，但是将 `text` 字符串“作为文本”插入而不是作为 HTML，\n- `elem.insertAdjacentElement(where, elem)` —— 语法一样，但是插入的是一个元素。\n\n它们的存在主要是为了使语法“统一”。实际上，大多数时候只使用 `insertAdjacentHTML`。因为对于元素和文本，我们有 `append/prepend/before/after` 方法 —— 它们也可以用于插入节点/文本片段，但写起来更短。\n\n所以，下面是显示一条消息的另一种变体：\n\n```html run\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  document.body.insertAdjacentHTML(\"afterbegin\", `<div class=\"alert\">\n    <strong>Hi there!</strong> You've read an important message.\n  </div>`);\n</script>\n```\n\n## 节点移除\n\n想要移除一个节点，可以使用 `node.remove()`。\n\n让我们的消息在一秒后消失：\n\n```html run untrusted\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert\";\n  div.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n\n  document.body.append(div);\n*!*\n  setTimeout(() => div.remove(), 1000);\n*/!*\n</script>\n```\n\n请注意：如果我们要将一个元素 **移动** 到另一个地方，则无需将其从原来的位置中删除。\n\n**所有插入方法都会自动从旧位置删除该节点。**\n\n例如，让我们进行元素交换：\n\n```html run height=50\n<div id=\"first\">First</div>\n<div id=\"second\">Second</div>\n<script>\n  // 无需调用 remove\n  second.after(first); // 获取 #second，并在其后面插入 #first\n</script>\n```\n\n## 克隆节点：cloneNode\n\n如何再插入一条类似的消息？\n\n我们可以创建一个函数，并将代码放在其中。但是另一种方法是 **克隆** 现有的 `div`，并修改其中的文本（如果需要）。\n\n当我们有一个很大的元素时，克隆的方式可能更快更简单。\n\n调用 `elem.cloneNode(true)` 来创建元素的一个“深”克隆 —— 具有所有特性（attribute）和子元素。如果我们调用 `elem.cloneNode(false)`，那克隆就不包括子元素。\n\n一个拷贝消息的示例：\n\n```html run height=\"120\"\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<div class=\"alert\" id=\"div\">\n  <strong>Hi there!</strong> You've read an important message.\n</div>\n\n<script>\n*!*\n  let div2 = div.cloneNode(true); // 克隆消息\n  div2.querySelector('strong').innerHTML = 'Bye there!'; // 修改克隆\n\n  div.after(div2); // 在已有的 div 后显示克隆\n*/!*\n</script>\n```\n\n## DocumentFragment [#document-fragment]\n\n`DocumentFragment` 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）。\n\n我们可以向其附加其他节点，但是当我们将其插入某个位置时，则会插入其内容。\n\n例如，下面这段代码中的 `getListContent` 会生成带有 `<li>` 列表项的片段，然后将其插入到 `<ul>` 中：\n\n```html run\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let fragment = new DocumentFragment();\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    fragment.append(li);\n  }\n\n  return fragment;\n}\n\n*!*\nul.append(getListContent()); // (*)\n*/!*\n</script>\n```\n\n请注意，在最后一行 `(*)` 我们附加了 `DocumentFragment`，但是它和 `ul` “融为一体（blends in）”了，所以最终的文档结构应该是：\n\n```html\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n</ul>\n```\n\n`DocumentFragment` 很少被显式使用。如果可以改为返回一个节点数组，那为什么还要附加到特殊类型的节点上呢？重写示例：\n\n```html run\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let result = [];\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    result.push(li);\n  }\n\n  return result;\n}\n\n*!*\nul.append(...getListContent()); // append + \"...\" operator = friends!\n*/!*\n</script>\n```\n\n我们之所以提到 `DocumentFragment`，主要是因为它上面有一些概念，例如 [template](info:template-element) 元素，我们将在以后讨论。\n\n## 老式的 insert/remove 方法\n\n[old]\n\n由于历史原因，还存在“老式”的 DOM 操作方法。\n\n这些方法来自真正的远古时代。如今，没有理由再使用它们了，因为诸如 `append`，`prepend`，`before`，`after`，`remove`，`replaceWith` 这些现代方法更加灵活。\n\n我们在这儿列出这些方法的唯一原因是，你可能会在许多脚本中遇到它们。\n\n`parentElem.appendChild(node)`\n: 将 `node` 附加为 `parentElem` 的最后一个子元素。\n\n    下面这个示例在 `<ol>` 的末尾添加了一个新的 `<li>`：\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n\n    <script>\n      let newLi = document.createElement('li');\n      newLi.innerHTML = 'Hello, world!';\n\n      list.appendChild(newLi);\n    </script>\n    ```\n\n`parentElem.insertBefore(node, nextSibling)`\n: 在 `parentElem` 的 `nextSibling` 前插入 `node`。\n\n    下面这段代码在第二个 `<li>` 前插入了一个新的列表项：\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n    <script>\n      let newLi = document.createElement('li');\n      newLi.innerHTML = 'Hello, world!';\n\n    *!*\n      list.insertBefore(newLi, list.children[1]);\n    */!*\n    </script>\n    ```\n    如果要将 `newLi` 插入为第一个元素，我们可以这样做：\n\n    ```js\n    list.insertBefore(newLi, list.firstChild);\n    ```\n\n`parentElem.replaceChild(node, oldChild)`\n: 将 `parentElem` 的后代中的 `oldChild` 替换为 `node`。\n\n`parentElem.removeChild(node)`\n: 从 `parentElem` 中删除 `node`（假设 `node` 为 `parentElem` 的后代）。\n\n    下面这个示例从 `<ol>` 中删除了 `<li>`：\n\n    ```html run height=100\n    <ol id=\"list\">\n      <li>0</li>\n      <li>1</li>\n      <li>2</li>\n    </ol>\n\n    <script>\n      let li = list.firstElementChild;\n      list.removeChild(li);\n    </script>\n    ```\n\n所有这些方法都会返回插入/删除的节点。换句话说，`parentElem.appendChild(node)` 返回 `node`。但是通常我们不会使用返回值，我们只是使用对应的方法。\n\n## 聊一聊 \"document.write\"\n\n还有一个非常古老的向网页添加内容的方法：`document.write`。\n\n语法如下：\n\n```html run\n<p>Somewhere in the page...</p>\n*!*\n<script>\n  document.write('<b>Hello from JS</b>');\n</script>\n*/!*\n<p>The end</p>\n```\n\n调用 `document.write(html)` 意味着将 `html` “就地马上”写入页面。`html` 字符串可以是动态生成的，所以它很灵活。我们可以使用 JavaScript 创建一个完整的页面并对其进行写入。\n\n这个方法来自于没有 DOM，没有标准的上古时期……。但这个方法依被保留了下来，因为还有脚本在使用它。\n\n由于以下重要的限制，在现代脚本中我们很少看到它：\n\n**`document.write` 调用只在页面加载时工作。**\n\n如果我们稍后调用它，则现有文档内容将被擦除。\n\n例如：\n\n```html run\n<p>After one second the contents of this page will be replaced...</p>\n*!*\n<script>\n  // 1 秒后调用 document.write\n  // 这时页面已经加载完成，所以它会擦除现有内容\n  setTimeout(() => document.write('<b>...By this.</b>'), 1000);\n</script>\n*/!*\n```\n\n因此，在某种程度上讲，它在“加载完成”阶段是不可用的，这与我们上面介绍的其他 DOM 方法不同。\n\n这是它的缺陷。\n\n还有一个好处。从技术上讲，当在浏览器正在读取（“解析”）传入的 HTML 时调用 `document.write` 方法来写入一些东西，浏览器会像它本来就在 HTML 文本中那样使用它。\n\n所以它运行起来出奇的快，因为它 **不涉及 DOM 修改**。它直接写入到页面文本中，而此时 DOM 尚未构建。\n\n因此，如果我们需要向 HTML 动态地添加大量文本，并且我们正处于页面加载阶段，并且速度很重要，那么它可能会有帮助。但实际上，这些要求很少同时出现。我们可以在脚本中看到此方法，通常是因为这些脚本很旧。\n\n## 总结\n\n- 创建新节点的方法：\n    - `document.createElement(tag)` —— 用给定的标签创建一个元素节点，\n    - `document.createTextNode(value)` —— 创建一个文本节点（很少使用），\n    - `elem.cloneNode(deep)` —— 克隆元素，如果 `deep==true` 则与其后代一起克隆。\n\n- 插入和移除节点的方法：\n    - `node.append(...nodes or strings)` —— 在 `node` 末尾插入，\n    - `node.prepend(...nodes or strings)` —— 在 `node` 开头插入，\n    - `node.before(...nodes or strings)` —— 在 `node` 之前插入，\n    - `node.after(...nodes or strings)` —— 在 `node` 之后插入，\n    - `node.replaceWith(...nodes or strings)` —— 替换 `node`。\n    - `node.remove()` —— 移除 `node`。\n\n    文本字符串被“作为文本”插入。\n\n- 这里还有“旧式”的方法：\n    - `parent.appendChild(node)`\n    - `parent.insertBefore(node, nextSibling)`\n    - `parent.removeChild(node)`\n    - `parent.replaceChild(newElem, node)`\n\n    这些方法都返回 `node`。\n\n- 在 `html` 中给定一些 HTML，`elem.insertAdjacentHTML(where, html)` 会根据 `where` 的值来插入它：\n    - `\"beforebegin\"` —— 将 `html` 插入到 `elem` 前面，\n    - `\"afterbegin\"` —— 将 `html` 插入到 `elem` 的开头，\n    - `\"beforeend\"` —— 将 `html` 插入到 `elem` 的末尾，\n    - `\"afterend\"` —— 将 `html` 插入到 `elem` 后面。\n\n另外，还有类似的方法，`elem.insertAdjacentText` 和 `elem.insertAdjacentElement`，它们会插入文本字符串和元素，但很少使用。\n\n- 要在页面加载完成之前将 HTML 附加到页面：\n    - `document.write(html)`\n\n    页面加载完成后，这样的调用将会擦除文档。多见于旧脚本。",
        "libs": [],
        "children": [
          "createtextnode-vs-innerhtml",
          "clear-elem",
          "why-aaa",
          "create-list",
          "create-object-tree",
          "tree-count",
          "calendar-table",
          "clock-setinterval",
          "append-to-list",
          "sort-table"
        ],
        "parent": "document",
        "updatedAt": 1658929767
      }
    },
    "createtextnode-vs-innerhtml": {
      "type": "Task",
      "value": {
        "title": "createTextNode vs innerHTML vs textContent",
        "slug": "createtextnode-vs-innerhtml",
        "githubPath": "/2-ui/1-document/07-modifying-document/1-createtextnode-vs-innerhtml",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n我们有一个空的 DOM 元素 `elem` 和一个字符串 `text`。\n\n下面这 3 个命令中的哪些命令会执行完全相同的操作？\n\n1. `elem.append(document.createTextNode(text))`\n2. `elem.innerHTML = text`\n3. `elem.textContent = text`",
        "solution": "回答：**1 和 3**。\n\n这两个命令都会将 `text` “作为文本”添加到 `elem` 中。\n\n这是一个例子：\n\n```html run height=80\n<div id=\"elem1\"></div>\n<div id=\"elem2\"></div>\n<div id=\"elem3\"></div>\n<script>\n  let text = '<b>text</b>';\n\n  elem1.append(document.createTextNode(text));\n  elem2.innerHTML = text;\n  elem3.textContent = text;\n</script>\n```",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "clock-setinterval": {
      "type": "Task",
      "value": {
        "title": "使用 setInterval 的彩色时钟",
        "slug": "clock-setinterval",
        "githubPath": "/2-ui/1-document/07-modifying-document/10-clock-setinterval",
        "weight": 10,
        "libs": [],
        "importance": 4,
        "content": "\n\n创建一个像这样的彩色时钟：\n\n[iframe src=\"solution\" height=60]\n\n使用 HTML/CSS 进行样式设计，JavaScript 仅用来更新元素中的时间。",
        "solution": "首先，让我们编写 HTML/CSS。\n\n时间的每个组件都有其自己的 `<span>`，那将会看起来很棒：\n\n```html\n<div id=\"clock\">\n  <span class=\"hour\">hh</span>:<span class=\"min\">mm</span>:<span class=\"sec\">ss</span>\n</div>\n```\n\n另外，我们需要使用 CSS 为它们着色。\n\n函数 `update` 会刷新时钟，由 `setInterval` 每秒调用一次：\n\n```js\nfunction update() {\n  let clock = document.getElementById('clock');\n*!*\n  let date = new Date(); // (*)\n*/!*\n  let hours = date.getHours();\n  if (hours < 10) hours = '0' + hours;\n  clock.children[0].innerHTML = hours;\n\n  let minutes = date.getMinutes();\n  if (minutes < 10) minutes = '0' + minutes;\n  clock.children[1].innerHTML = minutes;\n\n  let seconds = date.getSeconds();\n  if (seconds < 10) seconds = '0' + seconds;\n  clock.children[2].innerHTML = seconds;\n}\n```\n\n在 `(*)` 行中，我们每次都检查当前时间。`setInterval` 调用并不可靠：它们可能会发生延迟现象。\n\n时钟管理函数：\n\n```js\nlet timerId;\n\nfunction clockStart() { // 运行时钟\n  if (!timerId) { // 仅当时钟停止时 setInterval\n    timerId = setInterval(update, 1000);\n  }\n  update(); // (*)\n}\n\nfunction clockStop() {\n  clearInterval(timerId);\n  timerId = null; // (**)\n}\n```\n\n请注意，`update()` 不仅在 `clockStart()` 中被调度，而且还立即在 `(*)` 行运行。否则，访问者将不得不等到 `setInterval` 第一次执行。在那之前，时钟将是空的。\n\n此外，在 `clockStart()` 中仅当时钟未运行时才进行 setInterval 也是至关重要的。否则多次点击 Start 按钮会设置多个并发的间隔。更糟糕的是 —— 我们只会保留最后一个时间间隔的 `timerID`，失去对所有其他时间间隔的引用。那我们就再也无法停止时钟了！请注意，当时钟停止时，我们需要在 `(**)` 行这样清除 `timerID`，以便可以通过执行 `clockStart()` 再次启动时钟。",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "append-to-list": {
      "type": "Task",
      "value": {
        "title": "将 HTML 插入到列表中",
        "slug": "append-to-list",
        "githubPath": "/2-ui/1-document/07-modifying-document/11-append-to-list",
        "weight": 11,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写代码，将 `<li>2</li><li>3</li>`，插入到两个 `<li>` 之间：\n\n```html\n<ul id=\"ul\">\n  <li id=\"one\">1</li>\n  <li id=\"two\">4</li>\n</ul>\n```",
        "solution": "当我们需要在某处插入 HTML 时，`insertAdjacentHTML` 是最适合的方案。\n\n解决方法：\n\n```js\none.insertAdjacentHTML('afterend', '<li>2</li><li>3</li>');\n```",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "sort-table": {
      "type": "Task",
      "value": {
        "title": "对表格进行排序",
        "slug": "sort-table",
        "githubPath": "/2-ui/1-document/07-modifying-document/12-sort-table",
        "weight": 12,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面是一个表格：\n\n```html run\n<table>\n<thead>\n  <tr>\n    <th>Name</th><th>Surname</th><th>Age</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>John</td><td>Smith</td><td>10</td>\n  </tr>\n  <tr>\n    <td>Pete</td><td>Brown</td><td>15</td>\n  </tr>\n  <tr>\n    <td>Ann</td><td>Lee</td><td>5</td>\n  </tr>\n  <tr>\n    <td>...</td><td>...</td><td>...</td>\n  </tr>\n</tbody>\n</table>\n```\n\n可能会有更多行。\n\n编写代码，按 `\"name\"` 列对其进行排序。",
        "solution": "这个解决方案虽然很短，但可能看起来有点难理解，因此，在这里我提供了一些扩展性的注释：\n\n```js\nlet sortedRows = Array.from(table.tBodies[0].rows) // 1\n  .sort((rowA, rowB) => rowA.cells[0].innerHTML.localeCompare(rowB.cells[0].innerHTML));\n\ntable.tBodies[0].append(...sortedRows); // (3)\n```\n\n对此算法一步一步进行讲解：\n\n1. 从 `<tbody>` 获取所有 `<tr>`。\n2. 然后将它们按第一个 `<td>`（`name` 字段）中的内容进行比较。\n3. 然后使用 `.append(...sortedRows)` 按正确的顺序插入节点。\n\n我们不必删除行元素，只需要“重新插入”，它们就会自动离开原来的位置。\n\nP.S. 在我们的例子中，表格中有一个明确的 `<tbody>`，但即使 HTML 中的表格没有 `<tbody>`，DOM 结构也总是具有它。",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "clear-elem": {
      "type": "Task",
      "value": {
        "title": "清除元素",
        "slug": "clear-elem",
        "githubPath": "/2-ui/1-document/07-modifying-document/4-clear-elem",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个函数 `clear(elem)` 用来移除元素里的内容。\n\n```html run height=60\n<ol id=\"elem\">\n  <li>Hello</li>\n  <li>World</li>\n</ol>\n\n<script>\n  function clear(elem) { /* 你的代码 */ }\n\n  clear(elem); // 清除列表\n</script>\n```",
        "solution": "首先，让我们看看 **错误** 的做法：\n\n```js\nfunction clear(elem) {\n  for (let i=0; i < elem.childNodes.length; i++) {\n      elem.childNodes[i].remove();\n  }\n}\n```\n\n这是行不通的，因为调用 `remove()` 会从首端开始移除 `elem.childNodes` 集合中的元素，因此，元素每次都从索引 `0` 开始。但是 `i` 在增加，所以元素就被跳过了。\n\n用 `for..of` 循环的结果也跟上面一样。\n\n正确的做法是：\n\n```js\nfunction clear(elem) {\n  while (elem.firstChild) {\n    elem.firstChild.remove();\n  }\n}\n```\n\n还有一种更简单的方法，也可以达到我们所要的效果：\n\n```js\nfunction clear(elem) {\n  elem.innerHTML = '';\n}\n```",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "why-aaa": {
      "type": "Task",
      "value": {
        "title": "为什么留下 \"aaa\"？",
        "slug": "why-aaa",
        "githubPath": "/2-ui/1-document/07-modifying-document/5-why-aaa",
        "weight": 5,
        "libs": [],
        "importance": 1,
        "content": "\n\n在下面这个示例中，我们调用 `table.remove()` 从文档中删除表格。\n\n但如果运行它，你就会看到文本 `\"aaa\"` 并没有被删除。\n\n这是为什么？\n\n```html height=100 run\n<table id=\"table\">\n  aaa\n  <tr>\n    <td>Test</td>\n  </tr>\n</table>\n\n<script>\n  alert(table); // 表格，就是它应有的样子\n\n  table.remove();\n  // 为什么 \"aaa\" 还存在于文档中？\n</script>\n```",
        "solution": "这个题目中的 HTML 是错的。这就是造成怪异现象的原因。\n\n浏览器必须自动修复它。但 `<table>` 内可能会没有文本：根据规范，只允许特定于表格的标签。所以浏览器将 `\"aaa\"` 展示在了 `<table>` **前面**。\n\n当我们删除表格后，文本 `\"aaa\"` 仍然存在的原因就很明显了吧。\n\n通过使用浏览器开发者工具查看 DOM，就可以轻松地回答这个问题。从浏览器开发者工具中我们可以看到，`\"aaa\"` 在 `<table>` 前面。\n\nHTML 标准规范详细描述了如何处理错误的 HTML，并且浏览器的这种行为是正确的。",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "create-list": {
      "type": "Task",
      "value": {
        "title": "创建一个列表",
        "slug": "create-list",
        "githubPath": "/2-ui/1-document/07-modifying-document/6-create-list",
        "weight": 6,
        "libs": [],
        "importance": 4,
        "content": "\n\n编写一个接口，根据用户输入创建一个列表（list）。\n\n对于每个列表项：\n\n1. 使用 `prompt` 向用户询问列表项的内容。\n2. 使用用户输入的内容创建 `<li>`，并添加到 `<ul>`。\n3. 重复以上步骤，直到用户取消输入（按下 `key:Esc` 键，或输入一个空内容）。\n\n所有元素应该都是动态创建的。\n\n如果用户输入了 HTML 标签，那么这些内容应该被视为文本进行后续处理。\n\n[demo src=\"solution\"]",
        "solution": "请注意使用 `textContent` 对 `<li>` 的内容进行赋值的用法。",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "create-object-tree": {
      "type": "Task",
      "value": {
        "title": "从对象创建树",
        "slug": "create-object-tree",
        "githubPath": "/2-ui/1-document/07-modifying-document/7-create-object-tree",
        "weight": 7,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写一个函数 `createTree`，从嵌套对象创建一个嵌套的 `ul/li` 列表（list）。\n\n例如：\n\n```js\nlet data = {\n  \"Fish\": {\n    \"trout\": {},\n    \"salmon\": {}\n  },\n\n  \"Tree\": {\n    \"Huge\": {\n      \"sequoia\": {},\n      \"oak\": {}\n    },\n    \"Flowering\": {\n      \"apple tree\": {},\n      \"magnolia\": {}\n    }\n  }\n};\n```\n\n语法：\n\n```js\nlet container = document.getElementById('container');\n*!*\ncreateTree(container, data); // 将树创建在 container 中\n*/!*\n```\n\n结果（树）看起来像这样：\n\n[iframe border=1 src=\"build-tree-dom\"]\n\n选择下面两种方式中的一种，来完成这个任务：\n\n1. 为树创建 HTML，然后将它们赋值给 `container.innerHTML`。\n2. 创建节点树，并使用 DOM 方法将它们附加（append）上去。\n\n如果这两种方式你都做，那就太好了。\n\nP.S. 树上不应该有“多余”的元素，例如空的 `<ul></ul>` 叶子节点。",
        "solution": "遍历对象的最简单的方法是使用递归。\n\n1. [使用 innerHTML 的解决方案](sandbox:innerhtml)。\n2. [使用 DOM 的解决方案](sandbox:build-tree-dom)。",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "tree-count": {
      "type": "Task",
      "value": {
        "title": "在树中显示后代",
        "slug": "tree-count",
        "githubPath": "/2-ui/1-document/07-modifying-document/8-tree-count",
        "weight": 8,
        "libs": [],
        "importance": 5,
        "content": "\n\n这里有一棵由嵌套的 `ul/li` 组成的树。\n\n编写代码，为每个 `<li>` 添加其后代数量。跳过叶子节点（没有子代的节点）。\n\n结果：\n\n[iframe border=1 src=\"solution\"]",
        "solution": "为了将文本附加到每个 `<li>` 中，我们可以改变文本节点的 `data`。",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "calendar-table": {
      "type": "Task",
      "value": {
        "title": "创建一个日历",
        "slug": "calendar-table",
        "githubPath": "/2-ui/1-document/07-modifying-document/9-calendar-table",
        "weight": 9,
        "libs": [],
        "importance": 4,
        "content": "\n\n编写一个函数 `createCalendar(elem, year, month)`。\n\n对该函数的调用，应该使用给定的 year/month 创建一个日历，并将创建的日历放入 `elem` 中。\n\n创建的日历应该是一个表格（table），其中每一周用 `<tr>` 表示，每一天用 `<td>` 表示。表格顶部应该是带有星期名的 `<th>`：第一天应该是 Monday，依此类推，直到 Sunday。\n\n例如，`createCalendar(cal, 2012, 9)` 应该在元素 `cal` 中生成如下所示的日历：\n\n[iframe height=210 src=\"solution\"]\n\nP.S. 在这个任务中，生成一个日历就可以了，不需要有点击交互的功能。",
        "solution": "我们将表格创建为字符串：`\"<table>...</table>\"`，然后将其赋值给 `innerHTML`。\n\n算法如下：\n\n1. 使用 `<th>` 创建带有星期名的表头。\n2. 创建日期对象 `d = new Date(year, month-1)`。它是 `month` 的第一天（考虑到 JavaScript 中的月份从 `0` 开始，而不是从 `1` 开始）。\n3. 直到月份的第一天 `d.getDay()`，前面的几个单元格是空的。让我们用 `<td></td>` 填充它们。\n4. 天数增长 `d`：`d.setDate(d.getDate()+1)`。如果 `d.getMonth()` 还没到下一个月，那么就将新的单元格 `<td>` 添加到日历中。如果那天是星期日，就添加一个新行 <code>\"&lt;/tr&gt;&lt;tr&gt;\"</code>。\n5. 如果该月结束，但表格的行尚未填满，就用空的 `<td>` 补齐。",
        "parent": "modifying-document",
        "version": 1
      }
    },
    "styles-and-classes": {
      "type": "Article",
      "value": {
        "title": "样式和类",
        "slug": "styles-and-classes",
        "githubPath": "/2-ui/1-document/08-styles-and-classes",
        "isFolder": false,
        "weight": 8,
        "content": "\n\n在我们讨论 JavaScript 处理样式和类的方法之前 —— 有一个重要的规则。希望它足够明显，但是我们仍然必须提到它。\n\n通常有两种设置元素样式的方式：\n\n1. 在 CSS 中创建一个类，并添加它：`<div class=\"...\">`\n2. 将属性直接写入 `style`：`<div style=\"...\">`。\n\nJavaScript 既可以修改类，也可以修改 `style` 属性。\n\n相较于将样式写入 `style` 属性，我们应该首选通过 CSS 类的方式来添加样式。仅当类“无法处理”时，才应选择使用 `style` 属性的方式。\n\n例如，如果我们动态地计算元素的坐标，并希望通过 JavaScript 来设置它们，那么使用 `style` 是可以接受的，如下所示：\n\n```js\nlet top = /* 复杂的计算 */;\nlet left = /* 复杂的计算 */;\n\nelem.style.left = left; // 例如 '123px'，在运行时计算出的\nelem.style.top = top; // 例如 '456px'\n```\n\n对于其他情况，例如将文本设为红色，添加一个背景图标 —— 可以在 CSS 中对这些样式进行描述，然后添加类（JavaScript 可以做到）。这样更灵活，更易于支持。\n\n## className 和 classList\n\n更改类是脚本中最常见的操作之一。\n\n在很久以前，JavaScript 中有一个限制：像 `\"class\"` 这样的保留字不能用作对象的属性。这一限制现在已经不存在了，但当时就不能存在像 `elem.class` 这样的 `\"class\"` 属性。\n\n因此，对于类，引入了看起来类似的属性 `\"className\"`：`elem.className` 对应于 `\"class\"` 特性（attribute）。\n\n例如：\n\n```html run\n<body class=\"main page\">\n  <script>\n    alert(document.body.className); // main page\n  </script>\n</body>\n```\n\n如果我们对 `elem.className` 进行赋值，它将替换类中的整个字符串。有时，这正是我们所需要的，但通常我们希望添加/删除单个类。\n\n这里还有另一个属性：`elem.classList`。\n\n`elem.classList` 是一个特殊的对象，它具有 `add/remove/toggle` 单个类的方法。\n\n例如：\n\n```html run\n<body class=\"main page\">\n  <script>\n*!*\n    // 添加一个 class\n    document.body.classList.add('article');\n*/!*\n\n    alert(document.body.className); // main page article\n  </script>\n</body>\n```\n\n因此，我们既可以使用 `className` 对完整的类字符串进行操作，也可以使用使用 `classList` 对单个类进行操作。我们选择什么取决于我们的需求。\n\n`classList` 的方法：\n\n- `elem.classList.add/remove(class)` —— 添加/移除类。\n- `elem.classList.toggle(class)` —— 如果类不存在就添加类，存在就移除它。\n- `elem.classList.contains(class)` —— 检查给定类，返回 `true/false`。\n\n此外，`classList` 是可迭代的，因此，我们可以像下面这样列出所有类：\n\n```html run\n<body class=\"main page\">\n  <script>\n    for (let name of document.body.classList) {\n      alert(name); // main，然后是 page\n    }\n  </script>\n</body>\n```\n\n## 元素样式\n\n`elem.style` 属性是一个对象，它对应于 `\"style\"` 特性（attribute）中所写的内容。`elem.style.width=\"100px\"` 的效果等价于我们在 `style` 特性中有一个 `width:100px` 字符串。\n\n对于多词（multi-word）属性，使用驼峰式 camelCase：\n\n```js no-beautify\nbackground-color  => elem.style.backgroundColor\nz-index           => elem.style.zIndex\nborder-left-width => elem.style.borderLeftWidth\n```\n\n例如：\n\n```js run\ndocument.body.style.backgroundColor = prompt('background color?', 'green');\n```\n\n````smart header=\"前缀属性\"\n像 `-moz-border-radius` 和 `-webkit-border-radius` 这样的浏览器前缀属性，也遵循同样的规则：连字符 `-` 表示大写。\n\n例如：\n\n```js\nbutton.style.MozBorderRadius = '5px';\nbutton.style.WebkitBorderRadius = '5px';\n```\n````\n\n## 重置样式属性\n\n有时我们想要分配一个样式属性，稍后移除它。\n\n例如，为了隐藏一个元素，我们可以设置 `elem.style.display = \"none\"`。\n\n然后，稍后我们可能想要移除 `style.display`，就像它没有被设置一样。这里不应该使用 `delete elem.style.display`，而应该使用 `elem.style.display = \"\"` 将其赋值为空。\n\n```js run\n// 如果我们运行这段代码，<body> 将会闪烁\ndocument.body.style.display = \"none\"; // 隐藏\n\nsetTimeout(() => document.body.style.display = \"\", 1000); // 恢复正常\n```\n\n如果我们将 `style.display` 设置为空字符串，那么浏览器通常会应用 CSS 类以及内建样式，就好像根本没有这样的 `style.display` 属性一样。\n\n还有一个特殊的方法 `elem.style.removeProperty('style property')`。所以，我们可以像这样删除一个属性：\n\n```js run\ndocument.body.style.background = 'red'; //将 background 设置为红色\n\nsetTimeout(() => document.body.style.removeProperty('background'), 1000); // 1 秒后移除 background\n```\n\n````smart header=\"用 `style.cssText` 进行完全的重写\"\n通常，我们使用 `style.*` 来对各个样式属性进行赋值。我们不能像这样的 `div.style=\"color: red; width: 100px\"` 设置完整的属性，因为 `div.style` 是一个对象，并且它是只读的。\n\n想要以字符串的形式设置完整的样式，可以使用特殊属性 `style.cssText`：\n\n```html run\n<div id=\"div\">Button</div>\n\n<script>\n  // 我们可以在这里设置特殊的样式标记，例如 \"important\"\n  div.style.cssText=`color: red !important;\n    background-color: yellow;\n    width: 100px;\n    text-align: center;\n  `;\n\n  alert(div.style.cssText);\n</script>\n```\n\n我们很少使用这个属性，因为这样的赋值会删除所有现有样式：它不是进行添加，而是替换它们。有时可能会删除所需的内容。但是，当我们知道我们不会删除现有样式时，可以安全地将其用于新元素。\n\n可以通过设置一个特性（attribute）来实现同样的效果：`div.setAttribute('style', 'color: red...')`。\n````\n\n## 注意单位\n\n不要忘记将 CSS 单位添加到值上。\n\n例如，我们不应该将 `elem.style.top` 设置为 `10`，而应将其设置为 `10px`。否则设置会无效：\n\n```html run height=100\n<body>\n  <script>\n  *!*\n    // 无效！\n    document.body.style.margin = 20;\n    alert(document.body.style.margin); // ''（空字符串，赋值被忽略了）\n  */!*\n\n    // 现在添加了 CSS 单位（px）—— 生效了\n    document.body.style.margin = '20px';\n    alert(document.body.style.margin); // 20px\n\n    alert(document.body.style.marginTop); // 20px\n    alert(document.body.style.marginLeft); // 20px\n  </script>\n</body>\n```\n\n请注意：浏览器在最后几行代码中对属性 `style.margin` 进行了“解包”，并从中推断出 `style.marginLeft` 和 `style.marginTop`。\n\n## 计算样式：getComputedStyle\n\n修改样式很简单。但是如何 **读取** 样式呢？\n\n例如，我们想知道元素的 size，margins 和 color。应该怎么获取？\n\n**`style` 属性仅对 `\"style\"` 特性（attribute）值起作用，而没有任何 CSS 级联（cascade）。**\n\n因此我们无法使用 `elem.style` 读取来自 CSS 类的任何内容。\n\n例如，这里的 `style` 看不到 margin：\n\n```html run height=60 no-beautify\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  The red text\n  <script>\n*!*\n    alert(document.body.style.color); // 空的\n    alert(document.body.style.marginTop); // 空的\n*/!*\n  </script>\n</body>\n```\n\n……但如果我们需要，例如，将 margin 增加 20px 呢？那么我们需要 margin 的当前值。\n\n对于这个需求，这里有另一种方法：`getComputedStyle`。\n\n语法如下：\n\n```js\ngetComputedStyle(element, [pseudo])\n```\n\nelement\n: 需要被读取样式值的元素。\n\npseudo\n: 伪元素（如果需要），例如 `::before`。空字符串或无参数则意味着元素本身。\n\n结果是一个具有样式属性的对象，像 `elem.style`，但现在对于所有的 CSS 类来说都是如此。\n\n例如：\n\n```html run height=100\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  <script>\n    let computedStyle = getComputedStyle(document.body);\n\n    // 现在我们可以读取它的 margin 和 color 了\n\n    alert( computedStyle.marginTop ); // 5px\n    alert( computedStyle.color ); // rgb(255, 0, 0)\n  </script>\n\n</body>\n```\n\n```smart header=\"计算值和解析值\"\n在 [CSS](https://drafts.csswg.org/cssom/#resolved-values) 中有两个概念：\n\n1. **计算 (computed)** 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果。它看起来像 `height:1em` 或 `font-size:125%`。\n2. **解析 (resolved)** 样式值是最终应用于元素的样式值。诸如 `1em` 或 `125%` 这样的值是相对的。浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位，例如：`height:20px` 或 `font-size:16px`。对于几何属性，解析（resolved）值可能具有浮点，例如：`width:50.5px`。\n\n很久以前，创建了 `getComputedStyle` 来获取计算（computed）值，但事实证明，解析（resolved）值要方便得多，标准也因此发生了变化。\n\n所以，现在 `getComputedStyle` 实际上返回的是属性的解析值（resolved）。\n```\n\n````warn header=\"`getComputedStyle` 需要完整的属性名\"\n我们应该总是使用我们想要的确切的属性，例如 `paddingLeft`、`marginTop` 或 `borderTopWidth`。否则，就不能保证正确的结果。\n\n例如，如果有 `paddingLeft/paddingTop` 属性，那么对于 `getComputedStyle(elem).padding`，我们会得到什么？什么都没有，或者是从已知的 padding 中“生成”的值？这里没有标准的规则。\n\n还有其他不一致的地方。例如，在下面这个例子中，某些浏览器（Chrome）会显示 `10px`，而某些浏览器（Firefox）则没有：\n\n```html run\n<style>\n  body {\n    margin: 10px;\n  }\n</style>\n<script>\n  let style = getComputedStyle(document.body);\n  alert(style.margin); // 在 Firefox 中是空字符串\n</script>\n```\n````\n\n```smart header=\"应用于 `:visited` 链接的样式被隐藏了！\"\n可以使用 CSS 伪类 `:visited` 对被访问过的链接进行着色。\n\n但 `getComputedStyle` 没有给出访问该颜色的方式，因为如果允许的话，任意页面都可以通过在页面上创建它，并通过检查样式来确定用户是否访问了某链接。\n\nJavaScript 看不到 `:visited` 所应用的样式。此外，CSS 中也有一个限制，即禁止在 `:visited` 中应用更改几何形状的样式。这是为了确保一个不好的页面无法检测链接是否被访问，进而窥探隐私。\n```\n\n## 总结\n\n要管理 class，有两个 DOM 属性：\n\n- `className` —— 字符串值，可以很好地管理整个类的集合。\n- `classList` —— 具有 `add/remove/toggle/contains` 方法的对象，可以很好地支持单个类。\n\n要改变样式：\n\n- `style` 属性是具有驼峰（camelCased）样式的对象。对其进行读取和修改与修改 `\"style\"` 特性（attribute）中的各个属性具有相同的效果。要了解如何应用 `important` 和其他特殊内容 —— 在 [MDN](mdn:api/CSSStyleDeclaration) 中有一个方法列表。\n\n- `style.cssText` 属性对应于整个 `\"style\"` 特性（attribute），即完整的样式字符串。\n\n要读取已解析的（resolved）样式（对于所有类，在应用所有 CSS 并计算最终值之后）：\n\n- `getComputedStyle(elem, [pseudo])` 返回与 `style` 对象类似的，且包含了所有类的对象。只读。",
        "libs": [],
        "children": [
          "create-notification"
        ],
        "parent": "document",
        "updatedAt": 1658932848
      }
    },
    "create-notification": {
      "type": "Task",
      "value": {
        "title": "创建一个通知",
        "slug": "create-notification",
        "githubPath": "/2-ui/1-document/08-styles-and-classes/2-create-notification",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写一个函数 `showNotification(options)`：该函数创建一个带有给定内容的通知 `<div class=\"notification\">`。该通知应该在 1.5 秒后自动消失。\n\n参数：\n\n```js\n// 在窗口的右上角附近显示一个带有文本 \"Hello\" 的元素\nshowNotification({\n  top: 10, // 距窗口顶部 10px（默认为 0px）\n  right: 10, // 距窗口右边缘 10px（默认为 0px）\n  html: \"Hello!\", // 通知中的 HTML\n  className: \"welcome\" // div 的附加类（可选）\n});\n```\n\n[demo src=\"solution\"]\n\n\n使用 CSS 定位在给定的 top/right 坐标处显示元素。源文档已经提供了必要的样式。",
        "solution": "",
        "parent": "styles-and-classes",
        "version": 1
      }
    },
    "size-and-scroll": {
      "type": "Article",
      "value": {
        "title": "元素大小和滚动",
        "slug": "size-and-scroll",
        "githubPath": "/2-ui/1-document/09-size-and-scroll",
        "isFolder": false,
        "weight": 9,
        "content": "\n\nJavaScript 中有许多属性可让我们读取有关元素宽度、高度和其他几何特征的信息。\n\n我们在 JavaScript 中移动或定位元素时，我们会经常需要它们。\n\n## 示例元素\n\n作为演示属性的示例元素，我们将使用下面给出的元素：\n\n```html no-beautify\n<div id=\"example\">\n  ...Text...\n</div>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #E8C48F;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n```\n\n它有边框（border），内边距（padding）和滚动（scrolling）等全套功能。但没有外边距（margin），因为它们不是元素本身的一部分，并且它们没什么特殊的属性。\n\n这个元素看起来就像这样：\n\n![](metric-css.svg)\n\n你可以 [在 sandbox 中打开这个文档](sandbox:metric)。\n\n```smart header=\"注意滚动条\"\n上图演示了元素具有滚动条这种最复杂的情况。一些浏览器（并非全部）通过从内容（上面标记为 \"content width\"）中获取空间来为滚动条保留空间。\n\n因此，如果没有滚动条，内容宽度将是 `300 px`，但是如果滚动条宽度是 `16px`（不同的设备和浏览器，滚动条的宽度可能有所不同），那么还剩下 `300 - 16 ＝ 284px`，我们应该考虑到这一点。这就是为什么本章的例子总是假设有滚动条。如果没有滚动条，一些计算会更简单。\n```\n\n```smart header=\"文本可能会溢出到 `padding-bottom` 中\"\n在我们的插图中的 padding 中通常显示为空，但是如果元素中有很多文本，并且溢出了，那么浏览器会在 `padding-bottom` 处显示“溢出”文本，这是正常现象。\n```\n\n## 几何\n\n这是带有几何属性的整体图片：\n\n![](metric-all.svg)\n\n这些属性的值在技术上讲是数字，但这些数字其实是“像素（pixel）”，因此它们是像素测量值。\n\n让我们从元素外部开始探索属性。\n\n## offsetParent，offsetLeft/Top\n\n这些属性很少使用，但它们仍然是“最外面”的几何属性，所以我们将从它们开始。\n\n`offsetParent` 是最接近的祖先（ancestor），在浏览器渲染期间，它被用于计算坐标。\n\n最近的祖先为下列之一：\n\n1. CSS 定位的（`position` 为 `absolute`、`relative`、`fixed` 或 `sticky`），\n2. 或 `<td>`，`<th>`，`<table>`，\n3. 或 `<body>`。\n\n属性 `offsetLeft/offsetTop` 提供相对于 `offsetParent` 左上角的 x/y 坐标。\n\n在下面这个例子中，内部的 `<div>` 有 `<main>` 作为 `offsetParent`，并且 `offsetLeft/offsetTop` 让它从左上角位移（`180`）：\n\n```html run height=10\n<main style=\"position: relative\" id=\"main\">\n  <article>\n    <div id=\"example\" style=\"position: absolute; left: 180px; top: 180px\">...</div>\n  </article>\n</main>\n<script>\n  alert(example.offsetParent.id); // main\n  alert(example.offsetLeft); // 180（注意：这是一个数字，不是字符串 \"180px\"）\n  alert(example.offsetTop); // 180\n</script>\n```\n\n![](metric-offset-parent.svg)\n\n有以下几种情况下，`offsetParent` 的值为 `null`：\n\n1. 对于未显示的元素（`display:none` 或者不在文档中）。\n2. 对于 `<body>` 与 `<html>`。\n3. 对于带有 `position:fixed` 的元素。\n\n## offsetWidth/Height\n\n现在，让我们继续关注元素本身。\n\n这两个属性是最简单的。它们提供了元素的“外部” width/height。或者，换句话说，它的完整大小（包括边框）。\n\n![](metric-offset-width-height.svg)\n\n对于我们的示例元素：\n\n- `offsetWidth = 390` —— 外部宽度（width），可以计算为内部 CSS-width（`300px`）加上 padding（`2 * 20px`）和 border（`2 * 25px`）。\n- `offsetHeight = 290` —— 外部高度（height）。\n\n````smart header=\"对于未显示的元素，几何属性为 0/null\"\n仅针对显示的元素计算几何属性。\n\n如果一个元素（或其任何祖先）具有 `display:none` 或不在文档中，则所有几何属性均为零（或 `offsetParent` 为 `null`）。\n\n例如，当我们创建了一个元素，但尚未将其插入文档中，或者它（或它的祖先）具有 `display:none` 时，`offsetParent` 为 `null`，并且 `offsetWidth` 和 `offsetHeight` 为 `0`。\n\n我们可以用它来检查一个元素是否被隐藏，像这样：\n\n```js\nfunction isHidden(elem) {\n  return !elem.offsetWidth && !elem.offsetHeight;\n}\n```\n\n请注意，对于会展示在屏幕上，但大小为零的元素，它们的 `isHidden` 返回 `true`。\n````\n\n## clientTop/Left\n\n在元素内部，我们有边框（border）。\n\n为了测量它们，可以使用 `clientTop` 和 `clientLeft`。\n\n在我们的例子中：\n\n- `clientLeft = 25` —— 左边框宽度\n- `clientTop = 25` —— 上边框宽度\n\n![](metric-client-left-top.svg)\n\n……但准确地说 —— 这些属性不是边框的 width/height，而是内侧与外侧的相对坐标。\n\n有什么区别？\n\n当文档从右到左显示（操作系统为阿拉伯语或希伯来语）时，影响就显现出来了。此时滚动条不在右边，而是在左边，此时 `clientLeft` 则包含了滚动条的宽度。\n\n在这种情况下，`clientLeft` 的值将不是 `25`，而是加上滚动条的宽度 `25 + 16 = 41`。\n\n这是希伯来语的例子：\n\n![](metric-client-left-top-rtl.svg)\n\n## clientWidth/Height\n\n这些属性提供了元素边框内区域的大小。\n\n它们包括了 \"content width\" 和 \"padding\"，但不包括滚动条宽度（scrollbar）：\n\n![](metric-client-width-height.svg)\n\n在上图中，我们首先考虑 `clientHeight`。\n\n这里没有水平滚动条，所以它恰好是 border 内的总和：CSS-height `200px` 加上顶部和底部的 padding（`2 * 20px`），总计 `240px`。\n\n现在 `clientWidth` —— 这里的 \"content width\" 不是 `300px`，而是 `284px`，因为被滚动条占用了 `16px`。所以加起来就是 `284px` 加上左侧和右侧的 padding，总计 `324px`。\n\n**如果这里没有 padding，那么 `clientWidth/Height` 代表的就是内容区域，即 border 和 scrollbar（如果有）内的区域。**\n\n![](metric-client-width-nopadding.svg)\n\n因此，当没有 padding 时，我们可以使用 `clientWidth/clientHeight` 来获取内容区域的大小。\n\n## scrollWidth/Height\n\n这些属性就像 `clientWidth/clientHeight`，但它们还包括滚动出（隐藏）的部分：\n\n![](metric-scroll-width-height.svg)\n\n在上图中：\n\n- `scrollHeight = 723` —— 是内容区域的完整内部高度，包括滚动出的部分。\n- `scrollWidth = 324` —— 是完整的内部宽度，这里我们没有水平滚动，因此它等于 `clientWidth`。\n\n我们可以使用这些属性将元素展开（expand）到整个 width/height。\n\n像这样：\n\n```js\n// 将元素展开（expand）到完整的内容高度\nelement.style.height = `${element.scrollHeight}px`;\n```\n\n```online\n点击按钮展开元素：\n\n<div id=\"element\" style=\"width:300px;height:200px; padding: 0;overflow: auto; border:1px solid black;\">text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text</div>\n\n<button style=\"padding:0\" onclick=\"element.style.height = `${element.scrollHeight}px`\">element.style.height = `${element.scrollHeight}px`</button>\n```\n\n## scrollLeft/scrollTop\n\n属性 `scrollLeft/scrollTop` 是元素的隐藏、滚动部分的 width/height。\n\n在下图中，我们可以看到带有垂直滚动块的 `scrollHeight` 和 `scrollTop`。\n\n![](metric-scroll-top.svg)\n\n换句话说，`scrollTop` 就是“已经滚动了多少”。\n\n````smart header=\"`scrollLeft/scrollTop` 是可修改的\"\n大多数几何属性是只读的，但是 `scrollLeft/scrollTop` 是可修改的，并且浏览器会滚动该元素。\n\n```online\n如果你点击下面的元素，则会执行代码 `elem.scrollTop += 10`。这使得元素内容向下滚动 `10px`。\n\n<div onclick=\"this.scrollTop+=10\" style=\"cursor:pointer;border:1px solid black;width:100px;height:80px;overflow:auto\">Click<br>Me<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</div>\n```\n\n将 `scrollTop` 设置为 `0` 或一个大的值，例如 `1e9`，将会使元素滚动到顶部/底部。\n````\n\n## 不要从 CSS 中获取 width/height\n\n我们刚刚介绍了 DOM 元素的几何属性，它们可用于获得宽度、高度和计算距离。\n\n但是，正如我们在 <info:styles-and-classes> 一章所知道的那样，我们可以使用 `getComputedStyle` 来读取 CSS-width 和 height。\n\n那为什么不像这样用 `getComputedStyle` 读取元素的 width 呢？\n\n```js run\nlet elem = document.body;\n\nalert( getComputedStyle(elem).width ); // 显示 elem 的 CSS width\n```\n\n为什么我们应该使用几何属性呢？这里有两个原因：\n\n1. 首先，CSS `width/height` 取决于另一个属性：`box-sizing`，它定义了“什么是” CSS 宽度和高度。出于 CSS 的目的而对 `box-sizing` 进行的更改可能会破坏此类 JavaScript 操作。\n2. 其次，CSS 的 `width/height` 可能是 `auto`，例如内联（inline）元素：\n\n    ```html run\n    <span id=\"elem\">Hello!</span>\n\n    <script>\n    *!*\n      alert( getComputedStyle(elem).width ); // auto\n    */!*\n    </script>\n    ```\n\n    从 CSS 的观点来看，`width:auto` 是完全正常的，但在 JavaScript 中，我们需要一个确切的 `px` 大小，以便我们在计算中使用它。因此，这里的 CSS 宽度没什么用。\n\n还有另一个原因：滚动条。有时，在没有滚动条的情况下代码工作正常，当出现滚动条时，代码就出现了 bug，因为在某些浏览器中，滚动条会占用内容的空间。因此，可用于内容的实际宽度小于 CSS 宽度。而 `clientWidth/clientHeight` 则会考虑到这一点。\n\n……但是，使用 `getComputedStyle(elem).width` 时，情况就不同了。某些浏览器（例如 Chrome）返回的是实际内部宽度减去滚动条宽度，而某些浏览器（例如 Firefox）返回的是 CSS 宽度（忽略了滚动条）。这种跨浏览器的差异是不使用 `getComputedStyle` 而依靠几何属性的原因。\n\n```online\n如果你的浏览器保留了滚动条的空间（大多数 Windows 中的浏览器），那么你可以在下面测试它。\n\n[iframe src=\"cssWidthScroll\" link border=1]\n\n带有文本的元素具有 `width:300px`。\n\n在桌面 Windows 操作系统上，Firefox、Chrome、Edge 都为滚动条保留了空间。但 Firefox 显示的是 `300px`，而 Chrome 和 Edge 显示较少。这是因为 Firefox 返回 CSS 宽度，其他浏览器返回“真实”宽度。\n```\n\n请注意，所描述的差异只是关于从 JavaScript 读取的 `getComputedStyle(...).width`，而视觉上看，一切都是正确的。\n\n## 总结\n\n元素具有以下几何属性：\n\n- `offsetParent` —— 是最接近的 CSS 定位的祖先，或者是 `td`，`th`，`table`，`body`。\n- `offsetLeft/offsetTop` —— 是相对于 `offsetParent` 的左上角边缘的坐标。\n- `offsetWidth/offsetHeight` —— 元素的“外部” width/height，边框（border）尺寸计算在内。\n- `clientLeft/clientTop` —— 从元素左上角外角到左上角内角的距离。对于从左到右显示内容的操作系统来说，它们始终是左侧/顶部 border 的宽度。而对于从右到左显示内容的操作系统来说，垂直滚动条在左边，所以 `clientLeft` 也包括滚动条的宽度。\n- `clientWidth/clientHeight` —— 内容的 width/height，包括 padding，但不包括滚动条（scrollbar）。\n- `scrollWidth/scrollHeight` —— 内容的 width/height，就像 `clientWidth/clientHeight` 一样，但还包括元素的滚动出的不可见的部分。\n- `scrollLeft/scrollTop` —— 从元素的左上角开始，滚动出元素的上半部分的 width/height。\n\n除了 `scrollLeft/scrollTop` 外，所有属性都是只读的。如果我们修改 `scrollLeft/scrollTop`，浏览器会滚动对应的元素。",
        "libs": [],
        "children": [
          "get-scroll-height-bottom",
          "scrollbar-width",
          "put-ball-in-center",
          "width-vs-clientwidth"
        ],
        "parent": "document",
        "updatedAt": 1669550763
      }
    },
    "get-scroll-height-bottom": {
      "type": "Task",
      "value": {
        "title": "相对于底部滚动了多少？",
        "slug": "get-scroll-height-bottom",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/1-get-scroll-height-bottom",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n`elem.scrollTop` 属性是从顶部滚动出来的部分的大小。如何获得底部滚动的大小（我们称其为 `scrollBottom`）？\n\n编写适用于任意 `elem` 的代码。\n\nP.S. 请检查你的代码：如果没有滚动，或元素底部已经完全滚动完成，那么它应该返回 `0`。",
        "solution": "解决方案：\n\n```js\nlet scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;\n```\n\n换句话说：（完全高度）减去（已滚出顶部的高度）减去（可见部分的高度）—— 得到的结果就是滚动出来的底部的部分。",
        "parent": "size-and-scroll",
        "version": 1
      }
    },
    "scrollbar-width": {
      "type": "Task",
      "value": {
        "title": "滚动条的宽度是多少？",
        "slug": "scrollbar-width",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/2-scrollbar-width",
        "weight": 2,
        "libs": [],
        "importance": 3,
        "content": "\n\n编写代码，返回标准滚动条宽度。\n\n对于 Windows，它通常在 `12px` 和 `20px` 之间变化。如果浏览器没有为其保留任何空间（滚动条以半透明的形式处于文本上面，也是可能发生的），那么它可能是 `0px`。\n\nP.S. 该代码应适用于任何 HTML 文档，而不依赖于其内容。",
        "solution": "为了获得滚动条的宽度，我们可以创建一个带有滚动条的元素，但是没有边框（border）和内边距（padding）。\n\n然后，它的全宽度 `offsetWidth` 和内部内容宽度 `clientWidth` 之间的差值就是滚动条的宽度：\n\n```js run\n// 创建一个包含滚动条的 div\nlet div = document.createElement('div');\n\ndiv.style.overflowY = 'scroll';\ndiv.style.width = '50px';\ndiv.style.height = '50px';\n\n// 必须将其放入文档（document）中，否则其大小将为 0\ndocument.body.append(div);\nlet scrollWidth = div.offsetWidth - div.clientWidth;\n\ndiv.remove();\n\nalert(scrollWidth);\n```",
        "parent": "size-and-scroll",
        "version": 1
      }
    },
    "put-ball-in-center": {
      "type": "Task",
      "value": {
        "title": "将小球置于区域（field）中心",
        "slug": "put-ball-in-center",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/4-put-ball-in-center",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n源文件的效果如下：\n\n[iframe src=\"source\" edit link height=180]\n\n区域（field）的中心坐标是多少？\n\n计算它们，并将小球置于绿色的区域（field）中心：\n\n[iframe src=\"solution\" height=180]\n\n- 该元素应该通过 JavaScript 移动，而不是 CSS。\n- 该代码应该适用于任何大小的球（`10`、`20`、`30` 像素）以及任意大小的区域（field），而不应该绑定到给定值。\n\nP.S. 当然了，置于中心的操作通过 CSS 也可以完成，但是这里我们需要通过 JavaScript 完成。此外，当必须使用 JavaScript 时，我们可能会遇到其他话题以及更加复杂的情况，这里我们只是做一个“热身”。",
        "solution": "球具有 `position:absolute`。这意味着它的 `left/top` 坐标是从最近的具有定位属性的元素开始测量的，这个元素即 `#field`（因为它有 `position:relative`）。\n\n坐标从场（field）的左上角内侧开始：\n\n![](field.svg)\n\n内部的场（field）的 width/height 是 `clientWidth/clientHeight`。所以场（field）的中心坐标为 `(clientWidth/2, clientHeight/2)`。\n\n……但是，如果我们将 `ball.style.left/top` 设置为这种值，那么在中心的会是球的左上边缘，而不是整个球：\n\n```js\nball.style.left = Math.round(field.clientWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2) + 'px';\n```\n\n这是它将显示出来的效果：\n\n[iframe height=180 src=\"ball-half\"]\n\n为了使球的中心与场（field）的中心重合，我们应该把球向左移动球宽度的一半，并向上移动球高度的一半：\n\n```js\nball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';\nball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';\n```\n\n现在，球终于居中了。\n\n````warn header=\"注意：陷阱！\"\n\n当 `<img>` 没有 width/height 时，代码将无法可靠地工作：\n\n```html\n<img src=\"ball.png\" id=\"ball\">\n```\n````\n\n当浏览器不知道图片的 width/height（通过标签 attribute 或 CSS）时，它会假定它们等于 `0`，直到图片加载完成。\n\n因此，在图片加载完成之前，`ball.offsetWidth` 的值为 `0`。这会导致上面的代码中会有错误的坐标。\n\n在第一次加载完成后，浏览器通常会缓存该图片，并在下一次加载时，浏览器会立即拥有该图片的大小。但是在第一次加载时，`ball.offsetWidth` 的值为 `0`。\n\n我们应该通过在 `<img>` 中添加 `width/height` 来解决这个问题：\n\n```html\n<img src=\"ball.png\" *!*width=\"40\" height=\"40\"*/!* id=\"ball\">\n```\n\n……或者在 CSS 中提供大小：\n\n```css\n#ball {\n  width: 40px;\n  height: 40px;\n}\n```",
        "parent": "size-and-scroll",
        "version": 1
      }
    },
    "width-vs-clientwidth": {
      "type": "Task",
      "value": {
        "title": "CSS width 与 clientWidth 的不同点",
        "slug": "width-vs-clientwidth",
        "githubPath": "/2-ui/1-document/09-size-and-scroll/6-width-vs-clientwidth",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n`getComputedStyle(elem).width` 与 `elem.clientWidth` 之间有什么不同点？\n\n指出至少三种不同点。当然越多越好。",
        "solution": "不同点：\n\n1. `clientWidth` 值是数值，而 `getComputedStyle(elem).width` 返回一个以 `px` 作为后缀的字符串。\n2. `getComputedStyle` 可能会返回非数值的 width，例如内联（inline）元素的 `\"auto\"`。\n3. `clientWidth` 是元素的内部内容区域加上 padding，而 CSS width（具有标准的 `box-sizing`）是内部内容区域，**不包括 padding**。\n4. 如果有滚动条，并且浏览器为其保留了空间，那么某些浏览器会从 CSS width 中减去该空间（因为它不再可用于内容），而有些则不会这样做。`clientWidth` 属性总是相同的：如果为滚动条保留了空间，那么将减去滚动条的大小。",
        "parent": "size-and-scroll",
        "version": 1
      }
    },
    "size-and-scroll-window": {
      "type": "Article",
      "value": {
        "title": "Window 大小和滚动",
        "slug": "size-and-scroll-window",
        "githubPath": "/2-ui/1-document/10-size-and-scroll-window",
        "isFolder": false,
        "weight": 10,
        "content": "\n\n我们如何找到浏览器窗口（window）的宽度和高度呢？我们如何获得文档（document）的包括滚动部分在内的完整宽度和高度呢？我们如何使用 JavaScript 滚动页面？\n\n对于此类信息，我们可以使用与 `<html>` 标签相对应的根文档元素 `document.documentElement`。但是还有其他方法和特性需要考虑。\n\n## 窗口的 width/height\n\n为了获取窗口（window）的宽度和高度，我们可以使用 `document.documentElement` 的 `clientWidth/clientHeight`：\n\n![](document-client-width-height.svg)\n\n```online\n例如，这个按钮会显示窗口的高度：\n\n<button onclick=\"alert(document.documentElement.clientHeight)\">alert(document.documentElement.clientHeight)</button>\n```\n\n````warn header=\"不是 `window.innerWidth/innerHeight`\"\n浏览器也支持像 `window.innerWidth/innerHeight` 这样的属性。它们看起来像我们想要的，那为什么不使用它们呢？\n\n如果这里存在一个滚动条，并且滚动条占用了一些空间，那么 `clientWidth/clientHeight` 会提供没有滚动条（减去它）的 width/height。换句话说，它们返回的是可用于内容的文档的可见部分的 width/height。\n\n`window.innerWidth/innerHeight` 包括了滚动条。\n\n如果这里有一个滚动条，它占用了一些空间，那么这两行代码会显示不同的值：\n```js run\nalert( window.innerWidth ); // 整个窗口的宽度\nalert( document.documentElement.clientWidth ); // 减去滚动条宽度后的窗口宽度\n```\n\n在大多数情况下，我们需要 **可用** 的窗口宽度以绘制或放置某些东西。也就是说，在滚动条内（如果有）。所以，我们应该使用 `documentElement.clientHeight/clientWidth`。\n````\n\n```warn header=\"`DOCTYPE` 很重要\"\n请注意：当 HTML 中没有 `<!DOCTYPE HTML>` 时，顶层级（top-level）几何属性的工作方式可能就会有所不同。可能会出现一些稀奇古怪的情况。\n\n在现代 HTML 中，我们始终都应该写 `DOCTYPE`。\n```\n\n## 文档的 width/height\n\n从理论上讲，由于根文档元素是 `document.documentElement`，并且它包围了所有内容，因此我们可以通过使用 `documentElement.scrollWidth/scrollHeight` 来测量文档的完整大小。\n\n但是在该元素上，对于整个文档，这些属性均无法正常工作。在 Chrome/Safari/Opera 中，如果没有滚动条，`documentElement.scrollHeight` 甚至可能小于 `documentElement.clientHeight`！很奇怪，对吧？\n\n为了可靠地获得完整的文档高度，我们应该采用以下这些属性的最大值：\n\n```js run\nlet scrollHeight = Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n);\n\nalert('Full document height, with scrolled out part: ' + scrollHeight);\n```\n\n为什么这样？最好不要问。这些不一致来源于远古时代，而不是“聪明”的逻辑。\n\n## 获得当前滚动 [#page-scroll]\n\nDOM 元素的当前滚动状态在其 `scrollLeft/scrollTop` 属性中。\n\n对于文档滚动，在大多数浏览器中，我们可以使用 `document.documentElement.scrollLeft/scrollTop`，但在较旧的基于 WebKit 的浏览器中则不行，例如在 Safari（bug [5991](https://bugs.webkit.org/show_bug.cgi?id=5991)）中，我们应该使用 `document.body` 而不是 `document.documentElement`。\n\n幸运的是，我们根本不必记住这些特性，因为我们可以从 `window.pageXOffset/pageYOffset` 中获取页面当前滚动信息：\n\n```js run\nalert('当前已从顶部滚动：' + window.pageYOffset);\nalert('当前已从左侧滚动：' + window.pageXOffset);\n```\n\n这些属性是只读的。\n\n```smart header=\"我们也可以从 `window` 的 `scrollX` 和 `scrollY` 属性中获取滚动信息\"\n由于历史原因，存在了这两种属性，但它们是一样的：\n- `window.pageXOffset` 是 `window.scrollX` 的别名。\n- `window.pageYOffset` 是 `window.scrollY` 的别名。\n```\n\n## 滚动：scrollTo，scrollBy，scrollIntoView [#window-scroll]\n\n```warn\n必须在 DOM 完全构建好之后才能通过 JavaScript 滚动页面。\n\n例如，如果我们尝试通过 `<head>` 中的脚本滚动页面，它将无法正常工作。\n```\n\n可以通过更改 `scrollTop/scrollLeft` 来滚动常规元素。\n\n我们可以使用 `document.documentElement.scrollTop/scrollLeft` 对页面进行相同的操作（Safari 除外，而应该使用 `document.body.scrollTop/Left` 代替）。\n\n或者，有一个更简单的通用解决方案：使用特殊方法 [window.scrollBy(x,y)](mdn:api/Window/scrollBy) 和 [window.scrollTo(pageX,pageY)](mdn:api/Window/scrollTo)。\n\n- 方法 `scrollBy(x,y)` 将页面滚动至 **相对于当前位置的 `(x, y)` 位置**。例如，`scrollBy(0,10)` 会将页面向下滚动 `10px`。\n\n    ```online\n    下面这个按钮演示了这个方法：\n\n    <button onclick=\"window.scrollBy(0,10)\">window.scrollBy(0,10)</button>\n    ```\n- 方法 `scrollTo(pageX,pageY)` 将页面滚动至 **绝对坐标**，使得可见部分的左上角具有相对于文档左上角的坐标 `(pageX, pageY)`。就像设置了 `scrollLeft/scrollTop` 一样。\n\n    要滚动到最开始，我们可以使用 `scrollTo(0,0)`。\n\n    ```online\n    <button onclick=\"window.scrollTo(0,0)\">window.scrollTo(0,0)</button>\n    ```\n\n这些方法适用于所有浏览器。\n\n## scrollIntoView\n\n为了完整起见，让我们再介绍一种方法：[elem.scrollIntoView(top)](mdn:api/Element/scrollIntoView)。\n\n对 `elem.scrollIntoView(top)` 的调用将滚动页面以使 `elem` 可见。它有一个参数：\n\n- 如果 `top=true`（默认值），页面滚动，使 `elem` 出现在窗口顶部。元素的上边缘将与窗口顶部对齐。\n- 如果 `top=false`，页面滚动，使 `elem` 出现在窗口底部。元素的底部边缘将与窗口底部对齐。\n\n```online\n下面这个按钮会滚动页面，以使其自身定位在窗口顶部：\n\n<button onclick=\"this.scrollIntoView()\">this.scrollIntoView()</button>\n\n下面这个按钮会滚动页面，以使其自身定位在窗口底部：\n\n<button onclick=\"this.scrollIntoView(false)\">this.scrollIntoView(false)</button>\n```\n\n## 禁止滚动\n\n有时候我们需要使文档“不可滚动”。例如，当我们需要用一条需要立即引起注意的大消息来覆盖文档时，我们希望访问者与该消息而不是与文档进行交互。\n\n要使文档不可滚动，只需要设置 `document.body.style.overflow = \"hidden\"`。该页面将“冻结”在其当前滚动位置上。\n\n```online\n试一试：\n\n<button onclick=\"document.body.style.overflow = 'hidden'\">document.body.style.overflow = 'hidden'</button>\n\n<button onclick=\"document.body.style.overflow = ''\">document.body.style.overflow = ''</button>\n\n第一个按钮用于冻结滚动，第二个按钮则用于恢复滚动。\n```\n\n我们还可以使用相同的技术来冻结其他元素的滚动，而不仅仅是 `document.body`。\n\n这个方法的缺点是会使滚动条消失。如果滚动条占用了一些空间，它原本占用的空间就会空出来，那么内容就会“跳”进去以填充它。\n\n这看起来有点奇怪，但是我们可以对比冻结前后的 `clientWidth`。如果它增加了（滚动条消失后），那么我们可以在 `document.body` 中滚动条原来的位置处通过添加 `padding`，来替代滚动条，这样这个问题就解决了。保持了滚动条冻结前后文档内容宽度相同。\n\n## 总结\n\n几何：\n\n- 文档可见部分的 width/height（内容区域的 width/height）：`document.documentElement.clientWidth/clientHeight`\n- 整个文档的 width/height，其中包括滚动出去的部分：\n\n    ```js\n    let scrollHeight = Math.max(\n      document.body.scrollHeight, document.documentElement.scrollHeight,\n      document.body.offsetHeight, document.documentElement.offsetHeight,\n      document.body.clientHeight, document.documentElement.clientHeight\n    );\n    ```\n\n滚动：\n\n- 读取当前的滚动：`window.pageYOffset/pageXOffset`。\n- 更改当前的滚动：\n\n    - `window.scrollTo(pageX,pageY)` —— 绝对坐标，\n    - `window.scrollBy(x,y)` —— 相对当前位置进行滚动，\n    - `elem.scrollIntoView(top)` —— 滚动以使 `elem` 可见（`elem` 与窗口的顶部/底部对齐）。",
        "libs": [],
        "children": [],
        "parent": "document",
        "updatedAt": 1658936749
      }
    },
    "coordinates": {
      "type": "Article",
      "value": {
        "title": "坐标",
        "slug": "coordinates",
        "githubPath": "/2-ui/1-document/11-coordinates",
        "isFolder": false,
        "weight": 11,
        "content": "\n\n要移动页面的元素，我们应该先熟悉坐标。\n\n大多数 JavaScript 方法处理的是以下两种坐标系中的一个：\n\n1. **相对于窗口** —— 类似于 `position:fixed`，从窗口的顶部/左侧边缘计算得出。\n    - 我们将这些坐标表示为 `clientX/clientY`，当我们研究事件属性时，就会明白为什么使用这种名称来表示坐标。\n2. **相对于文档** —— 与文档根（document root）中的 `position:absolute` 类似，从文档的顶部/左侧边缘计算得出。\n    - 我们将它们表示为 `pageX/pageY`。\n\n当页面滚动到最开始时，此时窗口的左上角恰好是文档的左上角，它们的坐标彼此相等。但是，在文档移动之后，元素的窗口相对坐标会发生变化，因为元素在窗口中移动，而元素在文档中的相对坐标保持不变。\n\n在下图中，我们在文档中取一点，并演示了它滚动之前（左）和之后（右）的坐标：\n\n![](document-and-window-coordinates-scrolled.svg)\n\n当文档滚动了：\n- `pageY` —— 元素在文档中的相对坐标保持不变，从文档顶部（现在已滚动出去）开始计算。\n- `clientY` —— 窗口相对坐标确实发生了变化（箭头变短了），因为同一个点越来越靠近窗口顶部。\n\n## 元素坐标：getBoundingClientRect\n\n方法 `elem.getBoundingClientRect()` 返回最小矩形的窗口坐标，该矩形将 `elem` 作为内建 [DOMRect](https://www.w3.org/TR/geometry-1/#domrect) 类的对象。\n\n主要的 `DOMRect` 属性：\n\n- `x/y` —— 矩形原点相对于窗口的 X/Y 坐标，\n- `width/height` —— 矩形的 width/height（可以为负）。\n\n此外，还有派生（derived）属性：\n\n- `top/bottom` —— 顶部/底部矩形边缘的 Y 坐标，\n- `left/right` —— 左/右矩形边缘的 X 坐标。\n\n```online\n例如，点击下面这个按钮以查看其窗口坐标：\n\n<p><input id=\"brTest\" type=\"button\" value=\"Get coordinates using button.getBoundingClientRect() for this button\" onclick='showRect(this)'/></p>\n\n<script>\nfunction showRect(elem) {\n  let r = elem.getBoundingClientRect();\n  alert(`x:${r.x}\ny:${r.y}\nwidth:${r.width}\nheight:${r.height}\ntop:${r.top}\nbottom:${r.bottom}\nleft:${r.left}\nright:${r.right}\n`);\n}\n</script>\n\n如果你滚动此页面并重复点击上面那个按钮，你会发现随着窗口相对按钮位置的改变，其窗口坐标（如果你垂直滚动页面，则为 `y/top/bottom`）也随之改变。\n```\n\n下面这张是 `elem.getBoundingClientRect()` 的输出的示意图：\n\n![](coordinates.svg)\n\n正如你所看到的，`x/y` 和 `width/height` 对矩形进行了完整的描述。可以很容易地从它们计算出派生（derived）属性：\n\n- `left = x`\n- `top = y`\n- `right = x + width`\n- `bottom = y + height`\n\n请注意：\n\n- 坐标可能是小数，例如 `10.5`。这是正常的，浏览器内部使用小数进行计算。在设置 `style.left/top` 时，我们不是必须对它们进行舍入。\n- 坐标可能是负数。例如滚动页面，使 `elem` 现在位于窗口的上方，则 `elem.getBoundingClientRect().top` 为负数。\n\n```smart header=\"为什么需要派生（derived）属性？如果有了 `x/y`，为什么还要还会存在 `top/left`？\"\n从数学上讲，一个矩形是使用其起点 `(x,y)` 和方向向量 `(width,height)` 唯一定义的。因此，其它派生属性是为了方便起见。\n\n从技术上讲，`width/height` 可能为负数，从而允许“定向（directed）”矩形，例如代表带有正确标记的开始和结束的鼠标选择。\n\n负的 `width/height` 值表示矩形从其右下角开始，然后向左上方“增长”。\n\n这是一个矩形，其 `width` 和 `height` 均为负数（例如 `width=-200`，`height=-100`）：\n\n![](coordinates-negative.svg)\n\n正如你所看到的，在这个例子中，`left/top` 与 `x/y` 不相等。\n\n但是实际上，`elem.getBoundingClientRect()` 总是返回正数的 width/height，这里我们提及负的 `width/height` 只是为了帮助你理解，为什么这些看起来重复的属性，实际上并不是重复的。\n```\n\n```warn header=\"IE 浏览器不支持 `x/y`\"\n由于历史原因，IE 浏览器不支持 `x/y` 属性。\n\n因此，我们可以写一个 polyfill（在 `DomRect.prototype` 中添加一个 getter），或者仅使用 `top/left`，因为对于正值的 `width/height` 来说，它们和 `x/y` 一直是一样的，尤其是对于 `elem.getBoundingClientRect()` 的结果。\n```\n\n```warn header=\"坐标的 right/bottom 与 CSS position 属性不同\"\n相对于窗口（window）的坐标和 CSS `position:fixed` 之间有明显的相似之处。\n\n但是在 CSS 定位中，`right` 属性表示距右边缘的距离，而 `bottom` 属性表示距下边缘的距离。\n\n如果我们再看一下上面的图片，我们可以看到在 JavaScript 中并非如此。窗口的所有坐标都从左上角开始计数，包括这些坐标。\n```\n\n## elementFromPoint(x, y) [#elementFromPoint]\n\n对 `document.elementFromPoint(x, y)` 的调用会返回在窗口坐标 `(x, y)` 处嵌套最多（the most nested）的元素。\n\n语法如下：\n\n```js\nlet elem = document.elementFromPoint(x, y);\n```\n\n例如，下面的代码会高亮显示并输出现在位于窗口中间的元素的标签：\n\n```js run\nlet centerX = document.documentElement.clientWidth / 2;\nlet centerY = document.documentElement.clientHeight / 2;\n\nlet elem = document.elementFromPoint(centerX, centerY);\n\nelem.style.background = \"red\";\nalert(elem.tagName);\n```\n\n因为它使用的是窗口坐标，所以元素可能会因当前滚动位置而有所不同。\n\n````warn header=\"对于在窗口之外的坐标，`elementFromPoint` 返回 `null`\"\n方法 `document.elementFromPoint(x,y)` 只对在可见区域内的坐标 `(x,y)` 起作用。\n\n如果任何坐标为负或者超过了窗口的 width/height，那么该方法就会返回 `null`。\n\n在大多数情况下，这种行为并不是一个问题，但是我们应该记住这一点。\n\n如果我们没有对其进行检查，可能就会发生下面这个典型的错误：\n\n```js\nlet elem = document.elementFromPoint(x, y);\n// 如果坐标恰好在窗口外，则 elem = null\n*!*\nelem.style.background = ''; // Error!\n*/!*\n```\n````\n\n## 用于 \"fixed\" 定位\n\n大多数时候，我们需要使用坐标来确定某些内容的位置。\n\n想要在某元素附近展示内容，我们可以使用 `getBoundingClientRect` 来获取这个元素的坐标，然后使用 CSS `position` 以及 `left/top`（或 `right/bottom`）。\n\n例如，下面的函数 `createMessageUnder(elem, html)` 在 `elem` 下显示了消息：\n\n```js\nlet elem = document.getElementById(\"coords-show-mark\");\n\nfunction createMessageUnder(elem, html) {\n  // 创建 message 元素\n  let message = document.createElement('div');\n  // 在这里最好使用 CSS class 来定义样式\n  message.style.cssText = \"position:fixed; color: red\";\n\n*!*\n  // 分配坐标，不要忘记 \"px\"！\n  let coords = elem.getBoundingClientRect();\n\n  message.style.left = coords.left + \"px\";\n  message.style.top = coords.bottom + \"px\";\n*/!*\n\n  message.innerHTML = html;\n\n  return message;\n}\n\n// 用法：\n// 在文档中添加 message 保持 5 秒\nlet message = createMessageUnder(elem, 'Hello, world!');\ndocument.body.append(message);\nsetTimeout(() => message.remove(), 5000);\n```\n\n```online\n点击下面这个按钮来运行它：\n\n<button id=\"coords-show-mark\">Button with id=\"coords-show-mark\", the message will appear under it</button>\n```\n\n我们可以修改代码以在元素左侧，右侧或下面显示消息，也可以应用 CSS 动画来营造“淡入淡出”效果等。这很简单，因为我们有该元素所有坐标和大小。\n\n但是请注意一个重要的细节：滚动页面时，消息就会从按钮流出。\n\n原因很显然：message 元素依赖于 `position:fixed`，因此当页面滚动时，它仍位于窗口的同一位置。\n\n要改变这一点，我们需要使用基于文档（document）的坐标和 `position:absolute` 样式。\n\n## 文档坐标 [#getCoords]\n\n文档相对坐标从文档的左上角开始计算，而不是窗口。\n\n在 CSS 中，窗口坐标对应于 `position:fixed`，而文档坐标与顶部的 `position:absolute` 类似。\n\n我们可以使用 `position:absolute` 和 `top/left` 来把某些内容放到文档中的某个位置，以便在页面滚动时，元素仍能保留在该位置。但是我们首先需要正确的坐标。\n\n这里没有标准方法来获取元素的文档坐标。但是写起来很容易。\n\n这两个坐标系统通过以下公式相连接：\n- `pageY` = `clientY` + 文档的垂直滚动出的部分的高度。\n- `pageX` = `clientX` + 文档的水平滚动出的部分的宽度。\n\n函数 `getCoords(elem)` 将从 `elem.getBoundingClientRect()` 获取窗口坐标，并向其中添加当前滚动：\n\n```js\n// 获取元素的文档坐标\nfunction getCoords(elem) {\n  let box = elem.getBoundingClientRect();\n\n  return {\n    top: box.top + window.pageYOffset,\n    right: box.right + window.pageXOffset,\n    bottom: box.bottom + window.pageYOffset,\n    left: box.left + window.pageXOffset\n  };\n}\n```\n\n如果在上面的示例中，我们将其与 `position:absolute` 一起使用，则在页面滚动时，消息仍停留在元素附近。\n\n修改后的 `createMessageUnder` 函数：\n\n```js\nfunction createMessageUnder(elem, html) {\n  let message = document.createElement('div');\n  message.style.cssText = \"*!*position:absolute*/!*; color: red\";\n\n  let coords = *!*getCoords(elem);*/!*\n\n  message.style.left = coords.left + \"px\";\n  message.style.top = coords.bottom + \"px\";\n\n  message.innerHTML = html;\n\n  return message;\n}\n```\n\n## 总结\n\n页面上的任何点都有坐标：\n\n1. 相对于窗口的坐标 —— `elem.getBoundingClientRect()`。\n2. 相对于文档的坐标 —— `elem.getBoundingClientRect()` 加上当前页面滚动。\n\n窗口坐标非常适合和 `position:fixed` 一起使用，文档坐标非常适合和 `position:absolute` 一起使用。\n\n这两个坐标系统各有利弊。有时我们需要其中一个或另一个，就像 CSS `position` 的 `absolute` 和 `fixed` 一样。",
        "libs": [],
        "children": [
          "find-point-coordinates",
          "position-at",
          "position-at-absolute",
          "position-inside-absolute"
        ],
        "headHtml": "<script>\ndocument.addEventListener('DOMContentLoaded', function() {\n\n  let elem = document.getElementById('coords-show-mark');\n\n  // no elem in ebook (pdf/epub) mode\n  if (elem) {\n    elem.onclick = function() {\n\n      function createMessageUnder(elem, text) {\n        let coords = elem.getBoundingClientRect();\n        let message = document.createElement('div');\n        message.style.cssText = \"position:fixed; color: red\";\n\n        message.style.left = coords.left + \"px\";\n        message.style.top = coords.bottom + \"px\";\n\n        message.innerHTML = text;\n\n        return message;\n      }\n\n      let message = createMessageUnder(elem, 'Hello, world!');\n      document.body.append(message);\n      setTimeout(() => message.remove(), 5000);\n    }\n  }\n\n});\n\n</script>\n",
        "parent": "document",
        "updatedAt": 1667128251
      }
    },
    "find-point-coordinates": {
      "type": "Task",
      "value": {
        "title": "查找区域的窗口坐标",
        "slug": "find-point-coordinates",
        "githubPath": "/2-ui/1-document/11-coordinates/1-find-point-coordinates",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n在下面的 iframe 中，你可以看到一个带有绿色区域（field）的文档。\n\n使用 JavaScript 查找带箭头指向的角的窗口坐标。\n\n为了方便起见，已经在文档中实现了一个小功能。在任何地方点击都会显示那里的坐标。\n\n[iframe border=1 height=360 src=\"source\" link edit]\n\n你的代码应该使用 DOM 来获取以下窗口坐标：\n\n1. 左上的外角（这很简单）。\n2. 右下的外角（也挺简单）。\n3. 左上的内角（这有点难）。\n4. 右下的内角（有几种方式，选择其中一种）。\n\n你计算得到的坐标，应该与点击鼠标返回的坐标相同。\n\nP.S. 如果元素具有其他大小（size）和边框（border），且未绑定任何固定的值，你写的代码也应该起作用。",
        "solution": "# 外角\n\n外角就是我们从 [elem.getBoundingClientRect()](https://developer.mozilla.org/en-US/docs/DOM/element.getBoundingClientRect) 获取的。\n\n`answer1` 为左上角的坐标，`answer2` 为右下角的坐标：\n\n```js\nlet coords = elem.getBoundingClientRect();\n\nlet answer1 = [coords.left, coords.top];\nlet answer2 = [coords.right, coords.bottom];\n```\n\n# 左上的内角坐标\n\n内角与外角主要的不同在于边框的宽度。一种获取距离的可靠的方法是 `clientLeft/clientTop`：\n\n```js\nlet answer3 = [coords.left + field.clientLeft, coords.top + field.clientTop];\n```\n\n# 右下的内角坐标\n\n在我们的例子中，我们需要把外部坐标减去边框（border）大小。\n\n我们可以使用 CSS 的方式：\n\n```js\nlet answer4 = [\n  coords.right - parseInt(getComputedStyle(field).borderRightWidth),\n  coords.bottom - parseInt(getComputedStyle(field).borderBottomWidth)\n];\n```\n\n另一种方式是把 `clientWidth/clientHeight` 和左上角的坐标相加。这个方式相较于上一个或许更好：\n\n```js\nlet answer4 = [\n  coords.left + elem.clientLeft + elem.clientWidth,\n  coords.top + elem.clientTop + elem.clientHeight\n];\n```",
        "parent": "coordinates",
        "version": 1
      }
    },
    "position-at": {
      "type": "Task",
      "value": {
        "title": "在元素旁显示一个 note",
        "slug": "position-at",
        "githubPath": "/2-ui/1-document/11-coordinates/2-position-at",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个函数 `positionAt(anchor, position, elem)` 来定位 `elem`，具体取决于 `anchor` 元素附近的 `position`。\n\n`position` 必须具有下列三个字符串中的一个：\n- `\"top\"` — 将 `elem` 定位在 `anchor` 上方\n- `\"right\"` — 将 `elem` 定位在 `anchor` 右侧\n- `\"bottom\"` — 将 `elem` 定位在 `anchor` 下方\n\n`position` 被用在函数 `showNote(anchor, position, html)` 内，该函数使用给定的 `html` 创建一个 \"note\" 元素，并将其显示在 `anchor` 附近的 `position` 处。\n\n这是一个演示示例：\n\n[iframe src=\"solution\" height=\"350\" border=\"1\" link]",
        "solution": "在这个任务中，我们只需要准确地计算坐标即可。具体细节，请参见代码。\n\n请注意：元素必须在文档中才能读取 `offsetHeight` 和其它属性。\n隐藏的（`display:none`）或者不在文档中的元素没有大小。",
        "parent": "coordinates",
        "version": 1
      }
    },
    "position-at-absolute": {
      "type": "Task",
      "value": {
        "title": "在元素旁（absolute）显示一个 note",
        "slug": "position-at-absolute",
        "githubPath": "/2-ui/1-document/11-coordinates/3-position-at-absolute",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n修改 [上一个任务](info:task/position-at) 的解决方案，让 note 元素使用 `position:absolute` 来替代 `position:fixed`。\n\n这可以防止页面滚动时元素的“失控”。\n\n以上一个任务的解决方案为基础。为了测试页面滚动，请添加样式 `<body style=\"height: 2000px\">`。",
        "solution": "解决方案实际上很简单：\n\n- 在 `.note` 的 CSS 中，使用 `position:absolute` 代替 `position:fixed`。\n- 使用在 <info:coordinates> 一章中所讲的函数 [getCoords()](info:coordinates#getCoords) 来获取相对于文档的坐标。",
        "parent": "coordinates",
        "version": 1
      }
    },
    "position-inside-absolute": {
      "type": "Task",
      "value": {
        "title": "把 note 放在元素内部（absolute）",
        "slug": "position-inside-absolute",
        "githubPath": "/2-ui/1-document/11-coordinates/4-position-inside-absolute",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n扩展上一个任务 <info:task/position-at-absolute>：教函数 `positionAt(anchor, position, elem)` 把 `elem` 插入到 `anchor` 内部。\n\n`position` 的新值：\n\n- `top-out`，`right-out`，`bottom-out` — 和之前一样工作，它们把 `elem` 插入到 `anchor` 的上方/右侧/下方。\n- `top-in`，`right-in`，`bottom-in` — 把 `elem` 插入到 `anchor` 内部：将其粘贴到上/右/下边缘。\n\n例如：\n\n```js\n// 在 blockquote 上方显示 note\npositionAt(blockquote, \"top-out\", note);\n\n// 在 blockquote 内部的上边缘显示 note\npositionAt(blockquote, \"top-in\", note);\n```\n\n结果：\n\n[iframe src=\"solution\" height=\"310\" border=\"1\" link]\n\n可以以上一个任务 <info:task/position-at-absolute> 的解决方案为基础。",
        "solution": "",
        "parent": "coordinates",
        "version": 1
      }
    },
    "events": {
      "type": "Article",
      "value": {
        "title": "事件简介",
        "slug": "events",
        "githubPath": "/2-ui/2-events",
        "isFolder": true,
        "weight": 2,
        "content": "\n\n浏览器事件、事件属性和处理模式简介。",
        "libs": [],
        "children": [
          "introduction-browser-events",
          "bubbling-and-capturing",
          "event-delegation",
          "default-browser-action",
          "dispatch-events"
        ],
        "parent": "ui"
      }
    },
    "introduction-browser-events": {
      "type": "Article",
      "value": {
        "title": "浏览器事件简介",
        "slug": "introduction-browser-events",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n**事件** 是某事发生的信号。所有的 DOM 节点都生成这样的信号（但事件不仅限于 DOM）。\n\n这是最有用的 DOM 事件的列表，你可以浏览一下：\n\n**鼠标事件：**\n- `click` —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）。\n- `contextmenu` —— 当鼠标右键点击一个元素时。\n- `mouseover` / `mouseout` —— 当鼠标指针移入/离开一个元素时。\n- `mousedown` / `mouseup` —— 当在元素上按下/释放鼠标按钮时。\n- `mousemove` —— 当鼠标移动时。\n\n**键盘事件**：\n- `keydown` 和 `keyup` —— 当按下和松开一个按键时。\n\n**表单（form）元素事件**：\n- `submit` —— 当访问者提交了一个 `<form>` 时。\n- `focus` —— 当访问者聚焦于一个元素时，例如聚焦于一个 `<input>`。\n\n**Document 事件**：\n- `DOMContentLoaded` —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。\n\n**CSS 事件**：\n- `transitionend` —— 当一个 CSS 动画完成时。\n\n还有很多其他事件。我们将在下一章中详细介绍具体事件。\n\n## 事件处理程序\n\n为了对事件作出响应，我们可以分配一个 **处理程序（handler）**—— 一个在事件发生时运行的函数。\n\n处理程序是在发生用户行为（action）时运行 JavaScript 代码的一种方式。\n\n有几种分配处理程序的方法。让我们来看看，从最简单的开始。\n\n### HTML 特性\n\n处理程序可以设置在 HTML 中名为 `on<event>` 的特性（attribute）中。\n\n例如，要为一个 `input` 分配一个 `click` 处理程序，我们可以使用 `onclick`，像这样；\n\n```html run\n<input value=\"Click me\" *!*onclick=\"alert('Click!')\"*/!* type=\"button\">\n```\n\n在鼠标点击时，`onclick` 中的代码就会运行。\n\n请注意，在 `onclick` 中，我们使用单引号，因为特性本身使用的是双引号。如果我们忘记了代码是在特性中的，而使用了双引号，像这样：`onclick=\"alert(\"Click!\")\"`，那么它就无法正确运行。\n\nHTML 特性不是编写大量代码的好位置，因此我们最好创建一个 JavaScript 函数，然后在 HTML 特性中调用这个函数。\n\n在这里点击会运行 `countRabbits()`：\n\n```html autorun height=50\n<script>\n  function countRabbits() {\n    for(let i=1; i<=3; i++) {\n      alert(\"Rabbit number \" + i);\n    }\n  }\n</script>\n\n<input type=\"button\" *!*onclick=\"countRabbits()\"*/!* value=\"Count rabbits!\">\n```\n\n我们知道，HTML 特性名是大小写不敏感的，所以 `ONCLICK` 和 `onClick` 以及 `onCLICK` 都一样可以运行。但是特性通常是小写的：`onclick`。\n\n### DOM 属性\n\n我们可以使用 DOM 属性（property）`on<event>` 来分配处理程序。\n\n例如 `elem.onclick`：\n\n```html autorun\n<input id=\"elem\" type=\"button\" value=\"Click me\">\n<script>\n*!*\n  elem.onclick = function() {\n    alert('Thank you');\n  };\n*/!*\n</script>\n```\n\n如果一个处理程序是通过 HTML 特性（attribute）分配的，那么随后浏览器读取它，并从特性的内容创建一个新函数，并将这个函数写入 DOM 属性（property）。\n\n因此，这种方法实际上与前一种方法相同。\n\n这两段代码工作相同：\n\n1. 只有 HTML：\n\n    ```html autorun height=50\n    <input type=\"button\" *!*onclick=\"alert('Click!')\"*/!* value=\"Button\">\n    ```\n2. HTML + JS：\n\n    ```html autorun height=50\n    <input type=\"button\" id=\"button\" value=\"Button\">\n    <script>\n    *!*\n      button.onclick = function() {\n        alert('Click!');\n      };\n    */!*\n    </script>\n    ```\n\n在第一个例子中，`button.onclick` 是通过 HTML 特性（attribute）初始化的，而在第二个例子中是通过脚本初始化的。这是它们唯一的不同之处。\n\n**因为这里只有一个 `onclick` 属性，所以我们无法分配更多事件处理程序。**\n\n在下面这个示例中，我们使用 JavaScript 添加了一个处理程序，覆盖了现有的处理程序：\n\n```html run height=50 autorun\n<input type=\"button\" id=\"elem\" onclick=\"alert('Before')\" value=\"Click me\">\n<script>\n*!*\n  elem.onclick = function() { // 覆盖了现有的处理程序\n    alert('After'); // 只会显示此内容\n  };\n*/!*\n</script>\n```\n\n要移除一个处理程序 —— 赋值 `elem.onclick = null`。\n\n## 访问元素：this\n\n处理程序中的 `this` 的值是对应的元素。就是处理程序所在的那个元素。\n\n下面这行代码中的 `button` 使用 `this.innerHTML` 来显示它的内容：\n\n```html height=50 autorun\n<button onclick=\"alert(this.innerHTML)\">Click me</button>\n```\n\n## 可能出现的错误\n\n如果你刚开始写事件 —— 请注意一些细微之处。\n\n我们可以将一个现存的函数用作处理程序：\n\n```js\nfunction sayThanks() {\n  alert('Thanks!');\n}\n\nelem.onclick = sayThanks;\n```\n\n但要注意：函数应该是以 `sayThanks` 的形式进行赋值，而不是 `sayThanks()`。\n\n```js\n// 正确\nbutton.onclick = sayThanks;\n\n// 错误\nbutton.onclick = sayThanks();\n```\n\n如果我们添加了括号，那么 `sayThanks()` 就变成了一个函数调用。所以，最后一行代码实际上获得的是函数执行的 **结果**，即 `undefined`（因为这个函数没有返回值）。此代码不会工作。\n\n……但在标记（markup）中，我们确实需要括号：\n\n```html\n<input type=\"button\" id=\"button\" onclick=\"sayThanks()\">\n```\n\n这个区别很容易解释。当浏览器读取 HTML 特性（attribute）时，浏览器将会使用 **特性中的内容** 创建一个处理程序。\n\n所以，标记（markup）会生成下面这个属性：\n```js\nbutton.onclick = function() {\n*!*\n  sayThanks(); // <-- 特性（attribute）中的内容变到了这里\n*/!*\n};\n```\n\n**不要对处理程序使用 `setAttribute`。**\n\n这样的调用会失效：\n\n```js run no-beautify\n// 点击 <body> 将产生 error，\n// 因为特性总是字符串的，函数变成了一个字符串\ndocument.body.setAttribute('onclick', function() { alert(1) });\n```\n\n**DOM 属性是大小写敏感的。**\n\n将处理程序分配给 `elem.onclick`，而不是 `elem.ONCLICK`，因为 DOM 属性是大小写敏感的。\n\n## addEventListener\n\n上述分配处理程序的方式的根本问题是 —— 我们不能为一个事件分配多个处理程序。\n\n假设，在我们点击了一个按钮时，我们代码中的一部分想要高亮显示这个按钮，另一部分则想要显示一条消息。\n\n我们想为此事件分配两个处理程序。但是，新的 DOM 属性将覆盖现有的 DOM 属性：\n\n```js no-beautify\ninput.onclick = function() { alert(1); }\n// ...\ninput.onclick = function() { alert(2); } // 替换了前一个处理程序\n```\n\nWeb 标准的开发者很早就了解到了这一点，并提出了一种使用特殊方法 `addEventListener` 和 `removeEventListener` 来管理处理程序的替代方法。它们没有这样的问题。\n\n添加处理程序的语法：\n\n```js\nelement.addEventListener(event, handler[, options]);\n```\n\n`event`\n: 事件名，例如：`\"click\"`。\n\n`handler`\n: 处理程序。\n\n`options`\n: 具有以下属性的附加可选对象：\n    - `once`：如果为 `true`，那么会在被触发后自动删除监听器。\n    - `capture`：事件处理的阶段，我们稍后将在 <info:bubbling-and-capturing> 一章中介绍。由于历史原因，`options` 也可以是 `false/true`，它与 `{capture: false/true}` 相同。\n    - `passive`：如果为 `true`，那么处理程序将不会调用 `preventDefault()`，我们稍后将在 <info:default-browser-action> 一章中介绍。\n\n要移除处理程序，可以使用 `removeEventListener`：\n\n```js\nelement.removeEventListener(event, handler[, options]);\n```\n\n````warn header=\"移除需要相同的函数\"\n要移除处理程序，我们需要传入与分配的函数完全相同的函数。\n\n这不起作用：\n\n```js no-beautify\nelem.addEventListener( \"click\" , () => alert('Thanks!'));\n// ....\nelem.removeEventListener( \"click\", () => alert('Thanks!'));\n```\n\n处理程序不会被移除，因为 `removeEventListener` 获取了另一个函数 —— 使用相同的代码，但这并不起作用，因为它是一个不同的函数对象。\n\n下面是正确方法：\n\n```js\nfunction handler() {\n  alert( 'Thanks!' );\n}\n\ninput.addEventListener(\"click\", handler);\n// ....\ninput.removeEventListener(\"click\", handler);\n```\n\n请注意 —— 如果我们不将函数存储在一个变量中，那么我们就无法移除它。由 `addEventListener` 分配的处理程序将无法被“读回”。\n````\n\n多次调用 `addEventListener` 允许添加多个处理程序，如下所示：\n\n```html run no-beautify\n<input id=\"elem\" type=\"button\" value=\"Click me\"/>\n\n<script>\n  function handler1() {\n    alert('Thanks!');\n  };\n\n  function handler2() {\n    alert('Thanks again!');\n  }\n\n*!*\n  elem.onclick = () => alert(\"Hello\");\n  elem.addEventListener(\"click\", handler1); // Thanks!\n  elem.addEventListener(\"click\", handler2); // Thanks again!\n*/!*\n</script>\n```\n\n正如我们在上面这个例子中所看到的，我们可以 **同时** 使用 DOM 属性和 `addEventListener` 来设置处理程序。但通常我们只使用其中一种方式。\n\n````warn header=\"对于某些事件，只能通过 `addEventListener` 设置处理程序\"\n有些事件无法通过 DOM 属性进行分配。只能使用 `addEventListener`。\n\n例如，`DOMContentLoaded` 事件，该事件在文档加载完成并且 DOM 构建完成时触发。\n\n```js\n// 永远不会运行\ndocument.onDOMContentLoaded = function() {\n  alert(\"DOM built\");\n};\n```\n\n```js\n// 这种方式可以运行\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  alert(\"DOM built\");\n});\n```\n所以 `addEventListener` 更通用。虽然这样的事件是特例而不是规则。\n````\n\n## 事件对象\n\n为了正确处理事件，我们需要更深入地了解发生了什么。不仅仅是 \"click\" 或 \"keydown\"，还包括鼠标指针的坐标是什么？按下了哪个键？等等。\n\n当事件发生时，浏览器会创建一个 **`event` 对象**，将详细信息放入其中，并将其作为参数传递给处理程序。\n\n下面是一个从 `event` 对象获取鼠标指针的坐标的示例：\n\n```html run\n<input type=\"button\" value=\"Click me\" id=\"elem\">\n\n<script>\n  elem.onclick = function(*!*event*/!*) {\n    // 显示事件类型、元素和点击的坐标\n    alert(event.type + \" at \" + event.currentTarget);\n    alert(\"Coordinates: \" + event.clientX + \":\" + event.clientY);\n  };\n</script>\n```\n\n`event` 对象的一些属性：\n\n`event.type`\n: 事件类型，这里是 `\"click\"`。\n\n`event.currentTarget`\n: 处理事件的元素。这与 `this` 相同，除非处理程序是一个箭头函数，或者它的 `this` 被绑定到了其他东西上，之后我们就可以从 `event.currentTarget` 获取元素了。\n\n`event.clientX / event.clientY`\n: 指针事件（pointer event）的指针的窗口相对坐标。\n\n还有很多属性。其中很多都取决于事件类型：键盘事件具有一组属性，指针事件具有另一组属性，稍后我们将详细讨论不同事件，那时我们再对其进行详细研究。\n\n````smart header=\"`event` 对象在 HTML 处理程序中也可用\"\n如果我们在 HTML 中分配了一个处理程序，那么我们也可以使用 `event` 对象，像这样：\n\n```html autorun height=60\n<input type=\"button\" onclick=\"*!*alert(event.type)*/!*\" value=\"Event type\">\n```\n\n这是可能的，因为当浏览器读取特性（attribute）时，它会创建像这样的处理程序：`function(event) { alert(event.type) }`。也就是说：它的第一个参数是 `\"event\"`，而主体取自于该特性（attribute）。\n````\n\n\n## 对象处理程序：handleEvent\n\n我们不仅可以分配函数，还可以使用 `addEventListener` 将一个对象分配为事件处理程序。当事件发生时，就会调用该对象的 `handleEvent` 方法。\n\n例如：\n\n\n```html run\n<button id=\"elem\">Click me</button>\n\n<script>\n  let obj = {\n    handleEvent(event) {\n      alert(event.type + \" at \" + event.currentTarget);\n    }\n  };\n\n  elem.addEventListener('click', obj);\n</script>\n```\n\n正如我们所看到的，当 `addEventListener` 接收一个对象作为处理程序时，在事件发生时，它就会调用 `obj.handleEvent(event)` 来处理事件。\n\n我们也可以对此使用一个类：\n\n\n```html run\n<button id=\"elem\">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      switch(event.type) {\n        case 'mousedown':\n          elem.innerHTML = \"Mouse button pressed\";\n          break;\n        case 'mouseup':\n          elem.innerHTML += \"...and released.\";\n          break;\n      }\n    }\n  }\n\n*!*\n  let menu = new Menu();\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n*/!*\n</script>\n```\n\n这里，同一个对象处理两个事件。请注意，我们需要使用 `addEventListener` 来显式设置事件，以指明要监听的事件。这里的 `menu` 对象只监听 `mousedown` 和 `mouseup`，而没有任何其他类型的事件。\n\n`handleEvent` 方法不必通过自身完成所有的工作。它可以调用其他特定于事件的方法，例如：\n\n```html run\n<button id=\"elem\">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      // mousedown -> onMousedown\n      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);\n      this[method](event);\n    }\n\n    onMousedown() {\n      elem.innerHTML = \"Mouse button pressed\";\n    }\n\n    onMouseup() {\n      elem.innerHTML += \"...and released.\";\n    }\n  }\n\n  let menu = new Menu();\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n</script>\n```\n\n现在事件处理程序已经明确地分离了出来，这样更容易进行代码编写和后续维护。\n\n## 总结\n\n这里有 3 种分配事件处理程序的方式：\n\n1. HTML 特性（attribute）：`onclick=\"...\"`。\n2. DOM 属性（property）：`elem.onclick = function`。\n3. 方法（method）：`elem.addEventListener(event, handler[, phase])` 用于添加，`removeEventListener` 用于移除。\n\nHTML 特性很少使用，因为 HTML 标签中的 JavaScript 看起来有些奇怪且陌生。而且也不能在里面写太多代码。\n\nDOM 属性用起来还可以，但我们无法为特定事件分配多个处理程序。在许多场景中，这种限制并不严重。\n\n最后一种方式是最灵活的，但也是写起来最长的。有少数事件只能使用这种方式。例如 `transtionend` 和 `DOMContentLoaded`（上文中讲到了）。`addEventListener` 也支持对象作为事件处理程序。在这种情况下，如果发生事件，则会调用 `handleEvent` 方法。\n\n无论你如何分类处理程序 —— 它都会将获得一个事件对象作为第一个参数。该对象包含有关所发生事件的详细信息。\n\n在下一章中，我们将学习更多关于一般事件和不同类型事件的内容。",
        "libs": [],
        "children": [
          "hide-other",
          "hide-self-onclick",
          "which-handlers-run",
          "move-ball-field",
          "sliding-menu",
          "hide-message",
          "carousel"
        ],
        "headHtml": "<style>\n/*\n.d0 { text-align:center;margin:auto; }\n.d1 p { margin: 0 }\n.d1 {\nmargin:2em;\nbackground-color:green;\nwidth:13em;\nheight:13em;\ntext-align:center;\n}\n.d1 .number {\n  line-height: 2em;\n}\n.d2 {\ntext-align:center;\nmargin:auto;\nbackground-color:blue;\nwidth:9em;\nheight:9em;\n}\n.d1 .d2 ,number {\n  line-height: 2em;\n}\n.d3 {\ntext-align:center;\nmargin:auto;\nbackground-color:red;\nwidth:5em;\nheight:5em;\n}\n.d1 .d2 .d3 .number {\n  line-height: 5em;\n}\n.d1 .d2 .d2a {\n  color:white;\n  line-height: 2em;\n}\n*/\n</style>\n<script>\n/*\nfunction highlightMe(elem) {\n    elem.style.backgroundColor='yellow'\n    alert(elem.className)\n    elem.style.backgroundColor = ''\n}\n\nfunction highlightMe2(e) {\n    highlightMe(e.currentTarget);\n}\n*/\n</script>\n",
        "parent": "events",
        "updatedAt": 1657705346
      }
    },
    "hide-other": {
      "type": "Task",
      "value": {
        "title": "点击隐藏",
        "slug": "hide-other",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/01-hide-other",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n为 `button` 添加 JavaScript 代码，使得 `<div id=\"text\">` 在我们点击该按钮时消失。\n\n示例：\n\n[iframe border=1 src=\"solution\" height=80]",
        "solution": "",
        "parent": "introduction-browser-events",
        "version": 1
      }
    },
    "hide-self-onclick": {
      "type": "Task",
      "value": {
        "title": "隐藏自己",
        "slug": "hide-self-onclick",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/02-hide-self-onclick",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个按钮，在被点击时，隐藏自己。\n\n```online\n就像这样：\n<input type=\"button\" onclick=\"this.hidden=true\" value=\"Click to hide\">\n```",
        "solution": "可以在处理程序中使用 `this` 来引用“元素自身”：\n\n```html run height=50\n<input type=\"button\" onclick=\"this.hidden=true\" value=\"Click to hide\">\n```",
        "parent": "introduction-browser-events",
        "version": 1
      }
    },
    "which-handlers-run": {
      "type": "Task",
      "value": {
        "title": "哪个处理程序会运行？",
        "slug": "which-handlers-run",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/03-which-handlers-run",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n在变量中有一个按钮。它上面没有处理程序。\n\n执行以下代码之后，哪些处理程序会在按钮被点击时运行？会显示哪些 alert？\n\n```js no-beautify\nbutton.addEventListener(\"click\", () => alert(\"1\"));\n\nbutton.removeEventListener(\"click\", () => alert(\"1\"));\n\nbutton.onclick = () => alert(2);\n```",
        "solution": "答案：`1` 和 `2`。\n\n第一个处理程序会触发，因为它没有被 `removeEventListener` 移除。要移除处理程序，我们需要传递正确的所分配的函数。在代码中，传递了一个新的函数，该函数看起来相同，但仍然是另一个函数。\n\n要移除一个函数对象，我们需要存储对它的引用，像这样：\n\n```js\nfunction handler() {\n  alert(1);\n}\n\nbutton.addEventListener(\"click\", handler);\nbutton.removeEventListener(\"click\", handler);\n```\n\n无论 `addEventListener` 怎样，`button.onclick` 处理程序都会触发。",
        "parent": "introduction-browser-events",
        "version": 1
      }
    },
    "move-ball-field": {
      "type": "Task",
      "value": {
        "title": "让球在球场中移动",
        "slug": "move-ball-field",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/04-move-ball-field",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n点击球场中任意一点，让球在球场中移动。就像这样：\n\n[iframe src=\"solution\" height=\"260\" link]\n\n要求：\n\n- 球的中心应该恰好在点击时鼠标指针位置的下方（如果在球不越过球场边缘的情况下，能实现的话）。\n- 最好添加一些 CSS 动画。\n- 球不能越过场地边界。\n- 页面滚动时，布局不能被破坏。\n\n注意：\n\n- 代码还应该适用于不同大小的球和球场，而不应该绑定到任何固定值。\n- 使用 `event.clientX/event.clientY` 属性来获取点击坐标。",
        "solution": "首先，我们需要选择一种定位球的方法。\n\n我们不能使用 `position:fixed`，因为滚动页面会造成球被移出球场。\n\n所以我们应该使用 `position:absolute`，并且要使定位真正可靠，应该使 `field` 自身具有 `position:absolute`。\n\n然后，球将相对于球场定位：\n\n```css\n#field {\n  width: 200px;\n  height: 150px;\n  position: relative;\n}\n\n#ball {\n  position: absolute;\n  left: 0; /* 相对于最接近的祖先（field） */\n  top: 0;\n  transition: 1s all; /* left/top 的 CSS 动画，使球飞起来 */\n}\n```\n\n接下来我们需要指定正确的 `ball.style.left/top`。它们现在包含相对于球场的坐标。\n\n这是示意图：\n\n![](move-ball-coords.svg)\n\n我们有 `event.clientX/clientY` —— 点击位置的窗口相对坐标。\n\n要获取点击位置的球场相对坐标 `left`，我们可以减去球场左边缘和边框的宽度：\n\n```js\nlet left = event.clientX - fieldCoords.left - field.clientLeft;\n```\n\n通常情况下，`ball.style.left` 表示“元素的左边缘”（球）。因此，如果我们将其指定为 `left`，那么球的边缘而非球的中心将位于鼠标光标下方。\n\n我们需要将球向左移动球宽度的一半，向上移动球高度的一半，以使其居中。\n\n所以，最后的 `left` 将是：\n\n```js\nlet left = event.clientX - fieldCoords.left - field.clientLeft - ball.offsetWidth/2;\n```\n\n使用相同的逻辑来计算垂直坐标。\n\n请注意，球的宽度/高度必须在我们访问 `ball.offsetWidth` 时就已知。应该在 HTML 或 CSS 中指定。",
        "parent": "introduction-browser-events",
        "version": 1
      }
    },
    "sliding-menu": {
      "type": "Task",
      "value": {
        "title": "创建滑动菜单",
        "slug": "sliding-menu",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/05-sliding-menu",
        "weight": 5,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个在点击时打开/折叠的菜单：\n\n[iframe border=1 height=100 src=\"solution\"]\n\nP.S. 源文档的 HTML/CSS 将被修改。",
        "solution": "# HTML/CSS\n\n首先，让我们创建 HTML/CSS。\n\n菜单是页面上的一个独立图形组件，所以最好把它放入一个单独的 DOM 元素中。\n\n菜单项的列表可以被作为列表 `ul/li` 列出。\n\n下面是示例结构：\n\n```html\n<div class=\"menu\">\n  <span class=\"title\">Sweeties (click me)!</span>\n  <ul>\n    <li>Cake</li>\n    <li>Donut</li>\n    <li>Honey</li>\n  </ul>\n</div>\n```\n\n我们对标题使用 `<span>`，因为 `<div>` 有一个隐式的 `display:block`，它会占据 100% 的水平宽度。\n\n就像这样：\n\n```html autorun height=50\n<div style=\"border: solid red 1px\" onclick=\"alert(1)\">Sweeties (click me)!</div>\n```\n\n因此，如果我们在它上面设置 `onclick`，那么它也会捕获文本右侧的点击。\n\n……由于 `<span>` 有一个隐式的 `display: inline`，它恰好占据了足以容纳所有文本的位置：\n\n```html autorun height=50\n<span style=\"border: solid red 1px\" onclick=\"alert(1)\">Sweeties (click me)!</span>\n```\n\n# 切换菜单\n\n切换菜单应更改箭头并显示/隐藏菜单列表。\n\n所有这些更改都可以通过 CSS 完美处理。在 JavaScript 中，我们应该通过添加/移除 `.open` 类来标记菜单的当前状态。\n\n没有它，菜单就会被关闭：\n\n```css\n.menu ul {\n  margin: 0;\n  list-style: none;\n  padding-left: 20px;\n  display: none;\n}\n\n.menu .title::before {\n  content: '▶ ';\n  font-size: 80%;\n  color: green;\n}\n```\n\n……有 `.open` 后，箭头会改变，列表会出现：\n\n```css\n.menu.open .title::before {\n  content: '▼ ';\n}\n\n.menu.open ul {\n  display: block;\n}\n```",
        "parent": "introduction-browser-events",
        "version": 1
      }
    },
    "hide-message": {
      "type": "Task",
      "value": {
        "title": "添加关闭按钮",
        "slug": "hide-message",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/06-hide-message",
        "weight": 6,
        "libs": [],
        "importance": 5,
        "content": "\n\n有一个消息列表。\n\n使用 JavaScript 在每条消息的右上角添加一个关闭按钮。\n\n结果应该如下所示：\n\n[iframe src=\"solution\" height=450]",
        "solution": "我们可以使用 `position:absolute`（并使窗格 `position:relative`）或者 `float:right` 来添加按钮。`float:right` 的好处是按钮永远都不会与文本重叠，但是 `position:absolute` 则提供了更大的自由度。选择权在你自己手上。\n\n然后，对于每个窗格（pane），代码可以像这样：\n```js\npane.insertAdjacentHTML(\"afterbegin\", '<button class=\"remove-button\">[x]</button>');\n```\n\n然后 `<button>` 变成了 `pane.firstChild`，因此我们可以像这样为它添加处理程序：\n\n```js\npane.firstChild.onclick = () => pane.remove();\n```",
        "parent": "introduction-browser-events",
        "version": 1
      }
    },
    "carousel": {
      "type": "Task",
      "value": {
        "title": "轮播图",
        "slug": "carousel",
        "githubPath": "/2-ui/2-events/01-introduction-browser-events/07-carousel",
        "weight": 7,
        "libs": [],
        "importance": 4,
        "content": "\n\n创建一个“轮播图（carousel）” —— 一条可以通过点击箭头来滚动图像的图像带。\n\n[iframe height=200 src=\"solution\"]\n\n之后，我们可以为其添加更多功能：无限滚动，动态加载等。\n\nP.S. 对于这个任务，HTML/CSS 结构实际上占解决方案的 90%。",
        "solution": "图像带可以表示为图像 `<img>` 的 `ul/li` 列表。\n\n通常，这样的图像带是很宽的，但我们在其周围放置了一个固定大小的 `<div>` 来“剪切”它，因此，只有图像带的一部分是可见的：\n\n![](carousel1.svg)\n\n为了使列表水平显示，我们需要为 `<li>` 应用正确的 CSS 属性，例如 `display: inline-block`。\n\n对于 `<img>` 来说，我们应该调整 `display`，因为默认情况下它是 `inline`。在 `inline` 元素下方为 \"letter tails\" 保留了额外的空间，因此，我们可以使用 `display:block` 来将其删除。\n\n我们可以移动 `<ul>` 来进行滚动。有很多方法可以实现这一点，例如，通过修改 `margin-left` 或者使用 `transform: translateX()`（性能更好）：\n\n![](carousel2.svg)\n\n外部的 `<div>` 具有固定的宽度，因此，会裁剪掉“多余”的图像。\n\n整个轮播图是页面上的一个独立的“图形组件”，因此我们最好将其包装到一个单独的 `<div class=\"carousel\">` 中，并在其中对其进行样式设置。",
        "parent": "introduction-browser-events",
        "version": 1
      }
    },
    "bubbling-and-capturing": {
      "type": "Article",
      "value": {
        "title": "冒泡和捕获",
        "slug": "bubbling-and-capturing",
        "githubPath": "/2-ui/2-events/02-bubbling-and-capturing",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n让我们从一个示例开始。\n\n处理程序（handler）被分配给了 `<div>`，但是如果你点击任何嵌套的标签（例如 `<em>` 或 `<code>`），该处理程序也会运行：\n\n```html autorun height=60\n<div onclick=\"alert('The handler!')\">\n  <em>If you click on <code>EM</code>, the handler on <code>DIV</code> runs.</em>\n</div>\n```\n\n这是不是有点奇怪？如果实际上点击的是 `<em>`，为什么在 `<div>` 上的处理程序会运行？\n\n## 冒泡\n\n冒泡（bubbling）原理很简单。\n\n**当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。**\n\n假设我们有 3 层嵌套 `FORM > DIV > P`，它们各自拥有一个处理程序：\n\n```html run autorun\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form onclick=\"alert('form')\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n```\n\n点击内部的 `<p>` 会首先运行 `onclick`：\n1. 在该 `<p>` 上的。\n2. 然后是外部 `<div>` 上的。\n3. 然后是外部 `<form>` 上的。\n4. 以此类推，直到最后的 `document` 对象。\n\n![](event-order-bubbling.svg)\n\n因此，如果我们点击 `<p>`，那么我们将看到 3 个 alert：`p` -> `div` -> `form`。\n\n这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，就像在水里的气泡一样。\n\n```warn header=\"**几乎**所有事件都会冒泡。\"\n这句话中的关键词是“几乎”。\n\n例如，`focus` 事件不会冒泡。同样，我们以后还会遇到其他例子。但这仍然是例外，而不是规则，大多数事件的确都是冒泡的。\n```\n\n## event.target\n\n父元素上的处理程序始终可以获取事件实际发生位置的详细信息。\n\n**引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 `event.target` 访问。**\n\n注意与 `this`（=`event.currentTarget`）之间的区别：\n\n- `event.target` —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。\n- `this` —— 是“当前”元素，其中有一个当前正在运行的处理程序。\n\n例如，如果我们有一个处理程序 `form.onclick`，那么它可以“捕获”表单内的所有点击。无论点击发生在哪里，它都会冒泡到 `<form>` 并运行处理程序。\n\n在 `form.onclick` 处理程序中：\n\n- `this`（=`event.currentTarget`）是 `<form>` 元素，因为处理程序在它上面运行。\n- `event.target` 是表单中实际被点击的元素。\n\n一探究竟：\n\n[codetabs height=220 src=\"bubble-target\"]\n\n`event.target` 可能会等于 `this` —— 当点击事件发生在 `<form>` 元素上时，就会发生这种情况。\n\n## 停止冒泡\n\n冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 `<html>`，然后再到 `document` 对象，有些事件甚至会到达 `window`，它们会调用路径上所有的处理程序。\n\n但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。\n\n用于停止冒泡的方法是 `event.stopPropagation()`。\n\n例如，如果你点击 `<button>`，这里的 `body.onclick` 不会工作：\n\n```html run autorun height=60\n<body onclick=\"alert(`the bubbling doesn't reach here`)\">\n  <button onclick=\"event.stopPropagation()\">Click me</button>\n</body>\n```\n\n```smart header=\"event.stopImmediatePropagation()\"\n如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行。\n\n换句话说，`event.stopPropagation()` 停止向上移动，但是当前元素上的其他处理程序都会继续运行。\n\n有一个 `event.stopImmediatePropagation()` 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行。\n```\n\n```warn header=\"不要在没有需要的情况下停止冒泡！\"\n冒泡很方便。不要在没有真实需求时阻止它：除非是显而易见的，并且在架构上经过深思熟虑的。\n\n有时 `event.stopPropagation()` 会产生隐藏的陷阱，以后可能会成为问题。\n\n例如：\n\n1. 我们创建了一个嵌套菜单，每个子菜单各自处理对自己的元素的点击事件，并调用 `stopPropagation`，以便不会触发外部菜单。\n2. 之后，我们决定捕获在整个窗口上的点击，以追踪用户的行为（用户点击的位置）。有些分析系统会这样做。通常，代码会使用 `document.addEventListener('click'…)` 来捕获所有的点击。\n3. 我们的分析不适用于被 `stopPropagation` 所阻止点击的区域。太伤心了，我们有一个“死区”。\n\n通常，没有真正的必要去阻止冒泡。一项看似需要阻止冒泡的任务，可以通过其他方法解决。其中之一就是使用自定义事件，稍后我们会介绍它们此外，我们还可以将我们的数据写入一个处理程序中的 `event` 对象，并在另一个处理程序中读取该数据，这样我们就可以向父处理程序传递有关下层处理程序的信息。\n```\n\n\n## 捕获\n\n事件处理的另一个阶段被称为“捕获（capturing）”。它很少被用在实际开发中，但有时是有用的。\n\n[DOM 事件](http://www.w3.org/TR/DOM-Level-3-Events/)标准描述了事件传播的 3 个阶段：\n\n1. 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。\n2. 目标阶段（Target phase）—— 事件到达目标元素。\n3. 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。\n\n下面是在表格中点击 `<td>` 的图片，摘自规范：\n\n![](eventflow.svg)\n\n也就是说：点击 `<td>`，事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序。\n\n**之前，我们只讨论了冒泡，因为捕获阶段很少被使用。通常我们看不到它。**\n\n使用 `on<event>` 属性或使用 HTML 特性（attribute）或使用两个参数的 `addEventListener(event, handler)` 添加的处理程序，对捕获一无所知，它们仅在第二阶段和第三阶段运行。\n\n为了在捕获阶段捕获事件，我们需要将处理程序的 `capture` 选项设置为 `true`：\n\n```js\nelem.addEventListener(..., {capture: true})\n// 或者，用 {capture: true} 的别名 \"true\"\nelem.addEventListener(..., true)\n```\n\n`capture` 选项有两个可能的值：\n\n- 如果为 `false`（默认值），则在冒泡阶段设置处理程序。\n- 如果为 `true`，则在捕获阶段设置处理程序。\n\n\n请注意，虽然形式上有 3 个阶段，但第 2 阶段（“目标阶段”：事件到达元素）没有被单独处理：捕获阶段和冒泡阶段的处理程序都在该阶段被触发。\n\n让我们来看看捕获和冒泡：\n\n```html run autorun height=140 edit\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form>FORM\n  <div>DIV\n    <p>P</p>\n  </div>\n</form>\n\n<script>\n  for(let elem of document.querySelectorAll('*')) {\n    elem.addEventListener(\"click\", e => alert(`Capturing: ${elem.tagName}`), true);\n    elem.addEventListener(\"click\", e => alert(`Bubbling: ${elem.tagName}`));\n  }\n</script>\n```\n\n上面这段代码为文档中的 **每个** 元素都设置了点击处理程序，以查看哪些元素上的点击事件处理程序生效了。\n\n如果你点击了 `<p>`，那么顺序是：\n\n1. `HTML` -> `BODY` -> `FORM` -> `DIV`（捕获阶段第一个监听器）：\n2. `P`（目标阶段，触发两次，因为我们设置了两个监听器：捕获和冒泡）\n3. `DIV` -> `FORM` -> `BODY` -> `HTML`（冒泡阶段，第二个监听器）。\n\n有一个属性 `event.eventPhase`，它告诉我们捕获事件的阶段数。但它很少被使用，因为我们通常是从处理程序中了解到它。\n\n```smart header=\"要移除处理程序，`removeEventListener` 需要同一阶段\"\n如果我们 `addEventListener(..., true)`，那么我们应该在 `removeEventListener(..., true)` 中提到同一阶段，以正确删除处理程序。\n```\n\n````smart header=\"同一元素的同一阶段的监听器按其设置顺序运行\"\n如果我们在同一阶段有多个事件处理程序，并通过 `addEventListener` 分配给了相同的元素，则它们的运行顺序与创建顺序相同：\n\n```js\nelem.addEventListener(\"click\", e => alert(1)); // 会先被触发\nelem.addEventListener(\"click\", e => alert(2));\n```\n````\n\n\n## 总结\n\n当一个事件发生时 —— 发生该事件的嵌套最深的元素被标记为“目标元素”（`event.target`）。\n\n- 然后，事件从文档根节点向下移动到 `event.target`，并在途中调用分配了 `addEventListener(..., true)` 的处理程序（`true` 是 `{capture: true}` 的一个简写形式）。\n- 然后，在目标元素自身上调用处理程序。\n- 然后，事件从 `event.target` 冒泡到根，调用使用 `on<event>`、HTML 特性（attribute）和没有第三个参数的，或者第三个参数为 `false/{capture:false}` 的 `addEventListener` 分配的处理程序。\n\n每个处理程序都可以访问 `event` 对象的属性：\n\n- `event.target` —— 引发事件的层级最深的元素。\n- `event.currentTarget`（=`this`）—— 处理事件的当前元素（具有处理程序的元素）\n- `event.eventPhase` —— 当前阶段（capturing=1，target=2，bubbling=3）。\n\n任何事件处理程序都可以通过调用 `event.stopPropagation()` 来停止事件，但不建议这样做，因为我们不确定是否确实不需要冒泡上来的事件，也许是用于完全不同的事情。\n\n捕获阶段很少使用，通常我们会在冒泡时处理事件。这背后有一个逻辑。\n\n在现实世界中，当事故发生时，当地警方会首先做出反应。他们最了解发生这件事的地方。然后，如果需要，上级主管部门再进行处理。\n\n事件处理程序也是如此。在特定元素上设置处理程序的代码，了解有关该元素最详尽的信息。特定于 `<td>` 的处理程序可能恰好适合于该 `<td>`，这个处理程序知道关于该元素的所有信息。所以该处理程序应该首先获得机会。然后，它的直接父元素也了解相关上下文，但了解的内容会少一些，以此类推，直到处理一般性概念并运行最后一个处理程序的最顶部的元素为止。\n\n冒泡和捕获为“事件委托”奠定了基础 —— 一种非常强大的事件处理模式，我们将在下一章中进行研究。",
        "libs": [],
        "children": [],
        "parent": "events",
        "updatedAt": 1658984692
      }
    },
    "event-delegation": {
      "type": "Article",
      "value": {
        "title": "事件委托",
        "slug": "event-delegation",
        "githubPath": "/2-ui/2-events/03-event-delegation",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n捕获和冒泡允许我们实现最强大的事件处理模式之一，即 **事件委托** 模式。\n\n这个想法是，如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。\n\n在处理程序中，我们获取 `event.target` 以查看事件实际发生的位置并进行处理。\n\n让我们看一个示例 —— 反映中国古代哲学的 [八卦图](http://en.wikipedia.org/wiki/Ba_gua)。\n\n如下所示：\n\n[iframe height=350 src=\"bagua\" edit link]\n\n其 HTML 如下所示：\n\n```html\n<table>\n  <tr>\n    <th colspan=\"3\"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>\n  </tr>\n  <tr>\n    <td class=\"nw\"><strong>Northwest</strong><br>Metal<br>Silver<br>Elders</td>\n    <td class=\"n\">...</td>\n    <td class=\"ne\">...</td>\n  </tr>\n  <tr>...2 more lines of this kind...</tr>\n  <tr>...2 more lines of this kind...</tr>\n</table>\n```\n\n该表格有 9 个单元格（cell），但可以有 99 个或 9999 个单元格，这都不重要。\n\n**我们的任务是在点击时高亮显示被点击的单元格 `<td>`。**\n\n与其为每个 `<td>`（可能有很多）分配一个 `onclick` 处理程序 —— 我们可以在 `<table>` 元素上设置一个“捕获所有”的处理程序。\n\n它将使用 `event.target` 来获取点击的元素并高亮显示它。\n\n代码如下：\n\n```js\nlet selectedTd;\n\n*!*\ntable.onclick = function(event) {\n  let target = event.target; // 在哪里点击的？\n\n  if (target.tagName != 'TD') return; // 不在 TD 上？那么我们就不会在意\n\n  highlight(target); // 高亮显示它\n};\n*/!*\n\nfunction highlight(td) {\n  if (selectedTd) { // 移除现有的高亮显示，如果有的话\n    selectedTd.classList.remove('highlight');\n  }\n  selectedTd = td;\n  selectedTd.classList.add('highlight'); // 高亮显示新的 td\n}\n```\n\n此代码不会关心在表格中有多少个单元格。我们可以随时动态添加/移除 `<td>`，高亮显示仍然有效。\n\n尽管如此，但还是存在缺陷。\n\n点击可能不是发生在 `<td>` 上，而是发生在其内部。\n\n在我们的例子中，如果我们看一下 HTML 内部，我们可以看到 `<td>` 内还有嵌套的标签，例如 `<strong>`：\n\n```html\n<td>\n*!*\n  <strong>Northwest</strong>\n*/!*\n  ...\n</td>\n```\n\n自然地，如果在该 `<strong>` 上点击，那么它将成为 `event.target` 的值。\n\n![](bagua-bubble.svg)\n\n在处理程序 `table.onclick` 中，我们应该接受这样的 `event.target`，并确定该点击是否在 `<td>` 内。\n\n下面是改进后的代码：\n\n```js\ntable.onclick = function(event) {\n  let td = event.target.closest('td'); // (1)\n\n  if (!td) return; // (2)\n\n  if (!table.contains(td)) return; // (3)\n\n  highlight(td); // (4)\n};\n```\n\n解释：\n1. `elem.closest(selector)` 方法返回与 `selector` 匹配的最近的祖先。在我们的例子中，我们从源元素开始向上寻找 `<td>`。\n2. 如果 `event.target` 不在任何 `<td>` 中，那么调用将立即返回，因为这里没有什么事儿可做。\n3. 对于嵌套的表格，`event.target` 可能是一个 `<td>`，但位于当前表格之外。因此我们需要检查它是否是 **我们的表格中的** `<td>`。\n4. 如果是的话，就高亮显示它。\n\n最终，我们得到了一个快速、高效的用于高亮显示的代码，该代码与表格中的 `<td>` 的数量无关。\n\n## 委托示例：标记中的行为\n\n事件委托还有其他用途。（译注：本节标题中的“标记中的行为”即 action in markup）\n\n例如，我们想要编写一个有“保存”、“加载”和“搜索”等按钮的菜单。并且，这里有一个具有 `save`、`load` 和 `search` 等方法的对象。如何匹配它们？\n\n第一个想法可能是为每个按钮分配一个单独的处理程序。但是有一个更优雅的解决方案。我们可以为整个菜单添加一个处理程序，并为具有方法调用的按钮添加 `data-action` 特性（attribute）：\n\n```html\n<button *!*data-action=\"save\"*/!*>Click to Save</button>\n```\n\n处理程序读取特性（attribute）并执行该方法。工作示例如下：\n\n```html autorun height=60 run untrusted\n<div id=\"menu\">\n  <button data-action=\"save\">Save</button>\n  <button data-action=\"load\">Load</button>\n  <button data-action=\"search\">Search</button>\n</div>\n\n<script>\n  class Menu {\n    constructor(elem) {\n      this._elem = elem;\n      elem.onclick = this.onClick.bind(this); // (*)\n    }\n\n    save() {\n      alert('saving');\n    }\n\n    load() {\n      alert('loading');\n    }\n\n    search() {\n      alert('searching');\n    }\n\n    onClick(event) {\n*!*\n      let action = event.target.dataset.action;\n      if (action) {\n        this[action]();\n      }\n*/!*\n    };\n  }\n\n  new Menu(menu);\n</script>\n```\n\n请注意，`this.onClick` 在 `(*)` 行中被绑定到了 `this`。这很重要，因为否则内部的 `this` 将引用 DOM 元素（`elem`），而不是 `Menu` 对象，那样的话，`this[action]` 将不是我们所需要的。\n\n那么，这里的委托给我们带来了什么好处？\n\n```compare\n+ 我们不需要编写代码来为每个按钮分配一个处理程序。只需要创建一个方法并将其放入标记（markup）中即可。\n+ HTML 结构非常灵活，我们可以随时添加/移除按钮。\n```\n\n我们也可以使用 `.action-save`，`.action-load` 类，但 `data-action` 特性（attribute）在语义上更好。我们也可以在 CSS 规则中使用它。\n\n## “行为”模式\n\n我们还可以使用事件委托将“行为（behavior）”以 **声明方式** 添加到具有特殊特性（attribute）和类的元素中。\n\n行为模式分为两个部分：\n1. 我们将自定义特性添加到描述其行为的元素。\n2. 用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上 —— 则执行行为（action）。\n\n### 行为：计数器\n\n例如，这里的特性 `data-counter` 给按钮添加了一个“点击增加”的行为。\n\n```html run autorun height=60\nCounter: <input type=\"button\" value=\"1\" data-counter>\nOne more counter: <input type=\"button\" value=\"2\" data-counter>\n\n<script>\n  document.addEventListener('click', function(event) {\n\n    if (event.target.dataset.counter != undefined) { // 如果这个特性存在...\n      event.target.value++;\n    }\n\n  });\n</script>\n```\n\n如果我们点击按钮 —— 它的值就会增加。但不仅仅是按钮，一般的方法在这里也很重要。\n\n我们可以根据需要使用 `data-counter` 特性，多少都可以。我们可以随时向 HTML 添加新的特性。使用事件委托，我们属于对 HTML 进行了“扩展”，添加了描述新行为的特性。\n\n```warn header=\"对于文档级的处理程序 —— 始终使用的是 `addEventListener`\"\n当我们将事件处理程序分配给 `document` 对象时，我们应该始终使用 `addEventListener`，而不是 `document.on<event>`，因为后者会引起冲突：新的处理程序会覆盖旧的处理程序。\n\n对于实际项目来说。在 `document` 上有许多由代码的不同部分设置的处理程序，这是很正常的。\n```\n\n### 行为：切换器\n\n再举一个例子。点击一个具有 `data-toggle-id` 特性的元素将显示/隐藏具有给定 `id` 的元素：\n\n```html autorun run height=60\n<button *!*data-toggle-id=\"subscribe-mail\"*/!*>\n  Show the subscription form\n</button>\n\n<form id=\"subscribe-mail\" hidden>\n  Your mail: <input type=\"email\">\n</form>\n\n<script>\n*!*\n  document.addEventListener('click', function(event) {\n    let id = event.target.dataset.toggleId;\n    if (!id) return;\n\n    let elem = document.getElementById(id);\n\n    elem.hidden = !elem.hidden;\n  });\n*/!*\n</script>\n```\n\n让我们再次注意我们做了什么。现在，要向元素添加切换功能 —— 无需了解 JavaScript，只需要使用特性 `data-toggle-id` 即可。\n\n这可能变得非常方便 —— 无需为每个这样的元素编写 JavaScript。只需要使用行为。文档级处理程序使其适用于页面的任意元素。\n\n我们也可以组合单个元素上的多个行为。\n\n“行为”模式可以替代 JavaScript 的小片段。\n\n## 总结\n\n事件委托真的很酷！这是 DOM 事件最有用的模式之一。\n\n它通常用于为许多相似的元素添加相同的处理，但不仅限于此。\n\n算法：\n\n1. 在容器（container）上放一个处理程序。\n2. 在处理程序中 —— 检查源元素 `event.target`。\n3. 如果事件发生在我们感兴趣的元素内，那么处理该事件。\n\n好处：\n\n```compare\n+ 简化初始化并节省内存：无需添加许多处理程序。\n+ 更少的代码：添加或移除元素时，无需添加/移除处理程序。\n+ DOM 修改 ：我们可以使用 `innerHTML` 等，来批量添加/移除元素。\n```\n\n事件委托也有其局限性：\n\n```compare\n- 首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用 `event.stopPropagation()`。\n- 其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。\n```",
        "libs": [],
        "children": [
          "hide-message-delegate",
          "sliding-tree",
          "sortable-table",
          "behavior-tooltip"
        ],
        "parent": "events",
        "updatedAt": 1650184258
      }
    },
    "hide-message-delegate": {
      "type": "Task",
      "value": {
        "title": "使用委托隐藏消息",
        "slug": "hide-message-delegate",
        "githubPath": "/2-ui/2-events/03-event-delegation/1-hide-message-delegate",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n有一个带有移除按钮 `[x]` 的消息列表。让按钮可以工作。\n\n就像这样：\n\n[iframe src=\"solution\" height=420]\n\nP.S. 在容器上应该只有一个事件监听器，请使用事件委托。",
        "solution": "",
        "parent": "event-delegation",
        "version": 1
      }
    },
    "sliding-tree": {
      "type": "Task",
      "value": {
        "title": "树形菜单",
        "slug": "sliding-tree",
        "githubPath": "/2-ui/2-events/03-event-delegation/2-sliding-tree",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个点击可以显示/隐藏子节点的树形菜单：\n\n[iframe border=1 src=\"solution\"]\n\n要求：\n\n- 只能有一个事件处理程序（使用委托）。\n- 对节点标题以外（在空白处）的点击不会做任何处理。",
        "solution": "解决方案分为两个部分。\n\n1. 将每个树节点的标题都包装到 `<span>` 中。然后我们可以在 `:hover` 上使用 CSS 样式，并精确地处理文本上的点击事件，因为 `<span>` 的宽度恰好是文本的宽度（与没有宽度不同）。\n2. 为 `tree` 的根节点设置一个处理程序，来处理 `<span>` 标题上的点击事件。",
        "parent": "event-delegation",
        "version": 1
      }
    },
    "sortable-table": {
      "type": "Task",
      "value": {
        "title": "可排序的表格",
        "slug": "sortable-table",
        "githubPath": "/2-ui/2-events/03-event-delegation/3-sortable-table",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\n\n使表格可排序：点击 `<th>` 元素，应按对应的列对表格进行排序。\n\n每个 `<th>` 的特性（attribute）中都有类型，如下所示：\n\n```html\n<table id=\"grid\">\n  <thead>\n    <tr>\n*!*\n      <th data-type=\"number\">Age</th>\n      <th data-type=\"string\">Name</th>\n*/!*\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>5</td>\n      <td>John</td>\n    </tr>\n    <tr>\n      <td>10</td>\n      <td>Ann</td>\n    </tr>\n    ...\n  </tbody>\n</table>\n```\n\n在上面的示例中，第一列为数字，第二列为字符串。排序函数应根据类型进行排序。\n\n应该只支持 `\"string\"` 和 `\"number\"` 类型。\n\n运行示例：\n\n[iframe border=1 src=\"solution\" height=190]\n\nP.S. 表格可以更大，有任意数量的行和列。",
        "solution": "",
        "parent": "event-delegation",
        "version": 1
      }
    },
    "behavior-tooltip": {
      "type": "Task",
      "value": {
        "title": "工具提示行为",
        "slug": "behavior-tooltip",
        "githubPath": "/2-ui/2-events/03-event-delegation/4-behavior-tooltip",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写工具提示（tooltip）行为的 JavaScript 代码。\n\n当鼠标在带有 `data-tooltip` 的元素的上方时，工具提示应显示在其上方，当鼠标移开时，工具提示将隐藏起来。\n\n带有注释的 HTML 示例：\n```html\n<button data-tooltip=\"the tooltip is longer than the element\">Short button</button>\n<button data-tooltip=\"HTML<br>tooltip\">One more button</button>\n```\n\n运行效果如下：\n\n[iframe src=\"solution\" height=200 border=1]\n\n在此任务中，我们假设所有具有 `data-tooltip` 的元素中都只有文本。尚无嵌套标签。\n\n详情：\n\n- 元素和工具提示之间的距离应为 `5px`。\n- 如果可能，工具提示应相对于元素居中。\n- 工具提示不应与窗口边缘交叉。通常，它应该在元素的上方，但是如果元素位于页面顶部，并且没有工具提示的空间，则应该在元素的下方。\n- 工具提示的内容在 `data-tooltip` 属性中给定。它可以是任意 HTML。\n\n在这里你将需要两个事件：\n- `mouseover` 当鼠标指针出现在元素上方时触发。\n- `mouseout` 当鼠标指针离开元素时触发。\n\n请使用事件委托：在 `document` 上设置两个处理程序，以跟踪带有 `data-tooltip` 的元素中的所有 \"over\" 和 \"out\"，并从那里管理工具提示。\n\n在实现了该行为后，即使不熟悉 JavaScript 的人也可以添加带注释的元素。\n\nP.S. 一次只能显示一个工具提示。",
        "solution": "",
        "parent": "event-delegation",
        "version": 1
      }
    },
    "default-browser-action": {
      "type": "Article",
      "value": {
        "title": "浏览器默认行为",
        "slug": "default-browser-action",
        "githubPath": "/2-ui/2-events/04-default-browser-action",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n许多事件会自动触发浏览器执行某些行为。\n\n例如：\n\n- 点击一个链接 —— 触发导航（navigation）到该 URL。\n- 点击表单的提交按钮 —— 触发提交到服务器的行为。\n- 在文本上按下鼠标按钮并移动 —— 选中文本。\n\n如果我们使用 JavaScript 处理一个事件，那么我们通常不希望发生相应的浏览器行为。而是想要实现其他行为进行替代。\n\n## 阻止浏览器行为\n\n有两种方式来告诉浏览器我们不希望它执行默认行为：\n\n- 主流的方式是使用 `event` 对象。有一个 `event.preventDefault()` 方法。\n- 如果处理程序是使用 `on<event>`（而不是 `addEventListener`）分配的，那返回 `false` 也同样有效。\n\n在下面这个示例中，点击链接不会触发导航（navigation），浏览器不会执行任何操作：\n\n```html autorun height=60 no-beautify\n<a href=\"/\" onclick=\"return false\">Click here</a>\nor\n<a href=\"/\" onclick=\"event.preventDefault()\">here</a>\n```\n\n在下一个示例中，我们将使用此技术来创建 JavaScript 驱动的菜单。\n\n```warn header=\"从处理程序返回 `false` 是一个例外\"\n事件处理程序返回的值通常会被忽略。\n\n唯一的例外是从使用 `on<event>` 分配的处理程序中返回的 `return false`。\n\n在所有其他情况下，`return` 值都会被忽略。并且，返回 `true` 没有意义。\n```\n\n### 示例：菜单\n\n考虑一个网站菜单，如下所示：\n\n```html\n<ul id=\"menu\" class=\"menu\">\n  <li><a href=\"/html\">HTML</a></li>\n  <li><a href=\"/javascript\">JavaScript</a></li>\n  <li><a href=\"/css\">CSS</a></li>\n</ul>\n```\n\n下面经过 CSS 渲染的外观：\n\n[iframe height=70 src=\"menu\" link edit]\n\n菜单项是通过使用 HTML 链接 `<a>` 实现的，而不是使用按钮 `<button>`。这样做有几个原因，例如：\n\n- 许多人喜欢使用“右键单击” —— “在一个新窗口打开链接”。如果我们使用 `<button>` 或 `<span>`，这个效果就无法实现。\n- 搜索引擎在建立索引时遵循 `<a href=\"...\">` 链接。\n\n所以我们在标记（markup）中使用了 `<a>`。但通常我们打算处理 JavaScript 中的点击。因此，我们应该阻止浏览器默认行为。\n\n像这样：\n\n```js\nmenu.onclick = function(event) {\n  if (event.target.nodeName != 'A') return;\n\n  let href = event.target.getAttribute('href');\n  alert( href ); // ...可以从服务器加载，UI 生成等\n\n*!*\n  return false; // 阻止浏览器行为（不前往访问 URL）\n*/!*\n};\n```\n\n如果我们省略 `return false`，那么在我们的代码执行完毕后，浏览器将执行它的“默认行为” —— 导航至在 `href` 中的 URL。\n\n顺便说一句，这里使用事件委托会使我们的菜单更灵活。我们可以添加嵌套列表并使用 CSS 对其进行样式设置来实现 \"slide down\" 的效果。\n\n````smart header=\"后续事件\"\n某些事件会相互转化。如果我们阻止了第一个事件，那就没有第二个事件了。\n\n例如，在 `<input>` 字段上的 `mousedown` 会导致在其中获得焦点，以及 `focus` 事件。如果我们阻止 `mousedown` 事件，在这就没有焦点了。\n\n尝试点击下面的第一个 `<input>` —— 会发生 `focus` 事件。但是如果你点击第二个，则没有聚焦。\n\n```html run autorun\n<input value=\"Focus works\" onfocus=\"this.value=''\">\n<input *!*onmousedown=\"return false\"*/!* onfocus=\"this.value=''\" value=\"Click me\">\n```\n\n这是因为浏览器行为在 `mousedown` 上被取消。如果我们用另一种方式进行输入，则仍然可以进行聚焦。例如，可以使用 `key:Tab` 键从第一个输入切换到第二个输入。但鼠标点击则不行。\n````\n\n## 处理程序选项 \"passive\"\n\n`addEventListener` 的可选项 `passive: true` 向浏览器发出信号，表明处理程序将不会调用 `preventDefault()`。\n\n为什么需要这样做？\n\n移动设备上会发生一些事件，例如 `touchmove`（当用户在屏幕上移动手指时），默认情况下会导致滚动，但是可以使用处理程序的 `preventDefault()` 来阻止滚动。\n\n因此，当浏览器检测到此类事件时，它必须首先处理所有处理程序，然后如果没有任何地方调用 `preventDefault`，则页面可以继续滚动。但这可能会导致 UI 中不必要的延迟和“抖动”。\n\n`passive: true` 选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。\n\n对于某些浏览器（Firefox，Chrome），默认情况下，`touchstart` 和 `touchmove` 事件的 `passive` 为 `true`。\n\n\n## event.defaultPrevented\n\n如果默认行为被阻止，那么 `event.defaultPrevented` 属性为 `true`，否则为 `false`。\n\n这儿有一个有趣的用例。\n\n你还记得我们在 <info:bubbling-and-capturing> 一章中讨论过的 `event.stopPropagation()`，以及为什么停止冒泡是不好的吗？\n\n有时我们可以使用 `event.defaultPrevented` 来代替，来通知其他事件处理程序，该事件已经被处理。\n\n我们来看一个实际的例子。\n\n默认情况下，浏览器在 `contextmenu` 事件（单击鼠标右键）时，显示带有标准选项的上下文菜单。我们可以阻止它并显示我们自定义的菜单，就像这样：\n\n```html autorun height=50 no-beautify run\n<button>Right-click shows browser context menu</button>\n\n<button *!*oncontextmenu=\"alert('Draw our menu'); return false\"*/!*>\n  Right-click shows our context menu\n</button>\n```\n\n现在，除了该上下文菜单外，我们还想实现文档范围的上下文菜单。\n\n右键单击时，应该显示最近的上下文菜单：\n\n```html autorun height=80 no-beautify run\n<p>Right-click here for the document context menu</p>\n<button id=\"elem\">Right-click here for the button context menu</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n```\n\n问题是，当我们点击 `elem` 时，我们会得到两个菜单：按钮级和文档级（事件冒泡）的菜单。\n\n如何修复呢？其中一个解决方案是：“当我们在按钮处理程序中处理鼠标右键单击事件时，我们阻止其冒泡”，使用 `event.stopPropagation()`：\n\n```html autorun height=80 no-beautify run\n<p>Right-click for the document menu</p>\n<button id=\"elem\">Right-click for the button menu (fixed with event.stopPropagation)</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n*!*\n    event.stopPropagation();\n*/!*\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n```\n\n现在按钮级菜单如期工作。但是代价太大，我们拒绝了任何外部代码对右键点击信息的访问，包括收集统计信息的计数器等。这是非常不明智的。\n\n另一个替代方案是，检查 `document` 处理程序是否阻止了浏览器的默认行为？如果阻止了，那么该事件已经得到了处理，我们无需再对此事件做出反应。\n\n\n```html autorun height=80 no-beautify run\n<p>Right-click for the document menu (added a check for event.defaultPrevented)</p>\n<button id=\"elem\">Right-click for the button menu</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n*!*\n    if (event.defaultPrevented) return;\n*/!*\n\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n```\n\n现在一切都可以正常工作了。如果我们有嵌套的元素，并且每个元素都有自己的上下文菜单，那么这也是可以运行的。只需确保检查每个 `contextmenu` 处理程序中的 `event.defaultPrevented`。\n\n```smart header=\"event.stopPropagation() 和 event.preventDefault()\"\n正如我们所看到的，`event.stopPropagation()` 和 `event.preventDefault()`（也被认为是 `return false`）是两个不同的东西。它们之间毫无关联。\n```\n\n```smart header=\"嵌套的上下文菜单结构\"\n还有其他实现嵌套上下文菜单的方式。其中之一是拥有一个具有 `document.oncontextmenu` 处理程序的全局对象，以及使我们能够在其中存储其他处理程序的方法。\n\n该对象将捕获任何右键单击，浏览存储的处理程序并运行适当的处理程序。\n\n但是，每段需要上下文菜单的代码都应该了解该对象，并使用它的帮助，而不是使用自己的 `contextmenu` 处理程序。\n```\n\n## 总结\n\n有很多默认的浏览器行为：\n\n- `mousedown` —— 开始选择（移动鼠标进行选择）。\n- 在 `<input type=\"checkbox\">` 上的 `click` —— 选中/取消选中的 `input`。\n- `submit` —— 点击 `<input type=\"submit\">` 或者在表单字段中按下 `key:Enter` 键会触发该事件，之后浏览器将提交表单。\n- `keydown` —— 按下一个按键会导致将字符添加到字段，或者触发其他行为。\n- `contextmenu` —— 事件发生在鼠标右键单击时，触发的行为是显示浏览器上下文菜单。\n- ……还有更多……\n\n如果我们只想通过 JavaScript 来处理事件，那么所有默认行为都是可以被阻止的。\n\n想要阻止默认行为 —— 可以使用 `event.preventDefault()` 或 `return false`。第二个方法只适用于通过 `on<event>` 分配的处理程序。\n\n`addEventListener` 的 `passive: true` 选项告诉浏览器该行为不会被阻止。这对于某些移动端的事件（像 `touchstart` 和 `touchmove`）很有用，用以告诉浏览器在滚动之前不应等待所有处理程序完成。\n\n如果默认行为被阻止，`event.defaultPrevented` 的值会变成 `true`，否则为 `false`。\n\n```warn header=\"保持语义，不要滥用\"\n从技术上来说，通过阻止默认行为并添加 JavaScript，我们可以自定义任何元素的行为。例如，我们可以使链接 `<a>` 像按钮一样工作，而按钮 `<button>` 也可以像链接那样工作（重定向到另一个 URL 等）。\n\n但我们通常应该保留 HTML 元素的语义。例如 `<a>` 应该表现为导航（navigation），而不是按钮。\n\n除了“只是一件好事”之外，这还会使你的 HTML 具有更好的可访问性。\n\n另外，如果我们考虑使用带有 `<a>` 的示例，那么请注意：浏览器允许我们在新窗口中打开此类链接（通过右键单击它们以及其他方式）。大家都喜欢这么做。但是，如果我们使用 JavaScript 让按钮行为表现得像链接，甚至使用 CSS 将其样式设置成看起来也像链接，即使这样，但仍然无法在按钮上使用特定于 `<a>` 的浏览器功能。\n```",
        "libs": [],
        "children": [
          "why-return-false-fails",
          "catch-link-navigation",
          "image-gallery"
        ],
        "parent": "events",
        "updatedAt": 1652272837
      }
    },
    "why-return-false-fails": {
      "type": "Task",
      "value": {
        "title": "为什么 \"return false\" 不起作用？",
        "slug": "why-return-false-fails",
        "githubPath": "/2-ui/2-events/04-default-browser-action/1-why-return-false-fails",
        "weight": 1,
        "libs": [],
        "importance": 3,
        "content": "\n\n为什么下面这段代码中的 `return false` 不起作用？\n\n```html autorun run\n<script>\n  function handler() {\n    alert( \"...\" );\n    return false;\n  }\n</script>\n\n<a href=\"https://w3.org\" onclick=\"handler()\">the browser will go to w3.org</a>\n```\n\n浏览器在点击时会根据 URL 进行跳转，但这不是我们想要的。\n\n如何修复它？",
        "solution": "当浏览器读取诸如 `onclick` 之类的 `on*` 特性（attribute）时，浏览器会根据其内容创建对应的处理程序。\n\n对于 `onclick=\"handler()\"` 来说，函数是：\n\n```js\nfunction(event) {\n  handler() // onclick 的内容\n}\n```\n\n现在我们可以看到 `handler()` 的返回值并没有被使用，也没有对结果产生影响。\n\n修复起来很简单：\n\n```html run\n<script>\n  function handler() {\n    alert(\"...\");\n    return false;\n  }\n</script>\n\n<a href=\"https://w3.org\" onclick=\"*!*return handler()*/!*\">w3.org</a>\n```\n\n我们也可以使用 `event.preventDefault()`，像这样：\n\n```html run\n<script>\n*!*\n  function handler(event) {\n    alert(\"...\");\n    event.preventDefault();\n  }\n*/!*\n</script>\n\n<a href=\"https://w3.org\" onclick=\"*!*handler(event)*/!*\">w3.org</a>\n```",
        "parent": "default-browser-action",
        "version": 1
      }
    },
    "catch-link-navigation": {
      "type": "Task",
      "value": {
        "title": "捕获元素中的链接",
        "slug": "catch-link-navigation",
        "githubPath": "/2-ui/2-events/04-default-browser-action/2-catch-link-navigation",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n使所有包含 `id=\"contents\"` 的元素内的链接询问用户是否真的要离开。如果用户不想离开，那就不离开。\n\n像这样：\n\n[iframe height=100 border=1 src=\"solution\"]\n\n细节：\n\n- 元素内的 HTML 可以被随时动态加载或重新生成，因此，我们无法找到所有链接并为其添加处理程序。这里使用事件委托。\n- 内容中可能有嵌套的标签。链接中也是，例如 `<a href=\"..\"><i>...</i></a>`。",
        "solution": "这是一个很好的使用事件委托模式的案例。\n\n在现实生活中，我们可以向服务器发送一个 \"logging\" 请求而不是询问，该请求会保存关于访问者离开位置的信息。或者，我们可以加载内容，并将其显示在页面中（如果允许的话）。\n\n我们只需要捕获 `contents.onclick`，然后使用 `confirm` 来询问用户。一个好主意是使用 `link.getAttribute('href')` 来代替 `link.href`。详情请参见解决方案。",
        "parent": "default-browser-action",
        "version": 1
      }
    },
    "image-gallery": {
      "type": "Task",
      "value": {
        "title": "图册",
        "slug": "image-gallery",
        "githubPath": "/2-ui/2-events/04-default-browser-action/3-image-gallery",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个图册，通过点击缩略图可以更改主图片。\n\n像这样：\n\n[iframe src=\"solution\" height=600]\n\nP.S. 使用事件委托。",
        "solution": "解决方案是将处理程序分配给容器，并追踪点击。如果点击在 `<a>` 链接上，则将 `#largeImg` 的 `src` 修改为该缩略图的 `href`。",
        "parent": "default-browser-action",
        "version": 1
      }
    },
    "dispatch-events": {
      "type": "Article",
      "value": {
        "title": "创建自定义事件",
        "slug": "dispatch-events",
        "githubPath": "/2-ui/2-events/05-dispatch-events",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n我们不仅可以分配事件处理程序，还可以从 JavaScript 生成事件。\n\n自定义事件可用于创建“图形组件”。例如，我们自己的基于 JavaScript 的菜单的根元素可能会触发 `open`（打开菜单），`select`（有一项被选中）等事件来告诉菜单发生了什么。另一个代码可能会监听事件，并观察菜单发生了什么。\n\n我们不仅可以生成出于自身目的而创建的全新事件，还可以生成例如 `click` 和 `mousedown` 等内建事件。这可能会有助于自动化测试。\n\n## 事件构造器\n\n内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类。根是内建的 [Event](http://www.w3.org/TR/dom/#event) 类。\n\n我们可以像这样创建 `Event` 对象：\n\n```js\nlet event = new Event(type[, options]);\n```\n\n参数：\n\n- **type** —— 事件类型，可以是像这样 `\"click\"` 的字符串，或者我们自己的像这样 `\"my-event\"` 的参数。\n- **options** —— 具有两个可选属性的对象：\n  - `bubbles: true/false` —— 如果为 `true`，那么事件会冒泡。\n  - `cancelable: true/false` —— 如果为 `true`，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。\n\n  默认情况下，以上两者都为 false：`{bubbles: false, cancelable: false}`。\n\n## dispatchEvent\n\n事件对象被创建后，我们应该使用 `elem.dispatchEvent(event)` 调用在元素上“运行”它。\n\n然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。如果事件是用 `bubbles` 标志创建的，那么它会冒泡。\n\n在下面这个示例中，`click` 事件是用 JavaScript 初始化创建的。处理程序工作方式和点击按钮的方式相同：\n\n```html run no-beautify\n<button id=\"elem\" onclick=\"alert('Click!');\">Autoclick</button>\n\n<script>\n  let event = new Event(\"click\");\n  elem.dispatchEvent(event);\n</script>\n```\n\n```smart header=\"event.isTrusted\"\n有一种方法可以区分“真实”用户事件和通过脚本生成的事件。\n\n对于来自真实用户操作的事件，`event.isTrusted` 属性为 `true`，对于脚本生成的事件，`event.isTrusted` 属性为 `false`。\n```\n\n## 冒泡示例\n\n我们可以创建一个名为 `\"hello\"` 的冒泡事件，并在 `document` 上捕获它。\n\n我们需要做的就是将 `bubbles` 设置为 `true`：\n\n```html run no-beautify\n<h1 id=\"elem\">Hello from the script!</h1>\n\n<script>\n  // 在 document 上捕获...\n  document.addEventListener(\"hello\", function(event) { // (1)\n    alert(\"Hello from \" + event.target.tagName); // Hello from H1\n  });\n\n  // ...在 elem 上 dispatch！\n  let event = new Event(\"hello\", {bubbles: true}); // (2)\n  elem.dispatchEvent(event);\n\n  // 在 document 上的处理程序将被激活，并显示消息。\n\n</script>\n```\n\n\n注意：\n\n1. 我们应该对我们的自定义事件使用 `addEventListener`，因为 `on<event>` 仅存在于内建事件中，`document.onhello` 则无法运行。\n2. 必须设置 `bubbles:true`，否则事件不会向上冒泡。\n\n内建事件（`click`）和自定义事件（`hello`）的冒泡机制相同。自定义事件也有捕获阶段和冒泡阶段。\n\n## MouseEvent，KeyboardEvent 及其他\n\n这是一个摘自于 [UI 事件规范](https://www.w3.org/TR/uievents) 的一个简短的 UI 事件类列表：\n\n- `UIEvent`\n- `FocusEvent`\n- `MouseEvent`\n- `WheelEvent`\n- `KeyboardEvent`\n- ...\n\n如果我们想要创建这样的事件，我们应该使用它们而不是 `new Event`。例如，`new MouseEvent(\"click\")`。\n\n正确的构造器允许为该类型的事件指定标准属性。\n\n就像鼠标事件的 `clientX/clientY` 一样：\n\n```js run\nlet event = new MouseEvent(\"click\", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert(event.clientX); // 100\n*/!*\n```\n\n请注意：通用的 `Event` 构造器不允许这样做。\n\n让我们试试：\n\n```js run\nlet event = new Event(\"click\", {\n  bubbles: true, // 构造器 Event 中只有 bubbles 和 cancelable 可以工作\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\n*!*\nalert(event.clientX); // undefined，未知的属性被忽略了！\n*/!*\n```\n\n从技术上讲，我们可以通过在创建后直接分配 `event.clientX=100` 来解决这个问题。所以，这是一个方便和遵守规则的问题。浏览器生成的事件始终具有正确的类型。\n\n规范中提供了不同 UI 事件的属性的完整列表，例如 [MouseEvent](https://www.w3.org/TR/uievents/#mouseevent)。\n\n## 自定义事件\n\n对于我们自己的全新事件类型，例如 `\"hello\"`，我们应该使用 `new CustomEvent`。从技术上讲，[CustomEvent](https://dom.spec.whatwg.org/#customevent) 和 `Event` 一样。除了一点不同。\n\n在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性 `detail`。\n\n例如：\n\n```html run refresh\n<h1 id=\"elem\">Hello for John!</h1>\n\n<script>\n  // 事件附带给处理程序的其他详细信息\n  elem.addEventListener(\"hello\", function(event) {\n    alert(*!*event.detail.name*/!*);\n  });\n\n  elem.dispatchEvent(new CustomEvent(\"hello\", {\n*!*\n    detail: { name: \"John\" }\n*/!*\n  }));\n</script>\n```\n\n`detail` 属性可以有任何数据。从技术上讲，我们可以不用，因为我们可以在创建后将任何属性分配给常规的 `new Event` 对象中。但是 `CustomEvent` 提供了特殊的 `detail` 字段，以避免与其他事件属性的冲突。\n\n此外，事件类描述了它是“什么类型的事件”，如果事件是自定义的，那么我们应该使用 `CustomEvent` 来明确它是什么。\n\n## event.preventDefault()\n\n许多浏览器事件都有“默认行为”，例如，导航到链接，开始一个选择，等。\n\n对于新的，自定义的事件，绝对没有默认的浏览器行为，但是分派（dispatch）此类事件的代码可能有自己的计划，触发该事件之后应该做什么。\n\n通过调用 `event.preventDefault()`，事件处理程序可以发出一个信号，指出这些行为应该被取消。\n\n在这种情况下，`elem.dispatchEvent(event)` 的调用会返回 `false`。那么分派（dispatch）该事件的代码就会知道不应该再继续。\n\n让我们看一个实际的例子 —— 一只隐藏的兔子（可以是关闭菜单或者其他）。\n\n在下面，你可以看到一个在其上分派了 `\"hide\"` 事件的 `#rabbit` 和 `hide()` 函数，以使所有感兴趣的各方面都知道这只兔子要隐藏起来。\n\n任何处理程序都可以使用 `rabbit.addEventListener('hide',...)` 来监听该事件，并在需要时使用 `event.preventDefault()` 来取消该行为。然后兔子就不会藏起来了：\n\n```html run refresh autorun\n<pre id=\"rabbit\">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_Y_/=\n   {>o<}\n</pre>\n<button onclick=\"hide()\">Hide()</button>\n\n<script>\n  function hide() {\n    let event = new CustomEvent(\"hide\", {\n      cancelable: true // 没有这个标志，preventDefault 将不起作用\n    });\n    if (!rabbit.dispatchEvent(event)) {\n      alert('The action was prevented by a handler');\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addEventListener('hide', function(event) {\n    if (confirm(\"Call preventDefault?\")) {\n      event.preventDefault();\n    }\n  });\n</script>\n```\n\n请注意：该事件必须具有 `cancelable: true` 标志，否则 `event.preventDefault()` 调用将会被忽略。\n\n## 事件中的事件是同步的\n\n通常事件是在队列中处理的。也就是说：如果浏览器正在处理 `onclick`，这时发生了一个新的事件，例如鼠标移动了，那么它的处理程序会被排入队列，相应的 `mousemove` 处理程序将在 `onclick` 事件处理完成后被调用。\n\n值得注意的例外情况就是，一个事件是在另一个事件中发起的。例如使用 `dispatchEvent`。这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序。\n\n例如，在下面的代码中，`menu-open` 事件是在 `onclick` 事件执行过程中被调用的。\n\n它会被立即执行，而不必等待 `onclick` 处理程序结束：\n\n\n```html run autorun\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  menu.onclick = function() {\n    alert(1);\n\n    menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    }));\n\n    alert(2);\n  };\n\n  // 在 1 和 2 之间触发\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n```\n\n输出顺序为：1 -> nested -> 2。\n\n请注意，嵌套事件 `menu-open` 会在 `document` 上被捕获。嵌套事件的传播（propagation）和处理先被完成，然后处理过程才会返回到外部代码（`onclick`）。\n\n这不只是与 `dispatchEvent` 有关，还有其他情况。如果一个事件处理程序调用了触发其他事件的方法 —— 它们同样也会被以嵌套的方式同步处理。\n\n不过有时候，这并不是我们期望的结果。我们想让 `onclick` 不受 `menu-open` 或者其它嵌套事件的影响，优先被处理完毕。\n\n那么，我们就可以将 `dispatchEvent`（或另一个触发事件的调用）放在 `onclick` 末尾，或者最好将其包装到零延迟的 `setTimeout` 中：\n\n```html run\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  menu.onclick = function() {\n    alert(1);\n\n    setTimeout(() => menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    })));\n\n    alert(2);\n  };\n\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n```\n\n现在，`dispatchEvent` 在当前代码执行完成之后异步运行，包括 `menu.onclick`，因此，事件处理程序是完全独立的。\n\n输出顺序变成：1 -> 2 -> nested。\n\n## 总结\n\n要从代码生成一个事件，我们首先需要创建一个事件对象。\n\n通用的 `Event(name, options)` 构造器接受任意事件名称和具有两个属性的 `options` 对象：\n- 如果事件应该冒泡，则 `bubbles: true`。\n- 如果 `event.preventDefault()` 应该有效，则 `cancelable: true`。\n\n其他像 `MouseEvent` 和 `KeyboardEvent` 这样的原生事件的构造器，都接受特定于该事件类型的属性。例如，鼠标事件的 `clientX`。\n\n对于自定义事件，我们应该使用 `CustomEvent` 构造器。它有一个名为 `detail` 的附加选项，我们应该将事件特定的数据分配给它。然后，所有处理程序可以以 `event.detail` 的形式来访问它。\n\n尽管技术上可以生成像 `click` 或 `keydown` 这样的浏览器事件，但我们还是应谨慎使用它们。\n\n我们不应该生成浏览器事件，因为这是运行处理程序的一种怪异（hacky）方式。大多数时候，这都是糟糕的架构。\n\n可以生成原生事件：\n\n- 如果第三方程序库不提供其他交互方式，那么这是使第三方程序库工作所需的一种肮脏手段。\n- 对于自动化测试，要在脚本中“点击按钮”并查看接口是否正确响应。\n\n使用我们自己的名称的自定义事件通常是出于架构的目的而创建的，以指示发生在菜单（menu），滑块（slider），轮播（carousel）等内部发生了什么。",
        "libs": [],
        "children": [],
        "parent": "events",
        "updatedAt": 1650184258
      }
    },
    "event-details": {
      "type": "Article",
      "value": {
        "title": "UI 事件",
        "slug": "event-details",
        "githubPath": "/2-ui/3-event-details",
        "isFolder": true,
        "weight": 3,
        "content": "\n\n在这里，我们介绍了最重要的用户界面事件，以及如何使用它们。",
        "libs": [],
        "children": [
          "mouse-events-basics",
          "mousemove-mouseover-mouseout-mouseenter-mouseleave",
          "mouse-drag-and-drop",
          "pointer-events",
          "keyboard-events",
          "onscroll"
        ],
        "parent": "ui"
      }
    },
    "mouse-events-basics": {
      "type": "Article",
      "value": {
        "title": "鼠标事件",
        "slug": "mouse-events-basics",
        "githubPath": "/2-ui/3-event-details/1-mouse-events-basics",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n在本章中，我们将详细介绍鼠标事件及其属性。\n\n请注意：此类事件不仅可能来自于“鼠标设备”，还可能来自于对此类操作进行了模拟以实现兼容性的其他设备，例如手机和平板电脑。\n\n## 鼠标事件类型\n\n我们已经见过了其中一些事件：\n\n`mousedown/mouseup`\n: 在元素上点击/释放鼠标按钮。\n\n`mouseover/mouseout`\n: 鼠标指针从一个元素上移入/移出。\n\n`mousemove`\n: 鼠标在元素上的每个移动都会触发此事件。\n\n`click`\n: 如果使用的是鼠标左键，则在同一个元素上的 `mousedown` 及 `mouseup` 相继触发后，触发该事件。\n\n`dblclick`\n: 在短时间内双击同一元素后触发。如今已经很少使用了。\n\n`contextmenu`\n: 在鼠标右键被按下时触发。还有其他打开上下文菜单的方式，例如使用特殊的键盘按键，在这种情况下它也会被触发，因此它并不完全是鼠标事件。\n\n……还有其他几种事件，我们稍后会学习它们。\n\n## 事件顺序\n\n从上面的列表中我们可以看到，一个用户操作可能会触发多个事件。\n\n例如，点击鼠标左键，在鼠标左键被按下时，会首先触发 `mousedown`，然后当鼠标左键被释放时，会触发 `mouseup` 和 `click`。\n\n在单个动作触发多个事件时，事件的顺序是固定的。也就是说，会遵循 `mousedown` -> `mouseup` -> `click` 的顺序调用处理程序。\n\n```online\n点击（译注：即单击）下面的按钮，你会看到事件。并尝试双击它。\n\n在测试台下面记录了所有的鼠标事件，如果它们之间的延迟时间超过 1 秒，那么它们会被水平分割线分开。\n\n我们还可以看出 `button` 属性允许检测鼠标按键，演示示例如下。\n\n<input onmousedown=\"return logMouse(event)\" onmouseup=\"return logMouse(event)\" onclick=\"return logMouse(event)\" oncontextmenu=\"return logMouse(event)\" ondblclick=\"return logMouse(event)\" value=\"使用鼠标左键或右键点击我\" type=\"button\"> <input onclick=\"logClear('test')\" value=\"Clear\" type=\"button\"> <form id=\"testform\" name=\"testform\"> <textarea style=\"font-size:12px;height:150px;width:360px;\"></textarea></form>\n```\n\n## 鼠标按钮\n\n与点击相关的事件始终具有 `button` 属性，该属性允许获取确切的鼠标按钮。 \n\n通常我们不在 `click` 和 `contextmenu` 事件中使用这一属性，因为前者只在单击鼠标左键时触发，后者只在单击鼠标右键时触发。\n\n不过，在 `mousedown` 和 `mouseup` 事件中则可能需要用到 `event.button`，因为这两个事件在任何按键上都会触发，所以我们可以使用 `button` 属性来区分是左键单击还是右键单击。\n\n`event.button` 的所有可能值如下：\n\n| 鼠标按键状态 | `event.button` |\n|--------------|----------------|\n| 左键 (主要按键) | 0 |\n| 中键 (辅助按键) | 1 |\n| 右键 (次要按键) | 2 |\n| X1 键 (后退按键) | 3 |\n| X2 键 (前进按键) | 4 |\n\n大多数鼠标设备只有左键和右键，对应的值就是 `0` 和 `2`。触屏设备中的点按操作也会触发类似的事件。\n\n另外，还有一个 `event.buttons` 属性，其中以整数的形式存储着当前所有按下的鼠标按键，每个按键一个比特位。在实际开发中，很少会用到这个属性，如果有需要的话，你可以在 [MDN](mdn:/api/MouseEvent/buttons) 中找到更多细节。\n\n```warn header=\"过时的 `event.which`\"\n一些老代码可能会使用 `event.which` 属性来获得按下的按键。这是一个古老的非标准的方式，具有以下可能值：\n\n- `event.which == 1` —— 鼠标左键，\n- `event.which == 2` —— 鼠标中键，\n- `event.which == 3` —— 鼠标右键。\n\n现在，`event.which` 已经被弃用了，不应再使用它。\n```\n\n## 组合键：shift，alt，ctrl，meta\n\n所有的鼠标事件都包含有关按下的组合键的信息。\n\n事件属性：\n\n- `shiftKey`：`key:Shift`\n- `altKey`：`key:Alt`（或对于 Mac 是 `key:Opt`）\n- `ctrlKey`：`key:Ctrl`\n- `metaKey`：对于 Mac 是 `key:Cmd`\n\n如果在事件期间按下了相应的键，则它们为 `true`。\n\n比如，下面这个按钮仅在 `key:Alt+Shift`+click 时才有效：\n\n```html autorun height=60\n<button id=\"button\">Alt+Shift+Click on me!</button>\n\n<script>\n  button.onclick = function(event) {\n*!*\n    if (event.altKey && event.shiftKey) {\n*/!*\n      alert('Hooray!');\n    }\n  };\n</script>\n```\n\n```warn header=\"注意：在 Mac 上我们通常使用 `Cmd` 代替 `Ctrl`\"\n在 Windows 和 Linux 上有 `key:Alt`，`key:Shift` 和 `key:Ctrl`。在 Mac 上还有：`key:Cmd`，它对应于属性 `metaKey`。\n\n在大多数情况下，当在 Windows/Linux 上使用 `key:Ctrl` 时，在 Mac 是使用 `key:Cmd`。\n\n也就说：当 Windows 用户按下 `key:Ctrl+Enter` 或 `key:Ctrl+A` 时，Mac 用户会按下 `key:Cmd+Enter` 或 `key:Cmd+A`，以此类推。\n\n因此，如果我们想支持 `key:Ctrl`+click，那么对于 Mac 应该使用 `key:Cmd`+click。对于 Mac 用户而言，这更舒适。\n\n即使我们想强制 Mac 用户使用 `key:Ctrl`+click —— 这非常困难。问题是：在 MacOS 上左键单击和 `key:Ctrl` 一起使用会被解释为 **右键单击**，并且会生成 `contextmenu` 事件，而不是像 Windows/Linux 中的 `click` 事件。\n\n因此，如果我们想让所有操作系统的用户都感到舒适，那么我们应该将 `ctrlKey` 与 `metaKey` 一起进行检查。\n\n对于 JS 代码，这意味着我们应该检查 `if (event.ctrlKey || event.metaKey)`。\n```\n\n```warn header=\"还有移动设备\"\n键盘组合是工作流的一个补充。这样，如果访客使用键盘操作 —— 它们就会起作用。\n\n但是，如果访客的设备没有键盘 —— 那么这里应该有另一种不使用键盘也能做到这一点的方式。\n```\n\n## 坐标：clientX/Y，pageX/Y\n\n所有的鼠标事件都提供了两种形式的坐标：\n\n1. 相对于窗口的坐标：`clientX` 和 `clientY`。\n2. 相对于文档的坐标：`pageX` 和 `pageY`。\n\n我们已经在 <info:coordinates> 中解释过它们之间的区别。\n\n简而言之，相对于文档的坐标 `pageX/Y` 以文档的左上角为参照物，并且同一位置的坐标不随页面的滚动而改变。相对于窗口的坐标 `clientX/Y` 以当前窗口的左上角为参照物，并且同一位置的坐标会随着页面的滚动而改变。\n\n例如，如果我们有一个大小为 500x500 的窗口，并且鼠标在左上角，那么 `clientX` 和 `clientY` 均为 `0`，无论页面如何滚动。\n\n如果鼠标位于中间，那么 `clientX` 和 `clientY` 均为 `250`。这与它在文档中的位置无关。在这方面，它们类似于 `position:fixed`。\n\n````online\n将鼠标移动到输入字段上，可以看到 `clientX/clientY`（此示例位于 `iframe` 中，因此坐标是相对于 `iframe` 的）：\n\n```html autorun height=50\n<input onmousemove=\"this.value=event.clientX+':'+event.clientY\" value=\"Mouse over me\">\n```\n````\n\n## 防止在鼠标按下时的选择\n\n双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本。\n\n比如，双击下面的文本，除了我们的处理程序外，还会选择文本：\n\n```html autorun height=50\n<span ondblclick=\"alert('dblclick')\">Double-click me</span>\n```\n\n如果按下鼠标左键，并在不松开的情况下移动鼠标，这也常常会造成不必要的选择。\n\n有多种防止选择的方法，你可以在 <info:selection-range> 一章中详细阅读。\n\n在这种情况下，最合理的方式是防止浏览器对 `mousedown` 进行操作。这样能够阻止刚刚提到的两种选择：\n\n```html autorun height=50\nBefore...\n<b ondblclick=\"alert('Click!')\" *!*onmousedown=\"return false\"*/!*>\n  Double-click me\n</b>\n...After\n```\n\n现在，在双击时，粗体元素不会被选中，并且在粗体元素上按下鼠标左键也不会开始选择。\n\n请注意：其中的文本仍然是可选择的。但是，选择不应该开始于该文本自身，而应该在该文本之前或之后开始。通常，这对用户来说挺好的。\n\n````smart header=\"防止复制\"\n如果我们想禁用选择以保护我们页面的内容不被复制粘贴，那么我们可以使用另一个事件：`oncopy`。\n\n```html autorun height=80 no-beautify\n<div *!*oncopy=\"alert('Copying forbidden!');return false\"*/!*>\n  Dear user,\n  The copying is forbidden for you.\n  If you know JS or HTML, then you can get everything from the page source though.\n</div>\n```\n如果你试图在 `<div>` 中复制一段文本，这是行不通的，因为默认行为 `oncopy` 被阻止了。\n\n当然，用户可以访问页面的 HTML 源码，并且可以从那里获取内容，但并不是每个人都知道如何做到这一点。\n````\n\n## 总结\n\n鼠标事件有以下属性：\n\n- 按钮：`button`。\n- 组合键（如果被按下则为 `true`）：`altKey`，`ctrlKey`，`shiftKey` 和 `metaKey`（Mac）。\n  - 如果你想处理 `key:Ctrl`，那么不要忘记 Mac 用户，他们通常使用的是 `key:Cmd`，所以最好检查 `if (e.metaKey || e.ctrlKey)`。\n\n- 窗口相对坐标：`clientX/clientY`。\n- 文档相对坐标：`pageX/pageY`。\n\n`mousedown` 的默认浏览器操作是文本选择，如果它对界面不利，则应避免它。\n\n在下一章中，我们将看到有关鼠标指针移动后的事件，以及如何跟踪其下元素变化的更多详细信息。",
        "libs": [],
        "children": [
          "selectable-list"
        ],
        "headHtml": "<script>\n{\n  let timer = 0;\n\n  function showmesg(t, form) {\n\n     if (timer == 0) {\n       timer = new Date();\n     }\n\n     let tm = new Date();\n\n     if (tm - timer > 300) {\n       t = '------------------------------\\n' + t;\n     }\n\n     let area = document.forms[form + 'form'].getElementsByTagName('textarea')[0];\n\n     area.value += t + '\\n';\n     area.scrollTop = area.scrollHeight;\n\n     timer = tm;\n  }\n\n  function logMouse(e) {\n     let evt = e.type;\n     while (evt.length < 11) evt += ' ';\n     showmesg(evt + \" button=\" + e.button, 'test')\n     return false;\n  }\n\n  function keyval(n) {\n     if (n == null) return 'undefined';\n     let s = '' + n;\n     if (n >= 32 && n < 127) s += ' ' + String.fromCharCode(n);\n     while (s.length < 6) s += ' ';\n     return s;\n  }\n\n\n  function logClear(form) {\n  \ttimer = 0;\n  \tdocument.forms[form+'form'].getElementsByTagName('textarea')[0].value ='';\n  \tlines = 0;\n  }\n\n  window.logClear = logClear;\n  window.logMouse = logMouse;\n}\n</script>\n",
        "parent": "event-details",
        "updatedAt": 1657705346
      }
    },
    "selectable-list": {
      "type": "Task",
      "value": {
        "title": "可选列表",
        "slug": "selectable-list",
        "githubPath": "/2-ui/3-event-details/1-mouse-events-basics/01-selectable-list",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个可以选择元素的列表，例如在文件管理器中。\n\n- 点击列表元素，只选择该元素（添加 `.selected` 类），取消选择其他所有元素。\n- 如果点击时，按键 `key:Ctrl`（在 Mac 中为 `key:Cmd`）是被按下的，则选择会被切换到被点击的元素上，但其他元素不会被改动。\n\n示例：\n\n[iframe border=\"1\" src=\"solution\" height=180]\n\nP.S. 对于此任务，我们可以假设列表项是纯文本的。没有嵌套标签。\n\nP.P.S. 防止点击时浏览器原生的文本选择。",
        "solution": "",
        "parent": "mouse-events-basics",
        "version": 1
      }
    },
    "mousemove-mouseover-mouseout-mouseenter-mouseleave": {
      "type": "Article",
      "value": {
        "title": "移动鼠标：mouseover/out，mouseenter/leave",
        "slug": "mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n我们将深入研究鼠标在元素之间移动时发生的事件。\n\n## 事件 mouseover/mouseout，relatedTarget\n\n当鼠标指针移到某个元素上时，`mouseover` 事件就会发生，而当鼠标离开该元素时，`mouseout` 事件就会发生。\n\n![](mouseover-mouseout.svg)\n\n这些事件很特别，因为它们具有 `relatedTarget` 属性。此属性是对 `target` 的补充。当鼠标从一个元素离开并去往另一个元素时，其中一个元素就变成了 `target`，另一个就变成了 `relatedTarget`。\n\n对于 `mouseover`：\n\n- `event.target` —— 是鼠标移过的那个元素。\n- `event.relatedTarget` —— 是鼠标来自的那个元素（`relatedTarget` -> `target`）。\n\n`mouseout` 则与之相反：\n\n- `event.target` —— 是鼠标离开的元素。\n- `event.relatedTarget` —— 是鼠标移动到的，当前指针位置下的元素（`target` -> `relatedTarget`）。\n\n```online\n在下面这个示例中，每张脸及其功能都是单独的元素。当你移动鼠标时，你可以在文本区域中看到鼠标事件。\n\n每个事件都具有关于 `target` 和 `relatedTarget` 的信息：\n\n[codetabs src=\"mouseoverout\" height=280]\n```\n\n```warn header=\"`relatedTarget` 可以为 `null`\"\n`relatedTarget` 属性可以为 `null`。\n\n这是正常现象，仅仅是意味着鼠标不是来自另一个元素，而是来自窗口之外。或者它离开了窗口。\n\n当我们在代码中使用 `event.relatedTarget` 时，我们应该牢记这种可能性。如果我们访问 `event.relatedTarget.tagName`，那么就会出现错误。\n```\n\n## 跳过元素\n\n当鼠标移动时，就会触发 `mousemove` 事件。但这并不意味着每个像素都会导致一个事件。\n\n浏览器会一直检查鼠标的位置。如果发现了变化，就会触发事件。\n\n这意味着，如果访问者非常快地移动鼠标，那么某些 DOM 元素就可能被跳过：\n\n![](mouseover-mouseout-over-elems.svg)\n\n如果鼠标从上图所示的 `#FROM` 快速移动到 `#TO` 元素，则中间的 `<div>`（或其中的一些）元素可能会被跳过。`mouseout` 事件可能会在 `#FROM` 上被触发，然后立即在 `#TO` 上触发 `mouseover`。\n\n这对性能很有好处，因为可能有很多中间元素。我们并不真的想要处理每一个移入和离开的过程。\n\n另一方面，我们应该记住，鼠标指针并不会“访问”所有元素。它可以“跳过”一些元素。\n\n特别是，鼠标指针可能会从窗口外跳到页面的中间。在这种情况下，`relatedTarget` 为 `null`，因为它是从石头缝里蹦出来的（nowhere）：\n\n![](mouseover-mouseout-from-outside.svg)\n\n```online\n你可以在下面的测试台中“实时”查看。\n\n它的 HTML 有两个嵌套的元素：`<div id=\"child\">` 在 `<div id=\"parent\">` 内部。如果将鼠标快速移动到它们上，则可能只有 `<div id=\"child\">` 或者只有 `<div id=\"parent\">` 触发事件，或者根本没有事件触发。 \n\n还可以将鼠标指针移动到 `<div id=\"child\">` 中，然后将其快速向下移动过其父级元素。如果移动速度足够快，则父元素就会被忽略。鼠标会越过父元素而不会引起其注意。\n\n[codetabs height=360 src=\"mouseoverout-fast\"]\n```\n\n```smart header=\"如果 `mouseover` 被触发了，则必须有 `mouseout`\"\n在鼠标快速移动的情况下，中间元素可能会被忽略，但是我们可以肯定一件事：如果鼠标指针“正式地”进入了一个元素（生成了 `mouseover` 事件），那么一旦它离开，我们就会得到 `mouseout`。\n```\n\n## 当移动到一个子元素时 mouseout\n\n`mouseout` 的一个重要功能 —— 当鼠标指针从元素移动到其后代时触发，例如在下面的这个 HTML 中，从 `#parent` 到 `#child`：\n\n```html\n<div id=\"parent\">\n  <div id=\"child\">...</div>\n</div>\n```\n\n如果我们在 `#parent` 上，然后将鼠标指针更深入地移入 `#child`，在 `#parent` 上我们会得到 `mouseout`！\n\n![](mouseover-to-child.svg)\n\n这听起来很奇怪，但很容易解释。\n\n**根据浏览器的逻辑，鼠标指针随时可能位于单个元素上 —— 嵌套最多的那个元素（z-index 最大的那个）。**\n\n因此，如果它转到另一个元素（甚至是一个后代），那么它将离开前一个元素。\n\n请注意事件处理的另一个重要的细节。\n\n后代的 `mouseover` 事件会冒泡。因此，如果 `#parent` 具有 `mouseover` 处理程序，它将被触发：\n\n![](mouseover-bubble-nested.svg)\n\n```online\n你可以在下面这个示例中很清晰地看到这一点：`<div id=\"child\">` 位于 `<div id=\"parent\">` 内部。`#parent` 元素上有 `mouseover/out` 的处理程序，这些处理程序用于输出事件详细信息。\n\n如果你将鼠标从 `#parent` 移动到 `#child`，那么你会看到在 `#parent` 上有两个事件:\n1. `mouseout [target: parent]`（离开 parent），然后\n2. `mouseover [target: child]`（来到 child，冒泡）。\n\n[codetabs height=360 src=\"mouseoverout-child\"]\n```\n\n如上例所示，当鼠标指针从 `#parent` 元素移动到 `#child` 时，会在父元素上触发两个处理程序：`mouseout` 和 `mouseover`：\n\n```js\nparent.onmouseout = function(event) {\n  /* event.target: parent element */\n};\nparent.onmouseover = function(event) {\n  /* event.target: child element (bubbled) */\n};\n```\n\n**如果我们不检查处理程序中的 `event.target`，那么似乎鼠标指针离开了 `#parent` 元素，然后立即回到了它上面。**\n\n但是事实并非如此！鼠标指针仍然位于父元素上，它只是更深入地移入了子元素。\n\n如果离开父元素时有一些行为（action），例如一个动画在 `parent.onmouseout` 中运行，当鼠标指针深入 `#parent` 时，我们并不希望发生这种行为。\n\n为了避免它，我们可以在处理程序中检查 `relatedTarget`，如果鼠标指针仍在元素内，则忽略此类事件。\n\n另外，我们可以使用其他事件：`mouseenter` 和 `mouseleave`，它们没有此类问题，接下来我们就对其进行详细介绍。\n\n## 事件 mouseenter 和 mouseleave\n\n事件 `mouseenter/mouseleave` 类似于 `mouseover/mouseout`。它们在鼠标指针进入/离开元素时触发。\n\n但是有两个重要的区别：\n\n1. 元素内部与后代之间的转换不会产生影响。\n2. 事件 `mouseenter/mouseleave` 不会冒泡。\n\n这些事件非常简单。\n\n当鼠标指针进入一个元素时 —— 会触发 `mouseenter`。而鼠标指针在元素或其后代中的确切位置无关紧要。\n\n当鼠标指针离开该元素时，事件 `mouseleave` 才会触发。\n\n```online\n这个例子和上面的例子相似，但是现在最顶部的元素有 `mouseenter/mouseleave` 而不是 `mouseover/mouseout`。\n\n正如你所看到的，唯一生成的事件是与将鼠标指针移入或移出顶部元素有关的事件。当鼠标指针进入 child 并返回时，什么也没发生。在后代之间的移动会被忽略。\n\n[codetabs height=340 src=\"mouseleave\"]\n```\n\n## 事件委托\n\n事件 `mouseenter/leave` 非常简单且易用。但它们不会冒泡。因此，我们不能使用它们来进行事件委托。\n\n假设我们要处理表格的单元格的鼠标进入/离开。并且这里有数百个单元格。\n\n通常的解决方案是 —— 在 `<table>` 中设置处理程序，并在那里处理事件。但 `mouseenter/leave` 不会冒泡。因此，如果类似的事件发生在 `<td>` 上，那么只有 `<td>` 上的处理程序才能捕获到它。\n\n`<table>` 上的 `mouseenter/leave` 的处理程序仅在鼠标指针进入/离开整个表格时才会触发。无法获取有关其内部移动的任何信息。\n\n因此，让我们使用 `mouseover/mouseout`。\n\n让我们从高亮显示鼠标指针下的元素的简单处理程序开始：\n\n```js\n// 高亮显示鼠标指针下的元素\ntable.onmouseover = function(event) {\n  let target = event.target;\n  target.style.background = 'pink';\n};\n\ntable.onmouseout = function(event) {\n  let target = event.target;\n  target.style.background = '';\n};\n```\n\n```online\n现在它们已经激活了。当鼠标在下面这个表格的各个元素上移动时，当前位于鼠标指针下的元素会被高亮显示：\n\n[codetabs height=480 src=\"mouseenter-mouseleave-delegation\"]\n```\n\n在我们的例子中，我们想要处理表格的单元格 `<td>` 之间的移动：进入一个单元格并离开它。我们对其他移动并不感兴趣，例如在单元格内部或在所有单元格的外部。让我们把这些过滤掉。\n\n我们可以这样做：\n\n- 在变量中记住当前被高亮显示的 `<td>`，让我们称它为 `currentElem`。\n- `mouseover` ——  如果我们仍然在当前的 `<td>` 中，则忽略该事件。\n- `mouseout` —— 如果没有离开当前的 `<td>`，则忽略。\n\n这是说明所有可能情况的代码示例：\n\n[js src=\"mouseenter-mouseleave-delegation-2/script.js\"]\n\n再次，重要的功能是：\n1. 它使用事件委托来处理表格中任何 `<td>` 的进入/离开。因此，它依赖于 `mouseover/out` 而不是 `mouseenter/leave`，`mouseenter/leave` 不会冒泡，因此也不允许事件委托。\n2. 额外的事件，例如在 `<td>` 的后代之间移动都会被过滤掉，因此 `onEnter/Leave` 仅在鼠标指针进入/离开 `<td>` 整体时才会运行。\n\n```online\n这是带有所有详细信息的完整示例：\n\n[codetabs height=460 src=\"mouseenter-mouseleave-delegation-2\"]\n\n尝试将鼠标指针移入和移出表格单元格及其内部。快还是慢都没关系。与前面的示例不同，只有 `<td>` 被作为一个整体高亮显示。\n```\n\n## 总结\n\n我们讲了 `mouseover`，`mouseout`，`mousemove`，`mouseenter` 和 `mouseleave` 事件。\n\n以下这些内容要注意：\n\n- 快速移动鼠标可能会跳过中间元素。\n- `mouseover/out` 和 `mouseenter/leave` 事件还有一个附加属性：`relatedTarget`。这就是我们来自/到的元素，是对 `target` 的补充。\n\n即使我们从父元素转到子元素时，也会触发 `mouseover/out` 事件。浏览器假定鼠标一次只会位于一个元素上 —— 最深的那个。\n\n`mouseenter/leave` 事件在这方面不同：它们仅在鼠标进入和离开元素时才触发。并且它们不会冒泡。",
        "libs": [],
        "children": [
          "behavior-nested-tooltip",
          "hoverintent"
        ],
        "parent": "event-details",
        "updatedAt": 1657705346
      }
    },
    "behavior-nested-tooltip": {
      "type": "Task",
      "value": {
        "title": "改进的工具提示行为",
        "slug": "behavior-nested-tooltip",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/1-behavior-nested-tooltip",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写 JavaScript，在带有 `data-tooltip` 特性（attribute）的元素上显示一个工具提示。该特性的值应该成为工具提示的文本。\n\n与任务 <info:task/behavior-tooltip> 类似，但这里可以嵌套带有注解（annotated）的元素。并且显示的是嵌套最深的工具提示。\n\n同一时间只能显示一个工具提示。\n\n例如：\n\n```html\n<div data-tooltip=\"这是房子的内部\" id=\"house\">\n  <div data-tooltip=\"这里是屋顶\" id=\"roof\"></div>\n  ...\n  <a href=\"https://en.wikipedia.org/wiki/The_Three_Little_Pigs\" data-tooltip=\"Read on…\">鼠标悬浮在我上</a>\n</div>\n```\n\n在 iframe 中的结果：\n\n[iframe src=\"solution\" height=300 border=1]",
        "solution": "",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "version": 1
      }
    },
    "hoverintent": {
      "type": "Task",
      "value": {
        "title": "“智能”工具提示",
        "slug": "hoverintent",
        "githubPath": "/2-ui/3-event-details/3-mousemove-mouseover-mouseout-mouseenter-mouseleave/2-hoverintent",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n编写一个函数，该函数仅在访问者将鼠标 **移至** 元素而不是 **移过** 元素的情况下，在该元素上显示工具提示。\n\n换句话说，如果访问者将鼠标移至元素上，并停下来 —— 显示工具提示。如果他们只是将鼠标移过元素，那就没必要显示，谁想要多余的闪烁呢？\n\n从技术上说，我们可以测量元素上的鼠标移动速度，如果速度很慢，那么我们就假定它 **在元素上**，并显示工具提示，如果速度很快 —— 那么我们就忽略它。\n\n为此，我们创建一个通用对象 `new HoverIntent(options)`。\n\n其 `options`：\n- `elem` —— 要跟踪的元素。\n- `over` —— 鼠标移动到元素上时要调用的函数：即，鼠标在元素上的移动速度很慢，或者停在该元素上。\n- `out` —— 当鼠标离开元素时调用的函数（如果 `over` 已经被调用过了）。\n\n在工具提示中使用此类对象的示例：\n\n```js\n// 一个简单的工具提示\nlet tooltip = document.createElement('div');\ntooltip.className = \"tooltip\";\ntooltip.innerHTML = \"Tooltip\";\n\n// 该对象将跟踪鼠标，并调用 over/out\nnew HoverIntent({\n  elem,\n  over() {\n    tooltip.style.left = elem.getBoundingClientRect().left + 'px';\n    tooltip.style.top = elem.getBoundingClientRect().bottom + 5 + 'px';\n    document.body.append(tooltip);\n  },\n  out() {\n    tooltip.remove();\n  }\n});\n```\n\n示例：\n\n[iframe src=\"solution\" height=140]\n\n如果你将鼠标快速地从“时钟”上移动过去，那么什么都不会发生，如果你使用鼠标在“时钟”上慢慢移动，或者停在“时钟”上，则会出现一个工具提示。\n\n请注意：当鼠标指针在“时钟”的元素之间移动时，工具提示不会“闪烁”",
        "solution": "算法看起来很简单：\n1. 将 `onmouseover/out` 处理程序放在元素上。在这里也可以使用 `onmouseenter/leave`，但是它们的通用性较差，如果我们想引入事件委托时，它则无法使用。\n2. 当鼠标指针进入元素时，开始测量 `mousemove` 上的速度。\n3. 如果速度慢，则运行 `over`。\n4. 当我们的鼠标指针要移出元素，并且 `over` 也执行了，则会运行 `out`。\n\n但是如何测量速度？\n\n第一个想法是：每 `100ms` 运行一次函数，并测量前坐标和新坐标之间的距离。如果很小，那么速度就很小。\n\n不幸的是，在 JavaScript 中无法获取“鼠标当前坐标”。没有像 `getCurrentMouseCoordinates()` 这样的函数。\n\n获取坐标的唯一方法是监听例如 `mousemove` 这样的鼠标事件。\n\n因此，我们可以在 `mousemove` 上设置一个处理程序来跟踪坐标并记住它们。然后我每 `100ms` 比较一次。\n\nP.S. 请注意：解决方案测试使用 `dispatchEvent` 来检查工具提示是否正确。",
        "parent": "mousemove-mouseover-mouseout-mouseenter-mouseleave",
        "version": 1
      }
    },
    "mouse-drag-and-drop": {
      "type": "Article",
      "value": {
        "title": "鼠标拖放事件",
        "slug": "mouse-drag-and-drop",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n拖放（Drag'n'Drop）是一个很赞的界面解决方案。取某件东西并将其拖放是执行许多东西的一种简单明了的方式，从复制和移动文档（如在文件管理器中）到订购（将物品放入购物车）。\n\n在现代 HTML 标准中有一个 [关于拖放的部分](https://html.spec.whatwg.org/multipage/interaction.html#dnd)，其中包含了例如 `dragstart` 和 `dragend` 等特殊事件。\n\n这些事件使我们能够支持特殊类型的拖放，例如处理从 OS 文件管理器中拖动文件，并将其拖放到浏览器窗口中。之后，JavaScript 便可以访问此类文件中的内容。\n\n但是，原生的拖放事件也有其局限性。例如，我们无法阻止从特定区域的拖动。并且，我们无法将拖动变成“水平”或“竖直”的。还有很多其他使用它们无法完成的拖放任务。并且，移动设备对此类事件的支持非常有限。\n\n因此，在这里我们将看到，如何使用鼠标事件来实现拖放。\n\n## 拖放算法\n\n基础的拖放算法如下所示：\n\n1. 在 `mousedown` 上 —— 根据需要准备要移动的元素（也许创建一个它的副本，向其中添加一个类或其他任何东西）。\n2. 然后在 `mousemove` 上，通过更改 `position:absolute` 情况下的 `left/top` 来移动它。\n3. 在 `mouseup` 上 —— 执行与完成的拖放相关的所有行为。\n\n这些都是基础内容。稍后，我们将看到如何实现其他功能，例如当我们将一个东西拖动到一个元素上方时，高亮显示该元素。\n\n下面是拖放一个球的实现代码：\n\n```js\nball.onmousedown = function(event) {\n  // (1) 准备移动：确保 absolute，并通过设置 z-index 以确保球在顶部\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n\n  // 将其从当前父元素中直接移动到 body 中\n  // 以使其定位是相对于 body 的\n  document.body.append(ball);\n\n  // 现在球的中心在 (pageX, pageY) 坐标上\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - ball.offsetWidth / 2 + 'px';\n    ball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n  }\n\n  // 将我们绝对定位的球移到指针下方\n  moveAt(event.pageX, event.pageY);\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // (2) 在 mousemove 事件上移动球\n  document.addEventListener('mousemove', onMouseMove);\n\n  // (3) 放下球，并移除不需要的处理程序\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n```\n\n如果我们运行这段代码，我们会发现一些奇怪的事情。在拖放的一开始，球“分叉”了：我们开始拖动它的“克隆”。\n\n```online\n这是一个正在运行中的示例：\n\n[iframe src=\"ball\" height=230]\n\n尝试使用鼠标进行拖放，你会看到这种奇怪的行为。\n```\n\n这是因为浏览器有自己的对图片和一些其他元素的拖放处理。它会在我们进行拖放操作时自动运行，并与我们的拖放处理产生了冲突。\n\n禁用它：\n\n```js\nball.ondragstart = function() {\n  return false;\n};\n```\n\n现在一切都正常了。\n\n```online\n这是一个正在运行中的示例：\n\n[iframe src=\"ball2\" height=230]\n```\n\n另一个重要的方面是 —— 我们在 `document` 上跟踪 `mousemove`，而不是在 `ball` 上。乍一看，鼠标似乎总是在球的上方，我们可以将 `mousemove` 放在球上。\n\n但正如我们所记得的那样，`mousemove` 会经常被触发，但不会针对每个像素都如此。因此，在快速移动鼠标后，鼠标指针可能会从球上跳转至文档中间的某个位置（甚至跳转至窗口外）。\n\n因此，我们应该监听 `document` 以捕获它。\n\n## 修正定位\n\n在上述示例中，球在移动时，球的中心始终位于鼠标指针下方：\n\n```js\nball.style.left = pageX - ball.offsetWidth / 2 + 'px';\nball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n```\n\n不错，但这存在副作用。要启动拖放，我们可以在球上的任意位置 `mousedown`。但是，如果从球的边缘“抓住”球，那么球会突然“跳转”以使球的中心位于鼠标指针下方。\n\n如果我们能够保持元素相对于鼠标指针的初始偏移，那就更好了。\n\n例如，我们按住球的边缘处开始拖动，那么在拖动时，鼠标指针应该保持在一开始所按住的边缘位置上。\n\n![](ball_shift.svg)\n\n让我们更新一下我们的算法：\n\n1. 当访问者按下按钮（`mousedown`）时 —— 我们可以在变量 `shiftX/shiftY` 中记住鼠标指针到球左上角的距离。我们应该在拖动时保持这个距离。\n\n    我们可以通过坐标相减来获取这个偏移：\n\n    ```js\n    // onmousedown\n    let shiftX = event.clientX - ball.getBoundingClientRect().left;\n    let shiftY = event.clientY - ball.getBoundingClientRect().top;\n    ```\n\n2. 然后，在拖动球时，我们将鼠标指针相对于球的这个偏移也考虑在内，像这样：\n\n    ```js\n    // onmousemove\n    // 球具有 position: absolute\n    ball.style.left = event.pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = event.pageY - *!*shiftY*/!* + 'px';\n    ```\n\n能够更好地进行定位的最终代码：\n\n```js\nball.onmousedown = function(event) {\n\n*!*\n  let shiftX = event.clientX - ball.getBoundingClientRect().left;\n  let shiftY = event.clientY - ball.getBoundingClientRect().top;\n*/!*\n\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n  document.body.append(ball);\n\n  moveAt(event.pageX, event.pageY);\n\n  // 移动现在位于坐标 (pageX, pageY) 上的球\n  // 将初始的偏移考虑在内\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - *!*shiftX*/!* + 'px';\n    ball.style.top = pageY - *!*shiftY*/!* + 'px';\n  }\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // 在 mousemove 事件上移动球\n  document.addEventListener('mousemove', onMouseMove);\n\n  // 放下球，并移除不需要的处理程序\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n\nball.ondragstart = function() {\n  return false;\n};\n```\n\n```online\nIn action (inside `<iframe>`):\n\n[iframe src=\"ball3\" height=230]\n```\n\n如果我们按住球的右下角来进行拖动，这种差异会尤其明显。在前面的示例中，球会在鼠标指针下“跳转”一下。现在，更新后的代码可以让我们从当前位置流畅地跟随鼠标。\n\n## 潜在的放置目标\n\n在前面的示例中，球可以被放置（drop）到“任何地方”。在实际中，我们通常是将一个元素放到另一个元素上。例如，将一个“文件”放置到一个“文件夹”或者其他地方。\n\n抽象地讲，我们取一个 \"draggable\" 的元素，并将其放在 \"droppable\" 的元素上。\n\n我们需要知道：\n- 在拖放结束时，所拖动的元素要放在哪里 —— 执行相应的行为\n- 并且，最好知道我们所拖动到的 \"droppable\" 的元素的位置，并高亮显示 \"droppable\" 的元素。\n\n这个解决方案很有意思，只是有点麻烦，所以我们在这儿对此进行介绍。\n\n第一个想法是什么？可能是将 `onmouseover/mouseup` 处理程序放在潜在的 \"droppable\" 的元素中？\n\n但这行不通。\n\n问题在于，当我们拖动时，可拖动元素一直是位于其他元素上的。而鼠标事件只发生在顶部元素上，而不是发生在那些下面的元素。\n\n例如，下面有两个 `<div>` 元素，红色的在蓝色的上面（完全覆盖）。这里，在蓝色的 `<div>` 中没有办法来捕获事件，因为红色的 `<div>` 在它上面：\n\n```html run autorun height=60\n<style>\n  div {\n    width: 50px;\n    height: 50px;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div style=\"background:blue\" onmouseover=\"alert('never works')\"></div>\n<div style=\"background:red\" onmouseover=\"alert('over red!')\"></div>\n```\n\n与可拖动的元素相同。球始终位于其他元素之上，因此事件会发生在球上。无论我们在较低的元素上设置什么处理程序，它们都不会起作用。\n\n这就是一开始的那个想法，将处理程序放在潜在的 \"droppable\" 的元素，在实际操作中不起作用的原因。它们不会运行。\n\n那么，该怎么办？\n\n有一个叫做 `document.elementFromPoint(clientX, clientY)` 的方法。它会返回在给定的窗口相对坐标处的嵌套的最深的元素（如果给定的坐标在窗口外，则返回 `null`）。如果同一坐标上有多个重叠的元素，则返回最上面的元素。\n\n我们可以在我们的任何鼠标事件处理程序中使用它，以检测鼠标指针下的潜在的 \"droppable\" 的元素，就像这样：\n\n```js\n// 在一个鼠标事件处理程序中\nball.hidden = true; // (*) 隐藏我们拖动的元素\n\nlet elemBelow = document.elementFromPoint(event.clientX, event.clientY);\n// elemBelow 是球下方的元素，可能是 droppable 的元素\n\nball.hidden = false;\n```\n\n请注意：我们需要在调用 `(*)` 之前隐藏球。否则，我们通常会在这些坐标上有一个球，因为它是在鼠标指针下的最顶部的元素：`elemBelow=ball`。\n\n我们可以使用该代码来检查我们正在“飞过”的元素是什么。并在放置（drop）时，对放置进行处理。\n\n基于 `onMouseMove` 扩展的代码，用于查找 \"droppable\" 的元素：\n\n```js\n// 我们当前正在飞过的潜在的 droppable 的元素\nlet currentDroppable = null;\n\nfunction onMouseMove(event) {\n  moveAt(event.pageX, event.pageY);\n\n  ball.hidden = true;\n  let elemBelow = document.elementFromPoint(event.clientX, event.clientY);\n  ball.hidden = false;\n\n  // mousemove 事件可能会在窗口外被触发（当球被拖出屏幕时）\n  // 如果 clientX/clientY 在窗口外，那么 elementfromPoint 会返回 null\n  if (!elemBelow) return;\n\n  // 潜在的 droppable 的元素被使用 \"droppable\" 类进行标记（也可以是其他逻辑）\n  let droppableBelow = elemBelow.closest('.droppable');\n\n  if (currentDroppable != droppableBelow) {\n    // 我们正在飞入或飞出...\n    // 注意：它们两个的值都可能为 null\n    //   currentDroppable=null —— 如果我们在此事件之前，鼠标指针不是在一个 droppable 的元素上（例如空白处）\n    //   droppableBelow=null —— 如果现在，在当前事件中，我们的鼠标指针不是在一个 droppable 的元素上\n\n    if (currentDroppable) {\n      // 处理“飞出” droppable 的元素时的处理逻辑（移除高亮）\n      leaveDroppable(currentDroppable);\n    }\n    currentDroppable = droppableBelow;\n    if (currentDroppable) {\n      // 处理“飞入” droppable 的元素时的逻辑\n      enterDroppable(currentDroppable);\n    }\n  }\n}\n```\n\n在下面这个示例中，当球被拖到球门上时，球门会被高亮显示。\n\n[codetabs height=250 src=\"ball4\"]\n\n现在，我们在整个处理过程中，在当前变量 `currentDroppable` 中都存储了当前的“放置目标”，可以用它来进行高亮显示或者其他操作。\n\n## 总结\n\n我们考虑了一种基础的拖放算法。\n\n关键部分：\n\n1. 事件流：`ball.mousedown` -> `document.mousemove` -> `ball.mouseup`（不要忘记取消原生 `ondragstart`）。\n2. 在拖动开始时 —— 记住鼠标指针相对于元素的初始偏移（shift）：`shiftX/shiftY`，并在拖动过程中保持它不变。\n3. 使用 `document.elementFromPoint` 检测鼠标指针下的 \"droppable\" 的元素。\n\n我们可以在此基础上做很多事情。\n\n- 在 `mouseup` 上，我们可以智能地完成放置（drop）：更改数据，移动元素。\n- 我们可以高亮我们正在“飞过”的元素。\n- 我们可以将拖动限制在特定的区域或者方向。\n- 我们可以对 `mousedown/up` 使用事件委托。一个大范围的用于检查 `event.target` 的事件处理程序可以管理数百个元素的拖放。\n- 等。\n\n有一些在此基础上已经将体系结构构建好的框架：`DragZone`，`Droppable`，`Draggable` 及其他 class。它们中的大多数做的都是与上述类似的事情，所以现在你应该很容易理解它们了。或者自己动手实现。正如你所看到的，其实挺简单的，有时候比基于第三方解决方案进行改写还容易。",
        "libs": [],
        "children": [
          "slider",
          "drag-heroes"
        ],
        "parent": "event-details",
        "updatedAt": 1657705346
      }
    },
    "slider": {
      "type": "Task",
      "value": {
        "title": "滑动条",
        "slug": "slider",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop/1-slider",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个滑动条（slider）：\n\n[iframe src=\"solution\" height=60 border=1]\n\n用鼠标拖动蓝色的滑块（thumb）并移动它。\n\n重要的细节：\n\n- 当鼠标按钮被按下时，在滑动过程中，鼠标指针可能会移动到滑块的上方或下方。此时滑块仍会继续移动（方便用户）。\n- 如果鼠标非常快地向左边或者向右边移动，那么滑块应该恰好停在边缘。",
        "solution": "正如我们从 HTML/CSS 中所看到的，滑动条就是一个带有彩色背景的 `<div>`，其中包含一个滑块 —— 另一个具有 `position:relative` 的 `<div>`。\n\n为了对滑块进行定位，我们使用 `position:relative` 来提供相对于其父元素的坐标，在这儿它比 `position:absolute` 更方便。\n\n然后我们通过限制宽度来实现仅水平方向的拖放。",
        "parent": "mouse-drag-and-drop",
        "version": 1
      }
    },
    "drag-heroes": {
      "type": "Task",
      "value": {
        "title": "将超级英雄放置在足球场周围",
        "slug": "drag-heroes",
        "githubPath": "/2-ui/3-event-details/4-mouse-drag-and-drop/2-drag-heroes",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n这个任务可以帮助你检查你对拖放和 DOM 的一些方面的理解程度。\n\n使所有元素都具有类 `draggable` —— 可拖动。就像本章中的球一样。\n\n要求：\n\n- 使用事件委托来跟踪拖动的开始：一个在 `document` 上的用于 `mousedown` 的处理程序。\n- 如果元素被拖动到了窗口的顶端/末端 —— 页面会向上/向下滚动以允许进一步的拖动。\n- 没有水平滚动（这使本任务更简单，但添加水平滚动也很简单）。\n- 即使在快速移动鼠标后，可拖动元素或该元素的部分也绝不应该离开窗口。\n\n这个示例太大了，不适合放在这里，所以在下面给出了示例链接。\n\n[demo src=\"solution\"]",
        "solution": "要拖动元素，我们可以使用 `position:fixed`，它使坐标更易于管理。最后，我们应该将其切换回 `position:absolute`，以使元素放置到文档中。\n\n当坐标位于窗口顶端/底端时，我们使用 `window.scrollTo` 来滚动它。\n\n更多细节请见代码注释。",
        "parent": "mouse-drag-and-drop",
        "version": 1
      }
    },
    "pointer-events": {
      "type": "Article",
      "value": {
        "title": "指针事件",
        "slug": "pointer-events",
        "githubPath": "/2-ui/3-event-details/6-pointer-events",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n指针事件（Pointer Events）是一种用于处理来自各种输入设备（例如鼠标、触控笔和触摸屏等）的输入信息的现代化解决方案。\n\n## 一段简史\n\n让我们先做一个简短的概览，以便你对指针事件及其在其它事件类型中所处位置有个粗略认识。\n\n- 很早以前，只存在鼠标事件。\n\n    后来，触屏设备开始普及，尤其是手机和平板电脑。为了使现有的脚本仍能正常工作，它们生成（现在仍生成）鼠标事件。例如，轻触屏幕就会生成 `mousedown` 事件。因此，触摸设备可以很好地与网页配合使用。\n\n    但是，触摸设备比鼠标具有更多的功能。例如，我们可以同时触控多点（多点触控）。然而，鼠标事件并没有相关属性来处理这种多点触控。\n\n- 因此，引入了触摸事件，例如 `touchstart`、`touchend` 和 `touchmove`，它们具有特定于触摸的属性（这里不再赘述这些特性，因为指针事件更加完善）。\n\n    不过这还是不够完美。因为很多其他输入设备（如触控笔）都有自己的特性。而且同时维护两份分别处理鼠标事件和触摸事件的代码，显得有些笨重了。\n\n- 为了解决这些问题，人们引入了全新的规范「指针事件」。它为各种指针输入设备提供了一套统一的事件。\n\n目前，各大主流浏览器已经支持了 [Pointer Events Level 2](https://www.w3.org/TR/pointerevents2/) 标准，版本更新的 [Pointer Events Level 3](https://w3c.github.io/pointerevents/) 已经发布，并且大多数情况下与 Pointer Events Level 2 兼容。\n\n因此，除非你写的代码需要兼容旧版本的浏览器，例如 IE 10 或 Safari 12 或更低的版本，否则无需继续使用鼠标事件或触摸事件 —— 我们可以使用指针事件。\n\n这样，你的代码就可以在触摸设备和鼠标设备上都能正常工作了。\n\n话虽如此，指针事件仍然有一些重要的奇怪特性，你应当对它们有所了解以正确使用指针事件，并避免一些意料之外的错误。我们将在本文中对它们进行介绍。\n\n## 指针事件类型\n\n指针事件的命名方式和鼠标事件类似：\n\n| 指针事件 | 类似的鼠标事件 |\n|---------------|-------------|\n| `pointerdown` | `mousedown` |\n| `pointerup` | `mouseup` |\n| `pointermove` | `mousemove` |\n| `pointerover` | `mouseover` |\n| `pointerout` | `mouseout` |\n| `pointerenter` | `mouseenter` |\n| `pointerleave` | `mouseleave` |\n| `pointercancel` | - |\n| `gotpointercapture` | - |\n| `lostpointercapture` | - |\n\n不难发现，每一个 `mouse<event>` 都有与之相对应的 `pointer<event>`。同时还有 3 个额外的事件没有相应的 `mouse...`，我们会在稍后详细解释它们。\n\n```smart header=\"在代码中用 `pointer<event>` 替换 `mouse<event>`\"\n我们可以把代码中的 `mouse<event>` 都替换成 `pointer<event>`，程序仍然正常兼容鼠标设备。\n\n替换之后，程序对触屏设备的支持会“魔法般”地提升。但是，我们可能需要在 CSS 中的某些地方添加 `touch-action: none`。我们会在下文的 `pointercancel` 一节中描述这里面的细节。\n```\n\n## 指针事件属性\n\n指针事件具备和鼠标事件完全相同的属性，包括 `clientX/Y` 和 `target` 等，以及一些其他属性：\n\n- `pointerId` —— 触发当前事件的指针唯一标识符。\n\n    浏览器生成的。使我们能够处理多指针的情况，例如带有触控笔和多点触控功能的触摸屏（下文会有相关示例）。\n- `pointerType` —— 指针的设备类型。必须为字符串，可以是：\"mouse\"、\"pen\" 或 \"touch\"。\n\n    我们可以使用这个属性来针对不同类型的指针输入做出不同响应。\n- `isPrimary` —— 当指针为首要指针（多点触控时按下的第一根手指）时为 `true`。\n\n有些指针设备会测量接触面积和点按压力（例如一根手指压在触屏上），对于这种情况可以使用以下属性：\n\n- `width` —— 指针（例如手指）接触设备的区域的宽度。对于不支持的设备（如鼠标），这个值总是 `1`。\n- `height` —— 指针（例如手指）接触设备的区域的长度。对于不支持的设备，这个值总是 `1`。\n- `pressure` —— 触摸压力，是一个介于 0 到 1 之间的浮点数。对于不支持压力检测的设备，这个值总是 `0.5`（按下时）或 `0`。\n- `tangentialPressure` —— 归一化后的切向压力（tangential pressure）。\n- `tiltX`, `tiltY`, `twist` —— 针对触摸笔的几个属性，用于描述笔和屏幕表面的相对位置。\n\n大多数设备都不支持这些属性，因此它们很少被使用。如果你需要使用它们，可以在 [规范文档](https://w3c.github.io/pointerevents/#pointerevent-interface) 中查看更多有关它们的详细信息。\n\n## 多点触控\n\n多点触控（用户在手机或平板上同时点击若干个位置，或执行特殊手势）是鼠标事件完全不支持的功能之一。\n\n指针事件使我们能够通过 `pointerId` 和 `isPrimary` 属性的帮助，能够处理多点触控。\n\n当用户用一根手指触摸触摸屏的某个位置，然后将另一根手指放在该触摸屏的其他位置时，会发生以下情况：\n\n1. 第一个手指触摸：\n    - `pointerdown` 事件触发，`isPrimary=true`，并且被指派了一个 `pointerId`。\n2. 第二个和后续的更多个手指触摸（假设第一个手指仍在触摸）：\n    - `pointerdown` 事件触发，`isPrimary=false`，并且每一个触摸都被指派了不同的 `pointerId`。\n\n请注意：`pointerId` 不是分配给整个设备的，而是分配给每一个触摸的。如果 5 根手指同时触摸屏幕，我们会得到 5 个 `pointerdown` 事件和相应的坐标以及 5 个不同的 `pointerId`。\n\n和第一个触摸相关联的事件总有 `isPrimary=true`。\n\n利用 `pointerId`，我们可以追踪多根正在触摸屏幕的手指。当用户移动或抬起某根手指时，我们会得到和 `pointerdown` 事件具有相同 `pointerId` 的 `pointermove` 或 `pointerup` 事件。\n\n```online\n这是一个记录 `pointerdown` 和 `pointerup` 事件的演示:\n\n[iframe src=\"multitouch\" edit height=200]\n\n请注意：你使用的必须是一个多点触控设备（如平板或手机）才能在 `pointerId/isPrimary` 中看到区别。对于使用鼠标这样的单点触控设备，所有指针事件都会具有相同的 `pointerId` 和 `isPrimary=true` 属性。\n```\n\n## 事件：pointercancel\n\n`pointercancel` 事件将会在一个正处于活跃状态的指针交互由于某些原因被中断时触发。也就是在这个事件之后，该指针就不会继续触发更多事件了。\n\n导致指针中断的可能原因如下：\n- 指针设备硬件在物理层面上被禁用。\n- 设备方向旋转（例如给平板转了个方向）。\n- 浏览器打算自行处理这一交互，比如将其看作是一个专门的鼠标手势或缩放操作等。\n\n我们会用一个实际例子来阐释 `pointercancel` 的影响。\n\n例如，我们想要实现一个像 <info:mouse-drag-and-drop> 中开头提到的那样的一个对球的拖放操作。\n\n用户的操作流和对应的事件如下：\n\n1) 用户按住了一张图片，开始拖拽\n    - `pointerdown` 事件触发\n2) 用户开始移动指针（从而拖动图片）\n    - `pointermove` 事件触发，可能触发多次\n3) 然后意料之外的情况发生了！浏览器有自己原生的图片拖放操作，接管了之前的拖放过程，于是触发了 `pointercancel` 事件。\n    - 现在拖放图片的操作由浏览器自行实现。用户甚至可能会把图片拖出浏览器，放进他们的邮件程序或文件管理器。\n    - 我们不会再得到 `pointermove` 事件了。\n\n这里的问题就在于浏览器”劫持“了这一个互动操作：在“拖放”过程开始时触发了 `pointercancel` 事件，并且不再有 `pointermove` 事件会被生成。\n\n```online\n这里是拖放示例的演示，并且在拖放过程中，指针事件（只包含 `up/down`、`move` 和 `cancel`）的触发会被记录在 `textarea` 中：\n\n[iframe src=\"ball\" height=240 edit]\n```\n\n我们想要实现自己的拖放操作，所以让我们来看看如何告诉浏览器不要接管拖放操作。\n\n**阻止浏览器的默认行为来防止 `pointercancel` 触发。**\n\n我们需要做两件事：\n\n1. 阻止原生的拖放操作发生：\n    - 正如我们在 <info:mouse-drag-and-drop> 中描述的那样，我们可以通过设置 `ball.ondragstart = () => false` 来实现这一需求。\n    - 这种方式也适用于鼠标事件。\n2. 对于触屏设备，还有其他和触摸相关的浏览器行为（除了拖放）。为了避免它们所引发的问题：\n    - 我们可以通过在 CSS 中设置 `#ball { touch-action: none }` 来阻止它们。\n    - 之后我们的代码便可以在触屏设备中正常工作了。\n\n经过上述操作，事件将会按照我们预期的方式触发，浏览器不会劫持拖放过程，也不会触发 `pointercancel` 事件。\n\n```online\n这个演示增加了以下几行：\n\n[iframe src=\"ball-2\" height=240 edit]\n\n可以看到，`pointercancel` 事件不再被触发。\n```\n\n现在我们就可以添加让球的位置移动的代码了，并且我们的代码对鼠标和触控设备都有效。\n\n## 指针捕获\n\n指针捕获（Pointer capturing）是针对指针事件的一个特性。\n\n这个想法很简单，但是乍一看可能感觉很奇怪，因为在其他任何事件类型中都没有这种东西。\n\n主要的方法是：\n- `elem.setPointerCapture(pointerId)` —— 将给定的 `pointerId` 绑定到 `elem`。在调用之后，所有具有相同 `pointerId` 的指针事件都将 `elem` 作为目标（就像事件发生在 `elem` 上一样），无论这些 `elem` 在文档中的实际位置是什么。\n\n换句话说，`elem.setPointerCapture(pointerId)` 将所有具有给定 `pointerId` 的后续事件重新定位到 `elem`。\n\n绑定会在以下情况下被移除：\n- 当 `pointerup` 或 `pointercancel` 事件出现时，绑定会被自动地移除。\n- 当 `elem` 被从文档中移除后，绑定会被自动地移除。\n- 当 `elem.releasePointerCapture(pointerId)` 被调用，绑定会被移除。\n\n那么，它有什么用？我们一起来看一个实际的例子吧。\n\n**指针捕获可以被用于简化拖放类的交互。**\n\n让我们来回忆一下在 <info:mouse-drag-and-drop> 中提到的，如何实现一个自定义滑动条。\n\n我们可以创建一个带有条形图的、并且内部有一个“滑块”（`thumb`）的滑动条元素（`slider`）：\n\n```html\n<div class=\"slider\">\n  <div class=\"thumb\"></div>\n</div>\n```\n\n添加样式后的效果如下：\n\n[iframe src=\"slider-html\" height=40 edit]\n\n<p></p>\n\n用指针事件替换鼠标事件后的实现逻辑：\n\n1. 用户按下滑动条的滑块 `thumb` —— `pointerdown` 事件被触发。\n2. 然后用户移动指针 —— `pointermove` 事件被触发，我们让移动事件只作用在 `thumb` 上。\n    - ……在指针的移动过程中，指针可能会离开滑动条的 `thumb` 元素，移动到 `thumb` 之上或之下的位置。而 `thumb` 应该严格在水平方向上移动，并与指针保持对齐。\n\n在基于鼠标事件实现的方案中，要跟踪指针的所有移动，包括指针移动到 `thumb` 之上或之下的位置时，我们必须在整个文档 `document` 上分配 `mousemove` 事件处理程序。\n\n不过，这并不是一个没有副作用的解决方案。其中的一个问题就是，指针在文档周围的移动可能会引起副作用，在其他元素上触发事件处理程序（例如 `mouseover`）并调用其他元素上与滑动条不相关的功能，这不是我们预期的效果。\n\n这就是 `setPointerCapture` 适用的场景。\n\n- 我们可以在 `pointerdown` 事件的处理程序中调用 `thumb.setPointerCapture(event.pointerId)`，\n- 这样接下来在 `pointerup/cancel` 之前发生的所有指针事件都会被重定向到 `thumb` 上。\n- 当 `pointerup` 发生时（拖动完成），绑定会被自动移除，我们不需要关心它。\n\n因此，即使用户在整个文档上移动指针，事件处理程序也将仅在 `thumb` 上被调用。尽管如此，事件对象的坐标属性，例如 `clientX/clientY` 仍将是正确的 —— 捕获仅影响 `target/currentTarget`。\n\n主要代码如下：\n\n```js\nthumb.onpointerdown = function(event) {\n  // 把所有指针事件（pointerup 之前发生的）重定向到 thumb\n  thumb.setPointerCapture(event.pointerId);\n\n  // 开始跟踪指针的移动\n  thumb.onpointermove = function(event) {\n    // 移动滑动条：在 thumb 上监听即可，因为所有指针事件都被重定向到了 thumb\n    let newLeft = event.clientX - slider.getBoundingClientRect().left;\n    thumb.style.left = newLeft + 'px';\n  };\n\n  // 当结束(pointerup)时取消对指针移动的跟踪\n  thumb.onpointerup = function(event) {\n    thumb.onpointermove = null;\n    thumb.onpointerup = null;\n    // ...这里还可以处理“拖动结束”相关的逻辑\n  };\n};\n\n// 注意：无需调用 thumb.releasePointerCapture，\n// 它会在 pointerup 时被自动调用\n```\n\n```online\n完整示例：\n\n[iframe src=\"slider\" height=100 edit]\n\n<p></p>\n\n在这个 demo 中还有一个元素，当它的 `onmouseover` 处理程序被触发时会显示当前的时间。\n\n请注意：当你拖动滑块的时候，鼠标可能会悬停在这个元素上，它的 `onmouseover` 处理程序**不会**被触发。\n\n借助于 `setPointerCapture`，现在拖动滑块不会再产生副作用了。\n```\n\n言而总之，指针捕获为我们带来了两个好处：\n1. 代码变得更加简洁，我们不再需要在整个 `document` 上添加/移除处理程序。绑定会被自动释放。\n2. 如果文档中有其他指针事件处理程序，则在用户拖动滑动条时，它们不会因指针的移动被意外地触发。\n\n### 指针捕获事件\n\n完整起见，这里还需要提及一个知识点。\n\n还有两个与指针捕获相关的事件：\n\n- `gotpointercapture` 会在一个元素使用 `setPointerCapture` 来启用捕获后触发。\n- `lostpointercapture` 会在捕获被释放后触发：其触发可能是由于 `releasePointerCapture` 的显式调用，或是 `pointerup`/`pointercancel` 事件触发后的自动调用。\n\n## 总结\n\n指针事件允许我们通过一份代码，同时处理鼠标、触摸和触控笔事件。\n\n指针事件是鼠标事件的拓展。我们可以在事件名称中用 `pointer` 替换 `mouse` 来让我们的代码既能继续支持鼠标，也能更好地支持其他类型的设备。\n\n对于浏览器可能会决定进行劫持并自行处理的拖放和复杂的触控交互 —— 请记住取消事件的默认操作，并在 CSS 中为涉及到的元素设置 `touch-action: none`。\n\n指针事件还额外具备以下能力：\n\n- 基于 `pointerId` 和 `isPrimary` 的多点触控支持。\n- 针对特定设备的属性，例如 `pressure` 和 `width/height` 等。\n- 指针捕获：我们可以把 `pointerup`/`pointercancel` 之前的所有指针事件重定向到一个特定的元素。\n\n目前，指针事件已经被各大主流浏览器支持，尤其是如果不需要支持 IE10 和 Safari 12 以下的版本，我们可以放心地使用它们。不过即便是针对这些老式浏览器，也可以通过 polyfill 来让它们支持指针事件。",
        "libs": [],
        "children": [],
        "parent": "event-details",
        "updatedAt": 1659365915
      }
    },
    "keyboard-events": {
      "type": "Article",
      "value": {
        "title": "键盘：keydown 和 keyup",
        "slug": "keyboard-events",
        "githubPath": "/2-ui/3-event-details/7-keyboard-events",
        "isFolder": false,
        "weight": 7,
        "content": "\n\n在我们开始学习键盘的相关内容之前，请注意，在现代设备上，还有其他“输入内容”的方法。例如，人们使用语音识别（尤其是在移动端设备上）或用鼠标复制/粘贴。\n\n因此，如果我们想要跟踪 `<input>` 字段中的所有输入，那么键盘事件是不够的。无论如何，还需要一个名为 `input` 的事件来跟踪 `<input>` 字段中的更改。对于这样的任务来说，这可能是一个更好的选择。稍后我们将在 <info:events-change-input> 一章中介绍它们。\n\n当我们想要处理键盘行为时，应该使用键盘事件（虚拟键盘也算）。例如，对方向键 `key:Up` 和 `key:Down` 或热键（包括按键的组合）作出反应。\n\n\n## 测试台 [#keyboard-test-stand]\n\n```offline\n为了更好地理解键盘事件，你可以使用下面这个 [测试台](sandbox:keyboard-dump)。\n```\n\n```online\n为了更好地理解键盘事件，你可以使用下面这个测试台。\n\n在文本区域中尝试使用不同的组合键。\n\n[codetabs src=\"keyboard-dump\" height=480]\n```\n\n\n## Keydown 和 keyup\n\n当一个按键被按下时，会触发 `keydown` 事件，而当按键被释放时，会触发 `keyup` 事件。\n\n### event.code 和 event.key\n\n事件对象的 `key` 属性允许获取字符，而事件对象的 `code` 属性则允许获取“物理按键代码”。\n\n例如，同一个按键 `key:Z`，可以与或不与 `Shift` 一起按下。我们会得到两个不同的字符：小写的 `z` 和大写的 `Z`。\n\n`event.key` 正是这个字符，并且它将是不同的。但是，`event.code` 是相同的：\n\n| Key          | `event.key` | `event.code` |\n|--------------|-------------|--------------|\n| `key:Z`      |`z`（小写）     |`KeyZ`        |\n| `key:Shift+Z`|`Z`（大写）     |`KeyZ`        |\n\n\n如果用户使用不同的语言，那么切换到另一种语言将产生完全不同的字符，而不是 `\"Z\"`。它将成为 `event.key` 的值，而 `event.code` 则始终都是一样的：`\"KeyZ\"`。\n\n```smart header=\"\\\"KeyZ\\\" 和其他按键代码\"\n每个按键的代码都取决于该按键在键盘上的位置。[UI 事件代码规范](https://www.w3.org/TR/uievents-code/) 中描述了按键代码。\n\n例如：\n- 字符键的代码为 `\"Key<letter>\"`：`\"KeyA\"`，`\"KeyB\"` 等。\n- 数字键的代码为：`\"Digit<number>\"`：`\"Digit0\"`，`\"Digit1\"` 等。\n- 特殊按键的代码为按键的名字：`\"Enter\"`，`\"Backspace\"`，`\"Tab\"` 等。\n\n有几种广泛应用的键盘布局，该规范给出了每种布局的按键代码。\n\n有关更多按键代码，请参见 [规范的字母数字部分](https://www.w3.org/TR/uievents-code/#key-alphanumeric-section)，或者只需在上面的 [测试台](#keyboard-test-stand) 中按下一个按键。\n```\n\n```warn header=\"大小写敏感：`\\\"KeyZ\\\"`，不是 `\\\"keyZ\\\"`\"\n这是显而易见的，但人们仍会搞错。\n\n请规避错误类型：它是 `KeyZ`，而不是 `keyZ`。像 `event.code==\"keyZ\"` 这样的检查不起作用：`\"Key\"` 的首字母必须大写。\n```\n\n如果按键没有给出任何字符呢？例如，`key:Shift` 或 `key:F1` 或其他。对于这些按键，它们的 `event.key` 与 `event.code` 大致相同：\n\n| Key          | `event.key` | `event.code` |\n|--------------|-------------|--------------|\n| `key:F1`      |`F1`          |`F1`        |\n| `key:Backspace`      |`Backspace`          |`Backspace`        |\n| `key:Shift`|`Shift`          |`ShiftRight` 或 `ShiftLeft`       |\n\n请注意，`event.code` 准确地标明了哪个键被按下了。例如，大多数键盘有两个 `key:Shift` 键，一个在左边，一个在右边。`event.code` 会准确地告诉我们按下了哪个键，而 `event.key` 对按键的“含义”负责：它是什么（一个 \"Shift\"）。\n\n假设，我们要处理一个热键：`key:Ctrl+Z`（或 Mac 上的 `key:Cmd+Z`）。大多数文本编辑器将“撤销”行为挂在其上。我们可以在 `keydown` 上设置一个监听器，并检查哪个键被按下了。\n\n这里有个难题：在这样的监听器中，我们应该检查 `event.key` 的值还是 `event.code` 的值？\n\n一方面，`event.key` 的值是一个字符，它随语言而改变。如果访问者在 OS 中使用多种语言，并在它们之间进行切换，那么相同的按键将给出不同的字符。因此检查 `event.code` 会更好，因为它总是相同的。\n\n像这样：\n\n```js run\ndocument.addEventListener('keydown', function(event) {\n  if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {\n    alert('Undo!')\n  }\n});\n```\n\n另一方面，`event.code` 有一个问题。对于不同的键盘布局，相同的按键可能会具有不同的字符。\n\n例如，下面是美式布局（\"QWERTY\"）和德式布局（\"QWERTZ\"）—— 来自 Wikipedia：\n\n![](us-layout.svg)\n\n![](german-layout.svg)\n\n对于同一个按键，美式布局为 \"Z\"，而德式布局为 \"Y\"（字母被替换了）。\n\n从字面上看，对于使用德式布局键盘的人来说，但他们按下 `key:Y` 时，`event.code` 将等于 `KeyZ`。\n\n如果我们在代码中检查 `event.code == 'KeyZ'`，那么对于使用德式布局键盘的人来说，当他们按下 `key:Y` 时，这个测试就通过了。\n\n听起来确实很怪，但事实确实如此。[规范](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system) 中明确提到了这种行为。\n\n因此，`event.code` 可能由于意外的键盘布局而与错误的字符进行了匹配。不同键盘布局中的相同字母可能会映射到不同的物理键，从而导致了它们有不同的代码。幸运的是，这种情况只发生在几个代码上，例如 `keyA`，`keyQ`，`keyZ`（我们已经看到了），而对于诸如 `Shift` 这样的特殊按键没有发生这种情况。你可以在 [规范](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system) 中找到该列表。\n\n为了可靠地跟踪与受键盘布局影响的字符，使用 `event.key` 可能是一个更好的方式。\n\n另一方面，`event.code` 的好处是，绑定到物理键位置的 `event.code` 会始终保持不变。因此，即使在切换了语言的情况下，依赖于它的热键也能正常工作。\n\n我们想要处理与布局有关的按键？那么 `event.key` 是我们必选的方式。\n\n或者我们希望一个热键即使在切换了语言后，仍能正常使用？那么 `event.code` 可能会更好。\n\n## 自动重复\n\n如果按下一个键足够长的时间，它就会开始“自动重复”：`keydown` 会被一次又一次地触发，然后当按键被释放时，我们最终会得到 `keyup`。因此，有很多 `keydown` 却只有一个 `keyup` 是很正常的。\n\n对于由自动重复触发的事件，`event` 对象的 `event.repeat` 属性被设置为 `true`。\n\n\n## 默认行为\n\n默认行为各不相同，因为键盘可能会触发很多可能的东西。\n\n例如：\n\n- 出现在屏幕上的一个字符（最明显的结果）。\n- 一个字符被删除（`key:Delete` 键）。\n- 滚动页面（`key:PageDown` 键）。\n- 浏览器打开“保存页面”对话框（`key:Ctrl+S`）\n-  ……等。\n\n阻止对 `keydown` 的默认行为可以取消大多数的行为，但基于 OS 的特殊按键除外。例如，在 Windows 中，`key:Alt+F4` 会关闭当前浏览器窗口。并且无法通过在 JavaScript 中阻止默认行为来阻止它。\n\n例如，下面的这个 `<input>` 期望输入的内容为一个电话号码，因此它不会接受除数字，`+`，`()` 和 `-` 以外的按键：\n\n```html autorun height=60 run\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') || ['+','(',')','-'].includes(key);\n}\n</script>\n<input *!*onkeydown=\"return checkPhoneKey(event.key)\"*/!* placeholder=\"请输入手机号\" type=\"tel\">\n```\n\n这里 `onkeydown` 的处理程序使用 `checkPhoneKey` 来检查被按下的按键。如果它是有效的（`0..9` 或 `+-()` 之一），那么将返回 `true`，否则返回 `false`。\n\n我们都知道，像上面那样，从事件处理程序返回 `false` 会阻止事件的默认行为，所以如果按下的按键未通过按键检查，那么 `<input>` 中什么都不会出现（从事件处理程序返回 `true` 不会对任何行为产生影响，只有返回 `false` 会产生对应的影响）。\n\n请注意，像 `key:Backspace`、`key:Left`、`key:Right` 这样的特殊按键在 `<input>` 中无效。这是严格过滤器 `checkPhoneKey` 的副作用。这些按键会使 `checkPhoneKey` 返回 `false`。\n\n让我们将过滤条件放宽一点，允许 `key:Left`、`key:Right`、`key:Delete` 和 `key:Backspace` 按键：\n\n```html autorun height=60 run\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') ||\n    ['+','(',')','-',*!*'ArrowLeft','ArrowRight','Delete','Backspace'*/!*].includes(key);\n}\n</script>\n<input onkeydown=\"return checkPhoneKey(event.key)\" placeholder=\"Phone, please\" type=\"tel\">\n```\n\n现在方向键和删除键都能正常使用了。\n\n……即使我们对按键进行了过滤，但仍然可以使用鼠标右键单击 + 粘贴来输入任何内容。移动端设备提供了其他输入内容的方式。因此，这个过滤器并不是 100% 可靠。\n\n另一种方式是跟踪 `oninput` 事件 —— 在任何修改后都会触发此事件。这样我们就可以检查新的 `input.value`，并在其无效时修改它/高亮显示 `<input>`。或者我们可以同时使用这两个事件处理程序。\n\n## 历史遗留\n\n过去有一个 `keypress` 事件，还有事件对象的 `keyCode`、`charCode` 和 `which` 属性。\n\n大多数浏览器对它们都存在兼容性问题，以致使该规范的开发者不得不弃用它们并创建新的现代的事件（本文上面所讲的这些事件），除此之外别无选择。旧的代码仍然有效，因为浏览器还在支持它们，但现在完全没必要再使用它们。\n\n## 移动端键盘\n\n当使用虚拟/移动端键盘时，更正式一点的名字叫做 IME（Input-Method Editor），W3C 标准规定 KeyboardEvent 的 [`e.keyCode` 应该为 `229`](https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode)，并且 [`e.key` 应该为 `\"Unidentified\"`](https://www.w3.org/TR/uievents-key/#key-attr-values)。\n\n当按下某些按键（例如箭头或退格键）时，虽然其中一些键盘可能仍然使用正确的值来表示 `e.key`、`e.code`、`e.keyCode`...，但并不能保证所有情况下都能对应正确的值。所以你的键盘逻辑可能并不能保证适用于移动设备。\n\n## 总结\n\n按一个按键总是会产生一个键盘事件，无论是符号键，还是例如 `key:Shift` 或 `key:Ctrl` 等特殊按键。唯一的例外是有时会出现在笔记本电脑的键盘上的 `key:Fn` 键。它没有键盘事件，因为它通常是被在比 OS 更低的级别上实现的。\n\n键盘事件：\n\n- `keydown` —— 在按下键时（如果长按按键，则将自动重复），\n- `keyup` —— 释放按键时。\n\n键盘事件的主要属性：\n\n- `code` —— “按键代码”（`\"KeyA\"`，`\"ArrowLeft\"` 等），特定于键盘上按键的物理位置。\n- `key` —— 字符（`\"A\"`，`\"a\"` 等），对于非字符（non-character）的按键，通常具有与 `code` 相同的值。\n\n过去，键盘事件有时会被用于跟踪表单字段中的用户输入。这并不可靠，因为输入可能来自各种来源。我们有 `input` 和 `change` 事件来处理任何输入（稍后我们会在 <info:events-change-input> 一章中进行介绍）。它们在任何类型的输入（包括复制粘贴或语音识别）后触发。\n\n当我们真的想要键盘时，我们应该使用键盘事件。例如，对热键或特殊键作出反应。",
        "libs": [],
        "children": [
          "check-sync-keydown"
        ],
        "parent": "event-details",
        "updatedAt": 1650195000
      }
    },
    "check-sync-keydown": {
      "type": "Task",
      "value": {
        "title": "扩展热键",
        "slug": "check-sync-keydown",
        "githubPath": "/2-ui/3-event-details/7-keyboard-events/2-check-sync-keydown",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个 `runOnKeys(func, code1, code2, ... code_n)` 函数，在同时按下 `code1, code2, ... code_n` 键时运行函数 `func`。\n\n例如，当按键 `\"Q\"` 和 `\"W\"` 被一起按下时（任何语言中，无论是否 CapsLock），下面的代码将显示 `alert`：\n\n```js no-beautify\nrunOnKeys(\n  () => alert(\"Hello!\"),\n  \"KeyQ\",\n  \"KeyW\"\n);\n```\n\n[demo src=\"solution\"]",
        "solution": "我们应该使用两个处理程序：`document.onkeydown` 和 `document.onkeyup`。\n\n让我们创建一个集合 `pressed = new Set()` 来保存当前被按下的键。\n\n第一个处理程序把当前被按下的键添加到集合中，而第二个处理程序将被松开的按键从集合中移除。我们每次在 `keydown` 上检查我们是否按下了足够多的键，如果是，则运行函数 `func`。",
        "parent": "keyboard-events",
        "version": 1
      }
    },
    "onscroll": {
      "type": "Article",
      "value": {
        "title": "滚动",
        "slug": "onscroll",
        "githubPath": "/2-ui/3-event-details/8-onscroll",
        "isFolder": false,
        "weight": 8,
        "content": "\n\n`scroll` 事件允许对页面或元素滚动作出反应。我们可以在这里做一些有用的事情。\n\n例如：\n- 根据用户在文档中的位置显示/隐藏其他控件或信息。\n- 当用户向下滚动到页面末端时加载更多数据。\n\n这是一个显示当前滚动的小函数：\n\n```js autorun\nwindow.addEventListener('scroll', function() {\n  document.getElementById('showScroll').innerHTML = window.pageYOffset + 'px';\n});\n```\n\n```online\n在运行中：\n\nCurrent scroll = <b id=\"showScroll\">scroll the window</b>\n```\n\n`scroll` 事件在 `window` 和可滚动元素上都可以运行。\n\n## 防止滚动\n\n我们如何使某些东西变成不可滚动？\n\n我们不能通过在 `onscroll` 监听器中使用 `event.preventDefault()` 来阻止滚动，因为它会在滚动发生 **之后** 才触发。\n\n但是我们可以在导致滚动的事件上，例如在 `key:pageUp` 和 `key:pageDown` 的 `keydown` 事件上，使用 `event.preventDefault()` 来阻止滚动。\n\n如果我们向这些事件中添加事件处理程序，并向其中添加 `event.preventDefault()`，那么滚动就不会开始。\n\n启动滚动的方式有很多，使用 CSS 的 `overflow` 属性更加可靠。\n\n有几个练习题，你可以解决或者浏览以下几个任务来看一下 `onscroll` 的应用。",
        "libs": [],
        "children": [
          "endless-page",
          "updown-button",
          "load-visible-img"
        ],
        "parent": "event-details",
        "updatedAt": 1605278165
      }
    },
    "endless-page": {
      "type": "Task",
      "value": {
        "title": "无限的页面",
        "slug": "endless-page",
        "githubPath": "/2-ui/3-event-details/8-onscroll/1-endless-page",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个无限的页面。当访问者滚动到页面末端时，它会自动将当期日期时间附加到文本中（以便访问者可以滚动更多内容）。\n\n像这样：\n\n[iframe src=\"solution\" height=200]\n\n请注意滚动的两个重要特性：\n\n1. **滚动是“弹性的”**。在某些浏览器/设备中，我们可以在文档的顶端或末端稍微多滚动出一点（超出部分显示的是空白区域，然后文档将自动“弹回”到正常状态）。\n2. **滚动并不精确**。当我们滚动到页面末端时，实际上我们可能距真实的文档末端约 0-50px。\n\n因此，“滚动到末端”应该意味着访问者离文档末端的距离不超过 100px。\n\nP.S. 在现实生活中，我们可能希望显示“更多信息”或“更多商品”。",
        "solution": "解决方案的核心是一个函数，当我们在页面末端时，该函数可以向页面添加更多日期（或者在实际开发中是加载更多内容）。\n\n我们可以立即调用它，并将其添加为 `window.onscroll` 处理程序。\n\n最重要的问题是：“如何检测页面滚动到了末端？”\n\n让我们使用相对于窗口的坐标。\n\n文档（document）在 `<html>` 标签中被表示（被包含）为 `document.documentElement`。\n\n我们可以通过 `document.documentElement.getBoundingClientRect()` 来获取整个文档相对于窗口的坐标。`bottom` 属性将是文档末端的相对于窗口的坐标。\n\n例如，如果整个 HTML 文档的高度是 `2000px`，那么：\n\n```js\n// 当我们在页面顶端时\n// 相对于窗口 top = 0\ndocument.documentElement.getBoundingClientRect().top = 0\n\n// 相对于窗口 bottom = 2000\n// 如果文档太长，那么可能会远远超出窗口底部\ndocument.documentElement.getBoundingClientRect().bottom = 2000\n```\n\n如果我们向下滚动 `500px`，那么：\n\n```js\n// 文档顶端在窗口之方 500px\ndocument.documentElement.getBoundingClientRect().top = -500\n// 文档末端相对于窗口近了 500px\ndocument.documentElement.getBoundingClientRect().bottom = 1500\n```\n\n当我们滚动到文档末端时，假设窗口高度为 `600px`：\n\n\n```js\n// 文档顶端在窗口上方 -1400px\ndocument.documentElement.getBoundingClientRect().top = -1400\n// 文档末端相对于窗口坐标为 600px\ndocument.documentElement.getBoundingClientRect().bottom = 600\n```\n\n请注意，`bottom` 不能为 `0`，因为它永远不会到达窗口顶部。`bottom` 坐标的最低限度是窗口高度（我们假设其为 `600`），我们无法再向上滚动了。\n\n我们可以获得窗口的高度为 `document.documentElement.clientHeight`。\n\n对于本任务，我们需要知道何时文档末端距窗口底部不超过 `100px`（即，如果窗口高度为 `600px`，则为 `600-700px`）。\n\n所以，函数如下：\n\n```js\nfunction populate() {\n  while(true) {\n    // 文档末端\n    let windowRelativeBottom = document.documentElement.getBoundingClientRect().bottom;\n\n    // 如果用户将页面滚动的距离不够远（文档末端距窗口底部 >100px）\n    if (windowRelativeBottom > document.documentElement.clientHeight + 100) break;\n\n    // 让我们添加更多数据\n    document.body.insertAdjacentHTML(\"beforeend\", `<p>Date: ${new Date()}</p>`);\n  }\n}\n```",
        "parent": "onscroll",
        "version": 1
      }
    },
    "updown-button": {
      "type": "Task",
      "value": {
        "title": "Up/down 按钮",
        "slug": "updown-button",
        "githubPath": "/2-ui/3-event-details/8-onscroll/2-updown-button",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个“到顶部”按钮来帮助页面滚动。\n\n它应该像这样运行：\n- 页面向下滚动的距离没有超过窗口高度时 —— 按钮不可见。\n- 当页面向下滚动距离超过窗口高度时 —— 在左上角出现一个“向上”的箭头。如果页面回滚回去，箭头就会消失。\n- 单击箭头时，页面将滚动到顶部。\n\n像这样（左上角，滚动查看）：\n\n[iframe border=\"1\" height=\"200\" link src=\"solution\"]",
        "solution": "",
        "parent": "onscroll",
        "version": 1
      }
    },
    "load-visible-img": {
      "type": "Task",
      "value": {
        "title": "加载可视化图像",
        "slug": "load-visible-img",
        "githubPath": "/2-ui/3-event-details/8-onscroll/3-load-visible-img",
        "weight": 3,
        "libs": [],
        "importance": 4,
        "content": "\n\n假设我们有一个速度较慢的客户端，并且希望节省它们在移动端的流量。\n\n为此，我们决定不立即显示图像，而是将其替换为占位符，如下所示：\n\n```html\n<img *!*src=\"placeholder.svg\"*/!* width=\"128\" height=\"128\" *!*data-src=\"real.jpg\"*/!*>\n```\n\n因此，最初所有图像均为 `placeholder.svg`。当页面滚动到用户可以看到图像位置时 —— 我们就会将 `src` 更改为 `data-src` 的 `src`，从而加载图像。\n\n这是在 `iframe` 中的一个示例：\n\n[iframe src=\"solution\"]\n\n滚动它可以看到图像是“按需”加载的。\n\n要求：\n- 加载页面时，屏幕上的那些图像应该在滚动之前立即加载。\n- 有些图像可能是常规图像，没有 `data-src`。代码不应该改动它们。\n- 一旦图像被加载，它就不应该在滚动进/出时被重新加载。\n\nP.S. 如果你有能力，可以创建一个更高级的解决方案，以“预加载”当前位置下方/之后一页的图像。\n\nP.P.S. 仅处理垂直滚动，不处理水平滚动。",
        "solution": "`onscroll` 处理程序应该检查哪些图像是可见的，并显示它们。\n\n我们还希望在页面加载时运行它，以检测即将可见的图像并加载它们。\n\n该代码应该在文档加载完成时执行，以便可以访问文档内容。\n\n或者将该代码放在 `<body>` 底部：\n\n```js\n// ...页面内容在上面...\n\nfunction isVisible(elem) {\n\n  let coords = elem.getBoundingClientRect();\n\n  let windowHeight = document.documentElement.clientHeight;\n\n  // 顶部元素边缘可见吗？\n  let topVisible = coords.top > 0 && coords.top < windowHeight;\n\n  // 底部元素边缘可见吗？\n  let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;\n\n  return topVisible || bottomVisible;\n}\n```\n\n`showVisible()` 函数使用通过 `isVisible()` 实现的可见性检查，来加载可见图像：\n\n```js\nfunction showVisible() {\n  for (let img of document.querySelectorAll('img')) {\n    let realSrc = img.dataset.src;\n    if (!realSrc) continue;\n\n    if (isVisible(img)) {\n      img.src = realSrc;\n      img.dataset.src = '';\n    }\n  }\n}\n\n*!*\nshowVisible();\nwindow.onscroll = showVisible;\n*/!*\n```\n\nP.S. 此解决方案还有一个 `isVisible` 的变体，可以“预加载”当前文档滚动上方/下方 1 页内的图像",
        "parent": "onscroll",
        "version": 1
      }
    },
    "forms-controls": {
      "type": "Article",
      "value": {
        "title": "表单，控件",
        "slug": "forms-controls",
        "githubPath": "/2-ui/4-forms-controls",
        "isFolder": true,
        "weight": 4,
        "content": "\n\n表单 `<form>` 和控件的特殊属性和事件：`<input>`，`<select>` 及其他。",
        "libs": [],
        "children": [
          "form-elements",
          "focus-blur",
          "events-change-input",
          "forms-submit"
        ],
        "parent": "ui"
      }
    },
    "form-elements": {
      "type": "Article",
      "value": {
        "title": "表单属性和方法",
        "slug": "form-elements",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n表单（form）以及例如 `<input>` 的控件（control）元素有许多特殊的属性和事件。\n\n当我们学习了这些相关内容后，处理表单会变得更加方便。\n\n## 导航：表单和元素\n\n文档中的表单是特殊集合 `document.forms` 的成员。\n\n这就是所谓的“**命名的集合**”：既是被命名了的，也是有序的。我们既可以使用名字，也可以使用在文档中的编号来获取表单。\n\n```js no-beautify\ndocument.forms.my; // name=\"my\" 的表单\ndocument.forms[0]; // 文档中的第一个表单\n```\n\n当我们有了一个表单时，其中的任何元素都可以通过命名的集合 `form.elements` 来获取到。\n\n例如：\n\n```html run height=40\n<form name=\"my\">\n  <input name=\"one\" value=\"1\">\n  <input name=\"two\" value=\"2\">\n</form>\n\n<script>\n  // 获取表单\n  let form = document.forms.my; // <form name=\"my\"> 元素\n\n  // 获取表单中的元素\n  let elem = form.elements.one; // <input name=\"one\"> 元素\n\n  alert(elem.value); // 1\n</script>\n```\n\n可能会有多个名字相同的元素，这种情况经常在处理单选按钮中出现。\n\n在这种情况下，`form.elements[name]` 将会是一个**集合**。例如：\n\n```html run height=40\n<form>\n  <input type=\"radio\" *!*name=\"age\"*/!* value=\"10\">\n  <input type=\"radio\" *!*name=\"age\"*/!* value=\"20\">\n</form>\n\n<script>\nlet form = document.forms[0];\n\nlet ageElems = form.elements.age;\n\n*!*\nalert(ageElems[0]); // [object HTMLInputElement]\n*/!*\n</script>\n```\n\n这些导航（navigation）属性并不依赖于标签的结构。所有的控件元素，无论它们在表单中有多深，都可以通过 `form.elements` 获取到。\n\n\n````smart header=\"Fieldset 作为“子表单”\"\n一个表单内会有一个或多个 `<fieldset>` 元素。它们也具有 `elements` 属性，该属性列出了 `<fieldset>` 中的表单控件。\n\n例如：\n\n```html run height=80\n<body>\n  <form id=\"form\">\n    <fieldset name=\"userFields\">\n      <legend>info</legend>\n      <input name=\"login\" type=\"text\">\n    </fieldset>\n  </form>\n\n  <script>\n    alert(form.elements.login); // <input name=\"login\">\n\n*!*\n    let fieldset = form.elements.userFields;\n    alert(fieldset); // HTMLFieldSetElement\n\n    // 我们可以通过名字从表单和 fieldset 中获取 input\n    alert(fieldset.elements.login == form.elements.login); // true\n*/!*\n  </script>\n</body>\n```\n````\n\n````warn header=\"更简短的表示方式：`form.name`\"\n还有一个更简短的表示方式：我们可以通过 `form[index/name]` 来访问元素。\n\n换句话说，我们可以将 `form.elements.login` 写成 `form.login`。\n\n这也有效，但是会有一个小问题：如果我们访问一个元素，然后修改它的 `name`，之后它仍然可以被通过旧的 `name` 访问到（当然也能通过新的 `name` 访问）。\n\n我们可以很直观地通过一个例子看到这个情况：\n\n```html run height=40\n<form id=\"form\">\n  <input name=\"login\">\n</form>\n\n<script>\n  alert(form.elements.login == form.login); // true，与 <input> 相同\n\n  form.login.name = \"username\"; // 修改 input 的 name\n\n  // form.elements 更新了 name：\n  alert(form.elements.login); // undefined\n  alert(form.elements.username); // input\n\n*!*\n  // form 允许我们使用两个名字：新的名字和旧的名字\n  alert(form.username == form.login); // true\n*/!*\n</script>\n```\n\n这通常来说并不是一个问题，因为我们很少修改表单元素的名字。\n\n````\n\n## 反向引用：element.form\n\n对于任何元素，其对应的表单都可以通过 `element.form` 访问到。因此，表单引用了所有元素，元素也引用了表单。\n\n这是一张示意图：\n\n![](form-navigation.svg)\n\n例如：\n\n```html run height=40\n<form id=\"form\">\n  <input type=\"text\" name=\"login\">\n</form>\n\n<script>\n*!*\n  // form -> element\n  let login = form.login;\n\n  // element -> form\n  alert(login.form); // HTMLFormElement\n*/!*\n</script>\n```\n\n## 表单元素\n\n让我们来谈谈表单控件。\n\n### input 和 textarea\n\n我们可以通过 `input.value`（字符串）或 `input.checked`（布尔值）来访问复选框（checkbox）和单选按钮（radio button）中的 `value`。\n\n像这样：\n\n```js\ninput.value = \"New value\";\ntextarea.value = \"New text\";\n\ninput.checked = true; // 对于复选框（checkbox）或单选按钮（radio button）\n```\n\n```warn header=\"使用 `textarea.value` 而不是 `textarea.innerHTML`\"\n请注意，即使 `<textarea>...</textarea>` 将它们的 `value` 作为嵌套的 HTML 标签来保存，我们也绝不应该使用 `textarea.innerHTML` 来访问它。\n\n它仅存储最初在页面上的 HTML，而不是存储的当前 `value`。\n```\n\n### select 和 option\n\n一个 `<select>` 元素有 3 个重要的属性：\n\n1. `select.options` —— `<option>` 的子元素的集合，\n2. `select.value` —— 当前所选择的 `<option>` 的 **value**，\n3. `select.selectedIndex` —— 当前所选择的 `<option>` 的**编号**。\n\n它们提供了三种为 `<select>` 设置 `value` 的不同方式：\n\n1. 找到对应的 `<option>` 元素（例如在 `select.options` 中），并将其 `option.selected` 设置为 `true`。\n2. 如果我们知道新的值：将 `select.value` 设置为对应的新的值。\n3. 如果我们知道新的选项的索引：将 `select.selectedIndex` 设置为对应 `<option>` 的编号。\n\n下面是这三种方式的示例：\n\n```html run\n<select id=\"select\">\n  <option value=\"apple\">Apple</option>\n  <option value=\"pear\">Pear</option>\n  <option value=\"banana\">Banana</option>\n</select>\n\n<script>\n  // 下面这三行做的都是同一件事\n  select.options[2].selected = true;\n  select.selectedIndex = 2;\n  select.value = 'banana';\n  // 请注意：选项编号是从零开始的，所以编号 2 表示的是第三项\n</script>\n```\n\n和大多数其它控件不同，如果 `<select>` 具有 `multiple` 特性（attribute），则允许多选。尽管这个特性（attribute）很少被用到。\n\n对于多选的值，使用第一种设置值的方式：在 `<option>` 子元素中添加/移除 `selected` 属性。\n\n这是一个如何从多选的 `<select>` 中获取选择的值的示例：\n\n```html run\n<select id=\"select\" *!*multiple*/!*>\n  <option value=\"blues\" selected>Blues</option>\n  <option value=\"rock\" selected>Rock</option>\n  <option value=\"classic\">Classic</option>\n</select>\n\n<script>\n  // 从 multi-select 中获取所有选定的 `value`\n  let selected = Array.from(select.options)\n    .filter(option => option.selected)\n    .map(option => option.value);\n\n  alert(selected); // blues,rock  \n</script>\n```\n\n`<select>` 元素的完整规范可以在规范 <https://html.spec.whatwg.org/multipage/forms.html#the-select-element> 中找到。\n\n### new Option\n\n在 [规范](https://html.spec.whatwg.org/multipage/forms.html#the-option-element) 中，有一个很好的简短语法可以创建一个 `<option>` 元素：\n\n```js\noption = new Option(text, value, defaultSelected, selected);\n```\n\n此语法是可选的。我们可以使用 `document.createElement('option')` 并手动设置特性（attribute）。不过，这种语法写起来可能会更短，其参数如下：\n\n- `text` —— `<option>` 中的文本，\n- `value` —— `<option>` 的 `value`，\n- `defaultSelected` —— 如果为 `true`，那么 `selected` HTML-特性（attribute）就会被创建，\n- `selected` —— 如果为 `true`，那么这个 `<option>` 就会被选中。\n\n`defaultSelected` 和 `selected` 的区别是，`defaultSelected` 设置的是 HTML-特性（attribute），我们可以使用 `option.getAttribute('selected')` 来获得。而 `selected` 设置的是选项是否被选中。\n\n在实际使用中，通常应该将**同时**将这两个值设置为 `true` 或 `false`。（或者，直接省略它们；两者都默认为 `false`。）\n\n例如，下面是一个新的**未被选中的**选项：\n\n```js\nlet option = new Option(\"Text\", \"value\");\n// 创建 <option value=\"value\">Text</option>\n```\n\n相同的选项，但被选中了：\n\n```js\nlet option = new Option(\"Text\", \"value\", true, true);\n```\n\n`<option>` 元素具有以下属性：\n\n`option.selected`\n: `<option>` 是否被选择。\n\n`option.index`\n: `<option>` 在其所属的 `<select>` 中的编号。\n\n`option.text`\n: `<option>` 的文本内容（可以被访问者看到）。\n\n## 参考资料\n\n- 规范：<https://html.spec.whatwg.org/multipage/forms.html>.\n\n## 总结\n\n表单导航：\n\n`document.forms`\n: 一个表单元素可以通过 `document.forms[name/index]` 访问到。\n\n`form.elements`  \n: 表单元素可以通过 `form.elements[name/index]` 的方式访问，或者也可以使用 `form[name/index]`。`elements` 属性也适用于 `<fieldset>`。\n\n`element.form`\n: 元素通过 `form` 属性来引用它们所属的表单。\n\n`value` 可以被通过 `input.value`，`textarea.value`，`select.value` 等来获取到。（对于单选按钮（radio button）和复选框（checkbox），可以使用 `input.checked` 来确定是否选择了一个值。\n\n对于 `<select>`，我们可以通过索引 `select.selectedIndex` 来获取它的 `value`，也可以通过 `<option>` 集合 `select.options` 来获取它的 `value`。\n\n这些是开始使用表单的基础。我们将在本教程中进一步介绍更多示例。\n\n在下一章中，我们将介绍可能在任何元素上出现，但主要在表单上处理的 `focus` 和 `blur` 事件。",
        "libs": [],
        "children": [
          "add-select-option"
        ],
        "parent": "forms-controls",
        "updatedAt": 1659368107
      }
    },
    "add-select-option": {
      "type": "Task",
      "value": {
        "title": "在 select 元素中添加一个选项",
        "slug": "add-select-option",
        "githubPath": "/2-ui/4-forms-controls/1-form-elements/1-add-select-option",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n下面是一个 `<select>` 元素：\n\n```html\n<select id=\"genres\">\n  <option value=\"rock\">Rock</option>\n  <option value=\"blues\" selected>Blues</option>\n</select>\n```\n\n使用 JavaScript 来实现：\n\n1. 显示所选选项的值和文本。\n2. 添加一个选项：`<option value=\"classic\">Classic</option>`。\n3. 使之变为可选的。\n\n请注意，如果你已正确完成所有事项，那么 `alert` 应该显示 `blues`。",
        "solution": "解决方案，分步进行：\n\n```html run\n<select id=\"genres\">\n  <option value=\"rock\">Rock</option>\n  <option value=\"blues\" selected>Blues</option>\n</select>\n\n<script>\n  // 1)\n  let selectedOption = genres.options[genres.selectedIndex];\n  alert( selectedOption.value );\n\n  // 2)\n  let newOption = new Option(\"Classic\", \"classic\");\n  genres.append(newOption);\n\n  // 3)\n  newOption.selected = true;\n</script>\n```",
        "parent": "form-elements",
        "version": 1
      }
    },
    "focus-blur": {
      "type": "Article",
      "value": {
        "title": "聚焦：focus/blur",
        "slug": "focus-blur",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n当用户点击某个元素或使用键盘上的 `key:Tab` 键选中时，该元素将会获得聚焦（focus）。还有一个 HTML 特性（attribute）`autofocus` 可以让焦点在网页加载时默认落在一个元素上，此外还有其它途径可以获得焦点。\n\n聚焦到一个元素通常意味着：“准备在此处接受数据”，所以，这正是我们可以运行代码以初始化所需功能的时刻。\n\n失去焦点的时刻（“blur”）可能更为重要。它可能发生在用户点击页面的其它地方，或者按下 `key:Tab` 键跳转到下一个表单字段，亦或是其它途径的时候。\n\n失去焦点通常意味着：“数据已经输入完成”，所以我们可以运行代码来检查它，甚至可以将其保存到服务器上，或进行其他操作。\n\n当处理焦点事件时，有一些重要的特性。我们将尽力把这些内容介绍完整。\n\n## focus/blur 事件\n\n当元素聚焦时，会触发 `focus` 事件，当元素失去焦点时，会触发 `blur` 事件。\n\n让我们使用它们来校验一个 `input` 字段。\n\n在下面这个示例中：\n\n- `blur` 事件处理程序检查这个字段是否输入了电子邮箱，如果没有输入，则显示一个 error。\n- `focus` 事件处理程序隐藏 error 信息（在 `blur` 事件处理程序上会被再检查一遍）：\n\n```html run autorun height=60\n<style>\n  .invalid { border-color: red; }\n  #error { color: red }\n</style>\n\nYour email please: <input type=\"email\" id=\"input\">\n\n<div id=\"error\"></div>\n\n<script>\n*!*input.onblur*/!* = function() {\n  if (!input.value.includes('@')) { // not email\n    input.classList.add('invalid');\n    error.innerHTML = 'Please enter a correct email.'\n  }\n};\n\n*!*input.onfocus*/!* = function() {\n  if (this.classList.contains('invalid')) {\n    // 移除 \"error\" 指示，因为用户想要重新输入一些内容\n    this.classList.remove('invalid');\n    error.innerHTML = \"\";\n  }\n};\n</script>\n```\n\n现代 HTML 允许我们使用 `input` 特性（attribute）进行许多验证：`required`，`pattern` 等。有时它们正是我们所需要的。当我们需要更大的灵活性时，可以使用 JavaScript。如果数据是正确的，我们可以把它自动发送到服务器。\n\n\n## focus/blur 方法\n\n`elem.focus()` 和 `elem.blur()` 方法可以设置和移除元素上的焦点。\n\n例如，如果输入值无效，我们可以让焦点无法离开这个 `input` 字段：\n\n```html run autorun height=80\n<style>\n  .error {\n    background: red;\n  }\n</style>\n\nYour email please: <input type=\"email\" id=\"input\">\n<input type=\"text\" style=\"width:220px\" placeholder=\"make email invalid and try to focus here\">\n\n<script>\n  input.onblur = function() {\n    if (!this.value.includes('@')) { // not email\n      // 显示 error\n      this.classList.add(\"error\");\n*!*\n      // ...将焦点放回来\n      input.focus();\n*/!*\n    } else {\n      this.classList.remove(\"error\");\n    }\n  };\n</script>\n```\n\n这段代码在除了火狐（[bug](https://bugzilla.mozilla.org/show_bug.cgi?id=53579)）之外的浏览器上都可以正常工作。\n\n如果我们在 `input` 中输入一些内容，然后尝试使用 `key:Tab` 键或点击远离 `<input>` 的位置，那么 `onblur` 事件处理程序会把焦点重新设置到这个 `input` 字段上。\n\n请注意，我们无法通过在 `onblur` 事件处理程序中调用 `event.preventDefault()` 来“阻止失去焦点”，因为 `onblur` 事件处理程序是在元素失去焦点 **之后** 运行的。\n\n但在实际中，在实现这样的功能之前应该认真考虑一下，因为我们通常 **应该将报错展示给用户**，但 **不应该阻止用户在填写我们的表单时的进度**。用户可能会想先填写其他表单项。\n\n```warn header=\"JavaScript 导致的焦点丢失\"\n很多种原因可以导致焦点丢失。\n\n其中之一就是用户点击了其它位置。当然 JavaScript 自身也可能导致焦点丢失，例如：\n\n- 一个 `alert` 会将焦点移至自身，因此会导致元素失去焦点（触发 `blur` 事件），而当 `alert` 对话框被取消时，焦点又会重新回到原元素上（触发 `focus` 事件）。\n- 如果一个元素被从 DOM 中移除，那么也会导致焦点丢失。如果稍后它被重新插入到 DOM，焦点也不会回到它身上。\n\n这些特性有时候会导致 `focus/blur` 处理程序发生异常 —— 在不需要它们时触发。\n\n最好的秘诀就是在使用这些事件时小心点。如果我们想要跟踪用户导致的焦点丢失，则应该避免自己造成的焦点丢失。\n```\n## 允许在任何元素上聚焦：tabindex\n\n默认情况下，很多元素不支持聚焦。\n\n列表（list）在不同的浏览器表现不同，但有一件事总是正确的：`focus/blur` 保证支持那些用户可以交互的元素：`<button>`，`<input>`，`<select>`，`<a>` 等。\n\n另一方面，为了格式化某些东西而存在的元素像 `<div>`，`<span>` 和 `<table>` —— 默认是不能被聚焦的。`elem.focus()` 方法不适用于它们，并且 `focus/blur` 事件也绝不会被触发。\n\n使用 HTML-特性（attribute）`tabindex` 可以改变这种情况。\n\n任何具有 `tabindex` 特性的元素，都会变成可聚焦的。该特性的 `value` 是当使用 `key:Tab`（或类似的东西）在元素之间进行切换时，元素的顺序号。\n\n也就是说：如果我们有两个元素，第一个具有 `tabindex=\"1\"`，第二个具有 `tabindex=\"2\"`，然后当焦点在第一个元素的时候，按下 `key:Tab` 键，会使焦点移动到第二个元素身上。\n\n切换顺序为：从 `1` 开始的具有 `tabindex` 的元素排在前面（按 `tabindex` 顺序），然后是不具有 `tabindex` 的元素（例如常规的 `<input>`）。\n\n不具有 `tabindex` 的元素按文档源顺序（默认顺序）切换。\n\n这里有两个特殊的值：\n\n- `tabindex=\"0\"` 会使该元素被与那些不具有 `tabindex` 的元素放在一起。也就是说，当我们切换元素时，具有 `tabindex=\"0\"` 的元素将排在那些具有 `tabindex ≥ 1` 的元素的后面。\n\n    通常，它用于使元素具有焦点，但是保留默认的切换顺序。使元素成为与 `<input>` 一样的表单的一部分。\n\n- `tabindex=\"-1\"` 只允许以编程的方式聚焦于元素。`key:Tab` 键会忽略这样的元素，但是 `elem.focus()` 有效。\n\n举个例子，这里有一个列表。点击第一项，然后按 `key:Tab` 键：\n\n```html autorun no-beautify\n点击第一项，然后按 Tab 键。跟踪顺序。请注意，多按几次 Tab 键后，会将焦点移到这个通过 iframe 嵌入的示例的外面。\n<ul>\n  <li tabindex=\"1\">One</li>\n  <li tabindex=\"0\">Zero</li>\n  <li tabindex=\"2\">Two</li>\n  <li tabindex=\"-1\">Minus one</li>\n</ul>\n\n<style>\n  li { cursor: pointer; }\n  :focus { outline: 1px dashed green; }\n</style>\n```\n\n顺序就像这样：`1 - 2 - 0`。通常，`<li>` 不支持聚焦，但 `tabindex` 可以使它能聚焦，使这成为可能，并且还带有事件以及 `:focus` 样式。\n\n```smart header=\"属性 `elem.tabIndex` 也有效\"\n我们可以使用 `elem.tabIndex` 通过 JavaScript 来添加 `tabindex`。效果是一样的。\n```\n\n## focus/blur 委托\n\n`focus` 和 `blur` 事件不会向上冒泡。\n\n例如，我们不能把 `onfocus` 放在 `<form>` 上来对其进行高亮，像这样：\n\n```html autorun height=80\n<!-- on focusing in the form -- add the class -->\n<form *!*onfocus=\"this.className='focused'\"*/!*>\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n```\n\n上面这个示例并不工作，因为当用户聚焦于 `<input>` 时，`focus` 事件只会在该 `<input>` 上触发。它不会向上冒泡。所以 `form.onfocus` 永远不会触发。\n\n这里有两个解决方案。\n\n方案一，有一个遗留下来的有趣的特性（feature）：`focus/blur` 不会向上冒泡，但会在捕获阶段向下传播。\n\n这样可以生效：\n\n```html autorun height=80\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n*!*\n  // 将处理程序置于捕获阶段（最后一个参数为 true）\n  form.addEventListener(\"focus\", () => form.classList.add('focused'), true);\n  form.addEventListener(\"blur\", () => form.classList.remove('focused'), true);\n*/!*\n</script>\n```\n\n方案二，可以使用 `focusin` 和 `focusout` 事件 —— 与 `focus/blur` 事件完全一样，只是它们会冒泡。\n\n值得注意的是，必须使用 `elem.addEventListener` 来分配它们，而不是 `on<event>`。\n\n所以，这是另一个可行的变体：\n\n```html autorun height=80\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n*!*\n  form.addEventListener(\"focusin\", () => form.classList.add('focused'));\n  form.addEventListener(\"focusout\", () => form.classList.remove('focused'));\n*/!*\n</script>\n```\n\n## 总结\n\n在元素获得/失去焦点时会触发 `focus` 和 `blur` 事件。\n\n它们的特点是：\n- 它们不会冒泡。但是可以改为在捕获阶段触发，或者使用 `focusin/focusout`。\n- 大多数元素默认不支持聚焦。使用 `tabindex` 可以使任何元素变成可聚焦的。\n\n可以通过 `document.activeElement` 来获取当前所聚焦的元素。",
        "libs": [],
        "children": [
          "editable-div",
          "edit-td-click",
          "keyboard-mouse"
        ],
        "parent": "forms-controls",
        "updatedAt": 1666798986
      }
    },
    "editable-div": {
      "type": "Task",
      "value": {
        "title": "可编辑的 div",
        "slug": "editable-div",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/3-editable-div",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个 `<div>`，它在被点击后变成 `<textarea>`。\n\n文本区域（textarea）允许我们编辑 `<div>` 里的 HTML。\n\n当用户按下 `key:Enter` 键，或者 `<textarea>` 失去焦点时，`<textarea>` 会变回 `<div>`，并且 `<textarea>` 中的内容会变成 `<div>` 中的 HTML。\n\n[demo src=\"solution\"]",
        "solution": "",
        "parent": "focus-blur",
        "version": 1
      }
    },
    "edit-td-click": {
      "type": "Task",
      "value": {
        "title": "点击即可编辑单元格",
        "slug": "edit-td-click",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/4-edit-td-click",
        "weight": 4,
        "libs": [],
        "importance": 5,
        "content": "\n\n使单元格在点击时可编辑。\n\n- 点击时 —— 单元格应该变成“可编辑的”（在里面会出现文本区域），我们修改其中的 HTML。在这不调整单元格大小，所有几何形状保持不变。\n- OK 和 CANCEL 按钮会出现在单元格的下面，用以完成/取消编辑。\n- 同一时刻只有一个单元格可被编辑。当一个 `<td>` 处于“编辑模式”时，在其它单元格上的点击会被忽略。\n- 该表格可能有很多单元格。请使用事件委托。\n\n示例：\n\n[iframe src=\"solution\" height=400]",
        "solution": "1. 在点击时 —— 用相同尺寸且无边框的 `<textarea>` 替换单元格的 `innerHTML`。可以使用 JavaScript 或 CSS 设置正确的尺寸。\n2. 将 `textarea.value` 设置为 `td.innerHTML`。\n3. 聚焦在文本区域（textarea）。\n4. 在单元格下方应该显示 OK/CANCEL 按钮，并处理对它们的点击事件。",
        "parent": "focus-blur",
        "version": 1
      }
    },
    "keyboard-mouse": {
      "type": "Task",
      "value": {
        "title": "键盘移动老鼠",
        "slug": "keyboard-mouse",
        "githubPath": "/2-ui/4-forms-controls/2-focus-blur/5-keyboard-mouse",
        "weight": 5,
        "libs": [],
        "importance": 4,
        "content": "\n\n聚焦在老鼠上。然后使用键盘的方向键移动它：\n\n[demo src=\"solution\"]\n\nP.S. 除了 `#mouse` 元素外，不要在任何地方放置事件处理程序。\n\nP.P.S. 不要修改 HTML/CSS，这个方法应该是通用的，可以用于任何元素。",
        "solution": "我们可以使用 `mouse.onclick` 来处理点击，并将老鼠设置为 `position:fixed`，然后使用 `mouse.onkeydown` 来处理键盘的方向键。\n\n唯一的缺陷是 `keydown` 仅会在聚焦的元素上触发。因此，我们需要向元素添加 `tabindex`。因为我们禁止更改 HTML，所以我们可以使用 `mouse.tabIndex` 属性。\n\nP.S. 我们也可以使用 `mouse.onfocus` 代替 `mouse.onclick`。",
        "parent": "focus-blur",
        "version": 1
      }
    },
    "events-change-input": {
      "type": "Article",
      "value": {
        "title": "事件：change，input，cut，copy，paste",
        "slug": "events-change-input",
        "githubPath": "/2-ui/4-forms-controls/3-events-change-input",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n让我们介绍一下伴随数据更新的各种事件。\n\n## 事件：change\n\n当元素更改完成时，将触发 `change` 事件。\n\n对于文本输入框，当其失去焦点时，就会触发 `change` 事件。\n\n例如，当我们在下面的文本字段中键入内容时 —— 不会触发 `change` 事件。但是，当我们将焦点移到其他位置时，例如，点击按钮 —— 就会触发 `change` 事件：\n\n```html autorun height=40 run\n<input type=\"text\" onchange=\"alert(this.value)\">\n<input type=\"button\" value=\"Button\">\n```\n\n对于其它元素：`select`，`input type=checkbox/radio`，会在选项更改后立即触发 `change` 事件。\n\n```html autorun height=40 run\n<select onchange=\"alert(this.value)\">\n  <option value=\"\">Select something</option>\n  <option value=\"1\">Option 1</option>\n  <option value=\"2\">Option 2</option>\n  <option value=\"3\">Option 3</option>\n</select>\n```\n\n\n## 事件：input\n\n每当用户对输入值进行修改后，就会触发 `input` 事件。\n\n与键盘事件不同，只要值改变了，`input` 事件就会触发，即使那些不涉及键盘行为（action）的值的更改也是如此：使用鼠标粘贴，或者使用语音识别来输入文本。\n\n例如：\n\n```html autorun height=40 run\n<input type=\"text\" id=\"input\"> oninput: <span id=\"result\"></span>\n<script>\n  input.oninput = function() {\n    result.innerHTML = input.value;\n  };\n</script>\n```\n\n如果我们想要处理对 `<input>` 的每次更改，那么此事件是最佳选择。\n\n另一方面，`input` 事件不会在那些不涉及值更改的键盘输入或其他行为上触发，例如在输入时按方向键 `key:⇦` `key:⇨`。\n\n```smart header=\"无法阻止 `oninput` 中的任何事件\"\n当输入值更改后，就会触发 `input` 事件。\n\n所以，我们无法使用 `event.preventDefault()` —— 已经太迟了，不会起任何作用了。\n```\n\n## 事件：cut，copy，paste\n\n这些事件发生于剪切/拷贝/粘贴一个值的时候。\n\n它们属于 [ClipboardEvent](https://www.w3.org/TR/clipboard-apis/#clipboard-event-interfaces) 类，并提供了对剪切/拷贝/粘贴的数据的访问方法。\n\n我们也可以使用 `event.preventDefault()` 来中止行为，然后什么都不会被复制/粘贴。\n\n例如，下面的代码阻止了剪切/拷贝/粘贴的事件，并显示出了我们所尝试剪切/拷贝/粘贴的内容：\n\n```html autorun height=40 run\n<input type=\"text\" id=\"input\">\n<script>\n  input.onpaste = function(event) {\n    alert(\"paste: \" + event.clipboardData.getData('text/plain'));\n    event.preventDefault();\n  };\n\n  input.oncut = input.oncopy = function(event) {\n    alert(event.type + '-' + document.getSelection());\n    event.preventDefault();\n  };\n</script>\n```\n\n请注意，在剪切/复制事件处理程序中调用 `event.clipboardData.getData(...)` 只会得到一个空字符串。从技术上讲，这是因为此时数据还未存入剪切板。如果我们使用 `event.preventDefault()`，则它根本不会被复制。\n\n所以上面的例子中使用 `document.getSelection()` 来得到被选中的文本。你可以在 <info:selection-range> 中了解更多关于文本选择（document selection）的细节。\n\n我们不仅可以复制/粘贴文本，也可以复制/粘贴其他各种内容。例如，我们可以在操作系统的文件管理器中复制一个文件并进行粘贴。\n\n这是因为 `clipboardData` 实现了 `DataTransfer` 接口，通常用于拖放和复制/粘贴。这超出了本文所讨论的范围，但你可以在 [DataTransfer 规范](https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface) 中进行详细了解。\n\n另外，还有一个可以访问剪切板的异步 API：`navigator.clipboard`，详见 [Clipboard API 和事件规范](https://www.w3.org/TR/clipboard-apis/)，[火狐浏览器（Firefox）尚未支持](https://caniuse.com/async-clipboard)。\n\n### 安全限制\n\n剪贴板是“全局”操作系统级别的东西。用户可能会在各种应用程序之间切换，复制/粘贴不同的内容，而浏览器页面不应该能访问这些内容。\n\n因此，大多数浏览器仅允许在某些用户操作范围内（例如复制/粘贴等）对剪切板进行无缝的读/写访问。\n\n除火狐（Firefox）浏览器外，所有浏览器都禁止使用 `dispatchEvent` 生成“自定义”剪贴板事件，即使我们设法调度此类事件。规范也明确声明了，合成（syntetic）事件不得提供对剪切板的访问权限。\n\n此外，如果有人想将 `event.clipboardData` 保存在事件处理程序中，然后稍后再访问它 —— 这也不会生效。\n\n重申，[event.clipboardData](https://www.w3.org/TR/clipboard-apis/#clipboardevent-clipboarddata) 仅在用户启动的事件处理程序的上下文中生效。\n\n另外, [navigator.clipboard](https://www.w3.org/TR/clipboard-apis/#h-navigator-clipboard) 是一个较新的 API，适用于任何上下文。如果需要，它会请求用户的许可。\n\n## 总结\n\n数据更改事件:\n\n| 事件 | 描述 | 特点 |\n|---------|----------|-------------|\n| `change`| 值被改变。 | 对于文本输入，当失去焦点时触发。 |\n| `input` | 文本输入的每次更改。 | 立即触发，与 `change` 不同。 |\n| `cut/copy/paste` | 剪贴/拷贝/粘贴行为。 | 行为可以被阻止。`event.clipboardData` 属性可以用于访问剪贴板。除了火狐（Firefox）之外的浏览器都支持 `navigator.clipboard`。 |",
        "libs": [],
        "children": [
          "deposit-calculator"
        ],
        "parent": "forms-controls",
        "updatedAt": 1657705346
      }
    },
    "deposit-calculator": {
      "type": "Task",
      "value": {
        "title": "存款计算器",
        "slug": "deposit-calculator",
        "githubPath": "/2-ui/4-forms-controls/3-events-change-input/1-deposit-calculator",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个界面，允许输入银行存款总额以及存款利率，然后计算在给定时间段后，钱会变成多少。\n\n这是示例：\n\n[iframe src=\"solution\" height=\"350\" border=\"1\"]\n\n当输入有变化时，应立即进行处理。\n\n公式如下：\n```js\n// initial: 总存款的初始值\n// interest: 例如 0.05 意味着每年涨幅 5% \n// years: 要等待多少年\nlet result = Math.round(initial * (1 + interest) ** years);\n```",
        "solution": "",
        "parent": "events-change-input",
        "version": 1
      }
    },
    "forms-submit": {
      "type": "Article",
      "value": {
        "title": "表单：事件和方法提交",
        "slug": "forms-submit",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n提交表单时，会触发 `submit` 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单。\n\n`form.submit()` 方法允许从 JavaScript 启动表单发送。我们可以使用此方法动态地创建表单，并将其发送到服务器。\n\n让我们看看它们的更多细节。\n\n## 事件：submit\n\n提交表单主要有两种方式：\n\n1. 第一种 —— 点击 `<input type=\"submit\">` 或 `<input type=\"image\">`。\n2. 第二种 —— 在 `input` 字段中按下 `key:Enter` 键。\n\n这两个行为都会触发表单的 `submit` 事件。处理程序可以检查数据，如果有错误，就显示出来，并调用 `event.preventDefault()`，这样表单就不会被发送到服务器了。\n\n在下面的表单中：\n1. 在文本字段中按下 `key:Enter` 键。\n2. 点击 `<input type=\"submit\">`。\n\n这两种行为都会显示 `alert`，而因为代码中的 `return false`，表单不会被发送到别处：\n\n```html autorun height=60 no-beautify\n<form onsubmit=\"alert('submit!');return false\">\n  First: Enter in the input field <input type=\"text\" value=\"text\"><br>\n  Second: Click \"submit\": <input type=\"submit\" value=\"Submit\">\n</form>\n```\n\n````smart header=\"`submit` 和 `click` 的关系\"\n在输入框中使用 `key:Enter` 发送表单时，会在 `<input type=\"submit\">` 上触发一次 `click` 事件。\n\n这很有趣，因为实际上根本没有点击。\n\n这是一个示例：\n```html autorun height=60\n<form onsubmit=\"return false\">\n <input type=\"text\" size=\"30\" value=\"Focus here and press enter\">\n <input type=\"submit\" value=\"Submit\" *!*onclick=\"alert('click')\"*/!*>\n</form>\n```\n\n````\n\n## 方法：submit\n\n如果要手动将表单提交到服务器，我们可以调用 `form.submit()`。\n\n这样就不会产生 `submit` 事件。这里假设如果开发人员调用 `form.submit()`，就意味着此脚本已经进行了所有相关处理。\n\n有时该方法被用来手动创建和发送表单，如下所示：\n\n```js run\nlet form = document.createElement('form');\nform.action = 'https://google.com/search';\nform.method = 'GET';\n\nform.innerHTML = '<input name=\"q\" value=\"test\">';\n\n// 该表单必须在文档中才能提交\ndocument.body.append(form);\n\nform.submit();\n```",
        "libs": [],
        "children": [
          "modal-dialog"
        ],
        "parent": "forms-controls",
        "updatedAt": 1585735679
      }
    },
    "modal-dialog": {
      "type": "Task",
      "value": {
        "title": "模态框表单",
        "slug": "modal-dialog",
        "githubPath": "/2-ui/4-forms-controls/4-forms-submit/1-modal-dialog",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个函数 `showPrompt(html, callback)`，该函数显示一个表单，里面有消息 `html`，一个 `input` 字段和 `OK/CANCEL` 按钮。\n\n- 用户应该在文本字段中输入一些内容，然后按下 `key:Enter` 键或点击 OK 按钮，然后 `callback(value)` 就会被调用，参数为输入的值。\n- 否则，如果用户按下 `key:Esc` 键或点击 CANCEL 按钮，那么 `callback(null)` 就会被调用。\n\n在这两种情况下，输入过程都会结束，并移除表单。\n\n要求：\n\n- 表单应该在窗口的正中心。\n- 表单是 **模态框（modal）**。换句话说，在用户关闭模态框之前，用户无法与页面的其它部分进行任何交互。\n- 当表单显示后，焦点应该在用户需要进行输入的 `<input>` 输入框中。\n- 按键 `key:Tab`/`key:Shift+Tab` 应该能在表单字段之间切换焦点，不允许焦点离开表单字段到页面的其它元素上。\n\n使用示例：\n\n```js\nshowPrompt(\"Enter something<br>...smart :)\", function(value) {\n  alert(value);\n});\n```\n\n使用 iframe 嵌入的一个示例：\n\n[iframe src=\"solution\" height=160 border=1]\n\nP.S. 源文档有给表单设定了固定位置的 HTML/CSS，但是做成模态框的方式取决于你。",
        "solution": "可以使用一个覆盖整个窗口的半透明 `<div id=\"cover-div\">` 来实现模态框窗口，如下所示：\n\n```css\n#cover-div {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 9000;\n  width: 100%;\n  height: 100%;\n  background-color: gray;\n  opacity: 0.3;\n}\n```\n\n由于 `<div>` 遮盖了所有的元素，所以它会获取到所有的点击，而它下面的元素就无法获取这些点击了。\n\n我们也可以设置 `body.style.overflowY='hidden'` 来阻止页面的滚动。\n\n表单元素不应该在 `<div>` 中，而应在它下边，因为我们不想让表单具有 `opacity` 属性。",
        "parent": "forms-submit",
        "version": 1
      }
    },
    "loading": {
      "type": "Article",
      "value": {
        "title": "加载文档和其他资源",
        "slug": "loading",
        "githubPath": "/2-ui/5-loading",
        "isFolder": true,
        "weight": 5,
        "content": "",
        "libs": [],
        "children": [
          "onload-ondomcontentloaded",
          "script-async-defer",
          "onload-onerror"
        ],
        "parent": "ui"
      }
    },
    "onload-ondomcontentloaded": {
      "type": "Article",
      "value": {
        "title": "页面生命周期：DOMContentLoaded，load，beforeunload，unload",
        "slug": "onload-ondomcontentloaded",
        "githubPath": "/2-ui/5-loading/01-onload-ondomcontentloaded",
        "isFolder": false,
        "weight": 1,
        "content": "\n\nHTML 页面的生命周期包含三个重要事件：\n\n- `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。\n- `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。\n- `beforeunload/unload` —— 当用户正在离开页面时。\n\n每个事件都是有用的：\n\n- `DOMContentLoaded` 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。\n- `load` 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。\n- `beforeunload` 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。\n- `unload` 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。\n\n我们探索一下这些事件的细节。\n\n## DOMContentLoaded\n\n`DOMContentLoaded` 事件发生在 `document` 对象上。\n\n我们必须使用 `addEventListener` 来捕获它：\n\n```js\ndocument.addEventListener(\"DOMContentLoaded\", ready);\n// 不是 \"document.onDOMContentLoaded = ...\"\n```\n\n例如：\n\n```html run height=200 refresh\n<script>\n  function ready() {\n    alert('DOM is ready');\n\n    // 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  }\n\n*!*\n  document.addEventListener(\"DOMContentLoaded\", ready);\n*/!*\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\n```\n\n在示例中，`DOMContentLoaded` 处理程序在文档加载完成后触发，所以它可以查看所有元素，包括它下面的 `<img>` 元素。\n\n但是，它不会等待图片加载。因此，`alert` 显示其大小为零。\n\n乍一看，`DOMContentLoaded` 事件非常简单。DOM 树准备就绪 —— 这是它的触发条件。它并没有什么特别之处。\n\n### DOMContentLoaded 和脚本\n\n当浏览器处理一个 HTML 文档，并在文档中遇到 `<script>` 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 `document.write` 操作，所以 `DOMContentLoaded` 必须等待脚本执行结束。\n\n因此，`DOMContentLoaded` 肯定在下面的这些脚本执行结束之后发生：\n\n```html run\n<script>\n  document.addEventListener(\"DOMContentLoaded\", () => {\n    alert(\"DOM ready!\");\n  });\n</script>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n\n<script>\n  alert(\"Library loaded, inline script executed\");\n</script>\n```\n\n在上面这个例子中，我们首先会看到 \"Library loaded...\"，然后才会看到 \"DOM ready!\"（所有脚本都已经执行结束）。\n\n```warn header=\"不会阻塞 `DOMContentLoaded` 的脚本\"\n此规则有两个例外：\n1. 具有 `async` 特性（attribute）的脚本不会阻塞 `DOMContentLoaded`，[稍后](info:script-async-defer) 我们会讲到。\n2. 使用 `document.createElement('script')` 动态生成并添加到网页的脚本也不会阻塞 `DOMContentLoaded`。\n```\n\n### DOMContentLoaded 和样式\n\n外部样式表不会影响 DOM，因此 `DOMContentLoaded` 不会等待它们。\n\n但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：\n\n```html run\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n<script>\n  // 在样式表加载完成之前，脚本都不会执行\n  alert(getComputedStyle(document.body).marginTop);\n</script>\n```\n\n原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。\n\n当 `DOMContentLoaded` 等待脚本时，它现在也在等待脚本前面的样式。\n\n### 浏览器内建的自动填充\n\nFirefox，Chrome 和 Opera 都会在 `DOMContentLoaded` 中自动填充表单。\n\n例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 `DOMContentLoaded` 上，浏览器会尝试自动填充它们（如果得到了用户允许）。\n\n因此，如果 `DOMContentLoaded` 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名/密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 `DOMContentLoaded` 事件之前的延迟。\n\n\n## window.onload [#window-onload]\n\n当整个页面，包括样式、图片和其他资源被加载完成时，会触发 `window` 对象上的 `load` 事件。可以通过 `onload` 属性获取此事件。\n\n下面的这个示例正确显示了图片大小，因为 `window.onload` 会等待所有图片加载完毕：\n\n```html run height=200 refresh\n<script>\n  window.onload = function() { // 也可以用 window.addEventListener('load', (event) => {\n    alert('Page loaded');\n\n    // 此时图片已经加载完成\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  };\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\n```\n\n## window.onunload\n\n当访问者离开页面时，`window` 对象上的 `unload` 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。\n\n有一个值得注意的特殊情况是发送分析数据。\n\n假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。\n\n自然地，当用户要离开的时候，我们希望通过 `unload` 事件将数据保存到我们的服务器上。\n\n有一个特殊的 `navigator.sendBeacon(url, data)` 方法可以满足这种需求，详见规范 <https://w3c.github.io/beacon/>。\n\n它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 `sendBeacon`。\n\n使用方式如下：\n```js\nlet analyticsData = { /* 带有收集的数据的对象 */ };\n\nwindow.addEventListener(\"unload\", function() {\n  navigator.sendBeacon(\"/analytics\", JSON.stringify(analyticsData));\n});\n```\n\n- 请求以 POST 方式发送。\n- 我们不仅能发送字符串，还能发送表单以及其他格式的数据，在 <info:fetch> 一章有详细讲解，但通常它是一个字符串化的对象。\n- 数据大小限制在 64kb。\n\n当 `sendBeacon` 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）。\n\n还有一个 `keep-alive` 标志，该标志用于在 [fetch](info:fetch) 方法中为通用的网络请求执行此类“离开页面后”的请求。你可以在 <info:fetch-api> 一章中找到更多相关信息。\n\n\n如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 —— `onbeforeunload`。\n\n## window.onbeforeunload [#window.onbeforeunload]\n\n如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，`beforeunload` 处理程序将要求进行更多确认。\n\n如果我们要取消事件，浏览器会询问用户是否确定。\n\n你可以通过运行下面这段代码，然后重新加载页面来进行尝试：\n\n```js run\nwindow.onbeforeunload = function() {\n  return false;\n};\n```\n\n由于历史原因，返回非空字符串也被视为取消事件。在以前，浏览器曾经将其显示为消息，但是根据 [现代规范](https://html.spec.whatwg.org/#unloading-documents) 所述，它们不应该这样。\n\n这里有个例子：\n\n```js run\nwindow.onbeforeunload = function() {\n  return \"有未保存的值。确认要离开吗？\";\n};\n```\n\n它的行为已经改变了，因为有些站长通过显示误导性和恶意信息滥用了此事件处理程序。所以，目前一些旧的浏览器可能仍将其显示为消息，但除此之外 —— 无法自定义显示给用户的消息。\n\n````warn header=\"`event.preventDefault()` 在 `beforeunload` 处理程序中不起作用\"\n这听起来可能很奇怪，但大多数浏览器都会忽略 `event.preventDefault()`。\n\n这意味着，以下代码可能不起作用：\n```js run\nwindow.addEventListener(\"beforeunload\", (event) => {\n  // 不起作用，所以这个事件处理程序没做任何事儿\n\tevent.preventDefault();\n});\n```\n\n相反，在这样的处理程序中，应该将 `event.returnValue` 设置为一个字符串，以获得类似于上面代码的结果：\n```js run\nwindow.addEventListener(\"beforeunload\", (event) => {\n  // 起作用，与在 window.onbeforeunload 中 return 值的效果是一样的\n\tevent.returnValue = \"有未保存的值。确认要离开吗？\";\n});\n```\n````\n\n## readyState\n\n如果我们在文档加载完成之后设置 `DOMContentLoaded` 事件处理程序，会发生什么？\n\n很自然地，它永远不会运行。\n\n在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。\n\n`document.readyState` 属性可以为我们提供当前加载状态的信息。\n\n它有 3 个可能值：\n\n- `loading` —— 文档正在被加载。\n- `interactive` —— 文档被全部读取。\n- `complete` —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。\n\n所以，我们可以检查 `document.readyState` 并设置一个处理程序，或在代码准备就绪时立即执行它。\n\n像这样：\n\n```js\nfunction work() { /*...*/ }\n\nif (document.readyState == 'loading') {\n  // 仍在加载，等待事件\n  document.addEventListener('DOMContentLoaded', work);\n} else {\n  // DOM 已就绪！\n  work();\n}\n```\n\n还有一个 `readystatechange` 事件，会在状态发生改变时触发，因此我们可以打印所有这些状态，就像这样：\n\n```js run\n// 当前状态\nconsole.log(document.readyState);\n\n// 状态改变时打印它\ndocument.addEventListener('readystatechange', () => console.log(document.readyState));\n```\n\n`readystatechange` 事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用。\n\n但是为了完整起见，让我们看看完整的事件流。\n\n这是一个带有 `<iframe>`，`<img>` 和记录事件的处理程序的文档：\n\n```html\n<script>\n  log('initial readyState:' + document.readyState);\n\n  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));\n  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));\n\n  window.onload = () => log('window onload');\n</script>\n\n<iframe src=\"iframe.html\" onload=\"log('iframe onload')\"></iframe>\n\n<img src=\"http://en.js.cx/clipart/train.gif\" id=\"img\">\n<script>\n  img.onload = () => log('img onload');\n</script>\n```\n\n此示例运行 [在 sandbox 中](sandbox:readystate)。\n\n典型输出：\n1. [1] initial readyState:loading\n2. [2] readyState:interactive\n3. [2] DOMContentLoaded\n4. [3] iframe onload\n5. [4] img onload\n6. [4] readyState:complete\n7. [4] window onload\n\n方括号中的数字表示发生这种情况的大致时间。标有相同数字的事件几乎是同时发生的（+- 几毫秒）。\n\n- 在 `DOMContentLoaded` 之前，`document.readyState` 会立即变成 `interactive`。它们俩的意义实际上是相同的。\n- 当所有资源（`iframe` 和 `img`）都加载完成后，`document.readyState` 变成 `complete`。这里我们可以发现，它与 `img.onload`（`img` 是最后一个资源）和 `window.onload` 几乎同时发生。转换到 `complete` 状态的意义与 `window.onload` 相同。区别在于 `window.onload` 始终在所有其他 `load` 处理程序之后运行。\n\n\n## 总结\n\n页面生命周期事件：\n\n- 当 DOM 准备就绪时，`document` 上的 `DOMContentLoaded` 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。\n  - 诸如 `<script>...</script>` 或 `<script src=\"...\"></script>` 之类的脚本会阻塞  `DOMContentLoaded`，浏览器将等待它们执行结束。\n  - 图片和其他资源仍然可以继续被加载。\n- 当页面和所有资源都加载完成时，`window` 上的 `load` 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。\n- 当用户想要离开页面时，`window` 上的 `beforeunload` 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。\n- 当用户最终离开时，`window` 上的 `unload` 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 `navigator.sendBeacon` 来发送网络请求。\n- `document.readyState` 是文档的当前状态，可以在 `readystatechange` 事件中跟踪状态更改：\n  - `loading` —— 文档正在被加载。\n  - `interactive` —— 文档已被解析完成，与 `DOMContentLoaded` 几乎同时发生，但是在 `DOMContentLoaded` 之前发生。\n  - `complete` —— 文档和资源均已加载完成，与 `window.onload` 几乎同时发生，但是在 `window.onload` 之前发生。",
        "libs": [],
        "children": [],
        "parent": "loading",
        "updatedAt": 1650217249
      }
    },
    "script-async-defer": {
      "type": "Article",
      "value": {
        "title": "脚本：async，defer",
        "slug": "script-async-defer",
        "githubPath": "/2-ui/5-loading/02-script-async-defer",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n现代的网站中，脚本往往比 HTML 更“重”：它们的大小通常更大，处理时间也更长。\n\n当浏览器加载 HTML 时遇到 `<script>...</script>` 标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本 `<script src=\"...\"></script>` 也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。\n\n这会导致两个重要的问题：\n\n1. 脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。\n2. 如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容：\n\n```html run height=100\n<p>...content before script...</p>\n\n<script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- This isn't visible until the script loads -->\n<p>...content after script...</p>\n```\n\n这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：\n\n```html\n<body>\n  ...all content is above the script...\n\n  <script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n</body>\n```\n\n但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。\n\n这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。\n\n幸运的是，这里有两个 `<script>` 特性（attribute）可以为我们解决这个问题：`defer` 和 `async`。\n\n## defer\n\n`defer` 特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行。\n\n这是与上面那个相同的示例，但是带有 `defer` 特性：\n\n```html run height=100\n<p>...content before script...</p>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- 立即可见 -->\n<p>...content after script...</p>\n```\n\n换句话说：\n\n- 具有 `defer` 特性的脚本不会阻塞页面。\n- 具有 `defer` 特性的脚本总是要等到 DOM 解析完毕，但在 `DOMContentLoaded` 事件之前执行。\n\n下面这个示例演示了上面所说的第二句话：\n\n```html run height=100\n<p>...content before scripts...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"DOM ready after defer!\"));\n</script>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<p>...content after scripts...</p>\n```\n\n1. 页面内容立即显示。\n2. `DOMContentLoaded` 事件处理程序等待具有 `defer` 特性的脚本执行完成。它仅在脚本下载且执行结束后才会被触发。\n\n**具有 `defer` 特性的脚本保持其相对顺序，就像常规脚本一样。**\n\n假设，我们有两个具有 `defer` 特性的脚本：`long.js` 在前，`small.js` 在后。\n\n```html\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script defer src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n```\n\n浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。因此，在上面的示例中，两个脚本是并行下载的。`small.js` 可能会先下载完成。\n\n……但是，`defer` 特性除了告诉浏览器“不要阻塞页面”之外，还可以确保脚本执行的相对顺序。因此，即使 `small.js` 先加载完成，它也需要等到 `long.js` 执行结束才会被执行。\n\n当我们需要先加载 JavaScript 库，然后再加载依赖于它的脚本时，这可能会很有用。\n\n```smart header=\"`defer` 特性仅适用于外部脚本\"\n如果 `<script>` 脚本没有 `src`，则会忽略 `defer` 特性。\n```\n\n## async\n\n`async` 特性与 `defer` 有些类似。它也能够让脚本不阻塞页面。但是，在行为上二者有着重要的区别。\n\n`async` 特性意味着脚本是完全独立的：\n\n- 浏览器不会因 `async` 脚本而阻塞（与 `defer` 类似）。\n- 其他脚本不会等待 `async` 脚本加载完成，同样，`async` 脚本也不会等待其他脚本。\n- `DOMContentLoaded` 和异步脚本不会彼此等待：\n    - `DOMContentLoaded` 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）\n    - `DOMContentLoaded` 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）\n\n换句话说，`async` 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。`async` 脚本就是一个会在加载完成时执行的完全独立的脚本。就这么简单，现在明白了吧？\n\n下面是一个类似于我们在讲 `defer` 时所看到的例子：`long.js` 和 `small.js` 两个脚本，只是现在 `defer` 变成了 `async`。\n\n它们不会等待对方。先加载完成的（可能是 `small.js`）—— 先执行：\n\n```html run height=100\n<p>...content before scripts...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"DOM ready!\"));\n</script>\n\n<script async src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script async src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n\n<p>...content after scripts...</p>\n```\n\n- 页面内容立刻显示出来：加载写有 `async` 的脚本不会阻塞页面渲染。\n- `DOMContentLoaded` 可能在 `async` 之前或之后触发，不能保证谁先谁后。\n- 较小的脚本 `small.js` 排在第二位，但可能会比 `long.js` 这个长脚本先加载完成，所以 `small.js` 会先执行。虽然，可能是 `long.js` 先加载完成，如果它被缓存了的话，那么它就会先执行。换句话说，异步脚本以“加载优先”的顺序执行。\n\n当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们：\n\n```html\n<!-- Google Analytics 脚本通常是这样嵌入页面的 -->\n<script async src=\"https://google-analytics.com/analytics.js\"></script>\n```\n\n```smart header=\"`async` 特性仅适用于外部脚本\"\n就像 `defer` 一样，如果 `<script>` 标签没有 `src` 特性（attribute），那么 `async` 特性会被忽略。\n```\n\n## 动态脚本\n\n此外，还有一种向页面添加脚本的重要的方式。\n\n我们可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中：\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"/article/script-async-defer/long.js\";\ndocument.body.append(script); // (*)\n```\n\n当脚本被附加到文档 `(*)` 时，脚本就会立即开始加载。\n\n**默认情况下，动态脚本的行为是“异步”的。**\n\n也就是说：\n- 它们不会等待任何东西，也没有什么东西会等它们。\n- 先加载完成的脚本先执行（“加载优先”顺序）。\n\n如果我们显式地设置了 `script.async=false`，则可以改变这个规则。然后脚本将按照脚本在文档中的顺序执行，就像 `defer` 那样。\n\n在下面这个例子中，`loadScript(src)` 函数添加了一个脚本，并将 `async` 设置为了 `false`。\n\n因此，`long.js` 总是会先执行（因为它是先被添加到文档的）：\n\n```js run\nfunction loadScript(src) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.async = false;\n  document.body.append(script);\n}\n\n// long.js 先执行，因为代码中设置了 async=false\nloadScript(\"/article/script-async-defer/long.js\");\nloadScript(\"/article/script-async-defer/small.js\");\n```\n\n如果没有 `script.async=false`，脚本则将以默认规则执行，即加载优先顺序（`small.js` 大概会先执行）。\n\n同样，和 `defer` 一样，如果我们要加载一个库和一个依赖于它的脚本，那么顺序就很重要。\n\n\n## 总结\n\n`async` 和 `defer` 有一个共同点：加载这样的脚本都不会阻塞页面的渲染。因此，用户可以立即阅读并了解页面内容。\n\n但是，它们之间也存在一些本质的区别：\n\n|         | 顺序 | `DOMContentLoaded` |\n|---------|---------|---------|\n| `async` | **加载优先顺序**。脚本在文档中的顺序不重要 —— 先加载完成的先执行 | 不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自于缓存，同时文档足够长，就会发生这种情况。 |\n| `defer` | **文档顺序**（它们在文档中的顺序） | 在文档加载和解析完成之后（如果需要，则会等待），即在 `DOMContentLoaded` 之前执行。 |\n\n在实际开发中，`defer` 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候。\n\n`async` 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。\n\n```warn header=\"没有脚本的页面应该也是可用的\"\n请注意：如果你使用的是 `defer` 或 `async`，那么用户将在脚本加载完成 **之前** 先看到页面。\n\n在这种情况下，某些图形组件可能尚未初始化完成。\n\n因此，请记得添加一个“正在加载”的提示，并禁用尚不可用的按钮。以让用户可以清楚地看到，他现在可以在页面上做什么，以及还有什么是正在准备中的。\n```",
        "libs": [],
        "children": [],
        "parent": "loading",
        "updatedAt": 1652634576
      }
    },
    "onload-onerror": {
      "type": "Article",
      "value": {
        "title": "资源加载：onload，onerror",
        "slug": "onload-onerror",
        "githubPath": "/2-ui/5-loading/03-onload-onerror",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n浏览器允许我们跟踪外部资源的加载 —— 脚本，iframe，图片等。\n\n这里有两个事件：\n\n- `onload` —— 成功加载，\n- `onerror` —— 出现 error。\n\n## 加载脚本\n\n假设我们需要加载第三方脚本，并调用其中的函数。\n\n我们可以像这样动态加载它：\n\n```js\nlet script = document.createElement('script');\nscript.src = \"my.js\";\n\ndocument.head.append(script);\n```\n\n……但如何运行在该脚本中声明的函数？我们需要等到该脚本加载完成，之后才能调用它。\n\n```smart\n对于我们自己的脚本，可以使用 [JavaScript module](info:modules)，但是它们并未被广泛应用于第三方库。\n```\n\n### script.onload\n\n我们的得力助手是 `load` 事件。它会在脚本加载并执行完成时触发。\n\n例如：\n\n```js run untrusted\nlet script = document.createElement('script');\n\n// 可以从任意域（domain），加载任意脚本\nscript.src = \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"\ndocument.head.append(script);\n\n*!*\nscript.onload = function() {\n  // 该脚本创建了一个变量 \"_\"\n  alert( _.VERSION ); // 显示库的版本\n};\n*/!*\n```\n\n因此，在 `onload` 中我们可以使用脚本中的变量，运行函数等。\n\n……如果加载失败怎么办？例如，这里没有这样的脚本（error 404）或者服务器宕机（不可用）。\n\n### script.onerror\n\n发生在脚本加载期间的 error 会被 `error` 事件跟踪到。\n\n例如，我们请求一个不存在的脚本：\n\n```js run\nlet script = document.createElement('script');\nscript.src = \"https://example.com/404.js\"; // 没有这个脚本\ndocument.head.append(script);\n\n*!*\nscript.onerror = function() {\n  alert(\"Error loading \" + this.src); // Error loading https://example.com/404.js\n};\n*/!*\n```\n\n请注意，在这里我们无法获取更多 HTTP error 的详细信息。我们不知道 error 是 404 还是 500 或者其他情况。只知道是加载失败了。\n\n```warn\n`onload`/`onerror` 事件仅跟踪加载本身。\n\n在脚本处理和执行期间可能发生的 error 超出了这些事件跟踪的范围。也就是说：如果脚本成功加载，则即使脚本中有编程 error，也会触发 `onload` 事件。如果要跟踪脚本 error，可以使用 `window.onerror` 全局处理程序。\n```\n\n## 其他资源\n\n`load` 和 `error` 事件也适用于其他资源，基本上（basically）适用于具有外部 `src` 的任何资源。\n\n例如：\n\n```js run\nlet img = document.createElement('img');\nimg.src = \"https://js.cx/clipart/train.gif\"; // (*)\n\nimg.onload = function() {\n  alert(`Image loaded, size ${img.width}x${img.height}`);\n};\n\nimg.onerror = function() {\n  alert(\"Error occurred while loading image\");\n};\n```\n\n但是有一些注意事项：\n\n- 大多数资源在被添加到文档中后，便开始加载。但是 `<img>` 是个例外。它要等到获得 src `(*)` 后才开始加载。\n- 对于 `<iframe>` 来说，iframe 加载完成时会触发 `iframe.onload` 事件，无论是成功加载还是出现 error。\n\n这是出于历史原因。\n\n## 跨源策略\n\n这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。例如，位于 `https://facebook.com` 的脚本无法读取位于 `https://gmail.com` 的用户邮箱。\n\n或者，更确切地说，一个源（域/端口/协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。\n\n这个规则还影响其他域的资源。\n\n如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。\n\n例如，让我们使用一个脚本 `error.js`，该脚本只包含一个（错误）函数调用：\n```js\n// 📁 error.js\nnoSuchFunction();\n```\n\n现在从它所在的同一个网站加载它：\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\n我们可以看到一个很好的 error 报告，就像这样：\n\n```\nUncaught ReferenceError: noSuchFunction is not defined\nhttps://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1\n```\n\n现在，让我们从另一个域中加载相同的脚本：\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\n此报告与上面那个示例中的不同，就像这样：\n\n```\nScript error.\n, 0:0\n```\n\nerror 的详细信息可能因浏览器而异，但是原理是相同的：有关脚本内部的任何信息（包括 error 堆栈跟踪）都被隐藏了。正是因为它来自于另一个域。\n\n为什么我们需要 error 的详细信息？\n\n因为有很多服务（我们也可以构建自己的服务）使用 `window.onerror` 监听全局 error，保存 error 并提供访问和分析 error 的接口。这很好，因为我们可以看到由用户触发的实际中的 error。但是，如果一个脚本来自于另一个源（origin），那么正如我们刚刚看到的那样，其中没有太多有关 error 的信息。\n\n对其他类型的资源也执行类似的跨源策略（CORS）。\n\n**要允许跨源访问，`<script>` 标签需要具有 `crossorigin` 特性（attribute），并且远程服务器必须提供特殊的 header。**\n\n这里有三个级别的跨源访问：\n\n1. **无 `crossorigin` 特性** —— 禁止访问。\n2. **`crossorigin=\"anonymous\"`** —— 如果服务器的响应带有包含 `*` 或我们的源（origin）的 header `Access-Control-Allow-Origin`，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。\n3. **`crossorigin=\"use-credentials\"`** —— 如果服务器发送回带有我们的源的 header `Access-Control-Allow-Origin` 和 `Access-Control-Allow-Credentials: true`，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器。\n\n```smart\n你可以在 <info:fetch-crossorigin> 一章中了解有关跨源访问的更多信息。这一章描述了用于网络请求的 `fetch` 方法，但策略是完全相同的。\n\n诸如 \"cookie\" 之类的内容超出了本章的范围，但你可以在 <info:cookie> 一章学习它们。\n```\n\n在我们的示例中没有任何跨源特性（attribute）。因此，跨源访问被禁止。让我们来添加它吧。\n\n我们可以在 `\"anonymous\"`（不会发送 cookie，需要一个服务器端的 header）和 `\"use-credentials\"`（会发送 cookie，需要两个服务器端的 header）之间进行选择。\n\n如果我们不关心 cookie，那么可以选择 `\"anonymous\"`：\n\n```html run height=0\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script *!*crossorigin=\"anonymous\"*/!* src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n```\n\n现在，假设服务器提供了 `Access-Control-Allow-Origin` header，一切都正常。我们有了完整的 error 报告。\n\n## 总结\n\n图片 `<img>`，外部样式，脚本和其他资源都提供了 `load` 和 `error` 事件以跟踪它们的加载：\n\n- `load` 在成功加载时被触发。\n- `error` 在加载失败时被触发。\n\n唯一的例外是 `<iframe>`：出于历史原因，不管加载成功还是失败，即使页面没有被找到，它都会触发 `load` 事件。\n\n`readystatechange` 事件也适用于资源，但很少被使用，因为 `load/error` 事件更简单。",
        "libs": [],
        "children": [
          "load-img-callback"
        ],
        "parent": "loading",
        "updatedAt": 1605278165
      }
    },
    "load-img-callback": {
      "type": "Task",
      "value": {
        "title": "使用回调函数加载图片",
        "slug": "load-img-callback",
        "githubPath": "/2-ui/5-loading/03-onload-onerror/1-load-img-callback",
        "weight": 1,
        "libs": [],
        "importance": 4,
        "content": "\n\n通常，图片在被创建时才会被加载。所以，当我们向页面中添加 `<img>` 时，用户不会立即看到图片。浏览器首先需要加载它。\n\n为了立即显示一张图片，我们可以“提前”创建它，像这样：\n\n```js\nlet img = document.createElement('img');\nimg.src = 'my.jpg';\n```\n\n浏览器开始加载图片，并将其保存到缓存中。以后，当相同图片出现在文档中时（无论怎样），它都会立即显示。\n\n**创建一个函数 `preloadImages(sources, callback)`，来加载来自数组 `source` 的所有图片，并在准备就绪时运行 `callback`。**\n\n例如，这段代码将在图片加载完成后显示一个 `alert`：\n\n```js\nfunction loaded() {\n  alert(\"Images loaded\")\n}\n\npreloadImages([\"1.jpg\", \"2.jpg\", \"3.jpg\"], loaded);\n```\n\n如果出现错误，函数应该仍假定图片已经“加载完成”。\n\n换句话说，当所有图片都已加载完成，或出现错误输出时，将执行 `callback`。\n\n例如，当我们计划显示一个包含很多图片的可滚动图册，并希望确保所有图片都已加载完成时，这个函数很有用。\n\n在源文档中，你可以找到指向测试图片的链接，以及检查它们是否已加载完成的代码。它应该输出 `300`。",
        "solution": "算法：\n1. 为每个资源创建 `img`。\n2. 为每个图片添加 `onload/onerror`。\n3. 在 `onload` 或 `onerror` 被触发时，增加计数器。\n4. 当计数器值等于资源值时 —— 我们完成了：`callback()`。",
        "parent": "onload-onerror",
        "version": 1
      }
    },
    "ui-misc": {
      "type": "Article",
      "value": {
        "title": "杂项",
        "slug": "ui-misc",
        "githubPath": "/2-ui/99-ui-misc",
        "isFolder": true,
        "weight": 99,
        "content": "",
        "libs": [],
        "children": [
          "mutation-observer",
          "selection-range",
          "event-loop"
        ],
        "parent": "ui"
      }
    },
    "mutation-observer": {
      "type": "Article",
      "value": {
        "title": "DOM 变动观察器（Mutation observer）",
        "slug": "mutation-observer",
        "githubPath": "/2-ui/99-ui-misc/01-mutation-observer",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n`MutationObserver` 是一个内建对象，它观察 DOM 元素，并在检测到更改时触发回调。\n\n我们将首先看一下语法，然后探究一个实际的用例，以了解它在什么地方有用。\n\n## 语法\n\n`MutationObserver` 使用简单。\n\n首先，我们创建一个带有回调函数的观察器：\n\n```js\nlet observer = new MutationObserver(callback);\n```\n\n然后将其附加到一个 DOM 节点：\n\n```js\nobserver.observe(node, config);\n```\n\n`config` 是一个具有布尔选项的对象，该布尔选项表示“将对哪些更改做出反应”：\n- `childList` —— `node` 的直接子节点的更改，\n- `subtree` —— `node` 的所有后代的更改，\n- `attributes` —— `node` 的特性（attribute），\n- `attributeFilter` —— 特性名称数组，只观察选定的特性。\n- `characterData` —— 是否观察 `node.data`（文本内容），\n\n其他几个选项：\n- `attributeOldValue` —— 如果为 `true`，则将特性的旧值和新值都传递给回调（参见下文），否则只传新值（需要 `attributes` 选项），\n- `characterDataOldValue` —— 如果为 `true`，则将 `node.data` 的旧值和新值都传递给回调（参见下文），否则只传新值（需要 `characterData` 选项）。\n\n然后，在发生任何更改后，将执行“回调”：更改被作为一个 [MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) 对象列表传入第一个参数，而观察器自身作为第二个参数。\n\n[MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) 对象具有以下属性：\n\n- `type` —— 变动类型，以下类型之一：\n    - `\"attributes\"`：特性被修改了，\n    - `\"characterData\"`：数据被修改了，用于文本节点，\n    - `\"childList\"`：添加/删除了子元素。\n- `target` —— 更改发生在何处：`\"attributes\"` 所在的元素，或 `\"characterData\"` 所在的文本节点，或 `\"childList\"` 变动所在的元素，\n- `addedNodes/removedNodes` —— 添加/删除的节点，\n- `previousSibling/nextSibling` —— 添加/删除的节点的上一个/下一个兄弟节点，\n- `attributeName/attributeNamespace` —— 被更改的特性的名称/命名空间（用于 XML），\n- `oldValue` —— 之前的值，仅适用于特性或文本更改，如果设置了相应选项 `attributeOldValue`/`characterDataOldValue`。\n\n例如，这里有一个 `<div>`，它具有 `contentEditable` 特性。该特性使我们可以聚焦和编辑元素。\n\n```html run\n<div contentEditable id=\"elem\">Click and <b>edit</b>, please</div>\n\n<script>\nlet observer = new MutationObserver(mutationRecords => {\n  console.log(mutationRecords); // console.log(the changes)\n});\n\n// 观察除了特性之外的所有变动\nobserver.observe(elem, {\n  childList: true, // 观察直接子节点\n  subtree: true, // 及其更低的后代节点\n  characterDataOldValue: true // 将旧的数据传递给回调\n});\n</script>\n```\n\n如果我们在浏览器中运行上面这段代码，并聚焦到给定的 `<div>` 上，然后更改 `<b>edit</b>` 中的文本，`console.log` 将显示一个变动：\n\n```js\nmutationRecords = [{\n  type: \"characterData\",\n  oldValue: \"edit\",\n  target: <text node>,\n  // 其他属性为空\n}];\n```\n\n如果我们进行更复杂的编辑操作，例如删除 `<b>edit</b>`，那么变动事件可能会包含多个变动记录：\n\n```js\nmutationRecords = [{\n  type: \"childList\",\n  target: <div#elem>,\n  removedNodes: [<b>],\n  nextSibling: <text node>,\n  previousSibling: <text node>\n  // 其他属性为空\n}, {\n  type: \"characterData\"\n  target: <text node>\n  // ...变动的详细信息取决于浏览器如何处理此类删除\n  // 它可能是将两个相邻的文本节点 \"edit \" 和 \", please\" 合并成一个节点，\n  // 或者可能将它们留在单独的文本节点中\n}];\n```\n\n因此，`MutationObserver` 允许对 DOM 子树中的任何更改作出反应。\n\n## 用于集成\n\n在什么时候可能有用？\n\n想象一下，你需要添加一个第三方脚本，该脚本不仅包含有用的功能，还会执行一些我们不想要的操作，例如显示广告 `<div class=\"ads\">Unwanted ads</div>`。\n\n当然，第三方脚本没有提供删除它的机制。\n\n使用 `MutationObserver`，我们可以监测到我们不需要的元素何时出现在我们的 DOM 中，并将其删除。\n\n还有一些其他情况，例如第三方脚本会将某些内容添加到我们的文档中，并且我们希望检测出这种情况何时发生，以调整页面，动态调整某些内容的大小等。\n\n`MutationObserver` 使我们能够实现这种需求。\n\n## 用于架构\n\n从架构的角度来看，在某些情况下，`MutationObserver` 有不错的作用。\n\n假设我们正在建立一个有关编程的网站。自然地，文章和其他材料中可能包含源代码段。\n\n在 HTML 标记（markup）中的此类片段如下所示：\n\n```html\n...\n<pre class=\"language-javascript\"><code>\n  // 这里是代码\n  let hello = \"world\";\n</code></pre>\n...\n```\n\n为了提高可读性，同时对其进行美化，我们将在我们的网站上使用 JavaScript 语法高亮显示库，例如 [Prism.js](https://prismjs.com/)。为了使用 Prism 对以上代码片段进行语法高亮显示，我们调用了 `Prism.highlightElem(pre)`，它会检查此类 `pre` 元素的内容，并为这些元素添加特殊的标签（tag）和样式，以进行彩色语法高亮显示，类似于你在本文的示例中看到的那样。\n\n那么，我们应该在什么时候执行该高亮显示方法呢？我们可以在 `DOMContentLoaded` 事件中执行，或者将脚本放在页面的底部。DOM 就绪后，我们可以搜索元素 `pre[class*=\"language\"]` 并对其调用 `Prism.highlightElem`：\n\n```js\n// 高亮显示页面上的所有代码段\ndocument.querySelectorAll('pre[class*=\"language\"]').forEach(Prism.highlightElem);\n```\n\n到目前为止，一切都很简单，对吧？我们找到 HTML 中的代码片段并高亮显示它们。\n\n现在让我们继续。假设我们要从服务器动态获取资料。我们将 [在本教程的后续章节](info:fetch) 中学习进行此操作的方法。目前，只需要关心我们从网络服务器获取 HTML 文章并按需显示：\n\n```js\nlet article = /* 从服务器获取新内容 */\narticleElem.innerHTML = article;\n```\n\n新的 `article` HTML 可能包含代码段。我们需要对其调用 `Prism.highlightElem`，否则它们将不会被高亮显示。\n\n**对于动态加载的文章，应该在何处何时调用 `Prism.highlightElem`？**\n\n我们可以将该调用附加到加载文章的代码中，如下所示：\n\n```js\nlet article = /* 从服务器获取新内容 */\narticleElem.innerHTML = article;\n\n*!*\nlet snippets = articleElem.querySelectorAll('pre[class*=\"language-\"]');\nsnippets.forEach(Prism.highlightElem);\n*/!*\n```\n\n……但是，想象一下，如果代码中有很多地方都是在加载内容：文章，测验和论坛帖子等。我们是否需要在每个地方都附加一个高亮显示调用，以在内容加载完成后，高亮内容中的代码。那很不方便。\n\n并且，如果内容是由第三方模块加载的，该怎么办？例如，我们有一个由其他人编写的论坛，该论坛可以动态加载内容，并且我们想为其添加语法高亮显示。没有人喜欢修补第三方脚本。\n\n幸运的是，还有另一种选择。\n\n我们可以使用 `MutationObserver` 来自动检测何时在页面中插入了代码段，并高亮显示它们。\n\n因此，我们在一个地方处理高亮显示功能，从而使我们无需集成它。\n\n### 动态高亮显示示例\n\n这是一个工作示例。\n\n如果你运行这段代码，它将开始观察下面的元素，并高亮显示现在此处的所有代码段：\n\n```js run\nlet observer = new MutationObserver(mutations => {\n\n  for(let mutation of mutations) {\n    // 检查新节点，有什么需要高亮显示的吗？\n\n    for(let node of mutation.addedNodes) {\n      // 我们只跟踪元素，跳过其他节点（例如文本节点）\n      if (!(node instanceof HTMLElement)) continue;\n\n      // 检查插入的元素是否为代码段\n      if (node.matches('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(node);\n      }\n\n      // 或者可能在子树的某个地方有一个代码段？\n      for(let elem of node.querySelectorAll('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(elem);\n      }\n    }\n  }\n\n});\n\nlet demoElem = document.getElementById('highlight-demo');\n\nobserver.observe(demoElem, {childList: true, subtree: true});\n```\n\n下面有一个 HTML 元素，以及使用 `innerHTML` 动态填充它的 JavaScript。\n\n请先运行前面那段代码（上面那段，观察元素），然后运行下面这段代码。你将看到 `MutationObserver` 是如何检测并高亮显示代码段的。\n\n<p id=\"highlight-demo\" style=\"border: 1px solid #ddd\">一个具有 <code>id=\"highlight-demo\"</code> 的示例元素，运行上面那段代码来观察它。</p>\n\n下面这段代码填充了其 `innerHTML`，这导致 `MutationObserver` 作出反应，并突出显示其内容：\n\n```js run\nlet demoElem = document.getElementById('highlight-demo');\n\n// 动态插入带有代码段的内容\ndemoElem.innerHTML = `下面是一个代码段：\n  <pre class=\"language-javascript\"><code> let hello = \"world!\"; </code></pre>\n  <div>另一个代码段：</div>\n  <div>\n    <pre class=\"language-css\"><code>.class { margin: 5px; } </code></pre>\n  </div>\n`;\n```\n\n现在我们有了 `MutationObserver`，它可以跟踪观察到的元素中的，或者整个 `document` 中的所有高亮显示。我们可以在 HTML 中添加/删除代码段，而无需考虑高亮问题。\n\n## 其他方法\n\n有一个方法可以停止观察节点：\n\n- `observer.disconnect()` —— 停止观察。\n\n当我们停止观察时，观察器可能尚未处理某些更改。在种情况下，我们使用：\n\n- `observer.takeRecords()` —— 获取尚未处理的变动记录列表，表中记录的是已经发生，但回调暂未处理的变动。\n\n这些方法可以一起使用，如下所示：\n\n```js\n// 如果你关心可能未处理的近期的变动\n// 那么，应该在 disconnect 前调用获取未处理的变动列表\nlet mutationRecords = observer.takeRecords();\n\n// 停止跟踪变动\nobserver.disconnect();\n...\n```\n\n\n```smart header=\"`observer.takeRecords()` 返回的记录被从处理队列中移除\"\n回调函数不会被 `observer.takeRecords()` 返回的记录调用。\n```\n\n```smart header=\"垃圾回收\"\n观察器在内部对节点使用弱引用。也就是说，如果一个节点被从 DOM 中移除了，并且该节点变得不可访问，那么它就可以被垃圾回收。\n\n观察到 DOM 节点这一事实并不能阻止垃圾回收。\n```\n\n## 总结  \n\n`MutationObserver` 可以对 DOM 的变化作出反应 —— 特性（attribute），文本内容，添加/删除元素。\n\n我们可以用它来跟踪代码其他部分引入的更改，以及与第三方脚本集成。\n\n`MutationObserver` 可以跟踪任何更改。`config` “要观察的内容”选项用于优化，避免不必要的回调调用以节省资源。",
        "libs": [],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1605411514
      }
    },
    "selection-range": {
      "type": "Article",
      "value": {
        "title": "选择（Selection）和范围（Range）",
        "slug": "selection-range",
        "githubPath": "/2-ui/99-ui-misc/02-selection-range",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n在本章中，我们将介绍文档中的选择以及在表单字段（如 `<input>`）中的选择。\n\nJavaScript 可以访问现有的选择，选择/取消全部或部分 DOM 节点的选择，从文档中删除所选部分，将其包装到一个标签（tag）中，等。\n\n你可以在本章末尾的“总结”部分找到一些常见的使用方式。可能就已经满足了你当前的需求，但如果你阅读全文，将会有更多收获。\n\n底层的（underlying）`Range` 和 `Selection` 对象很容易掌握，因此，你不需要任何诀窍便可以使用它们做你想要做的事儿。\n\n## 范围\n\n选择的基本概念是 [Range](https://dom.spec.whatwg.org/#ranges)：本质上是一对“边界点”：范围起点和范围终点。\n\n在没有任何参数的情况下，创建一个 `Range` 对象：\n\n```js\nlet range = new Range();\n```\n\n然后，我们可以使用 `range.setStart(node, offset)` 和 `range.setEnd(node, offset)` 来设置选择边界。\n\n正如你可能猜到的那样，我们将进一步使用 `Range` 对象进行选择，但首先让我们创建一些这样的对象。\n\n### 选择部分文本\n\n有趣的是，这两种方法中的第一个参数 `node` 都可以是文本节点或元素节点，而第二个参数的含义依赖于此。\n\n**如果 `node` 是一个文本节点，那么 `offset` 则必须是其文本中的位置。**\n\n例如，对于给定的 `<p>Hello</p>`，我们可以像下面这样创建一个包含字母 \"ll\" 的范围：\n\n```html run\n<p id=\"p\">Hello</p>\n<script>\n  let range = new Range();\n  range.setStart(p.firstChild, 2);\n  range.setEnd(p.firstChild, 4);\n  \n  // 对 range 进行 toString 处理，range 则会把其包含的内容以文本的形式返回\n  console.log(range); // ll\n</script>\n```\n\n在这里，我们获取 `<p>` 的第一个子节点（即文本节点）并指定其中的文本位置：\n\n![](range-hello-1.svg)\n\n### 选择元素节点\n\n**或者，如果 `node` 是一个元素节点，那么 `offset` 则必须是子元素的编号。**\n\n这对于创建包含整个节点的范围很方便，而不是在其文本中的某处停止。\n\n例如，我们有一个更复杂的文档片段：\n\n```html autorun\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n```\n\n这是它的 DOM 结构，包含元素和文本节点：\n\n<div class=\"select-p-domtree\"></div>\n\n<script>\nlet selectPDomtree = {\n  \"name\": \"P\",\n  \"nodeType\": 1,\n  \"children\": [{\n    \"name\": \"#text\",\n    \"nodeType\": 3,\n    \"content\": \"Example: \"\n  }, {\n    \"name\": \"I\",\n    \"nodeType\": 1,\n    \"children\": [{\n      \"name\": \"#text\",\n      \"nodeType\": 3,\n      \"content\": \"italic\"\n    }]\n  }, {\n    \"name\": \"#text\",\n    \"nodeType\": 3,\n    \"content\": \" and \"\n  }, {\n    \"name\": \"B\",\n    \"nodeType\": 1,\n    \"children\": [{\n      \"name\": \"#text\",\n      \"nodeType\": 3,\n      \"content\": \"bold\"\n    }]\n  }]\n}\n\ndrawHtmlTree(selectPDomtree, 'div.select-p-domtree', 690, 320);\n</script>\n\n让我们为 `\"Example: <i>italic</i>\"` 设置一个范围。\n\n正如我们所看到的，这个短语正好由 `<p>` 的索引为 `0` 和 `1` 的两个子元素组成。\n\n![](range-example-p-0-1.svg)\n\n- 起点以 `<p>` 作为父节点 `node`，`0` 作为偏移量。\n\n    因此，我们可以将其设置为 `range.setStart(p, 0)`。\n- 终点也是以 `<p>` 作为父节点 `node`，但以 `2` 作为偏移量（它指定最大范围，但不包括 `offset`）。\n\n    因此，我们可以将其设置为 `range.setEnd(p, 2)`。\n\n示例如下，如果你运行它，你可以看到文本被选中：\n\n```html run\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n*!*\n  let range = new Range();\n\n  range.setStart(p, 0);\n  range.setEnd(p, 2);\n*/!*\n\n  // 范围的 toString 以文本形式返回其内容，不带标签\n  console.log(range); // Example: italic\n\n  // 将此范围应用于文档选择，后文有解释\n  document.getSelection().addRange(range);\n</script>\n```\n\n这是一个更灵活的测试台，你可以在其中设置范围开始/结束编号，并探索各种情况：\n\n```html run autorun\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"start\" type=\"number\" value=1> – To <input id=\"end\" type=\"number\" value=4>\n<button id=\"button\">Click to select</button>\n<script>\n  button.onclick = () => {\n  *!*\n    let range = new Range();\n\n    range.setStart(p, start.value);\n    range.setEnd(p, end.value);\n  */!*\n\n    // 应用选择，后文有解释\n    document.getSelection().removeAllRanges();\n    document.getSelection().addRange(range);\n  };\n</script>\n```\n\n例如，在同一个 `<p>` 中从偏移量 `1` 到 `4` 选择得到的范围为 `<i>italic</i> and <b>bold</b>`：\n\n![](range-example-p-1-3.svg)\n\n```smart header=\"起始和结束的节点可以不同\"\n我们不是必须在 `setStart` 和 `setEnd` 中使用相同的节点。一个范围可能会跨越很多不相关的节点。唯一要注意的是终点要在起点之后。\n```\n\n### 选择更大的片段\n\n让我们在示例中选择一个更大的片段，像这样：\n\n![](range-example-p-2-b-3.svg)\n\n我们已经知道如何实现它了。我们只需要将起点和终点设置为文本节点中的相对偏移量即可。\n\n我们需要创建一个范围，它：\n- 从 `<p>` 的第一个子节点的位置 2 开始（选择 \"Ex<b>ample:</b> \" 中除前两个字母外的所有字母）\n- 到 `<b>` 的第一个子节点的位置 3 结束（选择 \"<b>bol</b>d\" 的前三个字母，就这些）：\n\n```html run\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n\n  range.setStart(p.firstChild, 2);\n  range.setEnd(p.querySelector('b').firstChild, 3);\n\n  console.log(range); // ample: italic and bol\n\n  // 使用此范围进行选择（后文有解释）\n  window.getSelection().addRange(range);\n</script>\n```\n\n正如你所看到的，选择我们想要的范围其实很容易实现。\n\n如果我们想将节点作为一个整体，我们可以将元素传入 `setStart/setEnd`。否则，我们可以在文本层级上进行操作。\n\n## range 属性\n\n我们在上面的示例中创建的 `range` 对象具有以下属性：\n\n![](range-example-p-2-b-3-range.svg)\n\n- `startContainer`，`startOffset` —— 起始节点和偏移量，\n  - 在上例中：分别是 `<p>` 中的第一个文本节点和 `2`。\n- `endContainer`，`endOffset` —— 结束节点和偏移量，\n  - 在上例中：分别是 `<b>` 中的第一个文本节点和 `3`。\n- `collapsed` —— 布尔值，如果范围在同一点上开始和结束（所以范围内没有内容）则为 `true`，\n  - 在上例中：`false`\n- `commonAncestorContainer` —— 在范围内的所有节点中最近的共同祖先节点，\n  - 在上例中：`<p> `\n\n\n## 选择范围的方法\n\n有许多便利的方法可以操纵范围。\n\n我们已经见过了 `setStart` 和 `setEnd`，这还有其他类似的方法。\n\n设置范围的起点：\n\n- `setStart(node, offset)` 将起点设置在：`node` 中的位置 `offset`\n- `setStartBefore(node)` 将起点设置在：`node` 前面\n- `setStartAfter(node)` 将起点设置在：`node` 后面\n\n设置范围的终点（类似的方法）：\n\n- `setEnd(node, offset)` 将终点设置为：`node` 中的位置 `offset`\n- `setEndBefore(node)` 将终点设置为：`node` 前面\n- `setEndAfter(node)` 将终点设置为：`node` 后面\n\n从技术上讲，`setStart/setEnd` 可以做任何事，但是更多的方法提供了更多的便捷性。\n\n在所有这些方法中，`node` 都可以是文本或者元素节点：对于文本节点，偏移量 `offset` 跨越的是很多字母，而对于元素节点则跨越的是很多子节点。\n\n更多创建范围的方法：\n- `selectNode(node)` 设置范围以选择整个 `node`\n- `selectNodeContents(node)` 设置范围以选择整个 `node` 的内容\n- `collapse(toStart)` 如果 `toStart=true` 则设置 end=start，否则设置 start=end，从而折叠范围\n- `cloneRange()` 创建一个具有相同起点/终点的新范围\n\n## 编辑范围的方法\n\n创建范围后，我们可以使用以下方法操作其内容：\n\n- `deleteContents()` —— 从文档中删除范围中的内容\n- `extractContents()` —— 从文档中删除范围中的内容，并将删除的内容作为 [DocumentFragment](info:modifying-document#document-fragment) 返回\n- `cloneContents()` —— 复制范围中的内容，并将复制的内容作为 [DocumentFragment](info:modifying-document#document-fragment) 返回\n- `insertNode(node)` —— 在范围的起始处将 `node` 插入文档\n- `surroundContents(node)` —— 使用 `node` 将所选范围中的内容包裹起来。要使此操作有效，则该范围必须包含其中所有元素的开始和结束标签：不能像 `<i>abc` 这样的部分范围。\n\n使用这些方法，我们基本上可以对选定的节点执行任何操作。\n\n这是在测试台上看到它们的实际效果：\n\n```html run refresh autorun height=260\n点击按钮运行所选内容上的方法，点击 \"resetExample\" 进行重置。\n\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<p id=\"result\"></p>\n<script>\n  let range = new Range();\n\n  // 下面演示了上述的每个方法：\n  let methods = {\n    deleteContents() {\n      range.deleteContents()\n    },\n    extractContents() {\n      let content = range.extractContents();\n      result.innerHTML = \"\";\n      result.append(\"extracted: \", content);\n    },\n    cloneContents() {\n      let content = range.cloneContents();\n      result.innerHTML = \"\";\n      result.append(\"cloned: \", content);\n    },\n    insertNode() {\n      let newNode = document.createElement('u');\n      newNode.innerHTML = \"NEW NODE\";\n      range.insertNode(newNode);\n    },\n    surroundContents() {\n      let newNode = document.createElement('u');\n      try {\n        range.surroundContents(newNode);\n      } catch(e) { console.log(e) }\n    },\n    resetExample() {\n      p.innerHTML = `Example: <i>italic</i> and <b>bold</b>`;\n      result.innerHTML = \"\";\n\n      range.setStart(p.firstChild, 2);\n      range.setEnd(p.querySelector('b').firstChild, 3);\n\n      window.getSelection().removeAllRanges();  \n      window.getSelection().addRange(range);  \n    }\n  };\n\n  for(let method in methods) {\n    document.write(`<div><button onclick=\"methods.${method}()\">${method}</button></div>`);\n  }\n\n  methods.resetExample();\n</script>\n```\n\n还有比较范围的方法，但是很少使用。当你需要它们时，请参考 [规范](https://dom.spec.whatwg.org/#interface-range) 或 [MDN 手册](mdn:/api/Range)。\n\n\n## 选择\n\n`Range` 是用于管理选择范围的通用对象。尽管创建一个 `Range` 并不意味着我们可以在屏幕上看到一个内容选择。\n\n我们可以创建 `Range` 对象并传递它们 —— 但它们并不会在视觉上选择任何内容。\n\n文档选择是由 `Selection` 对象表示的，可通过 `window.getSelection()` 或 `document.getSelection()` 来获取。一个选择可以包括零个或多个范围。至少，[Selection API 规范](https://www.w3.org/TR/selection-api/) 是这么说的。不过实际上，只有 Firefox 允许使用 `key:Ctrl+click` (Mac 上用 `key:Cmd+click`) 在文档中选择多个范围。\n\n这是在 Firefox 中做的一个具有 3 个范围的选择的截图：\n\n![](selection-firefox.svg)\n\n其他浏览器最多支持 1 个范围。正如我们将看到的，某些 `Selection` 方法暗示可能有多个范围，但同样，在除 Firefox 之外的所有浏览器中，范围最多是 1。\n\n这是一个小例子，将当前的选择（选择一些内容然后点击按钮）以文本的形式显示出来：\n\n<button onclick=\"alert(document.getSelection())\">alert(document.getSelection())</button>\n\n## 选择属性\n\n如前所述，理论上一个选择可能包含多个范围。我们可以使用下面这个方法获取这些范围对象：\n\n- `getRangeAt(i)` —— 获取第 `i` 个范围，`i` 从 `0` 开始。在除 Firefox 之外的所有浏览器中，仅使用 `0`。\n\n此外，还有更方便的属性。\n\n与范围类似，选择的起点被称为“锚点（anchor）”，终点被称为“焦点（focus）”。\n\n主要的选择属性有：\n\n- `anchorNode` —— 选择的起始节点，\n- `anchorOffset` —— 选择开始的 `anchorNode` 中的偏移量，\n- `focusNode` —— 选择的结束节点，\n- `focusOffset` —— 选择开始处 `focusNode` 的偏移量，\n- `isCollapsed` —— 如果未选择任何内容（空范围）或不存在，则为 `true` 。\n- `rangeCount` —— 选择中的范围数，除 Firefox 外，其他浏览器最多为 `1`。\n\n```smart header=\"选择和范围的起点和终点对比\"\n\n选择（selection）的锚点/焦点和 `Range` 的起点和终点有一个很重要的区别。\n\n正如我们所知道的，`Range` 对象的起点必须在其终点之前。\n \n但对于选择，并不总是这样的。\n\n我们可以在两个方向上使用鼠标进行选择：“从左到右”或“从右到左”。\n\n换句话说，当按下鼠标按键，然后它在文档中向前移动时，它结束的位置（焦点）将在它开始的位置（锚点）之后。\n\n例如，如果用户使用鼠标从 \"Example\" 开始选择到 \"italic\"：\n\n![](selection-direction-forward.svg)\n\n但是，我们也可以从前向后进行相同的选择：从 \"italic\" 到 \"Example\"（从前向后），这样它结束的位置（焦点）将在它开始的位置（锚点）之前。\n\n![](selection-direction-backward.svg)\n```\n\n## 选择事件\n\n有一些事件可以跟踪选择：\n\n- `elem.onselectstart` —— 当在元素 `elem` 上（或在其内部）**开始**选择时。例如，当用户在元素 `elem` 上按下鼠标按键并开始移动指针时。\n    - 阻止默认行为取消了选择的开始。因此，从该元素开始选择变得不可能，但该元素仍然是可选择的。用户只需要从其他地方开始选择。\n- `document.onselectionchange` —— 当选择发生变化或开始时。\n    - 请注意：此处理程序只能在 `document` 上设置。它跟踪的是 `document` 中的所有选择。\n\n### 选择跟踪演示\n\n下面是一个小例子，它跟踪了 `document` 上当前的选择，并将选择边界显示出来：\n\n```html run height=80\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n<script>\n  document.onselectionchange = function() {\n    let selection = document.getSelection();\n\n    let {anchorNode, anchorOffset, focusNode, focusOffset} = selection;\n\n    // anchorNode 和 focusNode 通常是文本节点\n    from.value = `${anchorNode?.data}, offset ${anchorOffset}`;\n    to.value = `${focusNode?.data}, offset ${focusOffset}`;\n  };\n</script>\n```\n\n### 选择复制演示\n\n复制所选内容有两种方式：\n\n1. 我们可以使用 `document.getSelection().toString()` 来获取其文本形式。\n2. 此外，想要复制整个 DOM 节点，例如，如果我们需要保持其格式不变，我们可以使用 `getRangeAt(...)` 获取底层的（underlying）范围。`Range` 对象还具有 `cloneContents()` 方法，该方法会拷贝范围中的内容并以 `DocumentFragment` 的形式返回，我们可以将这个返回值插入到其他位置。\n\n下面是将所选内容复制为文本和 DOM 节点的演示：\n\n```html run height=100\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nCloned: <span id=\"cloned\"></span>\n<br>\nAs text: <span id=\"astext\"></span>\n\n<script>\n  document.onselectionchange = function() {\n    let selection = document.getSelection();\n\n    cloned.innerHTML = astext.innerHTML = \"\";\n\n    // 从范围复制 DOM 节点（这里我们支持多选）\n    for (let i = 0; i < selection.rangeCount; i++) {\n      cloned.append(selection.getRangeAt(i).cloneContents());\n    }\n\n    // 获取为文本形式\n    astext.innerHTML += selection;\n  };\n</script>\n```\n\n## 选择方法\n\n我们可以通过添加/移除范围来处理选择：\n\n- `getRangeAt(i)` —— 获取从 `0` 开始的第 i 个范围。在除 Firefox 之外的所有浏览器中，仅使用 `0`。\n- `addRange(range)` —— 将 `range` 添加到选择中。如果选择已有关联的范围，则除 Firefox 外的所有浏览器都将忽略该调用。\n- `removeRange(range)` —— 从选择中删除 `range`。\n- `removeAllRanges()` —— 删除所有范围。\n- `empty()` —— `removeAllRanges` 的别名。\n\n还有一些方便的方法可以直接操作选择范围，而无需中间的 `Range` 调用：\n\n- `collapse(node, offset)` —— 用一个新的范围替换选定的范围，该新范围从给定的 `node` 处开始，到偏移 `offset` 处结束。\n- `setPosition(node, offset)` —— `collapse` 的别名。\n- `collapseToStart()` —— 折叠（替换为空范围）到选择起点，\n- `collapseToEnd()` —— 折叠到选择终点，\n- `extend(node, offset)` —— 将选择的焦点（focus）移到给定的 `node`，位置偏移 `oofset`，\n- `setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)` —— 用给定的起点 `anchorNode/anchorOffset` 和终点 `focusNode/focusOffset` 来替换选择范围。选中它们之间的所有内容。\n- `selectAllChildren(node)` —— 选择 `node` 的所有子节点。\n- `deleteFromDocument()` —— 从文档中删除所选择的内容。\n- `containsNode(node, allowPartialContainment = false)` —— 检查选择中是否包含 `node`（若第二个参数是 `true`，则只需包含 `node` 的部分内容即可）\n\n对于大多数需求，这些方法就够了，无需访问底层的（underlying）`Range` 对象。\n\n例如，选择段落 `<p>` 的全部内容：\n\n```html run\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  // 从 <p> 的第 0 个子节点选择到最后一个子节点\n  document.getSelection().setBaseAndExtent(p, 0, p, p.childNodes.length);\n</script>\n```\n\n使用范围来完成同一个操作：\n\n```html run\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n  range.selectNodeContents(p); // 或者也可以使用 selectNode(p) 来选择 <p> 标签\n\n  document.getSelection().removeAllRanges(); // 清除现有选择（如果有的话）\n  document.getSelection().addRange(range);\n</script>\n```\n\n```smart header=\"如要选择一些内容，请先移除现有的选择\"\n如果在文档中已存在选择，则首先使用 `removeAllRanges()` 将其清空。然后添加范围。否则，除 Firefox 外的所有浏览器都将忽略新范围。\n\n某些选择方法例外，它们会替换现有的选择，例如 `setBaseAndExtent`。\n```\n\n## 表单控件中的选择\n\n诸如 `input` 和 `textarea` 等表单元素提供了 [专用的选择 API](https://html.spec.whatwg.org/#textFieldSelection)，没有 `Selection` 或 `Range` 对象。由于输入值是纯文本而不是 HTML，因此不需要此类对象，一切都变得更加简单。\n\n属性：\n- `input.selectionStart` —— 选择的起始位置（可写），\n- `input.selectionEnd` —— 选择的结束位置（可写），\n- `input.selectionDirection` —— 选择方向，其中之一：\"forward\"，\"backward\" 或 \"none\"（例如使用鼠标双击进行的选择），\n\n事件：\n- `input.onselect` —— 当某个东西被选择时触发。\n\n方法：\n\n- `input.select()` —— 选择文本控件中的所有内容（可以是 `textarea` 而不是 `input`），\n- `input.setSelectionRange(start, end, [direction])` —— 在给定方向上（可选），从 `start` 一直选择到 `end`。\n- `input.setRangeText(replacement, [start], [end], [selectionMode])` —— 用新文本替换范围中的文本。\n\n    可选参数 `start` 和 `end`，如果提供的话，则设置范围的起点和终点，否则使用用户的选择。\n\n    最后一个参数 `selectionMode` 决定替换文本后如何设置选择。可能的值为：\n\n    - `\"select\"` —— 将选择新插入的文本。\n    - `\"start\"` —— 选择范围将在插入的文本之前折叠（光标将在其之前）。\n    - `\"end\"` —— 选择范围将在插入的文本之后折叠（光标将紧随其后）。\n    - `\"preserve\"` —— 尝试保留选择。这是默认值。\n\n现在，让我们看看这些方法的实际使用。\n\n### 示例：跟踪选择\n\n例如，此段代码使用 `onselect` 事件来跟踪选择：\n\n```html run autorun\n<textarea id=\"area\" style=\"width:80%;height:60px\">\nSelecting in this text updates values below.\n</textarea>\n<br>\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n\n<script>\n  area.onselect = function() {\n    from.value = area.selectionStart;\n    to.value = area.selectionEnd;\n  };\n</script>\n```\n\n请注意：\n- `onselect` 是在某项被选择时触发，而在选择被删除时不触发。\n- 根据 [规范](https://w3c.github.io/selection-api/#dfn-selectionchange)，表单控件内的选择不应该触发 `document.onselectionchange` 事件，因为它与 `document` 选择和范围不相关。一些浏览器会生成它，但我们不应该依赖它。\n\n\n### 示例：移动光标\n\n我们可以更改 `selectionStart` 和 `selectionEnd`，二者设定了选择。\n\n一个重要的边界情况是 `selectionStart` 和 `selectionEnd` 彼此相等。那正是光标位置。或者，换句话说，当未选择任何内容时，选择会折叠在光标位置。\n\n因此，通过将 `selectionStart` 和 `selectionEnd` 设置为相同的值，我们可以移动光标。\n\n例如：\n\n```html run autorun\n<textarea id=\"area\" style=\"width:80%;height:60px\">\nFocus on me, the cursor will be at position 10.\n</textarea>\n\n<script>\n  area.onfocus = () => {\n    // 设置零延迟 setTimeout 以在浏览器 \"focus\" 行为完成后运行\n    setTimeout(() => {\n      // 我们可以设置任何选择\n      // 如果 start=end，则光标就会在该位置\n      area.selectionStart = area.selectionEnd = 10;\n    });\n  };\n</script>\n```\n\n### 示例：修改选择\n\n如要修改选择的内容，我们可以使用 `input.setRangeText()` 方法。当然，我们可以读取 `selectionStart/End`，并在了解选择的情况下更改 `value` 的相应子字符串，但是 `setRangeText` 功能更强大，通常更方便。\n\n那是一个有点复杂的方法。使用其最简单的单参数形式，它可以替换用户选择的范围并删除该选择。\n\n例如，这里的用户的选择将被包装在 `*...*` 中：\n\n```html run autorun\n<input id=\"input\" style=\"width:200px\" value=\"Select here and click the button\">\n<button id=\"button\">Wrap selection in stars *...*</button>\n\n<script>\nbutton.onclick = () => {\n  if (input.selectionStart == input.selectionEnd) {\n    return; // 什么都没选\n  }\n\n  let selected = input.value.slice(input.selectionStart, input.selectionEnd);\n  input.setRangeText(`*${selected}*`);\n};\n</script>\n```\n\n使用更多参数，我们可以设置范围 `start` 和 `end`。\n\n在下面这个示例中，我们在输入文本中找到 `\"THIS\"`，将其替换，并保持替换文本的选中状态：\n\n```html run autorun\n<input id=\"input\" style=\"width:200px\" value=\"Replace THIS in text\">\n<button id=\"button\">Replace THIS</button>\n\n<script>\nbutton.onclick = () => {\n  let pos = input.value.indexOf(\"THIS\");\n  if (pos >= 0) {\n    input.setRangeText(\"*THIS*\", pos, pos + 4, \"select\");\n    input.focus(); // 聚焦（focus），以使选择可见\n  }\n};\n</script>\n```\n\n### 示例：在光标处插入\n\n如果未选择任何内容，或者我们在 `setRangeText` 中使用了相同的 `start` 和 `end`，则仅插入新文本，不会删除任何内容。\n\n我们也可以使用 `setRangeText` 在“光标处”插入一些东西。\n\n这是一个按钮，按下后会在光标位置插入 `\"HELLO\"`，然后光标紧随其后。如果选择不为空，则将其替换（我们可以通过比较 `selectionStart!=selectionEnd` 来进行检查，为空则执行其他操作）：\n\n```html run autorun\n<input id=\"input\" style=\"width:200px\" value=\"Text Text Text Text Text\">\n<button id=\"button\">Insert \"HELLO\" at cursor</button>\n\n<script>\n  button.onclick = () => {\n    input.setRangeText(\"HELLO\", input.selectionStart, input.selectionEnd, \"end\");\n    input.focus();\n  };    \n</script>\n```\n\n\n## 使不可选\n\n要使某些内容不可选，有三种方式：\n\n1. 使用 CSS 属性 `user-select: none`。\n\n    ```html run\n    <style>\n    #elem {\n      user-select: none;\n    }\n    </style>\n    <div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n    ```\n\n    这样不允许选择从 `elem` 开始。但是用户可以在其他地方开始选择，并将 `elem` 包含在内。\n\n    然后 `elem` 将成为 `document.getSelection()` 的一部分，因此选择实际发生了，但是在复制粘贴中，其内容通常会被忽略。\n\n\n2. 防止 `onselectstart` 或 `mousedown` 事件中的默认行为。\n\n    ```html run\n    <div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n\n    <script>\n      elem.onselectstart = () => false;\n    </script>\n    ```\n\n    这样可以防止在 `elem` 上开始选择，但是访问者可以在另一个元素上开始选择，然后扩展到 `elem`。\n\n    当同一行为上有另一个事件处理程序触发选择时（例如 `mousedown`），这会很方便。因此我们禁用选择以避免冲突，仍然允许复制 `elem` 内容。\n\n3. 我们还可以使用 `document.getSelection().empty()` 来在选择发生后清除选择。很少使用这种方法，因为这会在选择项消失时导致不必要的闪烁。\n\n## 参考\n\n- [DOM 规范：范围（Range）](https://dom.spec.whatwg.org/#ranges)\n- [选择（Selection）API](https://www.w3.org/TR/selection-api/#dom-globaleventhandlers-onselectstart)\n- [HTML 规范：用于文本控件选择的 API](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#textFieldSelection)\n\n\n## 总结\n\n我们介绍了用于选择的两种不同的 API：\n\n1. 对于文档：`Selection` 和 `Range` 对象。\n2. 对于 `input`，`textarea`：其他方法和属性。\n\n第二个 API 非常简单，因为它处理的是文本。\n\n最常用的方案一般是：\n\n1. 获取选择：\n    ```js\n    let selection = document.getSelection();\n\n    let cloned = /* 要将所选的节点克隆到的元素 */;\n\n    // 然后将 Range 方法应用于 selection.getRangeAt(0)\n    // 或者，像这样，用于所有范围，以支持多选\n    for (let i = 0; i < selection.rangeCount; i++) {\n      cloned.append(selection.getRangeAt(i).cloneContents());\n    }\n    ```\n2. 设置选择\n    ```js\n    let selection = document.getSelection();\n\n    // 直接：\n    selection.setBaseAndExtent(...from...to...);\n\n    // 或者我们可以创建一个范围并：\n    selection.removeAllRanges();\n    selection.addRange(range);\n    ```\n\n最后，关于光标。在诸如 `<textarea>` 之类的可编辑元素中，光标的位置始终位于选择的起点或终点。我们可以通过设置 `elem.selectionStart` 和 `elem.selectionEnd` 来获取光标位置或移动光标。",
        "libs": [
          "d3",
          "domtree"
        ],
        "children": [],
        "parent": "ui-misc",
        "updatedAt": 1667114531
      }
    },
    "event-loop": {
      "type": "Article",
      "value": {
        "title": "事件循环：微任务和宏任务",
        "slug": "event-loop",
        "githubPath": "/2-ui/99-ui-misc/03-event-loop",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 **事件循环** 的。\n\n理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。\n\n在本章中，我们首先介绍事件循环工作方式的理论细节，然后介绍该知识的实际应用。\n\n## 事件循环\n\n**事件循环** 的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。\n\n引擎的一般算法：\n\n1. 当有任务时：\n    - 从最先进入的任务开始执行。\n2. 休眠直到出现任务，然后转到第 1 步。\n\n当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行。\n\n任务示例：\n\n- 当外部脚本 `<script src=\"...\">` 加载完成时，任务就是执行它。\n- 当用户移动鼠标时，任务就是派生出 `mousemove` 事件和执行处理程序。\n- 当安排的（scheduled）`setTimeout` 时间到达时，任务就是执行其回调。\n- ……诸如此类。\n\n设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。\n\n一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。\n\n多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：\n\n![](eventLoop.svg)\n\n例如，当引擎正在忙于执行一段 `script` 时，用户可能会移动鼠标而产生 `mousemove` 事件，`setTimeout` 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。\n\n队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 `script` 后，它会处理 `mousemove` 事件，然后处理 `setTimeout` 处理程序，依此类推。\n\n到目前为止，很简单，对吧？\n\n两个细节：\n1. 引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。\n2. 如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。\n\n以上是理论知识。现在，让我们来看看如何应用这些知识。\n\n## 用例 1：拆分 CPU 过载任务\n\n假设我们有一个 CPU 过载任务。\n\n例如，语法高亮（用来给本页面中的示例代码着色）是相当耗费 CPU 资源的任务。为了高亮显示代码，它执行分析，创建很多着了色的元素，然后将它们添加到文档中 —— 对于文本量大的文档来说，需要耗费很长时间。\n\n当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间，这是不可接受的。\n\n我们可以通过将大任务拆分成多个小任务来避免这个问题。高亮显示前 100 行，然后使用 `setTimeout`（延时参数为 0）来安排（schedule）后 100 行的高亮显示，依此类推。\n\n为了演示这种方法，简单起见，让我们写一个从 `1` 数到 `1000000000` 的函数，而不写文本高亮。\n\n如果你运行下面这段代码，你会看到引擎会“挂起”一段时间。对于服务端 JS 来说这显而易见，并且如果你在浏览器中运行它，尝试点击页面上其他按钮时，你会发现在计数结束之前不会处理其他事件。\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // 做一个繁重的任务\n  for (let j = 0; j < 1e9; j++) {\n    i++;\n  }\n\n  alert(\"Done in \" + (Date.now() - start) + 'ms');\n}\n\ncount();\n```\n\n浏览器甚至可能会显示一个“脚本执行时间过长”的警告。\n\n让我们使用嵌套的 `setTimeout` 调用来拆分这个任务：\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // 做繁重的任务的一部分 (*)\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  } else {\n    setTimeout(count); // 安排（schedule）新的调用 (**)\n  }\n\n}\n\ncount();\n```\n\n现在，浏览器界面在“计数”过程中可以正常使用。\n\n单次执行 `count` 会完成工作 `(*)` 的一部分，然后根据需要重新安排（schedule）自身的执行 `(**)`：\n\n1. 首先执行计数：`i=1...1000000`。\n2. 然后执行计数：`i=1000001..2000000`。\n3. ……以此类推。\n\n现在，如果在引擎忙于执行第一部分时出现了一个新的副任务（例如 `onclick` 事件），则该任务会被排入队列，然后在第一部分执行结束时，并在下一部分开始执行前，会执行该副任务。周期性地在两次 `count` 执行期间返回事件循环，这为 JavaScript 引擎提供了足够的“空气”来执行其他操作，以响应其他的用户行为。\n\n值得注意的是这两种变体 —— 是否使用了 `setTimeout` 对任务进行拆分 —— 在执行速度上是相当的。在执行计数的总耗时上没有多少差异。\n\n为了使两者耗时更接近，让我们来做一个改进。\n\n我们将要把调度（scheduling）移动到 `count()` 的开头：\n\n```js run\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // 将调度（scheduling）移动到开头\n  if (i < 1e9 - 1e6) {\n    setTimeout(count); // 安排（schedule）新的调用\n  }\n\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  }\n\n}\n\ncount();\n```\n\n现在，当我们开始调用 `count()` 时，会看到我们需要对 `count()` 进行更多调用，我们就会在工作前立即安排（schedule）它。\n\n如果你运行它，你很容易注意到它花费的时间明显减少了。\n\n为什么？\n\n这很简单：你应该还记得，多个嵌套的 `setTimeout` 调用在浏览器中的最小延迟为 4ms。即使我们设置了 `0`，但还是 `4ms`（或者更久一些）。所以我们安排（schedule）得越早，运行速度也就越快。\n\n最后，我们将一个繁重的任务拆分成了几部分，现在它不会阻塞用户界面了。而且其总耗时并不会长很多。\n\n## 用例 2：进度指示\n\n对浏览器脚本中的过载型任务进行拆分的另一个好处是，我们可以显示进度指示。\n\n正如前面所提到的，仅在当前运行的任务完成后，才会对 DOM 中的更改进行绘制，无论这个任务运行花费了多长时间。\n\n从一方面讲，这非常好，因为我们的函数可能会创建很多元素，将它们一个接一个地插入到文档中，并更改其样式 —— 访问者不会看到任何未完成的“中间态”内容。很重要，对吧？\n\n这是一个示例，对 `i` 的更改在该函数完成前不会显示出来，所以我们将只会看到最后的值：\n\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n\n  function count() {\n    for (let i = 0; i < 1e6; i++) {\n      i++;\n      progress.innerHTML = i;\n    }\n  }\n\n  count();\n</script>\n```\n\n……但是我们也可能想在任务执行期间展示一些东西，例如进度条。\n\n如果我们使用 `setTimeout` 将繁重的任务拆分成几部分，那么变化就会被在它们之间绘制出来。\n\n这看起来更好看：\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // 做繁重的任务的一部分 (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e7) {\n      setTimeout(count);\n    }\n\n  }\n\n  count();\n</script>\n```\n\n现在 `div` 显示了 `i` 的值的增长，这就是进度条的一种。\n\n\n## 用例 3：在事件之后做一些事情\n\n在事件处理程序中，我们可能会决定推迟某些行为，直到事件冒泡并在所有级别上得到处理后。我们可以通过将该代码包装到零延迟的 `setTimeout` 中来做到这一点。\n\n在 <info:dispatch-events> 一章中，我们看到过这样一个例子：自定义事件 `menu-open` 被在 `setTimeout` 中分派（dispatched），所以它在 `click` 事件被处理完成之后发生。\n\n```js\nmenu.onclick = function() {\n  // ...\n\n  // 创建一个具有被点击的菜单项的数据的自定义事件\n  let customEvent = new CustomEvent(\"menu-open\", {\n    bubbles: true\n  });\n\n  // 异步分派（dispatch）自定义事件\n  setTimeout(() => menu.dispatchEvent(customEvent));\n};\n```\n\n## 宏任务和微任务\n\n除了本章中所讲的 **宏任务（macrotask）** 外，还有在 <info:microtask-queue> 一章中提到的 **微任务（microtask）**。\n\n微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 `.then/catch/finally` 处理程序的执行会成为微任务。微任务也被用于 `await` 的“幕后”，因为它是 promise 处理的另一种形式。\n\n还有一个特殊的函数 `queueMicrotask(func)`，它对 `func` 进行排队，以在微任务队列中执行。\n\n**每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。**\n\n例如，看看下面这个示例：\n\n```js run\nsetTimeout(() => alert(\"timeout\"));\n\nPromise.resolve()\n  .then(() => alert(\"promise\"));\n\nalert(\"code\");\n```\n\n这里的执行顺序是怎样的？\n\n1. `code` 首先显示，因为它是常规的同步调用。\n2. `promise` 第二个出现，因为 `then` 会通过微任务队列，并在当前代码之后执行。\n3. `timeout` 最后显示，因为它是一个宏任务。\n\n更详细的事件循环图示如下（顺序是从上到下，即：首先是脚本，然后是微任务，渲染等）：\n\n![](eventLoop-full.svg)\n\n微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成。\n\n这很重要，因为它确保了微任务之间的应用程序环境基本相同（没有鼠标坐标更改，没有新的网络数据等）。\n\n如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 `queueMicrotask` 来对其进行安排（schedule）。\n\n这是一个与前面那个例子类似的，带有“计数进度条”的示例，但是它使用了 `queueMicrotask` 而不是 `setTimeout`。你可以看到它在最后才渲染。就像写的是同步代码一样：\n\n```html run\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // 做繁重的任务的一部分 (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e6) {\n  *!*\n      queueMicrotask(count);\n  */!*\n    }\n\n  }\n\n  count();\n</script>\n```\n\n## 总结\n\n更详细的事件循环算法（尽管与 [规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model) 相比仍然是简化过的）：\n\n1. 从 **宏任务** 队列（例如 \"script\"）中出队（dequeue）并执行最早的任务。\n2. 执行所有 **微任务**：\n    - 当微任务队列非空时：\n        - 出队（dequeue）并执行最早的微任务。\n3. 如果有变更，则将变更渲染出来。\n4. 如果宏任务队列为空，则休眠直到出现宏任务。\n5. 转到步骤 1。\n\n安排（schedule）一个新的 **宏任务**：\n- 使用零延迟的 `setTimeout(f)`。\n\n它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。\n\n此外，也被用于在事件处理程序中，将一个行为（action）安排（schedule）在事件被完全处理（冒泡完成）后。\n\n安排一个新的 **微任务**：\n- 使用 `queueMicrotask(f)`。\n- promise 处理程序也会通过微任务队列。\n\n在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。\n\n所以，我们可以使用 `queueMicrotask` 来在保持环境状态一致的情况下，异步地执行一个函数。\n\n```smart header=\"Web Workers\"\n对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 [Web Workers](https://html.spec.whatwg.org/multipage/workers.html)。\n\n这是在另一个并行线程中运行代码的方式。\n\nWeb Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。\n\nWeb Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。\n```",
        "libs": [],
        "children": [
          "micro-macro-queue"
        ],
        "parent": "ui-misc",
        "updatedAt": 1651487520
      }
    },
    "micro-macro-queue": {
      "type": "Task",
      "value": {
        "title": "下方这段代码的输出是什么？",
        "slug": "micro-macro-queue",
        "githubPath": "/2-ui/99-ui-misc/03-event-loop/2-micro-macro-queue",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n```js\nconsole.log(1);\n\nsetTimeout(() => console.log(2));\n\nPromise.resolve().then(() => console.log(3));\n\nPromise.resolve().then(() => setTimeout(() => console.log(4)));\n\nPromise.resolve().then(() => console.log(5));\n\nsetTimeout(() => console.log(6));\n\nconsole.log(7);\n```",
        "solution": "输出结果为：1 7 3 5 2 6 4。\n\n这道题其实很简单，我们只需要知道微任务和宏任务队列是如何工作的。\n\n让我们一起一步一步地看看发生了什么。\n\n```js\nconsole.log(1);\n// 第一行立即执行，它输出 `1`。\n// 到目前为止，宏任务队列和微任务队列都是空的。\n\nsetTimeout(() => console.log(2));\n// `setTimeout` 将回调添加到宏任务队列。\n// - 宏任务队列中的内容：\n//   `console.log(2)`\n\nPromise.resolve().then(() => console.log(3));\n// 将回调添加到微任务队列。\n// - 微任务队列中的内容：\n//   `console.log(3)`\n\nPromise.resolve().then(() => setTimeout(() => console.log(4)));\n// 带有 `setTimeout(...4)` 的回调被附加到微任务队列。\n// - 微任务队列中的内容：\n//   `console.log(3); setTimeout(...4)`\n\nPromise.resolve().then(() => console.log(5));\n// 回调被添加到微任务队列\n// - 微任务队列中的内容：\n//   `console.log(3); setTimeout(...4); console.log(5)`\n\nsetTimeout(() => console.log(6));\n// `setTimeout` 将回调添加到宏任务队列\n// - 宏任务队列中的内容：\n//   `console.log(2); console.log(6)`\n\nconsole.log(7);\n// 立即输出 7\n```\n\n总结一下：\n\n1. 立即输出数字 `1` 和 `7`，因为简单的 `console.log` 调用没有使用任何队列。\n2. 然后，主代码流程执行完成后，开始执行微任务队列。\n    - 其中有命令行：`console.log(3); setTimeout(...4); console.log(5)`。\n    - 输出数字 `3` 和 `5`，`setTimeout(() => console.log(4))` 将 `console.log(4)` 调用添加到了宏任务队列的尾部。\n    - 现在宏任务队列中有：`console.log(2); console.log(6); console.log(4)`。\n3. 当微任务队列为空后，开始执行宏任务队列。并输出 `2`、`6` 和 `4`。\n\n最终，我们的到的输出结果为：`1 7 3 5 2 6 4`。",
        "parent": "event-loop",
        "version": 1
      }
    },
    "frames-and-windows": {
      "type": "Article",
      "value": {
        "title": "Frame 和 window",
        "slug": "frames-and-windows",
        "githubPath": "/3-frames-and-windows",
        "isFolder": true,
        "weight": 3,
        "content": "",
        "libs": [],
        "children": [
          "popup-windows",
          "cross-window-communication",
          "clickjacking"
        ]
      }
    },
    "popup-windows": {
      "type": "Article",
      "value": {
        "title": "弹窗和 window 的方法",
        "slug": "popup-windows",
        "githubPath": "/3-frames-and-windows/01-popup-windows",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n弹窗（popup）是向用户显示其他文档的最古老的方法之一。\n\n基本上，你只需要运行：\n```js\nwindow.open('https://javascript.info/')\n```\n\n……它将打开一个具有给定 URL 的新窗口。大多数现代浏览器都配置为在新选项卡中打开 url，而不是单独的窗口。\n\n弹窗自古以来就存在。最初的想法是，在不关闭主窗口的情况下显示其他内容。目前为止，还有其他方式可以实现这一点：我们可以使用 [fetch](info:fetch) 动态加载内容，并将其显示在动态生成的 `<div>` 中。弹窗并不是我们每天都会使用的东西。\n\n并且，弹窗在移动设备上非常棘手，因为移动设备无法同时显示多个窗口。\n\n但仍然有一些任务在使用弹窗，例如进行 OAuth 授权（使用 Google/Facebook/... 登陆），因为：\n\n1. 弹窗是一个独立的窗口，具有自己的独立 JavaScript 环境。因此，使用弹窗打开一个不信任的第三方网站是安全的。\n2. 打开弹窗非常容易。\n3. 弹窗可以导航（修改 URL），并将消息发送到 opener 窗口（译注：即打开弹窗的窗口）。\n\n## 阻止弹窗\n\n在过去，很多恶意网站经常滥用弹窗。一个不好的页面可能会打开大量带有广告的弹窗。因此，现在大多数浏览器都会通过阻止弹窗来保护用户。\n\n**如果弹窗是在用户触发的事件处理程序（如 `onclick`）之外调用的，大多数浏览器都会阻止此类弹窗。**\n\n例如：\n```js\n// 弹窗被阻止\nwindow.open('https://javascript.info');\n\n// 弹窗被允许\nbutton.onclick = () => {\n  window.open('https://javascript.info');\n};\n```\n\n这种方式可以在某种程度上保护用户免受非必要的弹窗的影响，但是并没有完全阻止该功能。\n\n如果弹窗是从 `onclick` 打开的，但是在 `setTimeout` 之后，该怎么办？这有点棘手。\n\n试试运行一下这段代码：\n\n```js run\n// 3 秒后打开弹窗\nsetTimeout(() => window.open('http://google.com'), 3000);\n```\n\n这个弹窗在 Chrome 中会被打开，但是在 Firefox 中会被阻止。\n\n……如果我们减少延迟，则弹窗在 Firefox 中也会被打开：\n\n```js run\n// 1 秒后打开弹窗\nsetTimeout(() => window.open('http://google.com'), 1000);\n```\n\n区别在于 Firefox 可以接受 2000ms 或更短的延迟，但是超过这个时间 —— 则移除“信任”。所以，第一个弹窗被阻止，而第二个却没有。\n\n## window.open\n\n打开一个弹窗的语法是 `window.open(url, name, params)`：\n\nurl\n: 要在新窗口中加载的 URL。\n\nname\n: 新窗口的名称。每个窗口都有一个 `window.name`，在这里我们可以指定哪个窗口用于弹窗。如果已经有一个这样名字的窗口 —— 将在该窗口打开给定的 URL，否则会打开一个新窗口。\n\nparams\n: 新窗口的配置字符串。它包括设置，用逗号分隔。参数之间不能有空格，例如：`width=200,height=100`。\n\n`params` 的设置项：\n\n- 位置:\n  - `left/top`（数字）—— 屏幕上窗口的左上角的坐标。这有一个限制：不能将新窗口置于屏幕外（offscreen）。\n  - `width/height`（数字）—— 新窗口的宽度和高度。宽度/高度的最小值是有限制的，因此不可能创建一个不可见的窗口。\n- 窗口功能：\n  - `menubar`（yes/no）—— 显示或隐藏新窗口的浏览器菜单。\n  - `toolbar`（yes/no）—— 显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）。\n  - `location`（yes/no）—— 显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它。\n  - `status`（yes/no）—— 显示或隐藏状态栏。同样，大多数浏览器都强制显示它。\n  - `resizable`（yes/no）—— 允许禁用新窗口大小调整。不建议使用。\n  - `scrollbars`（yes/no）—— 允许禁用新窗口的滚动条。不建议使用。\n\n\n还有一些不太受支持的特定于浏览器的功能，通常不使用。通常不使用这些功能。更多示例请见 <a href=\"https://developer.mozilla.org/en/DOM/window.open\">MDN 中的 window.open</a>。\n\n## 示例：一个最简窗口\n\n让我们打开一个包含最小功能集的新窗口，来看看哪些功能是浏览器允许禁用的：\n\n```js run\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=0,height=0,left=-1000,top=-1000`;\n\nopen('/', 'test', params);\n```\n\n在这里，大多数“窗口功能”都被禁用了，并且窗口位于屏幕外。运行它，看看会发生什么。大多数浏览器都会“修复”奇怪的东西，例如 `width/height` 为零以及脱离屏幕（offscreen）的 `left/top` 设置。例如，Chrome 打开了一个全 `width/height` 的窗口，使其占满整个屏幕。\n\n让我们添加正常的定位选项和合理的 `width`、`height`、`left` 和 `top` 坐标：\n\n```js run\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=600,height=300,left=100,top=100`;\n\nopen('/', 'test', params);\n```\n\n大多数浏览器会根据要求显示上面的示例。\n\n设置中的省略规则：\n\n- 如果 `open` 调用中没有第三个参数，或者它是空的，则使用默认的窗口参数。\n- 如果这里有一个参数字符串，但是某些 `yes/no` 功能被省略了，那么被省略的功能则被默认值为 `no`。因此，如果你指定参数，请确保将所有必需的功能明确设置为 `yes`。\n- 如果参数中没有 `left/top`，那么浏览器会尝试在最后打开的窗口附近打开一个新窗口。\n- 如果没有 `width/height`，那么新窗口的大小将与上次打开的窗口大小相同。\n\n## 从窗口访问弹窗\n\n`open` 调用会返回对新窗口的引用。它可以用来操纵弹窗的属性，更改位置，甚至更多操作。\n\n在下面这个示例中，我们从 JavaScript 中生成弹窗：\n\n```js\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\"Hello, world!\");\n```\n\n这里，我们在其加载完成后，修改其中的内容：\n\n```js run\nlet newWindow = open('/', 'example', 'width=300,height=300')\nnewWindow.focus();\n\nalert(newWindow.location.href); // (*) about:blank，加载尚未开始\n\nnewWindow.onload = function() {\n  let html = `<div style=\"font-size:30px\">Welcome!</div>`;\n*!*\n  newWindow.document.body.insertAdjacentHTML('afterbegin', html);\n*/!*\n};\n```\n\n请注意：在刚刚进行了 `window.open` 的时候，新窗口还没有加载完成。我们可以通过 `(*)` 行中的 `alert` 证实这一点。因此，我们需要等待 `onload` 以对新窗口进行更改。我们也可以对 `newWin.document` 使用 `DOMContentLoaded` 处理程序。\n\n```warn header=\"同源策略\"\n只有在窗口是同源的时，窗口才能自由访问彼此的内容（`相同的协议://domain:port`）。\n\n否则，例如，如果主窗口来自于 `site.com`，弹窗来自于 `gmail.com`，则处于安全性考虑，这两个窗口不能访问彼此的内容。有关详细信息，请参见 <info:cross-window-communication> 一章。\n```\n\n## 从弹窗访问窗口\n\n弹窗也可以使用 `window.opener` 来访问 opener 窗口。除了弹窗之外，对其他所有窗口来说，`window.opener` 均为 `null`。\n\n如果你运行下面这段代码，它将用 \"Test\" 替换 opener（也就是当前的）窗口的内容：\n\n```js run\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\n  \"<script>window.opener.document.body.innerHTML = 'Test'<\\/script>\"\n);\n```\n\n所以，窗口之间的连接是双向的：主窗口和弹窗之间相互引用。\n\n## 关闭弹窗\n\n关闭一个窗口：`win.close()`。\n\n检查一个窗口是否被关闭：`win.closed`。\n\n从技术上讲，`close()` 方法可用于任何 `window`，但是如果 `window` 不是通过 `window.open()` 创建的，那么大多数浏览器都会忽略 `window.close()`。因此，`close()` 只对弹窗起作用。\n\n如果窗口被关闭了，那么 `closed` 属性则为 `true`。这对于检查弹窗（或主窗口）是否仍处于打开状态很有用。用户可以随时关闭它，我们的代码应该考虑到这种可能性。\n\n这段代码加载并关闭了窗口：\n\n```js run\nlet newWindow = open('/', 'example', 'width=300,height=300');\n\nnewWindow.onload = function() {\n  newWindow.close();\n  alert(newWindow.closed); // true\n};\n```\n\n\n## 移动和调整大小\n\n有一些方法可以移动一个窗口，或者调整一个窗口的大小：\n\n`win.moveBy(x,y)`\n: 将窗口相对于当前位置向右移动 `x` 像素，并向下移动 `y` 像素。允许负值（向上/向左移动）。\n\n`win.moveTo(x,y)`\n: 将窗口移动到屏幕上的坐标 `(x,y)` 处。\n\n`win.resizeBy(width,height)`\n: 根据给定的相对于当前大小的 `width/height` 调整窗口大小。允许负值。\n\n`win.resizeTo(width,height)`\n: 将窗口调整为给定的大小。\n\n还有 `window.onresize` 事件。\n\n```warn header=\"仅对于弹窗\"\n为了防止滥用，浏览器通常会阻止这些方法。它们仅在我们打开的，没有其他选项卡的弹窗中能够可靠地工作。\n```\n\n```warn header=\"没有最小化/最大化\"\nJavaScript 无法最小化或者最大化一个窗口。这些操作系统级别的功能对于前端开发者而言是隐藏的。\n\n移动或者调整大小的方法不适用于最小化/最大化的窗口。\n```\n\n## 滚动窗口\n\n我们已经在 <info:size-and-scroll-window> 一章中讨论过了滚动窗口。\n\n`win.scrollBy(x,y)`\n: 相对于当前位置，将窗口向右滚动 `x` 像素，并向下滚动 `y` 像素。允许负值。\n\n`win.scrollTo(x,y)`\n: 将窗口滚动到给定坐标 `(x,y)`。\n\n`elem.scrollIntoView(top = true)`\n: 滚动窗口，使 `elem` 显示在 `elem.scrollIntoView(false)` 的顶部（默认）或底部。\n\n这里也有 `window.onscroll` 事件。\n\n## 弹窗的聚焦/失焦\n\n从理论上讲，使用 `window.focus()` 和 `window.blur()` 方法可以使窗口获得或失去焦点。此外，这里还有 `focus/blur` 事件，可以捕获到访问者聚焦到一个窗口和切换到其他地方的时刻。\n\n尽管，在实际中它们被进行了严格地限制，因为在过去，恶意网站滥用这些方法。\n\n例如，看下面这段代码:\n\n```js run\nwindow.onblur = () => window.focus();\n```\n\n当用户尝试从窗口切换出去（`window.onblur`）时，这段代码又让窗口重新获得了焦点。目的是将用户“锁定”在 `window` 中。\n\n因此，浏览器必须引入很多限制，以禁用此类代码并保护用户免受广告和恶意页面的侵害。具体则取决于浏览器。\n\n例如，移动端浏览器通常会完全忽略 `window.focus()`。并且，当弹窗是在单独的选项卡而不是新窗口中打开时，也无法进行聚焦。\n\n尽管如此，在某些情况下，此类调用确实有效且很有用。\n\n例如：\n\n- 当我们打开一个弹窗时，在它上面执行 `newWindow.focus()` 是个好主意。以防万一，对于某些操作系统/浏览器组合（combination），它可以确保用户现在位于新窗口中。\n- 如果我们想要跟踪访问者何时在实际使用我们的 Web 应用程序，我们可以跟踪 `window.onfocus/onblur`。这使我们可以暂停/恢复页面活动和动画等。但是请注意，`blur` 事件意味着访问者从窗口切换了出来，但他们仍然可以观察到它。窗口处在背景中，但可能仍然是可见的。\n\n## 总结\n\n弹窗很少使用，因为有其他选择：在页面内或在 iframe 中加载和显示信息。\n\n如果我们要打开一个弹窗，将其告知用户是一个好的实践。在链接或按钮附近的“打开窗口”图标可以让用户免受焦点转移的困扰，并使用户知道点击它会弹出一个新窗口。\n\n- 可以通过 `open(url, name, params)` 调用打开一个弹窗。它会返回对新打开的窗口的引用。\n- 浏览器会阻止来自用户行为之外的代码中的 `open` 调用。通常会显示一条通知，以便用户可以允许它们。\n- 默认情况下，浏览器会打开一个新标签页，但如果提供了窗口大小，那么浏览器将打开一个弹窗。\n- 弹窗可以使用 `window.opener` 属性访问 opener 窗口（译注：即打开弹窗的窗口）。\n- 如果主窗口和弹窗同源，那么它们可以彼此自由地读取和修改。否则，它们可以更改彼此的地址（location），[交换消息](info:cross-window-communication)。\n\n要关闭弹窗：使用 `close()` 调用。用户也可以关闭弹窗（就像任何其他窗口一样）。关闭之后，`window.closed` 为 `true`。\n\n- `focus()` 和 `blur()` 方法允许聚焦/失焦于窗口。但它们并不是一直都有效。\n- `focus `和 `blur` 事件允许跟踪窗口的切换。但是请注意，在 `blur` 之后，即使窗口在背景状态下，窗口仍有可能是可见的。",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1651426345
      }
    },
    "cross-window-communication": {
      "type": "Article",
      "value": {
        "title": "跨窗口通信",
        "slug": "cross-window-communication",
        "githubPath": "/3-frames-and-windows/03-cross-window-communication",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n“同源（Same Origin）”策略限制了窗口（window）和 frame 之间的相互访问。\n\n这个想法出于这样的考虑，如果一个用户有两个打开的页面：一个来自 `john-smith.com`，另一个是 `gmail.com`，那么用户将不希望 `john-smith.com` 的脚本可以读取 `gmail.com` 中的邮件。所以，“同源”策略的目的是保护用户免遭信息盗窃。\n\n## 同源 [#same-origin]\n\n如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的。\n\n以下的几个 URL 都是同源的：\n\n- `http://site.com`\n- `http://site.com/`\n- `http://site.com/my/page.html`\n\n但是下面这几个不是：\n\n- <code>http://<b>www.</b>site.com</code>（另一个域：`www.` 影响）\n- <code>http://<b>site.org</b></code>（另一个域：`.org` 影响）\n- <code><b>https://</b>site.com</code>（另一个协议：`https`）\n- <code>http://site.com:<b>8080</b></code>（另一个端口：`8080`）\n\n“同源”策略规定：\n\n- 如果我们有对另外一个窗口（例如，一个使用 `window.open` 创建的弹窗，或者一个窗口中的 iframe）的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。\n- 否则，如果该窗口不是同源的，那么我们就无法访问该窗口中的内容：变量，文档，任何东西。唯一的例外是 `location`：我们可以修改它（进而重定向用户）。但是我们无法读取 `location`（因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息）。\n\n### 实例：iframe\n\n一个 `<iframe>` 标签承载了一个单独的嵌入的窗口，它具有自己的 `document` 和 `window`。\n\n我们可以使用以下属性访问它们：\n\n- `iframe.contentWindow` 来获取 `<iframe>` 中的 window。\n- `iframe.contentDocument` 来获取 `<iframe>` 中的 document，是 `iframe.contentWindow.document` 的简写形式。\n\n当我们访问嵌入的窗口中的东西时，浏览器会检查 iframe 是否具有相同的源。如果不是，则会拒绝访问（对 `location` 进行写入是一个例外，它是会被允许的）。\n\n例如，让我们尝试对来自另一个源的 `<iframe>` 进行读取和写入：\n\n```html run\n<iframe src=\"https://example.com\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // 我们可以获取对内部 window 的引用\n*!*\n    let iframeWindow = iframe.contentWindow; // OK\n*/!*\n    try {\n      // ...但是无法获取其中的文档\n*!*\n      let doc = iframe.contentDocument; // ERROR\n*/!*\n    } catch(e) {\n      alert(e); // Security Error（另一个源）\n    }\n\n    // 并且，我们也无法读取 iframe 中页面的 URL\n    try {\n      // 无法从 location 对象中读取 URL\n*!*\n      let href = iframe.contentWindow.location.href; // ERROR\n*/!*\n    } catch(e) {\n      alert(e); // Security Error\n    }\n\n    // ...我们可以写入 location（所以，在 iframe 中加载了其他内容）！\n*!*\n    iframe.contentWindow.location = '/'; // OK\n*/!*\n\n    iframe.onload = null; // 清空处理程序，在 location 更改后不要再运行它\n  };\n</script>\n```\n\n上述代码除了以下操作都会报错：\n\n- 通过 `iframe.contentWindow` 获取对内部 window 的引用 —— 这是被允许的。\n- 对 `location` 进行写入\n\n与此相反，如果 `<iframe>` 具有相同的源，我们可以使用它做任何事情：\n\n```html run\n<!-- 来自同一个网站的 iframe -->\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // 可以做任何事儿\n    iframe.contentDocument.body.prepend(\"Hello, world!\");\n  };\n</script>\n```\n\n```smart header=\"`iframe.onload` vs `iframe.contentWindow.onload`\"\n`iframe.onload` 事件（在 `<iframe>` 标签上）与 `iframe.contentWindow.onload`（在嵌入的 window 对象上）基本相同。当嵌入的窗口的所有资源都完全加载完毕时触发。\n\n……但是，我们无法使用 `iframe.contentWindow.onload` 访问不同源的 iframe。因此，请使用 `iframe.onload`，\n```\n\n## 子域上的 window：document.domain\n\n根据定义，两个具有不同域的 URL 具有不同的源。\n\n但是，如果窗口的二级域相同，例如 `john.site.com`，`peter.site.com` 和 `site.com`（它们共同的二级域是 `site.com`），我们可以使浏览器忽略该差异，使得它们可以被作为“同源”的来对待，以便进行跨窗口通信。\n\n为了做到这一点，每个这样的窗口都应该执行下面这行代码：\n\n```js\ndocument.domain = 'site.com';\n```\n\n这样就可以了。现在它们可以无限制地进行交互了。但是再强调一遍，这仅适用于具有相同二级域的页面。\n\n```warn header=\"已弃用，但仍有效\"\n`document.domain` 属性正在被从 [规范](https://html.spec.whatwg.org/multipage/origin.html#relaxing-the-same-origin-restriction) 中删除。跨窗口通信（下面将很快解释到）是建议的替代方案。\n\n也就是说，到目前为止，所有浏览器都支持它。并且未来也将继续支持它，而不会导致使用了 `document.domain` 的旧代码出现问题。\n```\n\n\n## Iframe：错误文档陷阱\n\n当一个 iframe 来自同一个源时，我们可能会访问其 `document`，但是这里有一个陷阱。它与跨源无关，但你一定要知道。\n\n在创建 iframe 后，iframe 会立即就拥有了一个文档。但是该文档不同于加载到其中的文档！\n\n因此，如果我们要立即对文档进行操作，就可能出问题。\n\n看一下下面这段代码：\n\n\n```html run\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  let oldDoc = iframe.contentDocument;\n  iframe.onload = function() {\n    let newDoc = iframe.contentDocument;\n*!*\n    // 加载的文档与初始的文档不同！\n    alert(oldDoc == newDoc); // false\n*/!*\n  };\n</script>\n```\n\n我们不应该对尚未加载完成的 iframe 的文档进行处理，因为那是 **错误的文档**。如果我们在其上设置了任何事件处理程序，它们将会被忽略。\n\n如何检测文档就位（加载完成）的时刻呢？\n\n正确的文档在 `iframe.onload` 触发时肯定就位了。但是，只有在整个 iframe 和它所有资源都加载完成时，`iframe.onload` 才会触发。\n\n我们可以尝试通过在 `setInterval` 中进行检查，以更早地捕获该时刻：\n\n```html run\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  let oldDoc = iframe.contentDocument;\n\n  // 每 100ms 检查一次文档是否为新文档\n  let timer = setInterval(() => {\n    let newDoc = iframe.contentDocument;\n    if (newDoc == oldDoc) return;\n\n    alert(\"New document is here!\");\n\n    clearInterval(timer); // 取消 setInterval，不再需要它做任何事儿\n  }, 100);\n</script>\n```\n\n## 集合：window.frames\n\n获取 `<iframe>` 的 window 对象的另一个方式是从命名集合 `window.frames` 中获取：\n\n- 通过索引获取：`window.frames[0]` —— 文档中的第一个 iframe 的 window 对象。\n- 通过名称获取：`window.frames.iframeName` —— 获取 `name=\"iframeName\"` 的 iframe 的 window 对象。\n\n例如：\n\n```html run\n<iframe src=\"/\" style=\"height:80px\" name=\"win\" id=\"iframe\"></iframe>\n\n<script>\n  alert(iframe.contentWindow == frames[0]); // true\n  alert(iframe.contentWindow == frames.win); // true\n</script>\n```\n\n一个 iframe 内可能嵌套了其他的 iframe。相应的 `window` 对象会形成一个层次结构（hierarchy）。\n\n可以通过以下方式获取：\n\n- `window.frames` —— “子”窗口的集合（用于嵌套的 iframe）。\n- `window.parent` —— 对“父”（外部）窗口的引用。\n- `window.top` —— 对最顶级父窗口的引用。\n\n例如：\n\n```js run\nwindow.frames[0].parent === window; // true\n```\n\n我们可以使用 `top` 属性来检查当前的文档是否是在 iframe 内打开的：\n\n```js run\nif (window == top) { // 当前 window == window.top?\n  alert('The script is in the topmost window, not in a frame');\n} else {\n  alert('The script runs in a frame!');\n}\n```\n\n## \"sandbox\" iframe 特性\n\n`sandbox` 特性（attribute）允许在 `<iframe>` 中禁止某些特定行为，以防止其执行不被信任的代码。它通过将 iframe 视为非同源的，或者应用其他限制来实现 iframe 的“沙盒化”。\n\n对于 `<iframe sandbox src=\"...\">`，有一个应用于其上的默认的限制集。但是，我们可以通过提供一个以空格分隔的限制列表作为特性的值，来放宽这些限制，该列表中的各项为不应该应用于这个 iframe 的限制，例如：`<iframe sandbox=\"allow-forms allow-popups\">`。\n\n换句话说，一个空的 `\"sandbox\"` 特性会施加最严格的限制，但是我们用一个以空格分隔的列表，列出要移除的限制。\n\n以下是限制的列表：\n\n`allow-same-origin`\n: 默认情况下，`\"sandbox\"` 会为 iframe 强制实施“不同来源”的策略。换句话说，它使浏览器将 `iframe` 视为来自另一个源，即使其 `src` 指向的是同一个网站也是如此。具有所有隐含的脚本限制。此选项会移除这些限制。\n\n`allow-top-navigation`\n: 允许 `iframe` 更改 `parent.location`。\n\n`allow-forms`\n: 允许在 `iframe` 中提交表单。\n\n`allow-scripts`\n: 允许在 `iframe` 中运行脚本。\n\n`allow-popups`\n: 允许在 `iframe` 中使用 `window.open` 打开弹窗。\n\n查看 [官方手册](mdn:/HTML/Element/iframe) 获取更多内容。\n\n下面的示例演示了一个具有默认限制集的沙盒 iframe：`<iframe sandbox src=\"...\">`。它有一些 JavaScript 代码和一个表单。\n\n请注意，这里没有东西会运行。可见默认设置非常苛刻：\n\n[codetabs src=\"sandbox\" height=140]\n\n\n```smart\n`\"sandbox\"` 特性的目的仅是 **添加更多** 限制。它无法移除这些限制。尤其是，如果 iframe 来自其他源，则无法放宽同源策略。\n```\n\n## 跨窗口通信\n\n`postMessage` 接口允许窗口之间相互通信，无论它们来自什么源。\n\n因此，这是解决“同源”策略的方式之一。它允许来自于 `john-smith.com` 的窗口与来自于 `gmail.com` 的窗口进行通信，并交换信息，但前提是它们双方必须均同意并调用相应的 JavaScript 函数。这可以保护用户的安全。\n\n这个接口有两个部分。\n\n### postMessage\n\n想要发送消息的窗口需要调用接收窗口的 [postMessage](mdn:api/Window.postMessage) 方法。换句话说，如果我们想把消息发送给 `win`，我们应该调用 `win.postMessage(data, targetOrigin)`。\n\n参数：\n\n`data`\n: 要发送的数据。可以是任何对象，数据会被通过使用“结构化序列化算法（structured serialization algorithm）”进行克隆。IE 浏览器只支持字符串，因此我们需要对复杂的对象调用 `JSON.stringify` 方法进行处理，以支持该浏览器。\n\n`targetOrigin`\n: 指定目标窗口的源，以便只有来自给定的源的窗口才能获得该消息。\n\n`targetOrigin` 是一种安全措施。请记住，如果目标窗口是非同源的，我们无法在发送方窗口读取它的 `location`。因此，我们无法确定当前在预期的窗口中打开的是哪个网站：用户随时可以导航离开，并且发送方窗口对此一无所知。\n\n指定 `targetOrigin` 可以确保窗口仅在当前仍处于正确的网站时接收数据。在有敏感数据时，这非常重要。\n\n例如，这里的 `win` 仅在它拥有来自 `http://example.com` 这个源的文档时，才会接收消息：\n\n```html no-beautify\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n  win.postMessage(\"message\", \"http://example.com\");\n</script>\n```\n\n如果我们不希望做这个检查，可以将 `targetOrigin` 设置为 `*`。\n\n```html no-beautify\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n*!*\n  win.postMessage(\"message\", \"*\");\n*/!*\n</script>\n```\n\n\n### onmessage\n\n为了接收消息，目标窗口应该在 `message` 事件上有一个处理程序。当 `postMessage` 被调用时触发该事件（并且 `targetOrigin` 检查成功）。\n\nevent 对象具有特殊属性：\n\n`data`\n: 从 `postMessage` 传递来的数据。\n\n`origin`\n: 发送方的源，例如 `http://javascript.info`。\n\n`source`\n: 对发送方窗口的引用。如果我们想，我们可以立即 `source.postMessage(...)` 回去。\n\n要为 `message` 事件分配处理程序，我们应该使用 `addEventListener`，简短的语法 `window.onmessage` 不起作用。\n\n这里有一个例子：\n\n```js\nwindow.addEventListener(\"message\", function(event) {\n  if (event.origin != 'http://javascript.info') {\n    // 来自未知的源的内容，我们忽略它\n    return;\n  }\n\n  alert( \"received: \" + event.data );\n\n  // 可以使用 event.source.postMessage(...) 向回发送消息\n});\n```\n\n完整示例：\n\n[codetabs src=\"postmessage\" height=120]\n\n## 总结\n\n要调用另一个窗口的方法或者访问另一个窗口的内容，我们应该首先拥有对其的引用。\n\n对于弹窗，我们有两个引用：\n- 从打开窗口的（opener）窗口：`window.open` —— 打开一个新的窗口，并返回对它的引用，\n- 从弹窗：`window.opener` —— 是从弹窗中对打开此弹窗的窗口（opener）的引用。\n\n对于 iframe，我们可以使用以下方式访问父/子窗口：\n- `window.frames` —— 一个嵌套的 window 对象的集合，\n- `window.parent`，`window.top` 是对父窗口和顶级窗口的引用，\n- `iframe.contentWindow` 是 `<iframe>` 标签内的 window 对象。\n\n如果几个窗口的源相同（域，端口，协议），那么这几个窗口可以彼此进行所需的操作。\n\n否则，只能进行以下操作：\n- 更改另一个窗口的 `location`（只能写入）。\n- 向其发送一条消息。\n\n例外情况：\n- 对于二级域相同的窗口：`a.site.com` 和 `b.site.com`。通过在这些窗口中均设置 `document.domain='site.com'`，可以使它们处于“同源”状态。 \n- 如果一个 iframe 具有 `sandbox` 特性（attribute），则它会被强制处于“非同源”状态，除非在其特性值中指定了 `allow-same-origin`。这可用于在同一网站的 iframe 中运行不受信任的代码。\n\n`postMessage` 接口允许两个具有任何源的窗口之间进行通信：\n\n1. 发送方调用 `targetWin.postMessage(data, targetOrigin)`。\n2. 如果 `targetOrigin` 不是 `'*'`，那么浏览器会检查窗口 `targetWin` 是否具有源 `targetOrigin`。\n3. 如果它具有，`targetWin` 会触发具有特殊的属性的 `message` 事件：\n    - `origin` —— 发送方窗口的源（比如 `http://my.site.com`）。\n    - `source` —— 对发送方窗口的引用。\n    - `data` —— 数据，可以是任何对象。但是 IE 浏览器只支持字符串，因此我们需要对复杂的对象调用 `JSON.stringify` 方法进行处理，以支持该浏览器。\n\n    我们应该使用 `addEventListener` 来在目标窗口中设置 `message` 事件的处理程序。",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1659518841
      }
    },
    "clickjacking": {
      "type": "Article",
      "value": {
        "title": "点击劫持攻击",
        "slug": "clickjacking",
        "githubPath": "/3-frames-and-windows/06-clickjacking",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n“点击劫持”攻击允许恶意页面 **以用户的名义** 点击“受害网站”。\n\n许多网站都被黑客以这种方式攻击过，包括 Twitter、Facebook 和 Paypal 等许多网站。当然，它们都已经被修复了。\n\n## 原理\n\n原理十分简单。\n\n我们以 Facebook 为例，解释点击劫持是如何完成的：\n\n1. 访问者被恶意页面吸引。怎样吸引的不重要。\n2. 页面上有一个看起来无害的链接（例如：“变得富有”或者“点我，超好玩！”）。\n3. 恶意页面在该链接上方放置了一个透明的 `<iframe>`，其 `src` 来自于 facebook.com，这使得“点赞”按钮恰好位于该链接上面。这通常是通过 `z-index` 实现的。\n4. 用户尝试点击该链接时，实际上点击的是“点赞”按钮。\n\n## 示例\n\n这是恶意页面看起来的样子。为了清楚起见，我们将 `<iframe>` 设置成了半透明的（在真正的恶意页面中，它是全透明的）：\n\n```html run height=120 no-beautify\n<style>\niframe { /* 来自受害网站的 iframe */\n  width: 400px;\n  height: 100px;\n  position: absolute;\n  top:0; left:-20px;\n*!*\n  opacity: 0.5; /* 在实际中为 opacity:0 */\n*/!*\n  z-index: 1;\n}\n</style>\n\n<div>点击即可变得富有：</div>\n\n<!-- 来自受害网站的 url -->\n*!*\n<iframe src=\"/clickjacking/facebook.html\"></iframe>\n\n<button>点这里！</button>\n*/!*\n\n<div>……你很酷（我实际上是一名帅气的黑客）！</div>\n```\n\n完整的攻击示例如下：\n\n[codetabs src=\"clickjacking-visible\" height=160]\n\n在上面这个示例中，我们有一个半透明的 `<iframe src=\"facebook.html\">`，我们可以看到，它位于按钮之上。点击按钮实际上会点击在 iframe 上，但这对用户不可见，因为 iframe 是透明的。\n\n结果，如果访问者登陆了 Facebook（“记住我”通常是打开的），那么这个行为就会点一个“赞”。Twitter 上是 \"Follow\" 按钮。\n\n下面是相同的示例，但 `iframe` 的透明度设置为了 `opacity:0`，更符合实际情况：\n\n[codetabs src=\"clickjacking\" height=160]\n\n我们进行攻击所需要做的 —— 就是将 `<iframe>` 放置在恶意页面中，使得按钮恰好位于链接的正上方。这样当用户点击链接时，他们实际上点击的是按钮。这通常可以通过 CSS 实现。\n\n```smart header=\"点击劫持是对点击事件，而非键盘事件\"\n此攻击仅影响鼠标行为（或者类似的行为，例如在手机上的点击）。\n\n键盘输入很难重定向。从技术上讲，我们可以用 iframe 的文本区域覆盖原有的文本区域实现攻击。因此，当访问者试图聚焦页面中的输入时，实际上聚焦的是 iframe 中的输入。\n\n但是这里有个问题。访问者键入的所有内容都会被隐藏，因为该 iframe 是不可见的。\n\n当用户无法在屏幕上看到自己输入的字符时，通常会停止打字。\n```\n\n## 传统防御（弱 👎）\n\n最古老的防御措施是一段用于禁止在 frame 中打开页面的 JavaScript 代码（所谓的 “framebusting”）。\n\n它看起来像这样：\n\n```js\nif (top != window) {\n  top.location = window.location;\n}\n```\n\n意思是说：如果 window 发现它不在顶部，那么它将自动使其自身位于顶部。\n\n这个方法并不可靠，因为有许多方式可以绕过这个限制。下面我们就介绍几个。\n\n### 阻止顶级导航\n\n我们可以阻止因更改 [beforeunload](info:onload-ondomcontentloaded#window.onbeforeunload) 事件处理程序中的 `top.location` 而引起的过渡（transition）。\n\n顶级页面（从属于黑客）在 `beforeunload` 上设置了一个用于阻止的处理程序，像这样：\n\n```js\nwindow.onbeforeunload = function() {\n  return false;\n};\n```\n\n当 `iframe` 试图更改 `top.location` 时，访问者会收到一条消息，询问他们是否要离开页面。\n\n在大多数情况下，访问者会做出否定的回答，因为他们并不知道还有这么一个 iframe，他们所看到的只有顶级页面，他们没有理由离开。所以 `top.location` 不会变化！\n\n演示示例：\n\n[codetabs src=\"top-location\"]\n\n### Sandbox 特性\n\n`sandbox` 特性的限制之一就是导航。沙箱化的 iframe 不能更改 `top.location`。\n\n但我们可以添加具有 `sandbox=\"allow-scripts allow-forms\"` 的 iframe。从而放开限制，允许脚本和表单。但我们没添加 `allow-top-navigation`，因此更改 `top.location` 是被禁止的。\n\n代码如下：\n\n```html\n<iframe *!*sandbox=\"allow-scripts allow-forms\"*/!* src=\"facebook.html\"></iframe>\n```\n\n还有其他方式可以绕过这个弱鸡防御。\n\n## X-Frame-Options\n\n服务器端 header `X-Frame-Options` 可以允许或禁止在 frame 中显示页面。\n\n它必须被完全作为 HTTP-header 发送：如果浏览器在 HTML `<meta>` 标签中找到它，则会忽略它。因此，`<meta http-equiv=\"X-Frame-Options\"...>` 没有任何作用。\n\n这个 header 可能包含 3 个值：\n\n\n`DENY`\n: 始终禁止在 frame 中显示此页面。\n\n`SAMEORIGIN`\n: 允许在和父文档同源的 frame 中显示此页面。\n\n`ALLOW-FROM domain`\n: 允许在来自给定域的父文档的 frame 中显示此页面。\n\n例如，Twitter 使用的是 `X-Frame-Options: SAMEORIGIN`。\n\n````online\n结果如下：\n\n```html\n<iframe src=\"https://twitter.com\"></iframe>\n```\n\n<!-- ebook: prerender/ chrome headless dies and timeouts on this iframe -->\n<iframe src=\"https://twitter.com\"></iframe>\n\n上面这个 `iframe` 可能为空，或者通过 alert 告知你浏览器不允许以这种方式导航至该页面，这取决于你的浏览器。\n````\n\n## 显示禁用的功能\n\n`X-Frame-Options` 有一个副作用。其他的网站即使有充分的理由也无法在 frame 中显示我们的页面。\n\n因此，还有其他解决方案……例如，我们可以用一个样式为 `height: 100%; width: 100%;` 的 `<div>` “覆盖”页面，这样它就能拦截所有点击。如果 `window == top` 或者我们确定不需要保护时，再将该 `<div>` 移除。\n\n像这样：\n\n```html\n<style>\n  #protector {\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 99999999;\n  }\n</style>\n\n<div id=\"protector\">\n  <a href=\"/\" target=\"_blank\">前往网站</a>\n</div>\n\n<script>\n  // 如果顶级窗口来自其他源，这里则会出现一个 error\n  // 但是在本例中没有问题\n  if (top.document.domain == document.domain) {\n    protector.remove();\n  }\n</script>\n```\n\n演示示例：\n\n[codetabs src=\"protector\"]\n\n## Samesite cookie 特性\n\n`samesite` cookie 特性也可以阻止点击劫持攻击。\n\n具有 `samesite` 特性的 cookie 仅在网站是通过直接方式打开（而不是通过 frame 或其他方式）的情况下才发送到网站。更多细节请见 <info:cookie#samesite>。\n\n如果网站，例如 Facebook，在其身份验证 cookie 中具有 `samesite` 特性，像这样：\n\n```\nSet-Cookie: authorization=secret; samesite\n```\n\n……那么，当在另一个网站中的 iframe 中打开 Facebook 时，此类 cookie 将不会被发送。因此，攻击将失败。\n\n当不使用 cookie 时，`samesite` cookie 特性将不会有任何影响。这可以使其他网站能够轻松地在 iframe 中显示我们公开的、未进行身份验证的页面。\n\n然而，这也可能会使得劫持攻击在少数情况下起作用。例如，通过检查 IP 地址来防止重复投票的匿名投票网站仍然会受到点击劫持的攻击，因为它不使用 cookie 对用户身份进行验证。\n\n## 总结\n\n点击劫持是一种“诱骗”用户在不知情的情况下点击恶意网站的方式。如果是重要的点击操作，这是非常危险的。\n\n黑客可以通过信息发布指向他的恶意页面的链接，或者通过某些手段引诱访问者访问他的页面。当然还有很多其他变体。\n\n一方面 —— 这种攻击方式是“浅层”的：黑客所做的只是拦截一次点击。但另一方面，如果黑客知道在点击之后将出现另一个控件，则他们可能还会使用狡猾的消息来迫使用户也点击它们。\n\n这种攻击相当危险，因为在设计交互界面时，我们通常不会考虑到可能会有黑客代表用户点击界面。所以，在许多意想不到的地方可能发现攻击漏洞。\n\n- 建议在那些不希望被在 frame 中查看的页面上（或整个网站上）使用 `X-Frame-Options: SAMEORIGIN`。\n- 如果我们希望允许在 frame 中显示我们的页面，那我们使用一个 `<div>` 对整个页面进行遮盖，这样也是安全的。",
        "libs": [],
        "children": [],
        "parent": "frames-and-windows",
        "updatedAt": 1623381144
      }
    },
    "binary": {
      "type": "Article",
      "value": {
        "title": "二进制数据，文件",
        "slug": "binary",
        "githubPath": "/4-binary",
        "isFolder": true,
        "weight": 4,
        "content": "\n\n使用 JavaScript 处理二进制数据和文件。",
        "libs": [],
        "children": [
          "arraybuffer-binary-arrays",
          "text-decoder",
          "blob",
          "file"
        ]
      }
    },
    "arraybuffer-binary-arrays": {
      "type": "Article",
      "value": {
        "title": "ArrayBuffer，二进制数组",
        "slug": "arraybuffer-binary-arrays",
        "githubPath": "/4-binary/01-arraybuffer-binary-arrays",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n在 Web 开发中，当我们处理文件时（创建，上传，下载），经常会遇到二进制数据。另一个典型的应用场景是图像处理。\n\n这些都可以通过 JavaScript 进行处理，而且二进制操作性能更高。\n\n不过，在 JavaScript 中有很多种二进制数据格式，会有点容易混淆。仅举几个例子：\n- `ArrayBuffer`，`Uint8Array`，`DataView`，`Blob`，`File` 及其他。\n\n与其他语言相比，JavaScript 中的二进制数据是以非标准方式实现的。但是，当我们理清楚以后，一切就会变得相当简单了。\n\n**基本的二进制对象是 `ArrayBuffer` —— 对固定长度的连续内存空间的引用。**\n\n我们这样创建它：\n```js run\nlet buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer\nalert(buffer.byteLength); // 16\n```\n\n它会分配一个 16 字节的连续内存空间，并用 0 进行预填充。\n\n```warn header=\"`ArrayBuffer` 不是某种东西的数组\"\n让我们先澄清一个可能的误区。`ArrayBuffer` 与 `Array` 没有任何共同之处：\n- 它的长度是固定的，我们无法增加或减少它的长度。\n- 它正好占用了内存中的那么多空间。\n- 要访问单个字节，需要另一个“视图”对象，而不是 `buffer[index]`。\n```\n\n`ArrayBuffer` 是一个内存区域。它里面存储了什么？无从判断。只是一个原始的字节序列。\n\n**如要操作 `ArrayBuffer`，我们需要使用“视图”对象。**\n\n视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 `ArrayBuffer` 中的字节。\n\n例如：\n\n- **`Uint8Array`** —— 将 `ArrayBuffer` 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位，因此只能容纳那么多）。这称为 “8 位无符号整数”。\n- **`Uint16Array`** —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。\n- **`Uint32Array`** —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。\n- **`Float64Array`** —— 将每 8 个字节视为一个 <code>5.0x10<sup>-324</sup></code> 到 <code>1.8x10<sup>308</sup></code> 之间的浮点数。\n\n因此，一个 16 字节 `ArrayBuffer` 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。\n\n![](arraybuffer-views.svg)\n\n`ArrayBuffer` 是核心对象，是所有的基础，是原始的二进制数据。\n\n但是，如果我们要写入值或遍历它，基本上几乎所有操作 —— 我们必须使用视图（view），例如：\n\n```js run\nlet buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer\n\n*!*\nlet view = new Uint32Array(buffer); // 将 buffer 视为一个 32 位整数的序列\n\nalert(Uint32Array.BYTES_PER_ELEMENT); // 每个整数 4 个字节\n*/!*\n\nalert(view.length); // 4，它存储了 4 个整数\nalert(view.byteLength); // 16，字节中的大小\n\n// 让我们写入一个值\nview[0] = 123456;\n\n// 遍历值\nfor(let num of view) {\n  alert(num); // 123456，然后 0，0，0（一共 4 个值）\n}\n\n```\n\n## TypedArray\n\n所有这些视图（`Uint8Array`，`Uint32Array` 等）的通用术语是 [TypedArray](https://tc39.github.io/ecma262/#sec-typedarray-objects)。它们共享同一方法和属性集。\n\n请注意，没有名为 `TypedArray` 的构造器，它只是表示 `ArrayBuffer` 上的视图之一的通用总称术语：`Int8Array`，`Uint8Array` 及其他，很快就会有完整列表。\n\n当你看到 `new TypedArray` 之类的内容时，它表示 `new Int8Array`、`new Uint8Array` 及其他中之一。\n\n类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。\n\n一个类型化数组的构造器（无论是 `Int8Array` 或 `Float64Array`，都无关紧要），其行为各不相同，并且取决于参数类型。\n\n参数有 5 种变体：\n\n```js\nnew TypedArray(buffer, [byteOffset], [length]);\nnew TypedArray(object);\nnew TypedArray(typedArray);\nnew TypedArray(length);\nnew TypedArray();\n```\n\n1. 如果给定的是 `ArrayBuffer` 参数，则会在其上创建视图。我们已经用过该语法了。\n\n    可选，我们可以给定起始位置 `byteOffset`（默认为 0）以及 `length`（默认至 buffer 的末尾），这样视图将仅涵盖 `buffer` 的一部分。\n\n2. 如果给定的是 `Array`，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。\n\n    我们可以使用它来预填充数组的数据：\n    ```js run\n    *!*\n    let arr = new Uint8Array([0, 1, 2, 3]);\n    */!*\n    alert( arr.length ); // 4，创建了相同长度的二进制数组\n    alert( arr[1] ); // 1，用给定值填充了 4 个字节（无符号 8 位整数）\n    ```\n3. 如果给定的是另一个 `TypedArray`，也是如此：创建一个相同长度的类型化数组，并复制其内容。如果需要的话，数据在此过程中会被转换为新的类型。\n    ```js run\n    let arr16 = new Uint16Array([1, 1000]);\n    *!*\n    let arr8 = new Uint8Array(arr16);\n    */!*\n    alert( arr8[0] ); // 1\n    alert( arr8[1] ); // 232，试图复制 1000，但无法将 1000 放进 8 位字节中（详述见下文）。\n    ```\n\n4. 对于数字参数 `length` —— 创建类型化数组以包含这么多元素。它的字节长度将是 `length` 乘以单个 `TypedArray.BYTES_PER_ELEMENT` 中的字节数：\n    ```js run\n    let arr = new Uint16Array(4); // 为 4 个整数创建类型化数组\n    alert( Uint16Array.BYTES_PER_ELEMENT ); // 每个整数 2 个字节\n    alert( arr.byteLength ); // 8（字节中的大小）\n    ```\n\n5. 不带参数的情况下，创建长度为零的类型化数组。\n\n我们可以直接创建一个 `TypedArray`，而无需提及 `ArrayBuffer`。但是，视图离不开底层的 `ArrayBuffer`，因此，除第一种情况（已提供 `ArrayBuffer`）外，其他所有情况都会自动创建 `ArrayBuffer`。\n\n如要访问底层的 `ArrayBuffer`，那么在 `TypedArray` 中有如下的属性：\n- `arr.buffer` —— 引用 `ArrayBuffer`。\n- `arr.byteLength` —— `ArrayBuffer` 的长度。\n\n因此，我们总是可以从一个视图转到另一个视图：\n```js\nlet arr8 = new Uint8Array([0, 1, 2, 3]);\n\n// 同一数据的另一个视图\nlet arr16 = new Uint16Array(arr8.buffer);\n```\n\n\n下面是类型化数组的列表：\n\n- `Uint8Array`，`Uint16Array`，`Uint32Array` —— 用于 8、16 和 32 位的整数。\n  - `Uint8ClampedArray` —— 用于 8 位整数，在赋值时便“固定“其值（见下文）。\n- `Int8Array`，`Int16Array`，`Int32Array` —— 用于有符号整数（可以为负数）。\n- `Float32Array`，`Float64Array` —— 用于 32 位和 64 位的有符号浮点数。\n\n```warn header=\"没有 `int8` 或类似的单值类型\"\n请注意，尽管有类似 `Int8Array` 这样的名称，但 JavaScript 中并没有像 `int`，或 `int8` 这样的单值类型。\n\n这是合乎逻辑的，因为 `Int8Array` 不是这些单值的数组，而是 `ArrayBuffer` 上的视图。\n```\n\n### 越界行为\n\n如果我们尝试将越界值写入类型化数组会出现什么情况？不会报错。但是多余的位被切除。\n\n例如，我们尝试将 256 放入 `Uint8Array`。256 的二进制格式是 `100000000`（9 位），但 `Uint8Array` 每个值只有 8 位，因此可用范围为 0 到 255。\n\n对于更大的数字，仅存储最右边的（低位有效）8 位，其余部分被切除： \n\n![](8bit-integer-256.svg)\n\n因此结果是 0。\n\n257 的二进制格式是 `100000001`（9 位），最右边的 8 位会被存储，因此数组中会有 `1`：\n\n![](8bit-integer-257.svg)\n\n换句话说，该数字对 2<sup>8</sup> 取模的结果被保存了下来。\n\n示例如下：\n\n```js run\nlet uint8array = new Uint8Array(16);\n\nlet num = 256;\nalert(num.toString(2)); // 100000000（二进制表示）\n\nuint8array[0] = 256;\nuint8array[1] = 257;\n\nalert(uint8array[0]); // 0\nalert(uint8array[1]); // 1\n```\n\n`Uint8ClampedArray` 在这方面比较特殊，它的表现不太一样。对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0。此行为对于图像处理很有用。\n\n## TypedArray 方法\n\n`TypedArray` 具有常规的 `Array` 方法，但有个明显的例外。\n\n我们可以遍历（iterate），`map`，`slice`，`find` 和 `reduce` 等。\n\n但有几件事我们做不了：\n\n- 没有 `splice` —— 我们无法“删除”一个值，因为类型化数组是缓冲区（buffer）上的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。\n- 无 `concat` 方法。\n\n还有两种其他方法：\n\n- `arr.set(fromArr, [offset])` 从 `offset`（默认为 0）开始，将 `fromArr` 中的所有元素复制到 `arr`。\n- `arr.subarray([begin, end])` 创建一个从 `begin` 到 `end`（不包括）相同类型的新视图。这类似于 `slice` 方法（同样也支持），但不复制任何内容 —— 只是创建一个新视图，以对给定片段的数据进行操作。\n\n有了这些方法，我们可以复制、混合类型化数组，从现有数组创建新数组等。\n\n\n\n## DataView\n\n[DataView](mdn:/JavaScript/Reference/Global_Objects/DataView) 是在 `ArrayBuffer` 上的一种特殊的超灵活“未类型化”视图。它允许以任何格式访问任何偏移量（offset）的数据。\n\n- 对于类型化的数组，构造器决定了其格式。整个数组应该是统一的。第 i 个数字是 `arr[i]`。\n- 通过 `DataView`，我们可以使用 `.getUint8(i)` 或 `.getUint16(i)` 之类的方法访问数据。我们在调用方法时选择格式，而不是在构造的时候。\n\n语法：\n\n```js\nnew DataView(buffer, [byteOffset], [byteLength])\n```\n\n- **`buffer`** —— 底层的 `ArrayBuffer`。与类型化数组不同，`DataView` 不会自行创建缓冲区（buffer）。我们需要事先准备好。\n- **`byteOffset`** —— 视图的起始字节位置（默认为 0）。\n- **`byteLength`** —— 视图的字节长度（默认至 `buffer` 的末尾）。\n\n例如，这里我们从同一个 buffer 中提取不同格式的数字：\n\n```js run\n// 4 个字节的二进制数组，每个都是最大值 255\nlet buffer = new Uint8Array([255, 255, 255, 255]).buffer;\n\nlet dataView = new DataView(buffer);\n\n// 在偏移量为 0 处获取 8 位数字\nalert( dataView.getUint8(0) ); // 255\n\n// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535\nalert( dataView.getUint16(0) ); // 65535（最大的 16 位无符号整数）\n\n// 在偏移量为 0 处获取 32 位数字\nalert( dataView.getUint32(0) ); // 4294967295（最大的 32 位无符号整数）\n\ndataView.setUint32(0, 0); // 将 4 个字节的数字设为 0，即将所有字节都设为 0\n```\n\n当我们将混合格式的数据存储在同一缓冲区（buffer）中时，`DataView` 非常有用。例如，当我们存储一个成对序列（16 位整数，32 位浮点数）时，用 `DataView` 可以轻松访问它们。\n\n## 总结\n\n`ArrayBuffer` 是核心对象，是对固定长度的连续内存区域的引用。\n\n几乎任何对 `ArrayBuffer` 的操作，都需要一个视图。\n\n- 它可以是 `TypedArray`：\n    - `Uint8Array`，`Uint16Array`，`Uint32Array` —— 用于 8 位、16 位和 32 位无符号整数。\n    - `Uint8ClampedArray` —— 用于 8 位整数，在赋值时便“固定”其值。\n    - `Int8Array`，`Int16Array`，`Int32Array` —— 用于有符号整数（可以为负数）。\n    - `Float32Array`，`Float64Array` —— 用于 32 位和 64 位的有符号浮点数。\n- 或 `DataView` —— 使用方法来指定格式的视图，例如，`getUint8(offset)`。\n\n在大多数情况下，我们直接对类型化数组进行创建和操作，而将 `ArrayBuffer` 作为“共同之处（common denominator）”隐藏起来。我们可以通过 `.buffer` 来访问它，并在需要时创建另一个视图。\n\n还有另外两个术语，用于对二进制数据进行操作的方法的描述：\n- `ArrayBufferView` 是所有这些视图的总称。\n- `BufferSource` 是 `ArrayBuffer` 或 `ArrayBufferView` 的总称。\n\n我们将在下一章中学习这些术语。`BufferSource` 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— `ArrayBuffer` 或其上的视图。\n\n这是一份备忘单：\n\n![](arraybuffer-view-buffersource.svg)",
        "libs": [],
        "children": [
          "concat"
        ],
        "parent": "binary",
        "updatedAt": 1657705346
      }
    },
    "concat": {
      "type": "Task",
      "value": {
        "title": "拼接类型化数组",
        "slug": "concat",
        "githubPath": "/4-binary/01-arraybuffer-binary-arrays/01-concat",
        "weight": 1,
        "libs": [],
        "content": "\n\n给定一个 `Uint8Array` 数组，请写一个函数 `concat(arrays)`，将数组拼接成一个单一数组并返回。",
        "solution": "",
        "solutionJs": "function concat(arrays) {\n  // sum of individual array lengths\n  let totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n\n  let result = new Uint8Array(totalLength);\n\n  if (!arrays.length) return result;\n\n  // for each array - copy it over result\n  // next array is copied right after the previous one\n  let length = 0;\n  for(let array of arrays) {\n    result.set(array, length);\n    length += array.length;\n  }\n\n  return result;\n}\n",
        "parent": "arraybuffer-binary-arrays",
        "version": 1
      }
    },
    "text-decoder": {
      "type": "Article",
      "value": {
        "title": "TextDecoder 和 TextEncoder",
        "slug": "text-decoder",
        "githubPath": "/4-binary/02-text-decoder",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n如果二进制数据实际上是一个字符串怎么办？例如，我们收到了一个包含文本数据的文件。\n\n内建的 [TextDecoder](https://encoding.spec.whatwg.org/#interface-textdecoder) 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，允许将值读取为实际的 JavaScript 字符串。\n\n首先我们需要创建：\n```js\nlet decoder = new TextDecoder([label], [options]);\n```\n\n- **`label`** —— 编码格式，默认为 `utf-8`，但同时也支持 `big5`，`windows-1251` 等许多其他编码格式。\n- **`options`** —— 可选对象：\n  - **`fatal`** —— 布尔值，如果为 `true` 则为无效（不可解码）字符抛出异常，否则（默认）用字符 `\\uFFFD` 替换无效字符。\n  - **`ignoreBOM`** —— 布尔值，如果为 `true` 则忽略 BOM（可选的字节顺序 Unicode 标记），很少需要使用。\n\n……然后解码：\n\n```js\nlet str = decoder.decode([input], [options]);\n```\n\n- **`input`** —— 要被解码的 `BufferSource`。\n- **`options`** —— 可选对象：\n  - **`stream`** —— 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 `decoder`。在这种情况下，多字节的字符可能偶尔会在块与块之间被分割。这个选项告诉 `TextDecoder` 记住“未完成”的字符，并在下一个数据块来的时候进行解码。\n\n例如：\n\n```js run\nlet uint8Array = new Uint8Array([72, 101, 108, 108, 111]);\n\nalert( new TextDecoder().decode(uint8Array) ); // Hello\n```\n\n\n```js run\nlet uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);\n\nalert( new TextDecoder().decode(uint8Array) ); // 你好\n```\n\n我们可以通过为其创建子数组视图来解码部分缓冲区：\n\n\n```js run\nlet uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);\n\n// 该字符串位于中间\n// 在不复制任何内容的前提下，创建一个新的视图\nlet binaryString = uint8Array.subarray(1, -1);\n\nalert( new TextDecoder().decode(binaryString) ); // Hello\n```\n\n## TextEncoder\n\n[TextEncoder](https://encoding.spec.whatwg.org/#interface-textencoder) 做相反的事情 —— 将字符串转换为字节。\n\n语法为：\n\n```js\nlet encoder = new TextEncoder();\n```\n\n只支持 `utf-8` 编码。\n\n它有两种方法：\n- **`encode(str)`** —— 从字符串返回 `Uint8Array`。\n- **`encodeInto(str, destination)`** —— 将 `str` 编码到 `destination` 中，该目标必须为 `Uint8Array`。\n\n```js run\nlet encoder = new TextEncoder();\n\nlet uint8Array = encoder.encode(\"Hello\");\nalert(uint8Array); // 72,101,108,108,111\n```",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1667114531
      }
    },
    "blob": {
      "type": "Article",
      "value": {
        "title": "Blob",
        "slug": "blob",
        "githubPath": "/4-binary/03-blob",
        "isFolder": false,
        "weight": 3,
        "content": "\n\n`arrayBuffer` 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分。\n\n在浏览器中，还有其他更高级的对象，特别是 `Blob`，在 [File API](https://www.w3.org/TR/FileAPI/) 中有相关描述。\n\n`Blob` 由一个可选的字符串 `type`（通常是 MIME 类型）和 `blobParts` 组成 —— 一系列其他 `Blob` 对象，字符串和 `BufferSource`。\n\n![](blob.svg)\n\n构造函数的语法为：\n\n```js\nnew Blob(blobParts, options);\n```\n\n- **`blobParts`** 是 `Blob`/`BufferSource`/`String` 类型的值的数组。\n- **`options`** 可选对象：\n  - **`type`** —— `Blob` 类型，通常是 MIME 类型，例如 `image/png`，\n  - **`endings`** —— 是否转换换行符，使 `Blob` 对应于当前操作系统的换行符（`\\r\\n` 或 `\\n`）。默认为 `\"transparent\"`（啥也不做），不过也可以是 `\"native\"`（转换）。\n\n例如：\n\n```js\n// 从字符串创建 Blob\nlet blob = new Blob([\"<html>…</html>\"], {type: 'text/html'});\n// 请注意：第一个参数必须是一个数组 [...]\n```\n\n```js\n// 从类型化数组（typed array）和字符串创建 Blob\nlet hello = new Uint8Array([72, 101, 108, 108, 111]); // 二进制格式的 \"hello\" \n\nlet blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});\n```\n\n\n我们可以用 `slice` 方法来提取 `Blob` 片段：\n\n```js\nblob.slice([byteStart], [byteEnd], [contentType]);\n```\n\n- **`byteStart`** —— 起始字节，默认为 0。\n- **`byteEnd`** —— 最后一个字节（不包括，默认为最后）。\n- **`contentType`** —— 新 blob 的 `type`，默认与源 blob 相同。\n\n参数值类似于 `array.slice`，也允许是负数。\n\n```smart header=\"`Blob` 对象是不可改变的\"\n我们无法直接在 `Blob` 中更改数据，但我们可以通过 `slice` 获得 `Blob` 的多个部分，从这些部分创建新的 `Blob` 对象，将它们组成新的 `Blob`，等。\n\n这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以生成一个新的改动过的字符串。\n```\n\n## Blob 用作 URL\n\nBlob 可以很容易用作 `<a>`、`<img>` 或其他标签的 URL，来显示它们的内容。\n\n多亏了 `type`，让我们也可以下载/上传 `Blob` 对象，而在网络请求中，`type` 自然地变成了 `Content-Type`。\n\n让我们从一个简单的例子开始。通过点击链接，你可以下载一个具有动态生成的内容为 `hello world` 的 `Blob` 的文件：\n\n```html run\n<!-- download 特性（attribute）强制浏览器下载而不是导航 -->\n<a download=\"hello.txt\" href='#' id=\"link\">Download</a>\n\n<script>\nlet blob = new Blob([\"Hello, world!\"], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n</script>\n```\n\n我们也可以在 Javascript 中动态创建一个链接，通过 `link.click()` 模拟一个点击，然后便自动下载了。\n\n下面是类似的代码，此代码可以让用户无需任何 HTML 即可下载动态生成的 `Blob`（译注：也就是通过代码模拟用户点击，从而自动下载）：\n\n```js run\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n\nlink.click();\n\nURL.revokeObjectURL(link.href);\n```\n\n`URL.createObjectURL` 取一个 `Blob`，并为其创建一个唯一的 URL，形式为 `blob:<origin>/<uuid>`。\n\n也就是 `link.href` 的值的样子：\n\n```\nblob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273\n```\n\n浏览器内部为每个通过 `URL.createObjectURL` 生成的 URL 存储了一个 URL -> `Blob` 映射。因此，此类 URL 很短，但可以访问 `Blob`。\n\n生成的 URL（即其链接）仅在当前文档打开的状态下才有效。它允许引用 `<img>`、`<a>` 中的 `Blob`，以及基本上任何其他期望 URL 的对象。\n\n不过它有个副作用。虽然这里有 `Blob` 的映射，但 `Blob` 本身只保存在内存中的。浏览器无法释放它。\n\n在文档退出时（unload），该映射会被自动清除，因此 `Blob` 也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。\n\n**因此，如果我们创建一个 URL，那么即使我们不再需要该 `Blob` 了，它也会被挂在内存中。**\n\n`URL.revokeObjectURL(url)` 从内部映射中移除引用，因此允许 `Blob` 被删除（如果没有其他引用的话），并释放内存。\n\n在上面最后一个示例中，我们打算仅使用一次 `Blob`，来进行即时下载，因此我们立即调用 `URL.revokeObjectURL(link.href)`。\n\n而在前一个带有可点击的 HTML 链接的示例中，我们不调用 `URL.revokeObjectURL(link.href)`，因为那样会使 `Blob` URL 无效。在调用该方法后，由于映射被删除了，因此该 URL 也就不再起作用了。\n\n## Blob 转换为 base64\n\n`URL.createObjectURL` 的一个替代方法是，将 `Blob` 转换为 base64-编码的字符串。\n\n这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。更重要的是 —— 我们可以在 \"data-url\" 中使用此编码。\n\n[\"data-url\"](mdn:/http/Data_URIs) 的形式为 `data:[<mediatype>][;base64],<data>`。我们可以在任何地方使用这种 url，和使用“常规” url 一样。\n\n例如，这是一个笑脸：\n\n```html\n<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n```\n\n浏览器将解码该字符串，并显示图像：<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n\n\n我们使用内建的 `FileReader` 对象来将 `Blob` 转换为 base64。它可以将 `Blob` 中的数据读取为多种格式。在[下一章](info:file) 我们将更深入地介绍它。\n\n下面是下载 `Blob` 的示例，这次是通过 base-64：\n\n```js run\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\n*!*\nlet reader = new FileReader();\nreader.readAsDataURL(blob); // 将 Blob 转换为 base64 并调用 onload\n*/!*\n\nreader.onload = function() {\n  link.href = reader.result; // data url\n  link.click();\n};\n```\n\n这两种从 `Blob` 创建 URL 的方法都可以用。但通常 `URL.createObjectURL(blob)` 更简单快捷。\n\n```compare title-plus=\"URL.createObjectURL(blob)\" title-minus=\"Blob 转换为 data url\"\n+ 如果介意内存，我们需要撤销（revoke）它们\n+ 直接访问 `Blob`，无需“编码/解码”\n- 无需撤销（revoke）任何操作。\n- 对大的 `Blob` 进行编码时，性能和内存会有损耗。\n```\n\n## Image 转换为 blob\n\n我们可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 `Blob`。这样方便将其上传至其他地方。\n\n图像操作是通过 `<canvas>` 元素来实现的：\n\n1. 使用 [canvas.drawImage](mdn:/api/CanvasRenderingContext2D/drawImage) 在 canvas 上绘制图像（或图像的一部分）。\n2. 调用 canvas 方法 [.toBlob(callback, format, quality)](mdn:/api/HTMLCanvasElement/toBlob) 创建一个 `Blob`，并在创建完成后使用其运行 `callback`。\n\n在下面这个示例中，图像只是被复制了，不过我们可以在创建 blob 之前，从中裁剪图像，或者在 canvas 上对其进行转换：\n\n```js run\n// 获取任何图像\nlet img = document.querySelector('img');\n\n// 生成同尺寸的 <canvas>\nlet canvas = document.createElement('canvas');\ncanvas.width = img.clientWidth;\ncanvas.height = img.clientHeight;\n\nlet context = canvas.getContext('2d');\n\n// 向其中复制图像（此方法允许剪裁图像）\ncontext.drawImage(img, 0, 0);\n// 我们 context.rotate()，并在 canvas 上做很多其他事情\n\n// toBlob 是异步操作，结束后会调用 callback\ncanvas.toBlob(function(blob) {\n  // blob 创建完成，下载它\n  let link = document.createElement('a');\n  link.download = 'example.png';\n\n  link.href = URL.createObjectURL(blob);\n  link.click();\n\n  // 删除内部 blob 引用，这样浏览器可以从内存中将其清除\n  URL.revokeObjectURL(link.href);\n}, 'image/png');\n```\n\n如果我们更喜欢 `async/await` 而不是 callback：\n```js\nlet blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n```\n\n对于页面截屏，我们可以使用诸如 <https://github.com/niklasvh/html2canvas> 之类的库。它所做的只是扫一遍浏览器页面，并将其绘制在 `<canvas>` 上。然后，我们就可以像上面一样获取一个它的 `Blob`。\n\n## Blob 转换为 ArrayBuffer\n\n`Blob` 构造器允许从几乎任何东西创建 blob，包括任何 `BufferSource`。\n\n但是，如果我们需要执行低级别的处理时，我们可以从 `blob.arrayBuffer()` 中获取最低级别的 `ArrayBuffer`：\n\n```js\n// 从 bolb 获取 arrayBuffer\nconst bufferPromise = await blob.arrayBuffer();\n\n// 或\nblob.arrayBuffer().then(buffer => /* 处理 ArrayBuffer */);\n```\n\n## Blob 转换为 Stream\n\n当我们读取和写入超过 `2 GB` 的 blob 时，将其转换为 `arrayBuffer` 的使用对我们来说会更加占用内存。这种情况下，我们可以直接将 blob 转换为 stream 进行处理。\n\nstream 是一种特殊的对象，我们可以从它那里逐部分地读取（或写入）。这块的知识点不在本文的范围之内，但这里有一个例子，你可以在 <https://developer.mozilla.org/en-US/docs/Web/API/Streams_API> 了解更多相关内容。对于适合逐段处理的数据，使用 stream 是很方便的。\n\n`Blob` 接口里的 `stream()` 方法返回一个 `ReadableStream`，在被读取时可以返回 `Blob` 中包含的数据。 \n\n如下所示：\n\n```js\n// 从 blob 获取可读流（readableStream）\nconst readableStream = blob.stream();\nconst stream = readableStream.getReader();\n\nwhile (true) {\n  // 对于每次迭代：value 是下一个 blob 数据片段\n  let { done, value } = await stream.read();\n  if (done) {\n    // 读取完毕，stream 里已经没有数据了\n    console.log('all blob processed.');\n    break;\n  }\n\n  // 对刚从 blob 中读取的数据片段做一些处理\n  console.log(value);\n}\n```\n\n## 总结\n\n`arrayBuffer`，`Uint8Array` 及其他 `BufferSource` 是“二进制数据”，而 [Blob](https://www.w3.org/TR/FileAPI/#dfn-Blob) 则表示“具有类型的二进制数据”。\n\n这样可以方便 `Blob` 用于在浏览器中非常常见的上传/下载操作。\n\n[XMLHttpRequest](info:xmlhttprequest)，[fetch](info:fetch) 等进行 Web 请求的方法可以自然地使用 `Blob`，也可以使用其他类型的二进制数据。\n\n我们可以轻松地在 `Blob` 和低级别的二进制数据类型之间进行转换：\n\n- 我们可以使用 `new Blob(...)` 构造函数从一个类型化数组（typed array）创建 `Blob`。\n- 我们可以使用 `blob.arrayBuffer()` 从 `Blob` 中取回 `arrayBuffer`，然后在其上创建一个视图（view），用于低级别的二进制处理。\n\n当我们需要处理大型 blob 时，将其转换为 `stream` 非常有用。你可以轻松地从 blob 创建 `ReadableStream`。`Blob` 接口的 `stream()` 方法返回一个 `ReadableStream`，其在被读取时返回 blob 中包含的数据。",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1667114531
      }
    },
    "file": {
      "type": "Article",
      "value": {
        "title": "File 和 FileReader",
        "slug": "file",
        "githubPath": "/4-binary/04-file",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n[File](https://www.w3.org/TR/FileAPI/#dfn-file) 对象继承自 `Blob`，并扩展了与文件系统相关的功能。 \n\n有两种方式可以获取它。\n\n第一种，与 `Blob` 类似，有一个构造器：\n\n```js\nnew File(fileParts, fileName, [options])\n```\n\n- **`fileParts`** —— Blob/BufferSource/String 类型值的数组。\n- **`fileName`** —— 文件名字符串。\n- **`options`** —— 可选对象：\n    - **`lastModified`** —— 最后一次修改的时间戳（整数日期）。\n\n第二种，更常见的是，我们从 `<input type=\"file\">` 或拖放或其他浏览器接口来获取文件。在这种情况下，file 将从操作系统（OS）获得 this 信息。\n\n由于 `File` 是继承自 `Blob` 的，所以 `File` 对象具有相同的属性，附加：\n- `name` —— 文件名，\n- `lastModified` —— 最后一次修改的时间戳。\n\n这就是我们从 `<input type=\"file\">` 中获取 `File` 对象的方式：\n\n```html run\n<input type=\"file\" onchange=\"showFile(this)\">\n\n<script>\nfunction showFile(input) {\n  let file = input.files[0];\n\n  alert(`File name: ${file.name}`); // 例如 my.png\n  alert(`Last modified: ${file.lastModified}`); // 例如 1552830408824\n}\n</script>\n```\n\n```smart\n输入（input）可以选择多个文件，因此 `input.files` 是一个类数组对象。这里我们只有一个文件，所以我们只取 `input.files[0]`。\n```\n\n## FileReader\n\n[FileReader](https://www.w3.org/TR/FileAPI/#dfn-filereader) 是一个对象，其唯一目的是从 `Blob`（因此也从 `File`）对象中读取数据。\n\n它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。\n\n构造函数：\n\n```js\nlet reader = new FileReader(); // 没有参数\n```\n\n主要方法:\n\n- **`readAsArrayBuffer(blob)`** —— 将数据读取为二进制格式的 `ArrayBuffer`。\n- **`readAsText(blob, [encoding])`** —— 将数据读取为给定编码（默认为 `utf-8` 编码）的文本字符串。\n- **`readAsDataURL(blob)`** —— 读取二进制数据，并将其编码为 base64 的 data url。\n- **`abort()`** —— 取消操作。\n\n`read*` 方法的选择，取决于我们喜欢哪种格式，以及如何使用数据。\n\n- `readAsArrayBuffer` —— 用于二进制文件，执行低级别的二进制操作。对于诸如切片（slicing）之类的高级别的操作，`File` 是继承自 `Blob` 的，所以我们可以直接调用它们，而无需读取。\n- `readAsText` —— 用于文本文件，当我们想要获取字符串时。\n- `readAsDataURL` —— 当我们想在 `src` 中使用此数据，并将其用于 `img` 或其他标签时。正如我们在  <info:blob> 一章中所讲的，还有一种用于此的读取文件的替代方案：`URL.createObjectURL(file)`。\n\n读取过程中，有以下事件：\n- `loadstart` —— 开始加载。\n- `progress` —— 在读取过程中出现。\n- `load` —— 读取完成，没有 error。\n- `abort` —— 调用了 `abort()`。\n- `error` —— 出现 error。\n- `loadend` —— 读取完成，无论成功还是失败。\n\n读取完成后，我们可以通过以下方式访问读取结果：\n- `reader.result` 是结果（如果成功）\n- `reader.error` 是 error（如果失败）。\n\n使用最广泛的事件无疑是 `load` 和 `error`。\n\n这是一个读取文件的示例：\n\n```html run\n<input type=\"file\" onchange=\"readFile(this)\">\n\n<script>\nfunction readFile(input) {\n  let file = input.files[0];\n\n  let reader = new FileReader();\n\n  reader.readAsText(file);\n\n  reader.onload = function() {\n    console.log(reader.result);\n  };\n\n  reader.onerror = function() {\n    console.log(reader.error);\n  };\n\n}\n</script>\n```\n\n```smart header=\"`FileReader` 用于 blob\"\n正如我们在 <info:blob> 一章中所提到的，`FileReader` 不仅可读取文件，还可读取任何 blob。\n\n我们可以使用它将 blob 转换为其他格式：\n- `readAsArrayBuffer(blob)` —— 转换为 `ArrayBuffer`，\n- `readAsText(blob, [encoding])` —— 转换为字符串（`TextDecoder` 的一个替代方案），\n- `readAsDataURL(blob)` —— 转换为 base64 的 data url。\n```\n\n\n```smart header=\"在 Web Workers 中可以使用 `FileReaderSync`\"\n对于 Web Worker，还有一种同步的 `FileReader` 变体，称为 [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync)。\n\n它的读取方法 `read*` 不会生成事件，但是会像常规函数那样返回一个结果。\n\n不过，这仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟，而在 Web Worker 中，这种延迟并不是很重要。它不会影响页面。\n```\n\n## 总结\n\n`File` 对象继承自 `Blob`。\n\n除了 `Blob` 方法和属性外，`File` 对象还有 `name` 和 `lastModified` 属性，以及从文件系统读取的内部功能。我们通常从用户输入如 `<input>` 或拖放事件来获取 `File` 对象。\n\n`FileReader` 对象可以从文件或 blob 中读取数据，可以读取为以下三种格式：\n- 字符串（`readAsText`）。\n- `ArrayBuffer`（`readAsArrayBuffer`）。\n- data url，base-64 编码（`readAsDataURL`）。\n\n但是，在很多情况下，我们不必读取文件内容。就像我们处理 blob 一样，我们可以使用 `URL.createObjectURL(file)` 创建一个短的 url，并将其赋给 `<a>` 或 `<img>`。这样，文件便可以下载文件或者将其呈现为图像，作为 canvas 等的一部分。\n\n而且，如果我们要通过网络发送一个 `File`，那也很容易：像 `XMLHttpRequest` 或 `fetch` 等网络 API 本身就接受 `File` 对象。",
        "libs": [],
        "children": [],
        "parent": "binary",
        "updatedAt": 1591272465
      }
    },
    "data-storage": {
      "type": "Article",
      "value": {
        "title": "在浏览器中存储数据",
        "slug": "data-storage",
        "githubPath": "/6-data-storage",
        "isFolder": true,
        "weight": 6,
        "content": "",
        "libs": [],
        "children": [
          "cookie",
          "localstorage",
          "indexeddb"
        ]
      }
    },
    "cookie": {
      "type": "Article",
      "value": {
        "title": "Cookie，document.cookie",
        "slug": "cookie",
        "githubPath": "/6-data-storage/01-cookie",
        "isFolder": false,
        "weight": 1,
        "content": "\n\nCookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分，由 [RFC 6265](https://tools.ietf.org/html/rfc6265) 规范定义。\n\nCookie 通常是由 Web 服务器使用响应 `Set-Cookie` HTTP-header 设置的。然后浏览器使用 `Cookie` HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中。\n\n最常见的用处之一就是身份验证：\n\n1. 登录后，服务器在响应中使用 `Set-Cookie` HTTP-header 来设置具有唯一“会话标识符（session identifier）”的 cookie。\n2. 下次当请求被发送到同一个域时，浏览器会使用 `Cookie` HTTP-header 通过网络发送 cookie。\n3. 所以服务器知道是谁发起了请求。\n\n我们还可以使用 `document.cookie` 属性从浏览器访问 cookie。\n\n关于 cookie 及其选项，有很多棘手的事情。在本章中，我们将详细介绍它们。\n\n## 从 document.cookie 中读取\n\n```online\n你的浏览器是否存储了本网站的任何 cookie？让我们来看看：\n```\n\n```offline\n假设你在一个网站上，则可以看到来自该网站的 cookie，像这样：\n```\n\n```js run\n// 在 javascript.info，我们使用谷歌分析来进行统计，\n// 所以应该存在一些 cookie\nalert( document.cookie ); // cookie1=value1; cookie2=value2;...\n```\n\n\n`document.cookie` 的值由 `name=value` 对组成，以 `; ` 分隔。每一个都是独立的 cookie。\n\n为了找到一个特定的 cookie，我们可以以 `; ` 作为分隔，将 `document.cookie` 分开，然后找到对应的名字。我们可以使用正则表达式或者数组函数来实现。\n\n我们把这个留给读者当作练习。此外，在本章的最后，你可以找到一些操作 cookie 的辅助函数。\n\n## 写入 document.cookie\n\n我们可以写入 `document.cookie`。但这不是一个数据属性，它是一个 [访问器（getter/setter）](info:property-accessors)。对其的赋值操作会被特殊处理。\n\n**对 `document.cookie` 的写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie。**\n\n例如，此调用设置了一个名称为 `user` 且值为 `John` 的 cookie：\n\n```js run\ndocument.cookie = \"user=John\"; // 只会更新名称为 user 的 cookie\nalert(document.cookie); // 展示所有 cookie\n```\n\n如果你运行了上面这段代码，你会看到多个 cookie。这是因为 `document.cookie=` 操作不是重写整所有 cookie。它只设置代码中提到的 cookie `user`。\n\n从技术上讲，cookie 的名称和值可以是任何字符。为了保持有效的格式，它们应该使用内建的 `encodeURIComponent` 函数对其进行转义：\n\n```js run\n// 特殊字符（空格），需要编码\nlet name = \"my name\";\nlet value = \"John Smith\"\n\n// 将 cookie 编码为 my%20name=John%20Smith\ndocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n\nalert(document.cookie); // ...; my%20name=John%20Smith\n```\n\n\n```warn header=\"限制\"\n存在一些限制：\n- `encodeURIComponent` 编码后的 `name=value` 对，大小不能超过 4KB。因此，我们不能在一个 cookie 中保存大的东西。\n- 每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。\n```\n\nCookie 有几个选项，其中很多都很重要，应该设置它。\n\n选项被列在 `key=value` 之后，以 `;` 分隔，像这样：\n\n```js run\ndocument.cookie = \"user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT\"\n```\n\n## path\n\n- **`path=/mypath`**\n\nurl 路径前缀必须是绝对路径。它使得该路径下的页面可以访问该 cookie。默认为当前路径。\n\n如果一个 cookie 带有 `path=/admin` 设置，那么该 cookie 在 `/admin` 和 `/admin/something` 下都是可见的，但是在 `/home` 或 `/adminpage` 下不可见。\n\n通常，我们应该将 `path` 设置为根目录：`path=/`，以使 cookie 对此网站的所有页面可见。\n\n## domain\n\n- **`domain=site.com`**\n\ndomain 控制了可访问 cookie 的域。但是在实际中，有一些限制。我们无法设置任何域。\n\n**无法从另一个二级域访问 cookie，因此 `other.com` 永远不会收到在 `site.com` 设置的 cookie。**\n\n这是一项安全限制，为了允许我们将敏感数据存储在应该仅在一个站点上可用的 cookie 中。\n\n默认情况下，cookie 只有在设置的域下才能被访问到。\n\n请注意，默认情况下，cookie 也不会共享给子域，例如 `forum.site.com`。\n\n```js\n// 如果我们在 site.com 网站上设置了 cookie……\ndocument.cookie = \"user=John\"\n\n// ……在 forum.site.com 域下我们无法访问它\nalert(document.cookie); // 没有 user\n```\n\n……但这是可以设置的。如果我们想允许像 `forum.site.com` 这样的子域在 `site.com` 上设置 cookie，也是可以实现的。\n\n为此，当在 `site.com` 设置 cookie 时，我们应该明确地将 `domain` 选项设置为根域：`domain=site.com`。那么，所有子域都可以访问到这样的 cookie。\n\n例如：\n\n```js\n// 在 site.com\n// 使 cookie 可以被在任何子域 *.site.com 访问：\ndocument.cookie = \"user=John; *!*domain=site.com*/!*\"\n\n// 之后\n\n// 在 forum.site.com\nalert(document.cookie); // 有 cookie user=John\n```\n\n出于历史原因，`domain=.site.com`（`site.com` 前面有一个点符号）也以相同的方式工作，允许从子域访问 cookie。这是一个旧的表示方式，如果我们需要支持非常旧的浏览器，那么应该使用它。\n\n总结一下，通过 `domain` 选项的设置，可以实现允许在子域访问 cookie。\n\n## expires，max-age\n\n默认情况下，如果一个 cookie 没有设置这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失。此类 cookie 被称为 \"session cookie”。\n\n为了让 cookie 在浏览器关闭后仍然存在，我们可以设置 `expires` 或 `max-age` 选项中的一个。\n\n- **`expires=Tue, 19 Jan 2038 03:14:07 GMT`**\n\ncookie 的过期时间定义了浏览器会自动清除该 cookie 的时间。\n\n日期必须完全采用 GMT 时区的这种格式。我们可以使用 `date.toUTCString` 来获取它。例如，我们可以将 cookie 设置为 1 天后过期。\n\n```js\n// 当前时间 +1 天\nlet date = new Date(Date.now() + 86400e3);\ndate = date.toUTCString();\ndocument.cookie = \"user=John; expires=\" + date;\n```\n\n如果我们将 `expires` 设置为过去的时间，则 cookie 会被删除。\n\n-  **`max-age=3600`**\n\n它是 `expires` 的替代选项，指明了 cookie 的过期时间距离当前时间的秒数。\n\n如果将其设置为 0 或负数，则 cookie 会被删除：\n\n```js\n// cookie 会在一小时后失效\ndocument.cookie = \"user=John; max-age=3600\";\n\n// 删除 cookie（让它立即过期）\ndocument.cookie = \"user=John; max-age=0\";\n```\n\n## secure\n\n- **`secure`**\n\nCookie 应只能被通过 HTTPS 传输。\n\n**默认情况下，如果我们在 `http://site.com` 上设置了 cookie，那么该 cookie 也会出现在 `https://site.com` 上，反之亦然。**\n\n也就是说，cookie 是基于域的，它们不区分协议。\n\n使用此选项，如果一个 cookie 是通过 `https://site.com` 设置的，那么它不会在相同域的 HTTP 环境下出现，例如 `http://site.com`。所以，如果一个 cookie 包含绝不应该通过未加密的 HTTP 协议发送的敏感内容，那么就应该设置 `secure` 标识。\n\n```js\n// 假设我们现在在 HTTPS 环境下\n// 设置 cookie secure（只在 HTTPS 环境下可访问）\ndocument.cookie = \"user=John; secure\";\n```\n\n## samesite\n\n这是另外一个关于安全的特性。它旨在防止 XSRF（跨网站请求伪造）攻击。\n\n为了了解它是如何工作的，以及何时有用，让我们看一下 XSRF 攻击。\n\n### XSRF 攻击\n\n想象一下，你登录了 `bank.com` 网站。此时：你有了来自该网站的身份验证 cookie。你的浏览器会在每次请求时将其发送到 `bank.com`，以便识别你，并执行所有敏感的财务上的操作。\n\n现在，在另外一个窗口中浏览网页时，你不小心访问了另一个网站 `evil.com`。该网站具有向 `bank.com` 网站提交一个具有启动与黑客账户交易的字段的表单 `<form action=\"https://bank.com/pay\">` 的 JavaScript 代码。\n\n你每次访问 `bank.com` 时，浏览器都会发送 cookie，即使该表单是从 `evil.com` 提交过来的。因此，银行会识别你的身份，并执行真实的付款。\n\n![](cookie-xsrf.svg)\n\n这就是所谓的“跨网站请求伪造（Cross-Site Request Forgery，简称 XSRF）”攻击。\n\n当然，实际的银行会防止出现这种情况。所有由 `bank.com` 生成的表单都具有一个特殊的字段，即所谓的 “XSRF 保护 token”，恶意页面既不能生成，也不能从远程页面提取它。它可以在那里提交表单，但是无法获取数据。并且，网站 `bank.com` 会对收到的每个表单都进行这种 token 的检查。\n\n但是，实现这种防护需要花费时间。我们需要确保每个表单都具有所需的 token 字段，并且我们还必须检查所有请求。\n\n### 输入 cookie samesite 选项\n\nCookie 的 `samesite` 选项提供了另一种防止此类攻击的方式，（理论上）不需要要求 “XSRF 保护 token”。\n\n它有两个可能的值：\n\n- **`samesite=strict`（和没有值的 `samesite` 一样)**\n\n如果用户来自同一网站之外，那么设置了 `samesite=strict` 的 cookie 永远不会被发送。\n\n换句话说，无论用户是通过邮件链接还是从 `evil.com` 提交表单，或者进行了任何来自其他域下的操作，cookie 都不会被发送。\n\n如果身份验证 cookie 具有 `samesite` 选项，那么 XSRF 攻击是没有机会成功的，因为来自 `evil.com` 的提交没有 cookie。因此，`bank.com` 将无法识别用户，也就不会继续进行付款。\n\n这种保护是相当可靠的。只有来自 `bank.com` 的操作才会发送 `samesite` cookie，例如来自 `bank.com` 的另一页面的表单提交。\n\n虽然，这样有一些不方便。\n\n当用户通过合法的链接访问 `bank.com` 时，例如从他们自己的笔记，他们会感到惊讶，`bank.com` 无法识别他们的身份。实际上，在这种情况下不会发送 `samesite=strict` cookie。\n\n我们可以通过使用两个 cookie 来解决这个问题：一个 cookie 用于“一般识别”，仅用于说 \"Hello, John\"，另一个带有 `samesite=strict` 的 cookie 用于进行数据更改的操作。这样，从网站外部来的用户会看到欢迎信息，但是支付操作必须是从银行网站启动的，这样第二个 cookie 才能被发送。\n\n- **`samesite=lax`**\n\n一种更轻松的方法，该方法还可以防止 XSRF 攻击，并且不会破坏用户体验。\n\n宽松（lax）模式，和 `strict` 模式类似，当从外部来到网站，则禁止浏览器发送 cookie，但是增加了一个例外。\n\n如果以下两个条件均成立，则会发送含 `samesite=lax` 的 cookie：\n1. HTTP 方法是“安全的”（例如 GET 方法，而不是 POST）。\n\n    所有安全的 HTTP 方法详见 [RFC7231 规范](https://tools.ietf.org/html/rfc7231)。基本上，这些都是用于读取而不是写入数据的方法。它们不得执行任何更改数据的操作。跟随链接始终是 GET，是安全的方法。\n\n2. 该操作执行顶级导航（更改浏览器地址栏中的 URL）。\n\n    这通常是成立的，但是如果导航是在一个 `<iframe>` 中执行的，那么它就不是顶级的。此外，用于网络请求的 JavaScript 方法不会执行任何导航，因此它们不适合。\n\n所以，`samesite=lax` 所做的是基本上允许最常见的“前往 URL”操作携带 cookie。例如，从笔记中打开网站链接就满足这些条件。\n\n但是，任何更复杂的事儿，例如来自另一个网站的网络请求或表单提交都会丢失 cookie。\n\n如果这种情况适合你，那么添加 `samesite=lax` 将不会破坏用户体验并且可以增加保护。\n\n总体而言，`samesite` 是一个很好的选项。\n\n但它有个缺点：\n\n- `samesite` 会被到 2017 年左右的旧版本浏览器忽略（不兼容）。\n\n**因此，如果我们仅依靠 `samesite` 提供保护，那么在旧版本的浏览器上将很容易受到攻击。**\n\n但是，我们肯定可以将 `samesite` 与其他保护措施一起使用，例如 XSRF token，这样可以多增加一层保护，将来，当旧版本的浏览器淘汰时，我们可能就可以删除 xsrf token 这种方式了。\n\n## httpOnly\n\n这个选项和 JavaScript 没有关系，但是我们必须为了完整性也提一下它。\n\nWeb 服务器使用 `Set-Cookie` header 来设置 cookie。并且，它可以设置 `httpOnly` 选项。\n\n这个选项禁止任何 JavaScript 访问 cookie。我们使用 `document.cookie` 看不到此类 cookie，也无法对此类 cookie 进行操作。\n\n这是一种预防措施，当黑客将自己的 JavaScript 代码注入网页，并等待用户访问该页面时发起攻击，而这个选项可以防止此时的这种攻击。这应该是不可能发生的，黑客应该无法将他们的代码注入我们的网站，但是网站有可能存在 bug，使得黑客能够实现这样的操作。\n\n\n通常来说，如果发生了这种情况，并且用户访问了带有黑客 JavaScript 代码的页面，黑客代码将执行并通过 `document.cookie` 获取到包含用户身份验证信息的 cookie。这就很糟糕了。\n\n但是，如果 cookie 设置了 `httpOnly`，那么 `document.cookie` 则看不到 cookie，所以它受到了保护。\n\n## 附录: Cookie 函数\n\n这里有一组有关 cookie 操作的函数，比手动修改 `document.cookie` 方便得多。\n\n有很多这种 cookie 库，所以这些函数只用于演示。虽然它们都能正常使用。\n\n### getCookie(name)\n\n获取 cookie 最简短的方式是使用 [正则表达式](info:regular-expressions)。\n\n`getCookie(name)` 函数返回具有给定 `name` 的 cookie：\n\n```js\n// 返回具有给定 name 的 cookie，\n// 如果没找到，则返回 undefined\nfunction getCookie(name) {\n  let matches = document.cookie.match(new RegExp(\n    \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n  ));\n  return matches ? decodeURIComponent(matches[1]) : undefined;\n}\n```\n\n这里的 `new RegExp` 是动态生成的，以匹配 `; name=<value>`。\n\n请注意 cookie 的值是经过编码的，所以 `getCookie` 使用了内建方法 `decodeURIComponent` 函数对其进行解码。\n\n### setCookie(name, value, options)\n\n将 cookie 的 `name` 设置为具有默认值 `path=/`（可以修改以添加其他默认值）和给定值 `value`：\n\n```js run\nfunction setCookie(name, value, options = {}) {\n\n  options = {\n    path: '/',\n    // 如果需要，可以在这里添加其他默认值\n    ...options\n  };\n\n  if (options.expires instanceof Date) {\n    options.expires = options.expires.toUTCString();\n  }\n\n  let updatedCookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\n  for (let optionKey in options) {\n    updatedCookie += \"; \" + optionKey;\n    let optionValue = options[optionKey];\n    if (optionValue !== true) {\n      updatedCookie += \"=\" + optionValue;\n    }\n  }\n\n  document.cookie = updatedCookie;\n}\n\n// 使用范例：\nsetCookie('user', 'John', {secure: true, 'max-age': 3600});\n```\n\n### deleteCookie(name)\n\n要删除一个 cookie，我们可以给它设置一个负的过期时间来调用它：\n\n```js\nfunction deleteCookie(name) {\n  setCookie(name, \"\", {\n    'max-age': -1\n  })\n}\n```\n\n```warn header=\"更新或删除必须使用相同的路径和域\"\n请注意：当我们更新或删除一个 cookie 时，我们应该使用和设置 cookie 时相同的路径和域选项。\n```\n\n代码放在：[cookie.js](cookie.js)。\n\n\n## 附录：第三方 cookie\n\n如果 cookie 是由用户所访问的页面的域以外的域放置的，则称其为第三方 cookie。\n\n例如：\n1. `site.com` 网站的一个页面加载了另外一个网站的 banner：`<img src=\"https://ads.com/banner.png\">`。\n2. 与 banner 一起，`ads.com` 的远程服务器可能会设置带有 `id=1234` 这样的 cookie 的 `Set-Cookie` header。此类 cookie 源自 `ads.com` 域，并且仅在 `ads.com` 中可见：\n\n    ![](cookie-third-party.svg)\n\n3. 下次访问 `ads.com` 网站时，远程服务器获取 cookie `id` 并识别用户：\n\n    ![](cookie-third-party-2.svg)\n\n4. 更为重要的是，当用户从 `site.com` 网站跳转至另一个也带有 banner 的网站 `other.com` 时，`ads.com` 会获得该 cookie，因为它属于 `ads.com`，从而识别用户并在他在网站之间切换时对其进行跟踪：\n\n    ![](cookie-third-party-3.svg)\n\n\n由于它的性质，第三方 cookie 通常用于跟踪和广告服务。它们被绑定在原始域上，因此 `ads.com` 可以在不同网站之间跟踪同一用户，如果这些网站都可以访问 `ads.com` 的话。\n\n当然，有些人不喜欢被跟踪，因此浏览器允许禁止此类 cookie。\n\n此外，一些现代浏览器对此类 cookie 采取特殊策略：\n- Safari 浏览器完全不允许第三方 cookie。\n- Firefox 浏览器附带了一个第三方域的黑名单，它阻止了来自名单内的域的第三方 cookie。\n\n\n```smart\n如果我们加载了一个来自第三方域的脚本，例如 `<script src=\"https://google-analytics.com/analytics.js\">`，并且该脚本使用 `document.cookie` 设置了 cookie，那么此类 cookie 就不是第三方的。\n\n如果一个脚本设置了一个 cookie，那么无论脚本来自何处 —— 这个 cookie 都属于当前网页的域。\n```\n\n## 附录: GDPR\n\n本主题和 JavaScript 无关，只是设置 cookie 时的一些注意事项。\n\n欧洲有一项名为 GDPR 的立法，该法规针对网站尊重用户实施了一系列规则。其中之一就是需要明确的许可才可以跟踪用户的 cookie。\n\n请注意，这仅与跟踪/识别/授权 cookie 有关。\n\n所以，如果我们设置一个只保存了一些信息的 cookie，但是既不跟踪也不识别用户，那么我们可以自由地设置它。\n\n但是，如果我们要设置带有身份验证会话（session）或跟踪 id 的 cookie，那么必须得到用户的允许。\n\n网站为了遵循 GDPR 通常有两种做法。你一定已经在网站中看到过它们了：\n\n1. 如果一个网站想要仅为已经经过身份验证的用户设置跟踪的 cookie。\n\n    为此，注册表单中必须要有一个复选框，例如“接受隐私政策”（描述怎么使用 cookie），用户必须勾选它，然后网站就可以自由设置身份验证 cookie 了。\n\n2. 如果一个网站想要为所有人设置跟踪的 cookie。\n\n    为了合法地这样做，网站为每个新用户显示一个“初始屏幕”弹窗，并要求他们同意设置 cookie。之后网站就可以设置 cookie，并可以让用户看到网站内容了。不过，这可能会使新用户感到反感。没有人喜欢看到“必须点击”的初始屏幕弹窗而不是网站内容。但是 GDPR 要求必须得到用户明确地准许。\n\n\nGDPR 不仅涉及 cookie，还涉及其他与隐私相关的问题，但这超出了我们的讨论范围。\n\n\n## 总结\n\n`document.cookie` 提供了对 cookie 的访问\n- 写入操作只会修改其中提到的 cookie。\n- name/value 必须被编码。\n- 一个 cookie 最大不能超过 4KB。每个域下最多允许有 20+ 个左右的 cookie（具体取决于浏览器）。\n\nCookie 选项：\n- `path=/`，默认为当前路径，使 cookie 仅在该路径下可见。\n- `domain=site.com`，默认 cookie 仅在当前域下可见。如果显式地设置了域，可以使 cookie 在子域下也可见。\n- `expires` 或 `max-age` 设定了 cookie 过期时间。如果没有设置，则当浏览器关闭时 cookie 就会失效。\n- `secure` 使 cookie 仅在 HTTPS 下有效。\n- `samesite`，如果请求来自外部网站，禁止浏览器发送 cookie。这有助于防止 XSRF 攻击。\n\n另外：\n- 浏览器可能会禁用第三方 cookie，例如 Safari 浏览器默认禁止所有第三方 cookie。\n- 在为欧盟公民设置跟踪 cookie 时，GDPR 要求必须得到用户明确许可。",
        "libs": [],
        "children": [],
        "parent": "data-storage",
        "updatedAt": 1662374065
      }
    },
    "localstorage": {
      "type": "Article",
      "value": {
        "title": "LocalStorage，sessionStorage",
        "slug": "localstorage",
        "githubPath": "/6-data-storage/02-localstorage",
        "isFolder": false,
        "weight": 2,
        "content": "\n\nWeb 存储对象 `localStorage` 和 `sessionStorage` 允许我们在浏览器上保存键/值对。\n\n它们有趣的是，在页面刷新后（对于 `sessionStorage`）甚至浏览器完全重启（对于 `localStorage`）后，数据仍然保留在浏览器中。我们很快就会看到。\n\n我们已经有了 cookie。为什么还要其他存储对象呢？\n\n- 与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数现代浏览器都允许保存至少 5MB 的数据（或更多），并且具有用于配置数据的设置。\n- 还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。\n- 存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。\n\n两个存储对象都提供相同的方法和属性：\n\n- `setItem(key, value)` —— 存储键/值对。\n- `getItem(key)` —— 按照键获取值。\n- `removeItem(key)` —— 删除键及其对应的值。\n- `clear()` —— 删除所有数据。\n- `key(index)` —— 获取该索引下的键名。\n- `length` —— 存储的内容的长度。\n\n正如你所看到的，它就像一个 `Map` 集合（`setItem/getItem/removeItem`），但也允许通过 `key(index)` 来按索引访问。\n\n让我们看看它是如何工作的吧。\n\n## localStorage 示例\n\n`localStorage` 最主要的特点是：\n\n- 在同源的所有标签页和窗口之间共享数据。\n- 数据不会过期。它在浏览器重启甚至系统重启后仍然存在。\n\n例如，如果你运行此代码……\n\n```js run\nlocalStorage.setItem('test', 1);\n```\n\n……然后关闭/重新打开浏览器，或者只是在不同的窗口打开同一页面，然后你可以这样获取它：\n\n```js run\nalert( localStorage.getItem('test') ); // 1\n```\n\n我们只需要在同一个源（域/端口/协议），URL 路径可以不同。\n\n在所有同源的窗口之间，`localStorage` 数据可以共享。因此，如果我们在一个窗口中设置了数据，则在另一个窗口中也可以看到数据变化。\n\n## 类对象形式访问\n\n我们还可以像使用一个普通对象那样，读取/设置键，像这样：\n\n```js run\n// 设置 key\nlocalStorage.test = 2;\n\n// 获取 key\nalert( localStorage.test ); // 2\n\n// 删除 key\ndelete localStorage.test;\n```\n\n这是历史原因造成的，并且大多数情况下都可行，但通常不建议这样做，因为：\n\n1. 如果键是由用户生成的，那么它可以是任何内容，例如 `length` 或 `toString`，也可以是 `localStorage` 的另一种内建方法。在这种情况下，`getItem/setItem` 可以正常工作，而类对象访问的方式则会失败：\n\n    ```js run\n    let key = 'length';\n    localStorage[key] = 5; // Error，无法对 length 进行赋值\n    ```\n\n2. 有一个 `storage` 事件，在我们更改数据时会触发。但以类对象方式访问时，不会触发该事件。我们将在本章的后面看到。\n\n## 遍历键\n\n正如我们所看到的，这些方法提供了“按照键获取/设置/删除”的功能。但我们如何获取所有保存的值或键呢？\n\n不幸的是，存储对象是不可迭代的。\n\n一种方法是像遍历数组那样遍历它们：\n\n```js run\nfor(let i = 0; i < localStorage.length; i++) {\n  let key = localStorage.key(i);\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\n另一个方式是使用 `for key in localStorage` 循环，就像处理常规对象一样。\n\n它会遍历所有的键，但也会输出一些我们不需要的内建字段。\n\n```js run\n// 不好的尝试\nfor(let key in localStorage) {\n  alert(key); // 显示 getItem，setItem 和其他内建的东西\n}\n```\n\n……因此，我们需要使用 `hasOwnProperty` 检查来过滤掉原型中的字段：\n\n```js run\nfor(let key in localStorage) {\n  if (!localStorage.hasOwnProperty(key)) {\n    continue; // 跳过像 \"setItem\"，\"getItem\" 等这样的键\n  }\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\n……或者，使用 `Object.keys` 获取只属于“自己”的键，然后如果需要，可以遍历它们：\n\n```js run\nlet keys = Object.keys(localStorage);\nfor(let key of keys) {\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n```\n\n后者有效，因为 `Object.keys` 只返回属于对象的键，会忽略原型上的。\n\n## 仅字符串\n\n请注意，键和值都必须是字符串。\n\n如果是任何其他类型，例数字或对象，它会被自动转换为字符串。\n\n```js run\nlocalStorage.user = {name: \"John\"};\nalert(localStorage.user); // [object Object]\n```\n\n我们可以使用 `JSON` 来存储对象：\n\n```js run\nlocalStorage.user = JSON.stringify({name: \"John\"});\n\n// sometime later\nlet user = JSON.parse( localStorage.user );\nalert( user.name ); // John\n```\n\n也可以对整个存储对象进行字符串化处理，例如出于调试目的：\n\n```js run\n// 为 JSON.stringify 增加了格式设置选项，以使对象看起来更美观\nalert( JSON.stringify(localStorage, null, 2) );\n```\n\n## sessionStorage\n\n`sessionStorage` 对象的使用频率比 `localStorage` 对象低得多。\n\n属性和方法是相同的，但是它有更多的限制：\n\n- `sessionStorage` 的数据只存在于当前浏览器标签页。\n  - 具有相同页面的另一个标签页中将会有不同的存储。\n  - 但是，它在同一标签页下的 iframe 之间是共享的（假如它们来自相同的源）。\n- 数据在页面刷新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留。\n\n让我们看看它的运行效果。\n\n运行此代码……\n\n```js run\nsessionStorage.setItem('test', 1);\n```\n\n……然后刷新页面。这时你仍然可以获取到数据：\n\n```js run\nalert( sessionStorage.getItem('test') ); // after refresh: 1\n```\n\n……但是，如果你在另一个新的标签页中打开此页面，然后在新页面中再次运行上面这行代码，则会得到 `null`，表示“未找到数据”。\n\n这是因为 `sessionStorage` 不仅绑定到源，还绑定在同一浏览器标签页。因此，`sessionStorage` 很少被使用。\n\n## Storage 事件\n\n当 `localStorage` 或 `sessionStorage` 中的数据更新后，[storage](https://html.spec.whatwg.org/multipage/webstorage.html#the-storageevent-interface) 事件就会触发，它具有以下属性：\n\n- `key` —— 发生更改的数据的 `key`（如果调用的是 `.clear()` 方法，则为 `null`）。\n- `oldValue` —— 旧值（如果是新增数据，则为 `null`）。\n- `newValue` —— 新值（如果是删除数据，则为 `null`）。\n- `url` —— 发生数据更新的文档的 url。\n- `storageArea` —— 发生数据更新的 `localStorage` 或 `sessionStorage` 对象。\n\n重要的是：该事件会在所有可访问到存储对象的 `window` 对象上触发，导致当前数据改变的 `window` 对象除外。\n\n我们来详细解释一下。\n\n想象一下，你有两个窗口，它们具有相同的页面。所以 `localStorage` 在它们之间是共享的。\n\n```online\n你可以想在浏览器的两个窗口中打开此页面来测试下面的代码。\n```\n\n如果两个窗口都在监听 `window.onstorage` 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应。\n\n```js run\n// 在其他文档对同一存储进行更新时触发\nwindow.onstorage = event => { // 也可以使用 window.addEventListener('storage', event => {\n  if (event.key != 'now') return;\n  alert(event.key + ':' + event.newValue + \" at \" + event.url);\n};\n\nlocalStorage.setItem('now', Date.now());\n```\n\n请注意，该事件还包含：`event.url` —— 发生数据更新的文档的 url。\n\n并且，`event.storageArea` 包含存储对象 —— `sessionStorage` 和 `localStorage` 具有相同的事件，所以 `event.storageArea` 引用了被修改的对象。我们可能会想设置一些东西，以“响应”更改。\n\n**这允许同源的不同窗口交换消息。**\n\n现代浏览器还支持 [Broadcast channel API](mdn:/api/Broadcast_Channel_API)，这是用于同源窗口之间通信的特殊 API，它的功能更全，但被支持的情况不好。有一些库基于 `localStorage` 来 polyfill 该 API，使其可以用在任何地方。\n\n## 总结\n\nWeb 存储对象 `localStorage` 和 `sessionStorage` 允许我们在浏览器中保存键/值对。\n\n- `key` 和 `value` 都必须为字符串。\n- 存储大小限制为 5MB+，具体取决于浏览器。\n- 它们不会过期。\n- 数据绑定到源（域/端口/协议）。\n\n| `localStorage` | `sessionStorage` |\n|----------------|------------------|\n| 在同源的所有标签页和窗口之间共享数据 | 在当前浏览器标签页中可见，包括同源的 iframe |\n| 浏览器重启后数据仍然保留 | 页面刷新后数据仍然保留（但标签页关闭后数据则不再保留） |\n\nAPI：\n\n- `setItem(key, value)` —— 存储键/值对。\n- `getItem(key)` —— 按照键获取值。\n- `removeItem(key)` —— 删除键及其对应的值。\n- `clear()` —— 删除所有数据。\n- `key(index)` —— 获取该索引下的键名。\n- `length` —— 存储的内容的长度。\n- 使用 `Object.keys` 来获取所有的键。\n- 我们将键作为对象属性来访问，在这种情况下，不会触发 `storage` 事件。\n\nStorage 事件：\n\n- 在调用 `setItem`，`removeItem`，`clear` 方法后触发。\n- 包含有关操作的所有数据（`key/oldValue/newValue`），文档 `url` 和存储对象 `storageArea`。\n- 在所有可访问到存储对象的 `window` 对象上触发，导致当前数据改变的 `window` 对象除外（对于 `sessionStorage` 是在当前标签页下，对于 `localStorage` 是在全局，即所有同源的窗口）。",
        "libs": [],
        "children": [
          "form-autosave"
        ],
        "parent": "data-storage",
        "updatedAt": 1657705346
      }
    },
    "form-autosave": {
      "type": "Task",
      "value": {
        "title": "自动保存表单字段",
        "slug": "form-autosave",
        "githubPath": "/6-data-storage/02-localstorage/1-form-autosave",
        "weight": 1,
        "libs": [],
        "content": "\n\n创建一个 `textarea` 字段，每当其值发生变化时，可以将其“自动保存”。\n\n因此，如果用户不小心关闭了页面，然后重新打开，他会发现之前未完成的输入仍然保留在那里。\n\n像这样：\n\n[iframe src=\"solution\" height=120]",
        "solution": "",
        "parent": "localstorage",
        "version": 1
      }
    },
    "indexeddb": {
      "type": "Article",
      "value": {
        "title": "IndexedDB",
        "slug": "indexeddb",
        "githubPath": "/6-data-storage/03-indexeddb",
        "isFolder": false,
        "weight": 3,
        "content": "\n\nIndexedDB 是一个浏览器内建的数据库，它比 `localStorage` 强大得多。\n\n- 通过支持多种类型的键，来存储几乎可以是任何类型的值。\n- 支撑事务的可靠性。\n- 支持键值范围查询、索引。\n- 和 `localStorage` 相比，它可以存储更大的数据量。\n\n对于传统的 客户端-服务器 应用，这些功能通常是没有必要的。IndexedDB 适用于离线应用，可与 ServiceWorkers 和其他技术相结合使用。\n\n根据规范 <https://www.w3.org/TR/IndexedDB> 中的描述，IndexedDB 的本机接口是基于事件的。\n\n我们还可以在基于 promise 的包装器（wrapper），如 <https://github.com/jakearchibald/idb> 的帮助下使用 `async/await`。这要方便的多，但是包装器并不完美，它并不能替代所有情况下的事件。因此，我们先练习事件（events），在理解了 IndexedDB 之后，我们将使用包装器。\n\n```smart header=\"数据在哪儿？\"\n从技术上讲，数据通常与浏览器设置、扩展程序等一起存储在访问者的主目录中。\n\n不同的浏览器和操作系统级别的用户都有各自独立的存储。\n```\n\n## 打开数据库\n\n要想使用 IndexedDB，首先需要 `open`（连接）一个数据库。\n\n语法：\n\n```js\nlet openRequest = indexedDB.open(name, version);\n```\n\n- `name` —— 字符串，即数据库名称。\n- `version` —— 一个正整数版本，默认为 `1`（下面解释）。\n\n数据库可以有许多不同的名称，但是必须存在于当前的源（域/协议/端口）中。不同的网站不能相互访问对方的数据库。\n\n调用之后会返回 `openRequest` 对象，我们需要监听该对象上的事件：\n- `success`：数据库准备就绪，`openRequest.result` 中有了一个数据库对象“Database Object”，我们应该将其用于进一步的调用。\n- `error`：打开失败。\n- `upgradeneeded`：数据库已准备就绪，但其版本已过时（见下文）。\n\n**IndexedDB 具有内建的“模式（scheme）版本控制”机制，这在服务器端数据库中是不存在的。**\n\n与服务器端数据库不同，IndexedDB 存在于客户端，数据存储在浏览器中。因此，开发人员无法随时都能访问它。因此，当我们发布了新版本的应用程序，用户访问我们的网页，我们可能需要更新该数据库。\n\n如果本地数据库版本低于 `open` 中指定的版本，会触发一个特殊事件 `upgradeneeded`。我们可以根据需要比较版本并升级数据结构。\n\n当数据库还不存在时（从技术上讲，其版本为 `0`），也会触发 `upgradeneeded` 事件。因此，我们可以执行初始化。\n\n假设我们发布了应用程序的第一个版本。\n\n接下来我们就可以打开版本 `1` 中的 IndexedDB 数据库，并在一个 `upgradeneeded` 的处理程序中执行初始化，如下所示：\n\n```js\nlet openRequest = indexedDB.open(\"store\", *!*1*/!*);\n\nopenRequest.onupgradeneeded = function() {\n  // 如果客户端没有数据库则触发\n  // ...执行初始化...\n};\n\nopenRequest.onerror = function() {\n  console.error(\"Error\", openRequest.error);\n};\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n  // 继续使用 db 对象处理数据库\n};\n```\n\n之后不久，我们发布了第二个版本。\n\n我们可以打开版本 `2` 中的 IndexedDB 数据库，并像这样进行升级：\n\n```js\nlet openRequest = indexedDB.open(\"store\", *!*2*/!*);\n\nopenRequest.onupgradeneeded = function(event) {\n  // 现有的数据库版本小于 2（或不存在）\n  let db = openRequest.result;\n  switch(event.oldVersion) { // 现有的 db 版本\n    case 0:\n      // 版本 0 表示客户端没有数据库\n      // 执行初始化\n    case 1:\n      // 客户端版本为 1\n      // 更新\n  }\n};\n```\n\n请注意：虽然我们目前的版本是 `2`，`onupgradeneeded` 处理程序有针对版本 `0` 的代码分支（适用于初次访问，浏览器中没有数据库的用户）和针对版本 `1` 的代码分支（用于升级）。\n\n接下来，当且仅当 `onupgradeneeded` 处理程序没有错误地执行完成，`openRequest.onsuccess` 被触发，数据库才算是成功打开了。\n\n删除数据库：\n\n```js\nlet deleteRequest = indexedDB.deleteDatabase(name)\n// deleteRequest.onsuccess/onerror 追踪（tracks）结果\n```\n\n```warn header=\"我们无法使用较旧的 open 调用版本打开数据库\"\n如果当前用户的数据库版本比 `open` 调用的版本更高（比如当前的数据库版本为 `3`，我们却尝试运行 `open(...2)`，就会产生错误并触发 `openRequest.onerror`）。\n\n这很罕见，但这样的事情可能会在用户加载了一个过时的 JavaScript 代码时发生（例如用户从一个代理缓存中加载 JS）。在这种情况下，代码是过时的，但数据库却是最新的。\n\n为了避免这样的错误产生，我们应当检查 `db.version` 并建议用户重新加载页面。使用正确的 HTTP 缓存头（header）来避免之前缓存的旧代码被加载，这样你就永远不会遇到此类问题。\n```\n\n### 并行更新问题\n\n提到版本控制，有一个相关的小问题。\n\n举个例子：\n1. 一个用户在一个浏览器标签页中打开了数据库版本为 `1` 的我们的网站。\n2. 接下来我们发布了一个更新，使得代码更新了。\n3. 接下来同一个用户在另一个浏览器标签中打开了这个网站。\n\n这时，有一个标签页和版本为 `1` 的数据库建立了一个连接，而另一个标签页试图在其 `upgradeneeded` 处理程序中将数据库版本升级到 `2`。\n\n问题是，这两个网页是同一个站点，同一个源，共享同一个数据库。而数据库不能同时为版本 `1` 和版本 `2`。要执行版本 `2` 的更新，必须关闭对版本 `1` 的所有连接，包括第一个标签页中的那个。\n\n为了解决这一问题，`versionchange` 事件会在“过时的”数据库对象上触发。我们需要监听这个事件，关闭对旧版本数据库的连接（还应该建议访问者重新加载页面，以加载最新的代码）。\n\n如果我们不监听 `versionchange` 事件，也不去关闭旧连接，那么新的连接就不会建立。`openRequest` 对象会产生 `blocked` 事件，而不是 `success` 事件。因此第二个标签页无法正常工作。\n\n下面是能够正确处理并行升级情况的代码。它安装了 `onversionchange` 处理程序，如果当前数据库连接过时（数据库版本在其他位置被更新）并关闭连接，则会触发该处理程序。\n\n```js\nlet openRequest = indexedDB.open(\"store\", 2);\n\nopenRequest.onupgradeneeded = ...;\nopenRequest.onerror = ...;\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n\n  *!*\n  db.onversionchange = function() {\n    db.close();\n    alert(\"Database is outdated, please reload the page.\")\n  };\n  */!*\n\n  // ……数据库已经准备好，请使用它……\n};\n\n*!*\nopenRequest.onblocked = function() {\n  // 如果我们正确处理了 onversionchange 事件，这个事件就不应该触发\n\n  // 这意味着还有另一个指向同一数据库的连接\n  // 并且在 db.onversionchange 被触发后，该连接没有被关闭\n};\n*/!*\n```\n\n……换句话说，在这我们做两件事：\n\n1. 如果当前数据库版本过时，`db.onversionchange` 监听器会通知我们并行尝试更新。\n2. `openRequest.onblocked` 监听器通知我们相反的情况：在其他地方有一个与过时的版本的连接未关闭，因此无法建立新的连接。\n\n我们可以在 `db.onversionchange` 中更优雅地进行处理，提示访问者在连接关闭之前保存数据等。\n\n或者，另一种方式是不在 `db.onversionchange` 中关闭数据库，而是使用 `onblocked` 处理程序（在浏览器新 tab 页中）来提醒用户，告诉他新版本无法加载，直到他们关闭浏览器其他 tab 页。\n\n这种更新冲突很少发生，但我们至少应该有一些对其进行处理的程序，至少在 `onblocked` 处理程序中进行处理，以防程序默默卡死而影响用户体验。\n\n## 对象库（object store）\n\n要在 `IndexedDB` 中存储某些内容，我们需要一个 **对象库**。\n\n对象库是 IndexedDB 的核心概念，在其他数据库中对应的对象称为“表”或“集合”。它是储存数据的地方。一个数据库可能有多个存储区：一个用于存储用户数据，另一个用于商品，等等。\n\n尽管被命名为“对象库”，但也可以存储原始类型。\n\n**几乎可以存储任何值，包括复杂的对象。**\n\nIndexedDB 使用 [标准序列化算法](https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage) 来克隆和存储对象。类似于 `JSON.stringify`，不过功能更加强大，能够存储更多的数据类型。\n\n有一种对象不能被存储：循环引用的对象。此类对象不可序列化，也不能进行 `JSON.stringify`。\n\n**库中的每个值都必须有唯一的键 `key`。**\n\n键的类型必须为数字、日期、字符串、二进制或数组。它是唯一的标识符，所以我们可以通过键来搜索/删除/更新值。\n\n![](indexeddb-structure.svg)\n\n正如我们很快就会看到的，类似于 `localStorage`，我们向存储区添加值时，可以提供一个键。但当我们存储对象时，IndexedDB 允许将一个对象属性设置为键，这就更加方便了。或者，我们可以自动生成键。\n\n但我们需要先创建一个对象库。\n\n创建对象库的语法：\n\n```js\ndb.createObjectStore(name[, keyOptions]);\n```\n\n请注意，操作是同步的，不需要 `await`。\n\n- `name` 是存储区名称，例如 `\"books\"` 表示书。\n- `keyOptions` 是具有以下两个属性之一的可选对象：\n  - `keyPath` —— 对象属性的路径，IndexedDB 将以此路径作为键，例如 `id`。\n  - `autoIncrement` —— 如果为 `true`，则自动生成新存储的对象的键，键是一个不断递增的数字。\n\n如果我们不提供 `keyOptions`，那么以后需要在存储对象时，显式地提供一个键。\n\n例如，此对象库使用 `id` 属性作为键：\n\n```js\ndb.createObjectStore('books', {keyPath: 'id'});\n```\n\n**在 `upgradeneeded` 处理程序中，只有在创建数据库版本时，对象库被才能被 创建/修改。**\n\n这是技术上的限制。在 upgradeneedHandler 之外，可以添加/删除/更新数据，但是只能在版本更新期间创建/删除/更改对象库。\n\n要进行数据库版本升级，主要有两种方法：\n\n1. 我们实现每个版本的升级功能：从 1 到 2，从 2 到 3，从 3 到 4，等等。在 `upgradeneeded` 中，可以进行版本比较（例如，老版本是 2，需要升级到 4），并针对每个中间版本（2 到 3，然后 3 到 4）逐步运行每个版本的升级。\n2. 或者我们可以检查数据库：以 `db.objectStoreNames` 的形式获取现有对象库的列表。该对象是一个 [DOMStringList](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist) 提供 `contains(name)` 方法来检查 name 是否存在，再根据存在和不存在的内容进行更新。\n\n对于小型数据库，第二种方法可能更简单。\n\n下面是第二种方法的演示:\n\n```js\nlet openRequest = indexedDB.open(\"db\", 2);\n\n// 创建/升级 数据库而无需版本检查\nopenRequest.onupgradeneeded = function() {\n  let db = openRequest.result;\n  if (!db.objectStoreNames.contains('books')) { // 如果没有 “books” 数据\n    db.createObjectStore('books', {keyPath: 'id'}); // 创造它\n  }\n};\n```\n\n删除对象库：\n\n```js\ndb.deleteObjectStore('books')\n```\n\n## 事务（transaction）\n\n术语“事务（transaction）”是通用的，许多数据库中都有用到。\n\n事务是一组操作，要么全部成功，要么全部失败。\n\n例如，当一个人买东西时，我们需要：\n\n1. 从他们的账户中扣除这笔钱。\n2. 将该项目添加到他们的清单中。\n\n如果完成了第一个操作，但是出了问题，比如停电。这时无法完成第二个操作，这非常糟糕。两件时应该要么都成功（购买完成，好！）或同时失败（这个人保留了钱，可以重新尝试）。\n\n事务可以保证同时完成。\n\n**所有数据操作都必须在 IndexedDB 中的事务内进行。**\n\n启动事务：\n\n```js\ndb.transaction(store[, type]);\n```\n\n- `store` 是事务要访问的库名称，例如 `\"books\"`。如果我们要访问多个库，则是库名称的数组。\n- `type` – 事务类型，以下类型之一：\n  - `readonly` —— 只读，默认值。\n  - `readwrite` —— 只能读取和写入数据，而不能 创建/删除/更改 对象库。\n\n还有 `versionchange` 事务类型：这种事务可以做任何事情，但不能被手动创建。IndexedDB 在打开数据库时，会自动为 `upgradeneeded` 处理程序创建 `versionchange` 事务。这就是它为什么可以更新数据库结构、创建/删除 对象库的原因。\n\n```smart header=\"为什么会有不同类型的事务？\"\n性能是事务需要标记为 `readonly` 和 `readwrite` 的原因。\n\n许多 `readonly` 事务能够同时访问同一存储区，但 `readwrite` 事务不能。因为 `readwrite` 事务会“锁定”存储区进行写操作。下一个事务必须等待前一个事务完成，才能访问相同的存储区。\n```\n\n创建事务后，我们可以将项目添加到库，就像这样：\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\"); // (1)\n\n// 获取对象库进行操作\n*!*\nlet books = transaction.objectStore(\"books\"); // (2)\n*/!*\n\nlet book = {\n  id: 'js',\n  price: 10,\n  created: new Date()\n};\n\n*!*\nlet request = books.add(book); // (3)\n*/!*\n\nrequest.onsuccess = function() { // (4)\n  console.log(\"Book added to the store\", request.result);\n};\n\nrequest.onerror = function() {\n  console.log(\"Error\", request.error);\n};\n```\n\n基本有四个步骤：\n\n1. 创建一个事务，在（1）表明要访问的所有存储。\n2. 使用 `transaction.objectStore(name)`，在（2）中获取存储对象。\n3. 在（3）执行对对象库 `books.add(book)` 的请求。\n4. ……处理请求 成功/错误（4），还可以根据需要发出其他请求。\n\n对象库支持两种存储值的方法：\n\n- **put(value, [key])**\n    将 `value` 添加到存储区。仅当对象库没有 `keyPath` 或 `autoIncrement` 时，才提供 `key`。如果已经存在具有相同键的值，则将替换该值。\n\n- **add(value, [key])**\n    与 `put` 相同，但是如果已经有一个值具有相同的键，则请求失败，并生成一个名为 `\"ConstraInterror\"` 的错误。\n\n与打开数据库类似，我们可以发送一个请求：`books.add(book)`，然后等待 `success/error` 事件。\n\n- `add` 的 `request.result` 是新对象的键。\n- 错误在 `request.error`（如果有的话）中。\n\n## 事务的自动提交\n\n在上面的示例中，我们启动了事务并发出了 `add` 请求。但正如前面提到的，一个事务可能有多个相关的请求，这些请求必须全部成功或全部失败。那么我们如何将事务标记为已完成，并不再请求呢？\n\n简短的回答是：没有。\n\n在下一个版本 3.0 规范中，可能会有一种手动方式来完成事务，但目前在 2.0 中还没有。\n\n**当所有事务的请求完成，并且 [微任务队列](info:microtask-queue) 为空时，它将自动提交。**\n\n通常，我们可以假设事务在其所有请求完成时提交，并且当前代码完成。\n\n因此，在上面的示例中，不需要任何特殊调用即可完成事务。\n\n事务自动提交原则有一个重要的副作用。不能在事务中间插入 `fetch`, `setTimeout` 等异步操作。IndexedDB 不会让事务等待这些操作完成。\n\n在下面的代码中，`request2` 中的行 `(*)` 失败，因为事务已经提交，不能在其中发出任何请求:\n\n```js\nlet request1 = books.add(book);\n\nrequest1.onsuccess = function() {\n  fetch('/').then(response => {\n*!*\n    let request2 = books.add(anotherBook); // (*)\n*/!*\n    request2.onerror = function() {\n      console.log(request2.error.name); // TransactionInactiveError\n    };\n  });\n};\n```\n\n这是因为 `fetch` 是一个异步操作，一个宏任务。事务在浏览器开始执行宏任务之前关闭。\n\nIndexedDB 规范的作者认为事务应该是短期的。主要是性能原因。\n\n值得注意的是，`readwrite` 事务将存储“锁定”以进行写入。因此，如果应用程序的一部分启动了 `books` 对象库上的 `readwrite` 操作，那么希望执行相同操作的另一部分必须等待新事务“挂起”，直到第一个事务完成。如果事务处理需要很长时间，将会导致奇怪的延迟。\n\n那么，该怎么办？\n\n在上面的示例中，我们可以在新请求 `(*)` 之前创建一个新的 `db.transaction`。\n\n如果需要在一个事务中把所有操作保持一致，更好的做法是将 IndexedDB 事务和“其他”异步内容分开。\n\n首先，执行 `fetch`，并根据需要准备数据。然后创建事务并执行所有数据库请求，然后就正常了。\n\n为了检测到成功完成的时刻，我们可以监听 `transaction.oncomplete` 事件:\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\n// ……执行操作……\n\ntransaction.oncomplete = function() {\n  console.log(\"Transaction is complete\"); // 事务执行完成\n};\n```\n\n只有 `complete` 才能保证将事务作为一个整体保存。个别请求可能会成功，但最终的写入操作可能会出错（例如 I/O 错误或其他错误）。\n\n要手动中止事务，请调用：\n\n```js\ntransaction.abort();\n```\n\n取消请求里所做的所有修改，并触发 `transaction.onabort` 事件。\n\n\n## 错误处理\n\n写入请求可能会失败。\n\n这是意料之中的事，不仅是我们可能会犯的粗心失误，还有与事务本身相关的其他原因。例如超过了存储配额。因此，必须做好请求失败的处理。\n\n**失败的请求将自动中止事务，并取消所有的更改。**\n\n在一些情况下，我们会想自己去处理失败事务（例如尝试另一个请求）并让它继续执行，而不是取消现有的更改。可以调用 `request.onerror` 处理程序，在其中调用 `event.preventDefault()` 防止事务中止。\n\n在下面的示例中，添加了一本新书，键 (`id`) 与现有的书相同。`store.add` 方法生成一个 `\"ConstraInterror\"`。可以在不取消事务的情况下进行处理：\n\n```js\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\nlet book = { id: 'js', price: 10 };\n\nlet request = transaction.objectStore(\"books\").add(book);\n\nrequest.onerror = function(event) {\n  // 有相同 id 的对象存在时，发生 ConstraintError\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Book with such id already exists\"); // 处理错误\n    event.preventDefault(); // 不要中止事务\n    // 这个 book 用另一个键？\n  } else {\n    // 意外错误，无法处理\n    // 事务将中止\n  }\n};\n\ntransaction.onabort = function() {\n  console.log(\"Error\", transaction.error);\n};\n```\n\n### 事件委托\n\n每个请求都需要调用 onerror/onsuccess ？并不，可以使用事件委托来代替。\n\n**IndexedDB 事件冒泡：请求 -> 事务 -> 数据库。**\n\n所有事件都是 DOM 事件，有捕获和冒泡，但通常只使用冒泡阶段。\n\n因此，出于报告或其他原因，我们可以使用 `db.onerror` 处理程序捕获所有错误：\n\n```js\ndb.onerror = function(event) {\n  let request = event.target; // 导致错误的请求\n\n  console.log(\"Error\", request.error);\n};\n```\n\n……但是错误被完全处理了呢？这种情况不应该被报告。\n\n我们可以通过在 `request.onerror` 中使用 `event.stopPropagation()` 来停止冒泡，从而停止 `db.onerror` 事件。\n\n```js\nrequest.onerror = function(event) {\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Book with such id already exists\"); // 处理错误\n    event.preventDefault(); // 不要中止事务\n    event.stopPropagation(); // 不要让错误冒泡, 停止它的传播\n  } else {\n    // 什么都不做\n    // 事务将中止\n    // 我们可以解决 transaction.onabort 中的错误\n  }\n};\n```\n\n## 搜索\n\n对象库有两种主要的搜索类型：\n\n1. 通过键值或键值范围。在我们的 \"books\" 存储中，将是 `book.id` 的值或值的范围。\n2. 通过另一个对象字段，例如 `book.price`。这需要一个额外的数据结构，名为“索引（index）”。\n\n### 通过 key 搜索\n\n首先，让我们来处理第一种类型的搜索：按键。\n\n支持精确的键值和被称为“值范围”的搜索方法 —— [IDBKeyRange](https://www.w3.org/TR/IndexedDB/#keyrange) 对象，指定一个可接受的“键值范围”。\n\n`IDBKeyRange` 对象是通过下列调用创建的：\n\n- `IDBKeyRange.lowerBound(lower, [open])` 表示：`≥lower`（如果 `open` 是 true，表示 `>lower`）\n- `IDBKeyRange.upperBound(upper, [open])` 表示：`≤upper`（如果 `open` 是 true，表示  `<upper`）\n- `IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])` 表示: 在 `lower` 和 `upper` 之间。如果 open 为 true，则相应的键不包括在范围中。\n- `IDBKeyRange.only(key)` —— 仅包含一个键的范围 `key`，很少使用。\n\n我们很快就会看到使用它们的实际示例。\n\n要进行实际的搜索，有以下方法。它们接受一个可以是精确键值或键值范围的 `query` 参数：\n\n- `store.get(query)` —— 按键或范围搜索第一个值。\n- `store.getAll([query], [count])` —— 搜索所有值。如果 `count` 给定，则按 `count` 进行限制。\n- `store.getKey(query)` —— 搜索满足查询的第一个键，通常是一个范围。\n- `store.getAllKeys([query], [count])` —— 搜索满足查询的所有键，通常是一个范围。如果 `count` 给定，则最多为 count。\n- `store.count([query])` —— 获取满足查询的键的总数，通常是一个范围。\n\n例如，我们存储区里有很多书。因为 `id` 字段是键，因此所有方法都可以按 `id` 进行搜索。\n\n请求示例：\n\n```js\n// 获取一本书\nbooks.get('js')\n\n// 获取 'css' <= id <= 'html' 的书\nbooks.getAll(IDBKeyRange.bound('css', 'html'))\n\n// 获取 id < 'html' 的书\nbooks.getAll(IDBKeyRange.upperBound('html', true))\n\n// 获取所有书\nbooks.getAll()\n\n// 获取所有 id > 'js' 的键\nbooks.getAllKeys(IDBKeyRange.lowerBound('js', true))\n```\n\n```smart header=\"对象中对值的存储始终是有序的\"\n对象内部存储的值是按键对值进行排序的。\n\n因此，请求的返回值，是按照键的顺序排列的。\n```\n\n### 通过使用索引的字段搜索\n\n要根据其他对象字段进行搜索，我们需要创建一个名为“索引（index）”的附加数据结构。\n\n索引是存储的\"附加项\"，用于跟踪给定的对象字段。对于该字段的每个值，它存储有该值的对象的键列表。下面会有更详细的图片。\n\n语法：\n\n```js\nobjectStore.createIndex(name, keyPath, [options]);\n```\n\n- **`name`** —— 索引名称。\n- **`keyPath`** —— 索引应该跟踪的对象字段的路径（我们将根据该字段进行搜索）。\n- **`option`** —— 具有以下属性的可选对象：\n  - **`unique`** —— 如果为true，则存储中只有一个对象在 `keyPath` 上具有给定值。如果我们尝试添加重复项，索引将生成错误。\n  - **`multiEntry`** —— 只有 `keypath` 上的值是数组时才使用。这时，默认情况下，索引将默认把整个数组视为键。但是如果 `multiEntry` 为 true，那么索引将为该数组中的每个值保留一个存储对象的列表。所以数组成员成为了索引键。\n\n在我们的示例中，是按照 `id` 键存储图书的。\n\n假设我们想通过 `price` 进行搜索。\n\n首先，我们需要创建一个索引。它像对象库一样，必须在 `upgradeneeded` 中创建完成：\n\n```js\nopenRequest.onupgradeneeded = function() {\n  // 在 versionchange 事务中，我们必须在这里创建索引\n  let books = db.createObjectStore('books', {keyPath: 'id'});\n*!*\n  let index = books.createIndex('price_idx', 'price');\n*/!*\n};\n```\n\n- 该索引将跟踪 `price` 字段。\n- 价格不是唯一的，可能有多本书价格相同，所以我们不设置唯一 `unique` 选项。\n- 价格不是一个数组，因此不适用多入口 `multiEntry` 标志。\n\n假设我们的库存里有4本书。下面的图片显示了该索引 `index` 的确切内容：\n\n![](indexeddb-index.svg)\n\n如上所述，每个 price 值的索引（第二个参数）保存具有该价格的键的列表。\n\n索引自动保持最新，所以我们不必关心它。\n\n现在，当我们想要搜索给定的价格时，只需将相同的搜索方法应用于索引：\n\n```js\nlet transaction = db.transaction(\"books\"); // 只读\nlet books = transaction.objectStore(\"books\");\nlet priceIndex = books.index(\"price_idx\");\n\n*!*\nlet request = priceIndex.getAll(10);\n*/!*\n\nrequest.onsuccess = function() {\n  if (request.result !== undefined) {\n    console.log(\"Books\", request.result); // 价格为 10 的书的数组\n  } else {\n    console.log(\"No such books\");\n  }\n};\n```\n\n我们还可以使用 `IDBKeyRange` 创建范围，并查找 便宜/贵 的书：\n\n```js\n// 查找价格 <=5 的书籍\nlet request = priceIndex.getAll(IDBKeyRange.upperBound(5));\n```\n\n在我们的例子中，索引是按照被跟踪对象字段价格 `price` 进行内部排序的。所以当我们进行搜索时，搜索结果也会按照价格排序。\n\n## 从存储中删除\n\n`delete` 方法查找要由查询删除的值，调用格式类似于 `getAll`\n\n- **`delete(query)`** —— 通过查询删除匹配的值。\n\n例如：\n\n```js\n// 删除 id='js' 的书\nbooks.delete('js');\n```\n\n如果要基于价格或其他对象字段删除书。首先需要在索引中找到键，然后调用 `delete`：\n\n```js\n// 找到价格 = 5 的钥匙\nlet request = priceIndex.getKey(5);\n\nrequest.onsuccess = function() {\n  let id = request.result;\n  let deleteRequest = books.delete(id);\n};\n```\n\n删除所有内容：\n\n```js\nbooks.clear(); // 清除存储。\n```\n\n## 光标（Cursors）\n\n像 `getAll/getAllKeys` 这样的方法，会返回一个 键/值 数组。\n\n但是一个对象库可能很大，比可用的内存还大。这时，`getAll` 就无法将所有记录作为一个数组获取。\n\n该怎么办呢？\n\n光标提供了解决这一问题的方法。\n\n**光标是一种特殊的对象，它在给定查询的情况下遍历对象库，一次返回一个键/值，从而节省内存。**\n\n由于对象库是按键在内部排序的，因此光标按键顺序（默认为升序）遍历存储。\n\n语法：\n\n```js\n// 类似于 getAll，但带有光标：\nlet request = store.openCursor(query, [direction]);\n\n// 获取键，而不是值（例如 getAllKeys）：store.openKeyCursor \n```\n\n- **`query`** 是一个键值或键值范围，与 `getAll` 相同。\n- **`direction`** 是一个可选参数，使用顺序是：\n  - `\"next\"` —— 默认值，光标从有最小索引的记录向上移动。\n  - `\"prev\"` —— 相反的顺序：从有最大的索引的记录开始下降。\n  - `\"nextunique\"`，`\"prevunique\"` —— 同上，但是跳过键相同的记录 （仅适用于索引上的光标，例如，对于价格为 5 的书，仅返回第一本）。\n\n**光标对象的主要区别在于 `request.onSuccess` 多次触发：每个结果触发一次。**\n\n这有一个如何使用光标的例子：\n\n```js\nlet transaction = db.transaction(\"books\");\nlet books = transaction.objectStore(\"books\");\n\nlet request = books.openCursor();\n\n// 为光标找到的每本书调用\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let key = cursor.key; // 书的键（id字段）\n    let value = cursor.value; // 书本对象\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"No more books\");\n  }\n};\n```\n\n主要的光标方法有：\n\n- `advance(count)` —— 将光标向前移动 `count` 次，跳过值。\n- `continue([key])` —— 将光标移至匹配范围中的下一个值（如果给定键，紧接键之后）。\n\n无论是否有更多的值匹配光标 —— 调用 `onsuccess`。结果中，我们可以获得指向下一条记录的光标，或者 `undefined`。\n\n在上面的示例中，光标是为对象库创建的。\n\n也可以在索引上创建一个光标。索引是允许按对象字段进行搜索的。在索引上的光标与在对象存储上的光标完全相同 —— 它们通过一次返回一个值来节省内存。\n\n对于索引上的游标，`cursor.key` 是索引键（例如：价格），我们应该使用 `cursor.primaryKey` 属性作为对象的键：\n\n```js\nlet request = priceIdx.openCursor(IDBKeyRange.upperBound(5));\n\n// 为每条记录调用\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let primaryKey = cursor.primaryKey; // 下一个对象存储键（id 字段）\n    let value = cursor.value; // 下一个对象存储对象（book 对象）\n    let key = cursor.key; // 下一个索引键（price）\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"No more books\"); // 没有书了\n  }\n};\n```\n\n## Promise 包装器\n\n将 `onsuccess/onerror` 添加到每个请求是一项相当麻烦的任务。我们可以通过使用事件委托（例如，在整个事务上设置处理程序）来简化我们的工作，但是 `async/await` 要方便的多。\n\n在本章，我们会进一步使用一个轻便的承诺包装器 <https://github.com/jakearchibald/idb> 。它使用 [promisified](info:promisify) IndexedDB 方法创建全局 `idb` 对象。 \n\n然后，我们可以不使用 `onsuccess/onerror`，而是这样写：\n\n```js\nlet db = await idb.openDB('store', 1, db => {\n  if (db.oldVersion == 0) {\n    // 执行初始化\n    db.createObjectStore('books', {keyPath: 'id'});\n  }\n});\n\nlet transaction = db.transaction('books', 'readwrite');\nlet books = transaction.objectStore('books');\n\ntry {\n  await books.add(...);\n  await books.add(...);\n\n  await transaction.complete;\n\n  console.log('jsbook saved');\n} catch(err) {\n  console.log('error', err.message);\n}\n```\n\n现在我们有了可爱的“简单异步代码”和「try..catch」捕获的东西。\n\n### 错误处理\n\n如果我们没有捕获到错误，那么程序将一直失败，直到外部最近的 `try..catch` 捕获到为止。\n\n未捕获的错误将成为 `window` 对象上的“unhandled promise rejection”事件。\n\n我们可以这样处理这种错误：\n\n```js\nwindow.addEventListener('unhandledrejection', event => {\n  let request = event.target; // IndexedDB 本机请求对象\n  let error = event.reason; //  未处理的错误对象，与 request.error 相同\n  // ……报告错误……\n});\n```\n\n### “非活跃事务”陷阱\n\n我们都知道，浏览器一旦执行完成当前的代码和 **微任务** 之后，事务就会自动提交。因此，如果我们在事务中间放置一个类似 `fetch` 的宏任务，事务只是会自动提交，而不会等待它执行完成。因此，下一个请求会失败。\n\n对于 promise 包装器和 `async/await`，情况是相同的。\n\n这是在事务中间进行 `fetch` 的示例：\n\n```js\nlet transaction = db.transaction(\"inventory\", \"readwrite\");\nlet inventory = transaction.objectStore(\"inventory\");\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() });\n\nawait fetch(...); // (*)\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() }); // 错误\n```\n\n`fetch` `(*)` 后的下一个 `inventory.add` 失败，出现“非活动事务”错误，因为这时事务已经被提交并且关闭了。\n\n解决方法与使用本机 IndexedDB 时相同：进行新事务，或者将事情分开。\n\n1. 准备数据，先获取所有需要的信息。\n2. 然后保存在数据库中。\n\n### 获取本机对象\n\n在内部，包装器执行本机 IndexedDB 请求，并添加 `onerror/onsuccess` 方法，并返回 rejects/resolves 结果的 promise。\n\n在大多数情况下都可以运行， 示例在这 <https://github.com/jakearchibald/idb>。\n\n极少数情况下，我们需要原始的 `request` 对象。可以将 `promise` 的 `promise.request` 属性，当作原始对象进行访问：\n\n```js\nlet promise = books.add(book); // 获取 promise 对象(不要 await 结果)\n\nlet request = promise.request; // 本地请求对象\nlet transaction = request.transaction; // 本地事务对象\n\n// ……做些本地的 IndexedDB 的处理……\n\nlet result = await promise; // 如果仍然需要\n```\n\n## 总结\n\nIndexedDB 可以被认为是“localStorage on steroids”。这是一个简单的键值对数据库，功能强大到足以支持离线应用，而且用起来比较简单。\n\n最好的指南是官方文档。[目前的版本](https://www.w3.org/TR/IndexedDB-2/) 是2.0，但是 [3.0](https://w3c.github.io/IndexedDB/) 版本中的一些方法（差别不大）也得到部分支持。\n\n基本用法可以用几个短语来描述：\n\n1. 获取一个 promise 包装器，比如 [idb](https://github.com/jakearchibald/idb)。\n2. 打开一个数据库：`idb.openDb(name, version, onupgradeneeded)`\n    - 在 `onupgradeneeded` 处理程序中创建对象存储和索引，或者根据需要执行版本更新。\n3. 对于请求：\n    - 创建事务 `db.transaction('books')`（如果需要的话，设置 readwrite）。\n    - 获取对象存储 `transaction.objectStore('books')`。\n4. 按键搜索，可以直接调用对象库上的方法。\n    - 要按对象字段搜索，需要创建索引。\n5. 如果内存中容纳不下数据，请使用光标。\n\n这里有一个小应用程序示例：\n\n[codetabs src=\"books\" current=\"index.html\"]",
        "libs": [
          "https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"
        ],
        "children": [],
        "parent": "data-storage",
        "updatedAt": 1657705346
      }
    },
    "animation": {
      "type": "Article",
      "value": {
        "title": "动画",
        "slug": "animation",
        "githubPath": "/7-animation",
        "isFolder": true,
        "weight": 7,
        "content": "\n\nCSS 和 JavaScript 动画。",
        "libs": [],
        "children": [
          "bezier-curve",
          "css-animations",
          "js-animation"
        ]
      }
    },
    "bezier-curve": {
      "type": "Article",
      "value": {
        "title": "贝塞尔曲线",
        "slug": "bezier-curve",
        "githubPath": "/7-animation/1-bezier-curve",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n贝塞尔曲线用于计算机图形绘制形状，CSS 动画和许多其他地方。\n\n它们其实非常简单，值得学习一次并且在矢量图形和高级动画的世界里非常受用。\n\n## 控制点\n\n[贝塞尔曲线](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)由控制点定义。\n\n这些点可能有 2、3、4 或更多。\n\n例如，两点曲线：\n\n![](bezier2.svg)\n\n三点曲线：\n\n![](bezier3.svg)\n\n四点曲线：\n\n![](bezier4.svg)\n\n如果仔细观察这些曲线，你会立即注意到：\n\n1. **控制点不总是在曲线上**这是非常正常的，稍后我们将看到曲线是如何构建的。\n2. **曲线的阶次等于控制点的数量减一**。\n对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。\n3. **曲线总是在控制点的[凸包](https://en.wikipedia.org/wiki/Convex_hull)内部：**\n\n    ![](bezier4-e.svg) ![](bezier3-e.svg)\n\n由于最后一个属性，在计算机图形学中，可以优化相交测试。如果凸包不相交，则曲线也不相交。因此，首先检查凸包的交叉点可以非常快地给出“无交叉”结果。检查交叉区域或凸包更容易，因为它们是矩形，三角形等（见上图），比曲线简单的多。\n\n贝塞尔曲线绘制的主要重点 —— 通过移动曲线，曲线**以直观明显的**方式变化。\n\n尝试在下面的示例中使用鼠标移动控制点：\n\n[iframe src=\"demo.svg?nocpath=1&p=0,0,0.5,0,0.5,1,1,1\" height=370]\n\n**可以注意到，曲线沿切线 1 -> 2 和 3 -> 4 延伸。**\n\n经过一些练习后，很明显我们知道怎样通过放置控制点来获得所需要的曲线。通过连接几条曲线，我们几乎可以得到任何东西。\n\n这里有一些例子：\n\n![](bezier-car.svg) ![](bezier-letter.svg) ![](bezier-vase.svg)\n\n## 数学\n\n贝塞尔曲线可以使用数学方程式来描述。\n\n很快我们就能看到 —— 没必要知道它。但是为了完整性 —— 请看这里。\n\n给定控制点 <code>P<sub>i</sub></code> 的坐标：第一个控制点的坐标为 <code>P<sub>1</sub> = (x<sub>1</sub>, y<sub>1</sub>)</code>，第二个控制点的坐标为 <code>P<sub>2</sub> = (x<sub>2</sub>, y<sub>2</sub>)</code>，以此类推，曲线坐标由方程式描述，这个方程式依赖属于区间 `[0,1]` 的参数 `t`。\n\n- 有两个控制点的曲线方程：\n\n    <code>P = (1-t)P<sub>1</sub> + tP<sub>2</sub></code>\n- 有三个控制点的曲线方程：\n\n    <code>P = (1−t)<sup>2</sup>P<sub>1</sub> + 2(1−t)tP<sub>2</sub> + t<sup>2</sup>P<sub>3</sub></code>\n- 有四个控制点的曲线方程：\n\n    <code>P = (1−t)<sup>3</sup>P<sub>1</sub> + 3(1−t)<sup>2</sup>tP<sub>2</sub>  +3(1−t)t<sup>2</sup>P<sub>3</sub> + t<sup>3</sup>P<sub>4</sub></code>\n\n这些是矢量方程。\n\n我们可以逐坐标重写它们，例如 3 点曲线：\n\n- <code>x = (1−t)<sup>2</sup>x<sub>1</sub> + 2(1−t)tx<sub>2</sub> + t<sup>2</sup>x<sub>3</sub></code>\n- <code>y = (1−t)<sup>2</sup>y<sub>1</sub> + 2(1−t)ty<sub>2</sub> + t<sup>2</sup>y<sub>3</sub></code>\n\n我们应该放置 3 个控制点的坐标，而不是 <code>x<sub>1</sub>、y<sub>1</sub>、x<sub>2</sub>、y<sub>2</sub>、x<sub>3</sub> 和 y<sub>3</sub></code>。\n\n例如，如果控制点是 `(0,0)`、`(0.5, 1)` 和 `(1, 0)`，则方程式为：\n\n- <code>x = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 0.5 + t<sup>2</sup> * 1 = (1-t)t + t<sup>2</sup> = t</code>\n- <code>y = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 1 + t<sup>2</sup> * 0 = 2(1-t)t = –t<sup>2</sup> + 2t</code>\n\n现在随着 `t` 从 `0` 到 `1` 变化，每个 `t` 对应的 `(x,y)` 集合可以构成曲线。\n\n这可能太学术化了，对于曲线为什么看起来像这样以及它们如何依赖于控制点的描述并不是很明显。\n\n所以绘制算法可能更容易理解。\n\n## 德卡斯特里奥算法\n\n[德卡斯特里奥算法](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)与曲线的数学定义相同，但直观地显示了曲线是如何被建立的。\n\n让我们看看 3 个控制点的例子。\n\n这里是一个演示，随后会有解释。\n\n控制点可以用鼠标移动，点击 “play” 运行演示。\n\n[iframe src=\"demo.svg?p=0,0,0.5,1,1,0&animate=1\" height=370]\n\n**德卡斯特里奥算法构造三点贝塞尔曲线：**\n\n1. 绘制控制点。在上面的演示中，它们标有：`1`、`2` 和 `3`。\n2. 创建控制点 1 -> 2 -> 3 间的线段. 在上面的演示中它们是<span style=\"color:#825E28\">棕色</span>的。\n3. 参数 `t` 从 `0` to `1` 变化。 在上面的演示中取值 `0.05`：循环遍历 `0, 0.05, 0.1, 0.15, ... 0.95, 1`。\n\n    对于每一个 `t` 的取值：\n\n    - 在每一个<span style=\"color:#825E28\">棕色</span>线段上我们取一个点，这个点距起点的距离按比例 `t` 取值。由于有两条线段，我们能得到两个点。\n\n        例如，当 `t=0` — 所有点都在线段起点处，当 `t=0.25` — 点到起点的距离为线段长度的 25%，当 `t=0.5` — 50%（中间），当 `t=1` — 线段终点。\n\n    - 连接这些点，下面这张图中连好的线被绘制成<span style=\"color:#167490\">蓝色</span>。\n\n\n| 当 `t=0.25`              | 当 `t=0.5`             |\n| ------------------------ | ---------------------- |\n| ![](bezier3-draw1.svg)   | ![](bezier3-draw2.svg) |\n\n4. 现在在<span style=\"color:#167490\">蓝色</span>线段上取一个点，距离比例取相同数值的 `t`。也就是说，当 `t=0.25`（左图）时，我们取到的点位于线段的左 1/4 终点处，当 `t=0.5`（右图）时 — 线段中间。在上图中这一点是<span style=\"color:red\">红色</span>的。\n\n5. 随着 `t` 从 `0` to `1` 变化，每一个 `t` 的值都会添加一个点到曲线上。这些点的集合就形成的贝塞尔曲线。它在上面的图中是红色的，并且是抛物线状的。\n\n这是三控制点的处理过程，但是对于 4 个点同样适用。\n\n4 个控制点的演示（点可以被鼠标移动）：\n\n[iframe src=\"demo.svg?p=0,0,0.5,0,0.5,1,1,1&animate=1\" height=370]\n\n算法：\n\n- 控制点通过线段连接：1 -> 2、2 -> 3 和 3 -> 4。 我们能得到 3 条<span style=\"color:#825E28\">棕色</span>的线段。\n- 对于 `0` to `1` 之间的每一个 `t`：\n    - 我们在这些线段上距起点距离比例为 `t` 的位置取点。把这些点连接起来，然后得到两条<span style=\"color:#0A0\">绿色线段</span>。\n    - 在这些线段上同样按比例 `t` 取点，得到一条<span style=\"color:#167490\">蓝色线段</span>。\n    - 在蓝色线段按比例 `t` 取点。在上面的例子中是<span style=\"color:red\">红色</span>的。\n- 这些点在一起组成了曲线。\n\n该算法是递归的，并且可以适应于任意数量的控制点。\n\n给定 N 个控制点，我们将它们连接起来以获得初始的 N-1 个线段。\n\n然后对从 `0` 到 `1` 的每一个 `t`：\n- 在每条线段上按 `t` 比例距离取一个点并且连接 —— 会得到 N-2 个线段。\n- 在上面得到的每条线段上按 `t` 比例距离取一个点并且连接 —— 会得到 N-3 个线段，以此类推……\n- 直到我们得到一个点。得到的这些点就形成了曲线。\n\n曲线的移动演示:\n\n[iframe src=\"demo.svg?p=0,0,0,0.75,0.25,1,1,1&animate=1\" height=370]\n\n和其它的点：\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1\" height=370]\n\n环形：\n\n[iframe src=\"demo.svg?p=0,0,1,0.5,0,1,0.5,0&animate=1\" height=370]\n\n非平滑贝塞尔曲线：\n\n[iframe src=\"demo.svg?p=0,0,1,1,0,1,1,0&animate=1\" height=370]\n\n由于算法是递归的，我们可以构建任何顺序的贝塞尔曲线：使用 5 个、6 个或更多个控制点。但在实践中它们没那么有用。通常我们取 2-3 个点，对于复杂的线条，将几条曲线拼接在一起。这更容易开发和计算。\n\n```smart header=\"如何通过给定点绘制曲线？\"\n我们使用控制点制作贝塞尔曲线。正如我们所见，它们并不在曲线上。或者更准确地说，第一个和最后一个在曲线上，但其它的不在。\n\n有时我们有另一种任务：绘制一条曲线**通过几个点**，让它们都在一条平滑曲线上。这种任务叫[插值](https://en.wikipedia.org/wiki/Interpolation)，这里我们不覆盖讲解它。\n\n这些曲线有数学方程式，例如[拉格朗日多项式](https://en.wikipedia.org/wiki/Lagrange_polynomial)。\n\n在计算机图形中[样条插值](https://en.wikipedia.org/wiki/Spline_interpolation)通常用于构建连接多个点的平滑曲线。\n```\n\n## 总结\n\n贝塞尔曲线由其控制点定义。\n\n贝塞尔曲线的两种定义方法：\n\n1. 使用数学方程式。\n2. 使用绘图过程：德卡斯特里奥算法\n\n贝塞尔曲线的优点：\n\n- 我们可以通过控制点移动来用鼠标绘制平滑线条。\n- 复杂的形状可以由多条贝塞尔曲线组成。\n\n用途：\n\n- 在计算机图形学，建模，矢量图形编辑器中。字体由贝塞尔曲线描述。\n- 在 Web 开发中 — 用于 Canvas 上的图形和 SVG 格式。顺便说一下，上面的“实时”示例是用 SVG 编写的。它们实际上是一个 SVG 文档，被赋予不同的控制点做参数。你可以在单独的窗口中打开它并查源码：[demo.svg](demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1)。\n- 在 CSS 动画中描述动画的路径和速度。",
        "libs": [],
        "children": [],
        "parent": "animation",
        "updatedAt": 1639583370
      }
    },
    "css-animations": {
      "type": "Article",
      "value": {
        "title": "CSS 动画",
        "slug": "css-animations",
        "githubPath": "/7-animation/2-css-animations",
        "isFolder": false,
        "weight": 2,
        "content": "\n\nCSS 动画可以在不借助 Javascript 的情况下做出一些简单的动画效果。\n\n你也可以通过 Javascript 控制 CSS 动画，使用少量的代码，就能让动画表现更加出色。\n\n## CSS 过渡（transition）[#css-transition]\n\nCSS 过渡的理念非常简单，我们只需要定义某一个属性以及如何动态地表现其变化。当属性变化时，浏览器将会绘制出相应的过渡动画。\n\n也就是说：我们只需要改变某个属性，然后所有流畅的动画都由浏览器生成。\n\n举个例子，以下 CSS 会为 `backgroud-color` 的变化生成一个 3 秒的过渡动画：\n\n```css\n.animated {\n  transition-property: background-color;\n  transition-duration: 3s;\n}\n```\n\n现在，只要一个元素拥有名为 `.animated` 的类，那么任何背景颜色的变化都会被渲染为 3 秒钟的动画。\n\n单击以下按钮以演示动画：\n\n```html run autorun height=60\n<button id=\"color\">Click me</button>\n\n<style>\n  #color {\n    transition-property: background-color;\n    transition-duration: 3s;\n  }\n</style>\n\n<script>\n  color.onclick = function() {\n    this.style.backgroundColor = 'red';\n  };\n</script>\n```\n\nCSS 提供了四个属性来描述一个过渡：\n\n- `transition-property`\n- `transition-duration`\n- `transition-timing-function`\n- `transition-delay`\n\n之后我们会详细介绍它们，目前我们需要知道，我们可以在 `transition` 中以 `property duration timing-function delay` 的顺序一次性定义它们，并且可以同时为多个属性设置过渡动画。\n\n请看以下例子，点击按钮生成 `color` 和 `font-size` 的过渡动画：\n\n```html run height=80 autorun no-beautify\n<button id=\"growing\">Click me</button>\n\n<style>\n#growing {\n*!*\n  transition: font-size 3s, color 2s;\n*/!*\n}\n</style>\n\n<script>\ngrowing.onclick = function() {\n  this.style.fontSize = '36px';\n  this.style.color = 'red';\n};\n</script>\n```\n\n现在让我们一个一个展开看这些属性。\n\n## transition-property\n\n在 `transition-property` 中我们可以列举要设置动画的所有属性，如：`left、margin-left、height 和 color`。\n\n不是所有的 CSS 属性都可以使用过渡动画，但是它们中的[大多数](http://www.w3.org/TR/css3-transitions/#animatable-properties-)都是可以的。`all` 表示应用在所有属性上。\n\n## transition-duration\n\n`transition-duration` 允许我们指定动画持续的时间。时间的格式参照 [CSS 时间格式](http://www.w3.org/TR/css3-values/#time)：单位为秒 `s` 或者毫秒 `ms`。\n\n## transition-delay\n\n`transition-delay` 允许我们设定动画**开始前**的延迟时间。例如，对于 `transition-delay: 1s`，动画将会在属性变化发生 1 秒后开始渲染。\n\n你也可以提供一个负值。那么动画将会从整个过渡的中间时刻开始渲染。例如，对于 `transition-duration: 2s`，同时把 `delay` 设置为 `-1s`，那么这个动画将会持续 1 秒钟，并且从正中间开始渲染。\n\n这里演示了数字从 `0` 到 `9` 的动画，使用了 CSS `translate` 方法：\n\n[codetabs src=\"digits\"]\n\n如下在 `tranform` 属性上应用动画：\n\n```css\n#stripe.animate {\n  transform: translate(-90%);\n  transition-property: transform;\n  transition-duration: 9s;\n}\n```\n\n在以上的例子中，JavaScript 把 `.animate` 类添加到了元素上，由此触发了动画：\n\n```js\nstripe.classList.add('animate');\n```\n\n我们也可以『从中间』开始，也就是说从某个特定数字开始，比方说，从当前的时间的秒数开始。这就要用到负的 `transition-delay`。\n\n此处，如果你单击这个数字，那么它会从当前的秒数开始渲染：\n\n[codetabs src=\"digits-negative-delay\"]\n\n只需添加一行 JavaScript 代码：\n\n```js\nstripe.onclick = function() {\n  let sec = new Date().getSeconds() % 10;\n*!*\n  // for instance, -3s here starts the animation from the 3rd second\n  stripe.style.transitionDelay = '-' + sec + 's';\n*/!*\n  stripe.classList.add('animate');\n};\n```\n\n## transition-timing-function\n\n时间函数描述了动画进程在时间上的分布。它是先慢后快还是先快后慢？\n\n乍一看，这可能是最复杂的属性了，但是稍微花点时间，你就会发现其实也很简单。\n\n这个属性接受两种值：一个贝塞尔曲线（Bezier curve）或者阶跃函数（steps）。我们先从贝塞尔曲线开始，这也是较为常用的。\n\n### 贝塞尔曲线（Bezier curve）\n\n时间函数可以用[贝塞尔曲线](/bezier-curve)描述，通过设置四个满足以下条件的控制点：\n\n1. 第一个应为：`(0,0)`。\n2. 最后一个应为：`(1,1)`。\n3. 对于中间值，`x` 必须位于 `0..1` 之间，`y` 可以为任意值。\n\nCSS 中设置一贝塞尔曲线的语法为：`cubic-bezier(x2, y2, x3, y3)`。这里我们只需要设置第二个和第三个值，因为第一个点固定为 `(0,0)`，第四个点固定为 `(1,1)`。\n\n时间函数描述了动画进行的快慢。\n\n- `x` 轴表示时间：`0` —— 开始时刻，`1` —— `transition-duration`的结束时刻。\n- `y` 轴表示过程的完成度：`0` —— 属性的起始值，`1` —— 属性的最终值。\n\n最简单的一种情况就是动画匀速进行，可以通过设置曲线为 `cubic-bezier(0, 0, 1, 1)` 来实现。\n\n看上去就像这样：\n\n![](bezier-linear.svg)\n\n...正如我们所见，这就是条直线。随着时间 `x` 推移，完成度 `y` 稳步从 `0` 增长到 `1`。\n\n例子中的列车匀速地从左侧移动到右侧：\n\n[codetabs src=\"train-linear\"]\n\n这个里面的 CSS 就是基于刚才那条曲线的：\n\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, 0, 1, 1);\n  /* JavaScript sets left to 450px */\n}\n```\n\n...那么，我们如果表现出减速行驶的列车呢？\n\n我们可以使用另一条贝塞尔曲线：`cubic-bezier(0.0, 0.5, 0.5 ,1.0)`。\n\n图像如下：\n\n![](train-curve.svg)\n\n正如我们所见，这个过程起初很快：曲线开始迅速升高，然后越来越慢。\n\n这是实际的效果演示：\n\n[codetabs src=\"train\"]\n\nCSS：\n```css\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, .5, .5, 1);\n  /* JavaScript sets left to 450px */\n}\n```\n\nCSS 提供几条内建的曲线：`linear`、`ease`、`ease-in`、`ease-out` 和 `ease-in-out`。\n\n`linear` 其实就是 `cubic-bezier(0, 0, 1, 1)` 的简写 —— 一条直线，刚刚我们已经看过了。 \n\n其它的名称是以下贝塞尔曲线的简写：\n\n| <code>ease</code><sup>*</sup> | <code>ease-in</code> | <code>ease-out</code> | <code>ease-in-out</code> |\n|-------------------------------|----------------------|-----------------------|--------------------------|\n| <code>(0.25, 0.1, 0.25, 1.0)</code> | <code>(0.42, 0, 1.0, 1.0)</code> | <code>(0, 0, 0.58, 1.0)</code> | <code>(0.42, 0, 0.58, 1.0)</code> |\n| ![ease, figure](ease.svg) | ![ease-in, figure](ease-in.svg) | ![ease-out, figure](ease-out.svg) | ![ease-in-out, figure](ease-in-out.svg) |\n\n`*` —— 默认值，如果没有指定时间函数，那么将使用 `ease` 作为默认值。\n\n所以，我们可以使用 `ease-out` 来表现减速行驶的列车：\n\n\n```css\n.train {\n  left: 0;\n  transition: left 5s ease-out;\n  /* transition: left 5s cubic-bezier(0, .5, .5, 1); */\n}\n```\n\n但是这看起来有点怪怪的。\n\n**贝塞尔曲线可以使动画『超出』其原本的范围。**\n\n曲线上的控制点的 `y` 值可以使任意的：不管是负值还是一个很大的值。如此，贝塞尔曲线就会变得很低或者很高，让动画超出其正常的范围。\n\n在一下的例子中使用的代码：\n```css\n.train {\n  left: 100px;\n  transition: left 5s cubic-bezier(.5, -1, .5, 2);\n  /* JavaScript sets left to 400px */\n}\n```\n\n`left` 本该在 `100px` 到 `400px` 之间变化。\n\n但是如果你点击列车，你会发现：\n\n- 起初，列车会**反向**运动：`left` 会变得小于 `100px`。\n- 然后，它会变回往前运动，并且超过 `400px`。\n- 最后再返回 —— 回到 `400px`。\n\n[codetabs src=\"train-over\"]\n\n为什么会这样？看一眼给定的贝塞尔曲线的图像你就会明白了。\n\n![](bezier-train-over.svg)\n\n我们把第二个点的 `y` 坐标移动到了小于 `0` 的位置，同时把第三个点的 `y` 坐标移动到了大于 `1` 的位置，因此曲线已经不再像一个四分之一圆了。`y` 坐标超出了常规的 `0..1` 的范围。\n\n正如我们所知，`y` 表示『动画进程的完成度』。`y = 0` 表示属性的初始值，`y = 1` 则表示属性的最终值。因此，`y < 0` 意味着属性值要比初始值小，而 `y > 1` 则表明属性值要比最终值大。\n\n当然了，`-1` 和 `2` 还是比较缓和的值。如果我们把 `y` 设为 `-99` 和 `99`，那么列车将会偏离地更远。\n\n但是，如何针对特定的任务寻找到合适的贝塞尔曲线呢？事实上，有很多工具可以帮到你。比方说，我们可以利用这个网站：<http://cubic-bezier.com/>。\n\n### 阶跃函数（Steps）\n\n时间函数 `steps(number of steps[, start/end])` 允许你让动画分段进行，`number of steps` 表示需要拆分为多少段。\n\n让我们通过一个数字的例子来演示一下。我们将会让数字以离散的方式变化，而不是以连续的方式。\n\n为了达到效果，我们把动画拆分为 9 段：\n\n```css\n#stripe.animate  {\n  transform: translate(-90%);\n  transition: transform 9s *!*steps(9, start)*/!*;\n}\n```\n\n`step(9, start)` 生效时：\n\n[codetabs src=\"step\"]\n\n`steps` 的第一个参数表示段数。这个过渡动画将会被拆分为 9 个部分（每个占 10%）。时间间隔也会以同样的方式被拆分：9 秒会被分割为多个时长 1 秒的间隔。\n\n第二个参数可以取 `start` 或 `end` 两者其一。\n\n`start` 表示在动画开始时，我们需要立即开始第一段的动画。\n\n可以观察到，在动画过程中：当我们单击数字之后，它会立马变为 `1`（即第一段），然后在下一秒开始的时候继续变化。\n\n具体的流程如下：\n\n- `0s` —— `-10%`（在第一秒开始的时候立即变化）\n- `1s` —— `-20%`\n- ...\n- `8s` -- `-80%`\n- （最后一秒，显示最终值）\n\n另一个值 `end` 表示：改变不应该在最开始的时候发生，而是发生在每一段的最后时刻。\n\n其流程如下：\n\n- `0s` —— `0`\n- `1s` —— `-10%`（在第一秒结束时第一次变化）\n- `2s` —— `-20%`\n- ...\n- `9s` —— `-90%`\n\n`step(9, end)` 生效时：\n\n[codetabs src=\"step-end\"]\n\n另外还有一些简写值：\n\n- `step-start` —— 等同于 `steps(1, start)`。即：动画立刻开始，并且只有一段。也就是说，会立刻开始，紧接着就结束了，宛如没有动画一样。\n- `step-end` —— 等同于 `steps(1, end)`。即：在 `transition-duration` 结束时生成一段动画。\n\n这些值很少会被用到，因为它们并不算是真正的动画，而是单步的变化。\n\n## transitionend 事件\n\nCSS 动画完成后，会触发 `transitionend` 事件。\n\n这被广泛用于在动画结束后执行某种操作。我们也可以用它来串联动画。\n\n举例来说，下面的小船会在点击后向右浮动，然后再回来。而且，每一次都会向右移动地更远一点：\n\n[iframe src=\"boat\" height=300 edit link]\n\n这个动画通过 `go` 函数初始化，并且在每次动画完成后都会重复执行，并转变方向：\n\n```js\nboat.onclick = function() {\n  //...\n  let times = 1;\n\n  function go() {\n    if (times % 2) {\n      // 向右移动\n      boat.classList.remove('back');\n      boat.style.marginLeft = 100 * times + 200 + 'px';\n    } else {\n      // 向左移动\n      boat.classList.add('back');\n      boat.style.marginLeft = 100 * times - 200 + 'px';\n    }\n\n  }\n\n  go();\n\n  boat.addEventListener('transitionend', function() {\n    times++;\n    go();\n  });\n};\n```\n\n`transitionend` 的事件对象有几个特定的属性：\n\n`event.propertyName`\n：当前完成动画的属性，这在我们同时为多个属性加上动画时会很有用。\n\n`event.elapsedTime`\n：动画完成的时间（按秒计算），不包括 `transition-delay`。\n\n## 关键帧动画（Keyframes）\n\n我们可以通过 CSS 提供的 `@keyframes` 规则整合多个简单的动画。\n\n它会指定某个动画的名称以及相应的规则：哪个属性，何时以及何地渲染动画。然后使用 `animation` 属性把动画绑定到相应的元素上，并为其添加额外的参数。\n\n这里有个详细的例子：\n\n```html run height=60 autorun=\"no-epub\" no-beautify\n<div class=\"progress\"></div>\n\n<style>\n*!*\n  @keyframes go-left-right {        /* 指定一个名字：\"go-left-right\" */\n    from { left: 0px; }             /* 从 left: 0px 开始 */\n    to { left: calc(100% - 50px); } /* 移动至 left: 100%-50px */\n  }\n*/!*\n\n  .progress {\n*!*\n    animation: go-left-right 3s infinite alternate;\n    /* 把动画 \"go-left-right\" 应用到元素上\n       持续 3 秒\n       持续次数：infinite\n       每次都改变方向\n    */\n*/!*\n\n    position: relative;\n    border: 2px solid green;\n    width: 50px;\n    height: 20px;\n    background: lime;\n  }\n</style>\n```\n\n有许多关于 `@keyframes` 的文章以及一个[详细的规范说明](https://drafts.csswg.org/css-animations/)。\n\n很可能你并不需要经常用到 `@keyframes`，除非你的网站上有一直在运动的元素。\n\n## 总结\n\nCSS 动画允许你为一个或者多个属性的变化创建丝滑流畅（也可能不是）的过渡动画。\n\n它们适用于大多数的动画需求。我们也可以使用 JavaScript 创建动画，下一章将会详细讲解相关内容。\n\n相对于 JavaScript 动画，CSS 动画存在的特点如下：\n\n```compare plus=\"CSS animations\" minus=\"JavaScript animations\"\n+ 简单的事，简单地做。\n+ 快速，而且对 CPU 造成的压力很小。\n- JavaScript 动画更加灵活。它们可以实现任何动画逻辑，比如某个元素的爆炸效果。\n- 不仅仅只是属性的变化。我们还可以在 JavaScript 中生成新元素用于动画。\n```\n\n本节已经介绍了可以使用 CSS 实现的主要动画类型，而且 `transitionend` 还允许在动画结束后执行 JavaScript 代码，因此它可以方便得与代码结合起来。\n\n但是在下一节，我们将会学习一些 JavaScript 动画来实现更加复杂的效果。",
        "libs": [],
        "children": [
          "animate-logo-css",
          "animate-logo-bezier-css",
          "animate-circle",
          "animate-circle-callback"
        ],
        "parent": "animation",
        "updatedAt": 1665942550
      }
    },
    "animate-logo-css": {
      "type": "Task",
      "value": {
        "title": "让飞机动起来（CSS）",
        "slug": "animate-logo-css",
        "githubPath": "/7-animation/2-css-animations/1-animate-logo-css",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n生成如下图的动画（点击显示）：\n\n[iframe src=\"solution\" height=300]\n\n- 点击后，图片会从 `40x24px` 变为 `400x240px` （变大十倍）。\n- 动画持续三秒。\n- 在动画结束后，输出：\"Done!\"。\n- 动画过程中，如果飞机被点击，这些操作不应该打断动画。",
        "solution": "使用 CSS 为 `width` 和 `height` 属性生成动效：\n```css\n/* 原始类 */\n\n#flyjet {\n  transition: all 3s;\n}\n\n/* JS 添加的 .growing */\n#flyjet.growing {\n  width: 400px;\n  height: 240px;\n}\n```\n\n请注意，`transitionend` 会被触发两次 —— 每个属性触发一次。因此，如果我们不进行额外检查的话，这条信息会显示两次。",
        "parent": "css-animations",
        "version": 1
      }
    },
    "animate-logo-bezier-css": {
      "type": "Task",
      "value": {
        "title": "为飞机生成动画（CSS）",
        "slug": "animate-logo-bezier-css",
        "githubPath": "/7-animation/2-css-animations/2-animate-logo-bezier-css",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n修改前一个的任务 <info:task/animate-logo-css> 的解决方案，让飞机超过原有的大小 `400x240px`（跳脱出来），然后再回到之前的大小。\n\n这里是效果演示（点击飞机）：\n\n[iframe src=\"solution\" height=350]\n\n在前一个解决方案的基础上做修改。",
        "solution": "我们需要为此选择合适的贝塞尔曲线。它应该在某个地方拥有 `y > 1`，来使得飞机『跳出来』。 \n\n举例来说，我们可以使两个控制点的 `y` 都大于 `1`：`cubic-bezier(0.25, 1.5, 0.75, 1.5)`。\n\n如图：\n\n![](bezier-up.svg)",
        "parent": "css-animations",
        "version": 1
      }
    },
    "animate-circle": {
      "type": "Task",
      "value": {
        "title": "圆圈动画",
        "slug": "animate-circle",
        "githubPath": "/7-animation/2-css-animations/3-animate-circle",
        "weight": 3,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个函数：`showCircle(cx, cy, radius)`，来显示一个不断变大的圆。\n\n- `cx,cy` 为圆心相对于窗口的位置。\n- `radius` 为圆的半径。\n\n点击下方的按钮以演示效果：\n\n[iframe src=\"solution\" height=260]\n\n源文件中提供了一个具有合适样式的圆样例，因此你需要做的就是创建合适的动画。",
        "solution": "",
        "parent": "css-animations",
        "version": 1
      }
    },
    "animate-circle-callback": {
      "type": "Task",
      "value": {
        "title": "带回调的圆圈动画",
        "slug": "animate-circle-callback",
        "githubPath": "/7-animation/2-css-animations/4-animate-circle-callback",
        "weight": 4,
        "libs": [],
        "content": "\n\n在练习 <info:task/animate-circle> 中展示了一个不断变大的圆。\n\n现在假设我们不止需要一个圆，还需要在其中显示一条消息。该消息应该出现在动画结束 **之后**（圆变最大时），否则看起来会很丑。\n\n在该练习的解决方案中，函数 `showCircle(cx, cy, radius)` 画了一个不断变大的圆，但无法知道它何时结束。\n\n添加一个回调函数：`showCircle(cx, cy, radius, callback)` 在动画完成时调用。`callback` 应该接收圆 `div` 作为参数。\n\n下面是一个例子：\n\n```js\nshowCircle(150, 150, 100, div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n```\n\nDemo：\n\n[iframe src=\"solution\" height=260]\n\n以 <info:task/animate-circle> 的解决方案为基础。",
        "solution": "",
        "parent": "css-animations",
        "version": 1
      }
    },
    "js-animation": {
      "type": "Article",
      "value": {
        "title": "JavaScript 动画",
        "slug": "js-animation",
        "githubPath": "/7-animation/3-js-animation",
        "isFolder": false,
        "weight": 3,
        "content": "\n\nJavaScript 动画可以处理 CSS 无法处理的事情。\n\n例如，沿着具有与 Bezier 曲线不同的时序函数的复杂路径移动，或者实现画布上的动画。\n\n## 使用 setInterval\n\n从 HTML/CSS 的角度来看，动画是 style 属性的逐渐变化。例如，将 `style.left` 从 `0px` 变化到 `100px` 可以移动元素。\n\n如果我们用 `setInterval` 每秒做 50 次小变化，看起来会更流畅。电影也是这样的原理：每秒 24 帧或更多帧足以使其看起来流畅。\n\n伪代码如下：\n\n```js\nlet delay = 1000 / 50; // 每秒 50 帧\nlet timer = setInterval(function() {\n  if (animation complete) clearInterval(timer);\n  else increase style.left\n}, delay)\n```\n\n更完整的动画示例：\n\n```js\nlet start = Date.now(); // 保存开始时间\n\nlet timer = setInterval(function() {\n  // 距开始过了多长时间\n  let timePassed = Date.now() - start;\n\n  if (timePassed >= 2000) {\n    clearInterval(timer); // 2 秒后结束动画\n    return;\n  }\n\n  // 在 timePassed 时刻绘制动画\n  draw(timePassed);\n\n}, 20);\n\n// 随着 timePassed 从 0 增加到 2000\n// 将 left 的值从 0px 增加到 400px\nfunction draw(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}\n```\n\n点击演示：\n\n[codetabs height=200 src=\"move\"]\n\n## 使用 requestAnimationFrame\n\n假设我们有几个同时运行的动画。\n\n如果我们单独运行它们，每个都有自己的 `setInterval(..., 20)`，那么浏览器必须以比 `20ms` 更频繁的速度重绘。\n\n每个 `setInterval` 每 `20ms` 触发一次，但它们相互独立，因此 `20ms` 内将有多个独立运行的重绘。\n\n这几个独立的重绘应该组合在一起，以使浏览器更加容易处理。\n\n换句话说，像下面这样：\n\n```js\nsetInterval(function() {\n  animate1();\n  animate2();\n  animate3();\n}, 20)\n```\n\n……比这样更好：\n\n```js\nsetInterval(animate1, 20);\nsetInterval(animate2, 20);\nsetInterval(animate3, 20);\n```\n\n还有一件事需要记住。有时当 CPU 过载时，或者有其他原因需要降低重绘频率。例如，如果浏览器选项卡被隐藏，那么绘图完全没有意义。\n\n有一个标准[动画时序](http://www.w3.org/TR/animation-timing/)提供了 `requestAnimationFrame` 函数。\n\n它解决了所有这些问题，甚至更多其它的问题。\n\n语法：\n```js\nlet requestId = requestAnimationFrame(callback);\n```\n\n这会让 `callback` 函数在浏览器每次重绘的最近时间运行。\n\n如果我们对 `callback` 中的元素进行变化，这些变化将与其他 `requestAnimationFrame` 回调和 CSS 动画组合在一起。因此，只会有一次几何重新计算和重绘，而不是多次。\n\n返回值 `requestId` 可用来取消回调：\n```js\n// 取消回调的周期执行\ncancelAnimationFrame(requestId);\n```\n\n`callback` 得到一个参数 —— 从页面加载开始经过的毫秒数。这个时间也可通过调用 [performance.now()](mdn:api/Performance/now) 得到。\n\n通常 `callback` 很快就会运行，除非 CPU 过载或笔记本电量消耗殆尽，或者其他原因。\n\n下面的代码显示了 `requestAnimationFrame` 的前 10 次运行之间的时间间隔。通常是 10-20ms：\n\n```html run height=40 refresh\n<script>\n  let prev = performance.now();\n  let times = 0;\n\n  requestAnimationFrame(function measure(time) {\n    document.body.insertAdjacentHTML(\"beforeEnd\", Math.floor(time - prev) + \" \");\n    prev = time;\n\n    if (times++ < 10) requestAnimationFrame(measure);\n  });\n</script>\n```\n\n## 结构化动画\n\n现在我们可以在 `requestAnimationFrame` 基础上创建一个更通用的动画函数：\n\n```js\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction 从 0 增加到 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // 计算当前动画状态\n    let progress = timing(timeFraction);\n\n    draw(progress); // 绘制\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\n`animate` 函数接受 3 个描述动画的基本参数：\n\n`duration`\n: 动画总时间，比如 `1000`。\n\n`timing(timeFraction)`\n: 时序函数，类似 CSS 属性 `transition-timing-function`，传入一个已过去的时间与总时间之比的小数（`0` 代表开始，`1` 代表结束），返回动画完成度（类似 Bezier 曲线中的 `y`）。\n\n    例如，线性函数意味着动画以相同的速度均匀地进行：\n\n    ```js\n    function linear(timeFraction) {\n      return timeFraction;\n    }\n    ```\n\n    图像如下：\n\n    ![](linear.svg)\n\n    它类似于 `transition-timing-function: linear`。后文有更多有趣的变体。\n\n`draw(progress)`\n: 获取动画完成状态并绘制的函数。值 `progress = 0` 表示开始动画状态，`progress = 1` 表示结束状态。\n\n    这是实际绘制动画的函数。\n\n    它可以移动元素：\n    ```js\n    function draw(progress) {\n      train.style.left = progress + 'px';\n    }\n    ```\n\n    ……或者做任何其他事情，我们可以以任何方式为任何事物制作动画。\n\n\n让我们使用我们的函数将元素的 `width` 从 `0` 变化为 `100%`。\n\n点击演示元素：\n\n[codetabs height=60 src=\"width\"]\n\n它的代码如下：\n\n```js\nanimate({\n  duration: 1000,\n  timing(timeFraction) {\n    return timeFraction;\n  },\n  draw(progress) {\n    elem.style.width = progress * 100 + '%';\n  }\n});\n```\n\n与 CSS 动画不同，我们可以在这里设计任何时序函数和任何绘图函数。时序函数不受 Bezier 曲线的限制。并且 `draw` 不局限于操作 CSS 属性，还可以为类似烟花动画或其他动画创建新元素。\n\n## 时序函数\n\n上文我们看到了最简单的线性时序函数。\n\n让我们看看更多。我们将尝试使用不同时序函数的移动动画来查看它们的工作原理。\n\n### n 次幂\n\n如果我们想加速动画，我们可以让 `progress` 为 `n` 次幂。\n\n例如，抛物线：\n\n```js\nfunction quad(timeFraction) {\n  return Math.pow(timeFraction, 2)\n}\n```\n\n图像如下：\n\n![](quad.svg)\n\n看看实际效果（点击激活）：\n\n[iframe height=40 src=\"quad\" link]\n\n……或者三次曲线甚至使用更大的 `n`。增大幂会让动画加速得更快。\n\n下面是 `progress` 为 `5` 次幂的图像:\n\n![](quint.svg)\n\n实际效果：\n\n[iframe height=40 src=\"quint\" link]\n\n### 圆弧\n\n函数：\n\n```js\nfunction circ(timeFraction) {\n  return 1 - Math.sin(Math.acos(timeFraction));\n}\n```\n\n图像：\n\n![](circ.svg)\n\n[iframe height=40 src=\"circ\" link]\n\n### 反弹：弓箭射击\n\n此函数执行“弓箭射击”。首先，我们“拉弓弦”，然后“射击”。\n\n与以前的函数不同，它取决于附加参数 `x`，即“弹性系数”。“拉弓弦”的距离由它定义。\n\n代码如下：\n\n```js\nfunction back(x, timeFraction) {\n  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x);\n}\n```\n\n**`x = 1.5` 时的图像：**\n\n![](back.svg)\n\n在动画中我们使用特定的 `x` 值。下面是 `x = 1.5` 时的例子：\n\n[iframe height=40 src=\"back\" link]\n\n### 弹跳\n\n想象一下，我们正在抛球。球落下之后，弹跳几次然后停下来。\n\n`bounce` 函数也是如此，但顺序相反：“bouncing”立即启动。它使用了几个特殊的系数：\n\n```js\nfunction bounce(timeFraction) {\n  for (let a = 0, b = 1, result; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n    }\n  }\n}\n```\n\n演示：\n\n[iframe height=40 src=\"bounce\" link]\n\n### 伸缩动画\n\n另一个“伸缩”函数接受附加参数 `x` 作为“初始范围”。\n\n```js\nfunction elastic(x, timeFraction) {\n  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)\n}\n```\n\n**`x=1.5` 时的图像：**\n![](elastic.svg)\n\n`x=1.5` 时的演示\n\n[iframe height=40 src=\"elastic\" link]\n\n## 逆转：ease*\n\n我们有一组时序函数。它们的直接应用称为“easeIn”。\n\n有时我们需要以相反的顺序显示动画。这是通过“easeOut”变换完成的。\n\n### easeOut\n\n在“easeOut”模式中，我们将 `timing` 函数封装到 `timingEaseOut`中：\n\n```js\ntimingEaseOut(timeFraction) = 1 - timing(1 - timeFraction);\n```\n\n换句话说，我们有一个“变换”函数 `makeEaseOut`，它接受一个“常规”时序函数 `timing` 并返回一个封装器，里面封装了 `timing` 函数：\n\n```js\n// 接受时序函数，返回变换后的变体\nfunction makeEaseOut(timing) {\n  return function(timeFraction) {\n    return 1 - timing(1 - timeFraction);\n  }\n}\n```\n\n例如，我们可以使用上面描述的 `bounce` 函数：\n\n```js\nlet bounceEaseOut = makeEaseOut(bounce);\n```\n\n这样，弹跳不会在动画开始时执行，而是在动画结束时。这样看起来更好：\n\n[codetabs src=\"bounce-easeout\"]\n\n在这里，我们可以看到变换如何改变函数的行为：\n\n![](bounce-inout.svg)\n\n如果在开始时有动画效果，比如弹跳 —— 那么它将在最后显示。\n\n上图中<span style=\"color:#EE6B47\">常规弹跳</span>为红色，<span style=\"color:#62C0DC\">easeOut 弹跳</span>为蓝色。\n\n- 常规弹跳 —— 物体在底部弹跳，然后突然跳到顶部。\n- `easeOut` 变换之后 —— 物体跳到顶部之后，在那里弹跳。\n\n### easeInOut\n\n我们还可以在动画的开头和结尾都显示效果。该变换称为“easeInOut”。\n\n给定时序函数，我们按下面的方式计算动画状态：\n\n```js\nif (timeFraction <= 0.5) { // 动画前半部分\n  return timing(2 * timeFraction) / 2;\n} else { // 动画后半部分\n  return (2 - timing(2 * (1 - timeFraction))) / 2;\n}\n```\n\n封装器代码：\n\n```js\nfunction makeEaseInOut(timing) {\n  return function(timeFraction) {\n    if (timeFraction < .5)\n      return timing(2 * timeFraction) / 2;\n    else\n      return (2 - timing(2 * (1 - timeFraction))) / 2;\n  }\n}\n\nbounceEaseInOut = makeEaseInOut(bounce);\n```\n\n`bounceEaseInOut` 演示如下:\n\n[codetabs src=\"bounce-easeinout\"]\n\n“easeInOut” 变换将两个图像连接成一个：动画的前半部分为“easeIn”（常规），后半部分为“easeOut”（反向）。\n\n如果我们比较 `circ` 时序函数的 `easeIn`、`easeOut` 和 `easeInOut` 的图像，就可以清楚地看到效果：\n\n![](circ-ease.svg)\n\n- <span style=\"color:#EE6B47\">红色</span>是 `circ`（`easeIn`）的常规变体。\n- <span style=\"color:#8DB173\">绿色</span> —— `easeOut`。\n- <span style=\"color:#62C0DC\">蓝色</span> —— `easeInOut`。\n\n正如我们所看到的，动画前半部分的图形是缩小的“easeIn”，后半部分是缩小的“easeOut”。结果是动画以相同的效果开始和结束。\n\n## 更有趣的 \"draw\"\n\n除了移动元素，我们还可以做其他事情。我们所需要的只是写出合适的 `draw`。\n\n这是动画形式的“弹跳”文字输入：\n\n[codetabs src=\"text\"]\n\n## 总结\n\nJavaScript 动画应该通过 `requestAnimationFrame` 实现。该内建方法允许设置回调函数，以便在浏览器准备重绘时运行。那通常很快，但确切的时间取决于浏览器。\n\n当页面在后台时，根本没有重绘，因此回调将不会运行：动画将被暂停并且不会消耗资源。那很棒。\n\n这是设置大多数动画的 helper 函数 `animate`：\n\n```js\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction 从 0 增加到 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // 计算当前动画状态\n    let progress = timing(timeFraction);\n\n    draw(progress); // 绘制\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n```\n\n参数：\n\n- `duration` —— 动画运行的总毫秒数。\n- `timing` —— 计算动画进度的函数。获取从 0 到 1 的小数时间，返回动画进度，通常也是从 0 到 1。\n- `draw` —— 绘制动画的函数。\n\n当然我们可以改进它，增加更多花里胡哨的东西，但 JavaScript 动画不是经常用到。它们用于做一些有趣和不标准的事情。因此，您大可在必要时再添加所需的功能。\n\nJavaScript 动画可以使用任何时序函数。我们介绍了很多例子和变换，使它们更加通用。与 CSS 不同，我们不仅限于 Bezier 曲线。\n\n`draw` 也是如此：我们可以将任何东西动画化，而不仅仅是 CSS 属性。",
        "libs": [],
        "children": [
          "animate-ball",
          "animate-ball-hops"
        ],
        "parent": "animation",
        "updatedAt": 1639583370
      }
    },
    "animate-ball": {
      "type": "Task",
      "value": {
        "title": "为弹跳的球设置动画",
        "slug": "animate-ball",
        "githubPath": "/7-animation/3-js-animation/1-animate-ball",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n做一个弹跳的球。点击查看应有的效果：\n\n[iframe height=250 src=\"solution\"]",
        "solution": "为了达到反弹效果，我们可以在带有 `position:relative` 属性的区域内，给小球使用 `top` 和 `position:absolute` CSS 属性。\n\nfield 区域的底部坐标是 `field.clientHeight`。`top` 属性给出了球顶部的坐标，在最底部时达到 `field.clientHeight - ball.clientHeight`。\n\n因此，我们将 `top` 从 `0` 变化到 `field.clientHeight - ball.clientHeight` 来设置动画。\n\n现在为了获得“弹跳”效果，我们可以在 `easeOut` 模式下使用时序函数 `bounce`。\n\n这是动画的最终代码：\n\n```js\nlet to = field.clientHeight - ball.clientHeight;\n\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw(progress) {\n    ball.style.top = to * progress + 'px'\n  }\n});\n```",
        "parent": "js-animation",
        "version": 1
      }
    },
    "animate-ball-hops": {
      "type": "Task",
      "value": {
        "title": "设置动画使球向右移动",
        "slug": "animate-ball-hops",
        "githubPath": "/7-animation/3-js-animation/2-animate-ball-hops",
        "weight": 2,
        "libs": [],
        "importance": 5,
        "content": "\n\n让球向右移动。像这样：\n\n[iframe height=250 src=\"solution\"]\n\n编写动画代码。终止时球到左侧的距离是 `100px`。\n\n从前一个任务 <info:task/animate-ball> 的答案开始。",
        "solution": "在任务 <info:task/animate-ball> 中，我们只有一个需要添加动画的属性。现在多了一个 `elem.style.left`。\n\n水平坐标由另一个定律改变：它不会“反弹”，而是逐渐增加使球逐渐向右移动。\n\n我们可以为它多写一个 `animate`。\n\n至于时序函数，我们可以使用 `linear`，但像 `makeEaseOut(quad)` 这样的函数看起来要好得多。\n\n代码：\n\n```js\nlet height = field.clientHeight - ball.clientHeight;\nlet width = 100;\n\n// 设置 top 动画（弹跳）\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(bounce),\n  draw: function(progress) {\n    ball.style.top = height * progress + 'px'\n  }\n});\n\n// 设置 left 动画（向右移动）\nanimate({\n  duration: 2000,\n  timing: makeEaseOut(quad),\n  draw: function(progress) {\n    ball.style.left = width * progress + \"px\"\n  }\n});\n```",
        "parent": "js-animation",
        "version": 1
      }
    },
    "web-components": {
      "type": "Article",
      "value": {
        "title": "Web components",
        "slug": "web-components",
        "githubPath": "/8-web-components",
        "isFolder": true,
        "weight": 8,
        "content": "\n\nWeb components is a set of standards to make self-contained components: custom HTML-elements with their own properties and methods, encapsulated DOM and styles.",
        "libs": [],
        "children": [
          "webcomponents-intro",
          "custom-elements",
          "shadow-dom",
          "template-element",
          "slots-composition",
          "shadow-dom-style",
          "shadow-dom-events"
        ]
      }
    },
    "webcomponents-intro": {
      "type": "Article",
      "value": {
        "title": "从星球轨道的高度讲起",
        "slug": "webcomponents-intro",
        "githubPath": "/8-web-components/1-webcomponents-intro",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n这一部分我们将会讲述关于「Web Components」的一系列现代标准。\n\n到目前为止，这些标准仍然在制定中。其中一些特性已经被很好地支持并集成到了现代 HTML/DOM 标准中，但是还有部分特性仍然处在草案阶段。你可以在任何浏览器中尝试一些例子，Google Chrome 可能是对这些新特性支持得最好的浏览器。猜测可能是因为 Google 公司的人本身就是很多相关标准的支持者。\n\n## 共通之处在于……\n\n整个组件化的概念并不是最新才提出的。很多框架和其他地方已经广泛地应用了组件化的设计。\n\n在我们开始探讨实现细节之前，先让我们看看人类的伟大成就：\n\n![](satellite.jpg)\n\n这是国际空间站（ISS）。\n\n这是其组成结构（大致的）：\n\n![](satellite-expanded.jpg)\n\n这个国际空间站：\n- 由许多组件构成。\n- 各个组件都由很多的更小的部分组成，\n- 组件都非常复杂，远比大部分网站更复杂。\n- 国际化的组件开发团队，整个工作由不同国家、说着不同语言的人共同完成。\n\n……并且这个家伙能飞，它让人类在太空中能够生存！\n\n这些复杂的设备是如何被创建的？\n\n我们可以从中借鉴哪些原则，让我们的开发项目同样的可靠并且可大规模化呢？或者至少让我们可以接近这些目标。\n\n## 组件化架构\n\n众所周知，开发复杂软件的原则是：不要让软件复杂。\n\n如果某个部分变得复杂了 —— 将其拆分成更简单的部分，再以最简明的方式组合起来。\n\n**只有让复杂的事情简单化的架构才是好架构。**\n\n我们可以把用户界面拆分为若干可视化组件：每个组件都在页面上占有一块位置，可以执行一个明确的任务，并且可以和其他组件区分开。\n\n接下来看一个实际的网站的例子，比如 Twitter。\n\n非常自然地，可以拆分为几个组件：\n\n![](web-components-twitter.svg)\n\n1. 顶部导航栏。\n2. 用户信息。\n3. 关注推荐。\n4. 提交表格。\n5. （6，7也是） —— 消息。\n\n组件也可以包含子组件，比如消息组件可能是更高阶组件「消息列表」的子组件。可点击的用户头像可能也是一个组件，这样的例子还有很多。\n\n我们如何划分一个组件呢？直觉、经验和常识可以帮助我们完成这件事。通常情况下，如果一个独立可视化实体，我们可以描述其可以做什么和如何在页面上交互，那么就可以将其划分为一个组件。在上面的例子中，这个页面存在几个模块，每个模块都有自己的角色，所以把它们划分为组件是合理的。\n\n一个组件有：\n- 自己的 JavaScript 类。\n- DOM 结构，并且只由自己的类管理，无法被外部代码操作。（「封装」原则）。\n- CSS 样式，作用在这个组件上。\n- API：事件，类方法等等，让组件可以与其他组件交互。\n\n再说一遍，整个「组件化」的概念并不是什么特别的东西。\n\n现在已经有了很多框架和开发方法论可以实现组件化，它们各个都有自己的卖点。通常情况下，采用特殊的 CSS 类命名和一些规范，已经可以带来「组件化的感觉」 —— 即 CSS 作用域和 DOM 封装。\n\n而现在浏览器已经原生支持了「Web Components」，我们就可以不用再自己去模拟组件化的结构了。\n\n- [Custom elements](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements) —— 用于自定义 HTML 元素.\n- [Shadow DOM](https://dom.spec.whatwg.org/#shadow-trees) —— 为组件创建内部 DOM，它对外部是不可见的。\n- [CSS Scoping](https://drafts.csswg.org/css-scoping/) —— 申明仅应用于组件的 Shadow DOM 内的样式。\n- [Event retargeting](https://dom.spec.whatwg.org/#retarget) 以及更多的小东西，让自定义组件更适用于开发工作。\n\n在下一篇中我们将会更细致地讲述「Custom Elements」 —— 一个已经被很广泛支持的 Web Components 重要组成部分。",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1639583370
      }
    },
    "custom-elements": {
      "type": "Article",
      "value": {
        "title": "Custom elements",
        "slug": "custom-elements",
        "githubPath": "/8-web-components/2-custom-elements",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n我们可以通过描述带有自己的方法、属性和事件等的类来创建自定义 HTML 元素。\n\n在 custom elements （自定义标签）定义完成之后，我们可以将其和 HTML 的内建标签一同使用。\n\n这是一件好事，因为虽然 HTML 有非常多的标签，但仍然是有穷尽的。如果我们需要像 `<easy-tabs>`、`<sliding-carousel>`、`<beautiful-upload>`…… 这样的标签，内建标签并不能满足我们。\n\n我们可以把上述的标签定义为特殊的类，然后使用它们，就好像它们本来就是 HTML 的一部分一样。\n\nCustom elements 有两种：\n\n1. **Autonomous custom elements （自主自定义标签）** —— \"全新的\" 元素, 继承自 `HTMLElement` 抽象类.\n2. **Customized built-in elements （自定义内建元素）** —— 继承内建的 HTML 元素，比如自定义 `HTMLButtonElement` 等。\n\n我们将会先创建 autonomous 元素，然后再创建 customized built-in 元素。\n\n在创建 custom elements 的时候，我们需要告诉浏览器一些细节，包括：如何展示它，以及在添加元素到页面和将其从页面移除的时候需要做什么，等等。\n\n通过创建一个带有几个特殊方法的类，我们可以完成这件事。这非常容易实现，我们只需要添加几个方法就行了，同时这些方法都不是必须的。\n\n下面列出了这几个方法的概述：\n\n```js\nclass MyElement extends HTMLElement {\n  constructor() {\n    super();\n    // 元素在这里创建\n  }\n\n  connectedCallback() {\n    // 在元素被添加到文档之后，浏览器会调用这个方法\n    //（如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）\n  }\n\n  disconnectedCallback() {\n    // 在元素从文档移除的时候，浏览器会调用这个方法\n    // （如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）\n  }\n\n  static get observedAttributes() {\n    return [/* 属性数组，这些属性的变化会被监视 */];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    // 当上面数组中的属性发生变化的时候，这个方法会被调用\n  }\n\n  adoptedCallback() {\n    // 在元素被移动到新的文档的时候，这个方法会被调用\n    // （document.adoptNode 会用到, 非常少见）\n  }\n\n  // 还可以添加更多的元素方法和属性\n}\n```\n\n在申明了上面几个方法之后，我们需要注册元素：\n\n```js\n// 让浏览器知道我们新定义的类是为 <my-element> 服务的\ncustomElements.define(\"my-element\", MyElement);\n```\n\n现在当任何带有 `<my-element>` 标签的元素被创建的时候，一个 `MyElement` 的实例也会被创建，并且前面提到的方法也会被调用。我们同样可以使用 `document.createElement('my-element')` 在 JavaScript 里创建元素。\n\n```smart header=\"Custom element 名称必须包括一个短横线 `-`\"\nCustom element 名称必须包括一个短横线 `-`, 比如 `my-element` 和 `super-button` 都是有效的元素名，但 `myelement` 并不是。\n\n这是为了确保 custom element 和内建 HTML 元素之间不会发生命名冲突。\n```\n\n## 例子: \"time-formatted\"\n\n举个例子，HTML 里面已经有 `<time>` 元素了，用于显示日期／时间。但是这个标签本身并不会对时间进行任何格式化处理。\n\n让我们来创建一个可以展示适用于当前浏览器语言的时间格式的 `<time-formatted>` 元素：\n\n\n```html run height=50 autorun=\"no-epub\"\n<script>\n*!*\nclass TimeFormatted extends HTMLElement { // (1)\n*/!*\n\n  connectedCallback() {\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n}\n\n*!*\ncustomElements.define(\"time-formatted\", TimeFormatted); // (2)\n*/!*\n</script>\n\n<!-- (3) -->\n*!*\n<time-formatted datetime=\"2019-12-01\"\n*/!*\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\n```\n\n1. 这个类只有一个方法 `connectedCallback()` —— 在 `<time-formatted>` 元素被添加到页面的时候，浏览器会调用这个方法（或者当 HTML 解析器检测到它的时候），它使用了内建的时间格式化工具 [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat)，这个工具可以非常好地展示格式化之后的时间，在各浏览器中兼容性都非常好。\n2. 我们需要通过 `customElements.define(tag, class)` 来注册这个新元素。\n3. 接下来在任何地方我们都可以使用这个新元素了。\n\n\n```smart header=\"Custom elements 升级\"\n如果浏览器在 `customElements.define` 之前的任何地方见到了 `<time-formatted>` 元素，并不会报错。但会把这个元素当作未知元素，就像任何非标准标签一样。\n\n`:not(:defined)` CSS 选择器可以对这样「未定义」的元素加上样式。\n\n当 `customElement.define` 被调用的时候，它们被「升级」了：一个新的 `TimeFormatted` 元素为每一个标签创建了，并且 `connectedCallback` 被调用。它们变成了 `:defined`。\n\n我们可以通过这些方法来获取更多的自定义标签的信息：\n- `customElements.get(name)` —— 返回指定 custom element  `name` 的类。\n- `customElements.whenDefined(name)` -- 返回一个 promise，将会在这个具有给定 `name` 的 custom element 变为已定义状态的时候 resolve（不带值）。\n\n```\n\n```smart header=\"在 `connectedCallback` 中渲染，而不是 `constructor` 中\"\n在上面的例子中，元素里面的内容是在 `connectedCallback` 中渲染（创建）的。\n\n为什么不在 `constructor` 中渲染？\n\n原因很简单：在 `constructor` 被调用的时候，还为时过早。虽然这个元素实例已经被创建了，但还没有插入页面。在这个阶段，浏览器还没有处理／创建元素属性：调用 `getAttribute` 将会得到 `null`。所以我们并不能在那里渲染元素。\n\n而且，如果你仔细考虑，这样作对于性能更好 —— 推迟渲染直到真正需要的时候。\n\n在元素被添加到文档的时候，它的 `connectedCallback` 方法会被调用。这个元素不仅仅是被添加为了另一个元素的子元素，同样也成为了页面的一部分。因此我们可以构建分离的 DOM，创建元素并且让它们为之后的使用准备好。它们只有在插入页面的时候才会真的被渲染。\n```\n\n## 监视属性\n\n我们目前的 `<time-formatted>` 实现中，在元素渲染以后，后续的属性变化并不会带来任何影响。这对于 HTML 元素来说有点奇怪。通常当我们改变一个属性的时候，比如 `a.href`，我们会预期立即看到变化。我们将会在下面修正这一点。\n\n为了监视这些属性，我们可以在 `observedAttributes()` static getter 中提供属性列表。当这些属性发生变化的时候，`attributeChangedCallback` 会被调用。出于性能优化的考虑，其他属性变化的时候并不会触发这个回调方法。\n\n以下是 `<time-formatted>` 的新版本，它会在属性变化的时候自动更新：\n\n```html run autorun=\"no-epub\" height=50\n<script>\nclass TimeFormatted extends HTMLElement {\n\n*!*\n  render() { // (1)\n*/!*\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n*!*\n  connectedCallback() { // (2)\n*/!*\n    if (!this.rendered) {\n      this.render();\n      this.rendered = true;\n    }\n  }\n\n*!*\n  static get observedAttributes() { // (3)\n*/!*\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n*!*\n  attributeChangedCallback(name, oldValue, newValue) { // (4)\n*/!*\n    this.render();\n  }\n\n}\n\ncustomElements.define(\"time-formatted\", TimeFormatted);\n</script>\n\n<time-formatted id=\"elem\" hour=\"numeric\" minute=\"numeric\" second=\"numeric\"></time-formatted>\n\n<script>\n*!*\nsetInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)\n*/!*\n</script>\n```\n\n1. 渲染逻辑被移动到了 `render()` 这个辅助方法里面。\n2. 这个方法在元素被插入到页面的时候调用。\n3. `attributeChangedCallback` 在 `observedAttributes()` 里的属性改变的时候被调用。\n4. …… 然后重渲染元素。\n5. 最终，一个计时器就这样被我们轻松地实现了。\n\n## 渲染顺序\n\n在 HTML 解析器构建 DOM 的时候，会按照先后顺序处理元素，先处理父级元素再处理子元素。例如，如果我们有 `<outer><inner></inner></outer>`，那么 `<outer>` 元素会首先被创建并接入到 DOM，然后才是 `<inner>`。\n\n这对 custom elements 产生了重要影响。\n\n比如，如果一个 custom element 想要在 `connectedCallback` 内访问 `innerHTML`，它什么也拿不到:\n\n```html run height=40\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n*!*\n    alert(this.innerHTML); // empty (*)\n*/!*\n  }\n\n});\n</script>\n\n*!*\n<user-info>John</user-info>\n*/!*\n```\n\n如果你运行上面的代码，`alert` 出来的内容是空的。\n\n这正是因为在那个阶段，子元素还不存在，DOM 还没有完成构建。HTML 解析器先连接 custom element `<user-info>`，然后再处理子元素，但是那时候子元素还并没有加载上。\n\n如果我们要给 custom element 传入信息，我们可以使用元素属性。它们是即时生效的。\n\n或者，如果我们需要子元素，我们可以使用延迟时间为零的 `setTimeout` 来推迟访问子元素。\n\n这样是可行的：\n\n```html run height=40\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n*!*\n    setTimeout(() => alert(this.innerHTML)); // John (*)\n*/!*\n  }\n\n});\n</script>\n\n*!*\n<user-info>John</user-info>\n*/!*\n```\n\n现在 `alert` 在 `(*)` 行展示了 「John」，因为我们是在 HTML 解析完成之后，才异步执行了这段程序。我们在这个时候处理必要的子元素并且结束初始化过程。\n\n另一方面，这个方案并不是完美的。如果嵌套的 custom element 同样使用了 `setTimeout` 来初始化自身，那么它们会按照先后顺序执行：外层的 `setTimeout` 首先触发，然后才是内层的。\n\n这样外层元素还是早于内层元素结束初始化。\n\n让我们用一个例子来说明：\n\n```html run height=0\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n  connectedCallback() {\n    alert(`${this.id} 已连接。`);\n    setTimeout(() => alert(`${this.id} 初始化完成。`));\n  }\n});\n</script>\n\n*!*\n<user-info id=\"outer\">\n  <user-info id=\"inner\"></user-info>\n</user-info>\n*/!*\n```\n\n输出顺序：\n\n1. outer 已连接。\n2. inner 已连接。\n2. outer 初始化完成。\n4. inner 初始化完成。\n\n我们可以很明显地看到外层元素并没有等待内层元素。\n\n并没有任何内建的回调方法可以在嵌套元素渲染好之后通知我们。但我们可以自己实现这样的回调。比如，内层元素可以分派像 `initialized` 这样的事件，同时外层的元素监听这样的事件并做出响应。\n\n## Customized built-in elements\n\n我们创建的 `<time-formatted>` 这些新元素，并没有任何相关的语义。搜索引擎并不知晓它们的存在，同时无障碍设备也无法处理它们。\n\n但上述两点同样是非常重要的。比如，搜索引擎会对这些事情感兴趣，比如我们真的展示了时间。或者如果我们创建了一个特别的按钮，为什么不复用已有的 `<button>` 功能呢？\n\n我们可以通过继承内建元素的类来扩展和定制它们。\n\n比如，按钮是 `HTMLButtonElement` 的实例，让我们在这个基础上创建元素。\n\n1. 我们的类继承自 `HTMLButtonElement`：\n\n    ```js\n    class HelloButton extends HTMLButtonElement { /* custom element 方法 */ }\n    ```\n\n2. 给 `customElements.define` 提供定义标签的第三个参数：\n    ```js\n    customElements.define('hello-button', HelloButton, *!*{extends: 'button'}*/!*);\n    ```\n    这一步是必要的，因为不同的标签会共享同一个类。\n\n3. 最后，插入一个普通的 `<button>` 标签，但添加 `is=\"hello-button\"` 到这个元素，这样就可以使用我们的 custom element：\n    ```html\n    <button is=\"hello-button\">...</button>\n    ```\n\n下面是一个完整的例子：\n\n```html run autorun=\"no-epub\"\n<script>\n// 这个按钮在被点击的时候说 \"hello\"\nclass HelloButton extends HTMLButtonElement {\n*!*\n  constructor() {\n*/!*\n    super();\n    this.addEventListener('click', () => alert(\"Hello!\"));\n  }\n}\n\n*!*\ncustomElements.define('hello-button', HelloButton, {extends: 'button'});\n*/!*\n</script>\n\n*!*\n<button is=\"hello-button\">Click me</button>\n*/!*\n\n*!*\n<button is=\"hello-button\" disabled>Disabled</button>\n*/!*\n```\n\n我们新定义的按钮继承了内建按钮，所以它拥有和内建按钮相同的样式和标准特性，比如 `disabled` 属性。\n\n## 引用参考\n\n- HTML 现行标准： <https://html.spec.whatwg.org/#custom-elements>。\n- 兼容性： <https://caniuse.com/#feat=custom-elements>。\n\n## 总结\n\n有两种 custom element：\n\n1. \"Autonomous\" —— 全新的标签，继承 `HTMLElement`。\n\n    定义方式：\n\n    ```js\n    class MyElement extends HTMLElement {\n      constructor() { super(); /* ... */ }\n      connectedCallback() { /* ... */ }\n      disconnectedCallback() { /* ... */  }\n      static get observedAttributes() { return [/* ... */]; }\n      attributeChangedCallback(name, oldValue, newValue) { /* ... */ }\n      adoptedCallback() { /* ... */ }\n     }\n    customElements.define('my-element', MyElement);\n    /* <my-element> */\n    ```\n\n2. \"Customized built-in elements\" —— 已有元素的扩展。\n\n    需要多一个 `.define` 参数，同时 `is=\"...\"` 在 HTML 中：\n    ```js\n    class MyButton extends HTMLButtonElement { /*...*/ }\n    customElements.define('my-button', MyElement, {extends: 'button'});\n    /* <button is=\"my-button\"> */\n    ```\n\nCustom element 在各浏览器中的兼容性已经非常好了。Edge 支持地相对较差，但是我们可以使用 polyfill <https://github.com/webcomponents/webcomponentsjs>。",
        "libs": [],
        "children": [
          "live-timer"
        ],
        "headHtml": "<script>\n  /*\nclass TimeFormatted extends HTMLElement {\n\n  render() {\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n  connectedCallback() { // (2)\n    if (!this.rendered) {\n      this.render();\n      this.rendered = true;\n    }\n  }\n\n  static get observedAttributes() { // (3)\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) { // (4)\n    this.render();\n  }\n\n}\n\nwindow.customElements && customElements.define(\"time-formatted\", TimeFormatted);\n*/\n</script>\n",
        "parent": "web-components",
        "updatedAt": 1638611305
      }
    },
    "live-timer": {
      "type": "Task",
      "value": {
        "title": "计时器元素实例",
        "slug": "live-timer",
        "githubPath": "/8-web-components/2-custom-elements/1-live-timer",
        "weight": 1,
        "libs": [],
        "content": "\n\n我们已经创建了 `<time-formatted>` 元素用于展示格式化好的时间。\n\n创建一个 `<live-timer>` 元素用于展示当前时间：\n1. 这个元素应该在内部使用 `<time-formatted>`，不要重复实现这个元素的功能。\n2. 每秒钟更新。\n3. 每一秒钟都应该有一个自定义事件 `tick` 被生成，这个事件的 `event.detail` 属性带有当前日期。（参考章节 <info:dispatch-events> ）。\n\n使用方式：\n\n```html\n<live-timer id=\"elem\"></live-timer>\n\n<script>\n  elem.addEventListener('tick', event => console.log(event.detail));\n</script>\n```\n\n例子：\n\n[iframe src=\"solution\" height=40]",
        "solution": "请注意：\n1. 在元素被从文档移除的时候，我们会清除 `setInterval` 的 timer。这非常重要，否则即使我们不再需要它了，它仍然会继续计时。这样浏览器就不能清除这个元素占用和被这个元素引用的内存了。\n2. 我们可以通过 `elem.date` 属性得到当前时间。类所有的方法和属性天生就是元素的方法和属性。",
        "parent": "custom-elements",
        "version": 1
      }
    },
    "shadow-dom": {
      "type": "Article",
      "value": {
        "title": "影子 DOM（Shadow DOM）",
        "slug": "shadow-dom",
        "githubPath": "/8-web-components/3-shadow-dom",
        "isFolder": false,
        "weight": 3,
        "content": "\n\nShadow DOM 为封装而生。它可以让一个组件拥有自己的「影子」DOM 树，这个 DOM 树不能在主文档中被任意访问，可能拥有局部样式规则，还有其他特性。\n\n## 内建 shadow DOM\n\n你是否曾经思考过复杂的浏览器控件是如何被创建和添加样式的？\n\n比如 `<input type=\"range\">`：\n\n<p>\n<input type=\"range\">\n</p>\n\n浏览器在内部使用 DOM/CSS 来绘制它们。这个 DOM 结构一般来说对我们是隐藏的，但我们可以在开发者工具里面看见它。比如，在 Chrome 里，我们需要打开「Show user agent shadow DOM」选项。\n\n然后 `<input type=\"range\">` 看起来会像这样：\n\n![](shadow-dom-range.png)\n\n你在 `#shadow-root` 下看到的就是被称为「shadow DOM」的东西。\n\n我们不能使用一般的 JavaScript 调用或者选择器来获取内建 shadow DOM 元素。它们不是常规的子元素，而是一个强大的封装手段。\n\n在上面的例子中，我们可以看到一个有用的属性 `pseudo`。这是一个因为历史原因而存在的属性，并不在标准中。我们可以使用它来给子元素加上 CSS 样式，像这样：\n\n```html run autorun\n<style>\n/* 让滑块轨道变红 */\ninput::-webkit-slider-runnable-track {\n  background: red;\n}\n</style>\n\n<input type=\"range\">\n```\n\n重申一次，`pseudo` 是一个非标准的属性。按照时间顺序来说，浏览器首先实验了使用内部 DOM 结构来实现控件，然后，在一段时间之后，shadow DOM 才被标准化来让我们，开发者们，做类似的事。\n\n接下来，我们将要使用现代 shadow DOM 标准，它在 [DOM spec](https://dom.spec.whatwg.org/#shadow-trees) 和其他相关标准中可以被找到。\n\n## Shadow tree\n\n一个 DOM 元素可以有以下两类 DOM 子树：\n\n1. Light tree（光明树） —— 一个常规 DOM 子树，由 HTML 子元素组成。我们在之前章节看到的所有子树都是「光明的」。\n2. Shadow tree（影子树） —— 一个隐藏的 DOM 子树，不在 HTML 中反映，无法被察觉。\n\n如果一个元素同时有以上两种子树，那么浏览器只渲染 shadow tree。但是我们同样可以设置两种树的组合。我们将会在后面的章节 <info:slots-composition> 中看到更多细节。\n\n影子树可以在自定义元素中被使用，其作用是隐藏组件内部结构和添加只在组件内有效的样式。\n\n比如，这个 `<show-hello>` 元素将它的内部 DOM 隐藏在了影子里面：\n\n```html run autorun height=60\n<script>\ncustomElements.define('show-hello', class extends HTMLElement {\n  connectedCallback() {\n    const shadow = this.attachShadow({mode: 'open'});\n    shadow.innerHTML = `<p>\n      Hello, ${this.getAttribute('name')}\n    </p>`;\n  }  \n});\n</script>\n\n<show-hello name=\"John\"></show-hello>\n```\n\n这就是在 Chrome 开发者工具中看到的最终样子，所有的内容都在「#shadow-root」下：\n\n![](shadow-dom-say-hello.png)\n\n首先，调用 `elem.attachShadow({mode: …})` 可以创建一个 shadow tree。\n\n这里有两个限制：\n1.  在每个元素中，我们只能创建一个 shadow root。\n2. `elem` 必须是自定义元素，或者是以下元素的其中一个：「article」、「aside」、「blockquote」、「body」、「div」、「footer」、「h1..h6」、「header」、「main」、「nav」、「p」、「section」或者「span」。其他元素，比如 `<img>`，不能容纳 shadow tree。\n\n`mode` 选项可以设定封装层级。他必须是以下两个值之一：\n- `「open」` —— shadow root 可以通过 `elem.shadowRoot` 访问。\n\n    任何代码都可以访问 `elem` 的 shadow tree。\n- `「closed」` —— `elem.shadowRoot` 永远是 `null`。\n\n    我们只能通过 `attachShadow` 返回的指针来访问 shadow DOM（并且可能隐藏在一个 class 中）。浏览器原生的 shadow tree，比如 `<input type=\"range\">`，是封闭的。没有任何方法可以访问它们。\n\n`attachShadow` 返回的 [shadow root](https://dom.spec.whatwg.org/#shadowroot)，和任何元素一样：我们可以使用 `innerHTML` 或者 DOM 方法，比如 `append` 来扩展它。\n\n我们称有 shadow root 的元素叫做「shadow tree host」，可以通过 shadow root 的 `host` 属性访问：\n\n```js\n// 假设 {mode: \"open\"}，否则 elem.shadowRoot 是 null\nalert(elem.shadowRoot.host === elem); // true\n```\n\n## 封装\n\nShadow DOM 被非常明显地和主文档分开：\n\n1. Shadow DOM 元素对于 light DOM 中的 `querySelector` 不可见。实际上，Shadow DOM 中的元素可能与 light DOM 中某些元素的 id 冲突。这些元素必须在 shadow tree 中独一无二。\n2. Shadow DOM 有自己的样式。外部样式规则在 shadow DOM 中不产生作用。\n\n比如：\n\n```html run untrusted height=40\n<style>\n*!*\n  /* 文档样式对 #elem 内的 shadow tree 无作用 (1) */\n*/!*\n  p { color: red; }\n</style>\n\n<div id=\"elem\"></div>\n\n<script>\n  elem.attachShadow({mode: 'open'});\n*!*\n    // shadow tree 有自己的样式 (2)\n*/!*\n  elem.shadowRoot.innerHTML = `\n    <style> p { font-weight: bold; } </style>\n    <p>Hello, John!</p>\n  `;\n\n*!*\n  // <p> 只对 shadow tree 里面的查询可见 (3)\n*/!*\n  alert(document.querySelectorAll('p').length); // 0\n  alert(elem.shadowRoot.querySelectorAll('p').length); // 1\n</script>  \n```\n\n1. 文档里面的样式对 shadow tree 没有任何效果。\n2. ……但是内部的样式是有效的。\n3. 为了获取 shadow tree 内部的元素，我们可以从树的内部查询。\n\n## 参考\n\n- DOM：<https://dom.spec.whatwg.org/#shadow-trees>\n- 兼容性：<https://caniuse.com/#feat=shadowdomv1>\n- Shadow DOM 在很多其他标准中被提到，比如：[DOM Parsing](https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin) 指定了 shadow root 有 `innerHTML`。\n\n\n## 总结\n\nShadow DOM 是创建组件级别 DOM 的一种方法。\n\n1. `shadowRoot = elem.attachShadow({mode: open|closed})` —— 为 `elem` 创建 shadow DOM。如果 `mode=\"open\"`，那么它通过 `elem.shadowRoot` 属性被访问。\n2. 我们可以使用 `innerHTML` 或者其他 DOM 方法来扩展 `shadowRoot`。\n\nShadow DOM 元素：\n- 有自己的 id 空间。\n- 对主文档的 JavaScript 选择器隐身，比如 `querySelector`。\n- 只使用 shadow tree 内部的样式，不使用主文档的样式。\n\nShadow DOM，如果存在的话，会被浏览器渲染而不是所谓的 「light DOM」（普通子元素）。在 <info:slots-composition> 章节中我们将会看到如何组织它们。",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1564283736
      }
    },
    "template-element": {
      "type": "Article",
      "value": {
        "title": "模板元素",
        "slug": "template-element",
        "githubPath": "/8-web-components/4-template-element",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n内建的 `<template>` 元素用来存储 HTML 模板。浏览器将忽略它的内容，仅检查语法的有效性，但是我们可以在 JavaScript 中访问和使用它来创建其他元素。\n\n从理论上讲，我们可以在 HTML 中的任何位置创建不可见元素来储存 HTML 模板。那 `<template>` 元素有什么优势？\n\n首先，其内容可以是任何有效的HTML，即使它通常需要特定的封闭标签。\n\n例如，我们可以在其中放置一行表格 `<tr>` ：\n```html\n<template>\n  <tr>\n    <td>Contents</td>\n  </tr>\n</template>\n```\n\n通常，如果我们在 `<tr>` 内放置类似 `<div>` 的元素，浏览器会检测到无效的 DOM 结构并对其进行“修复”，然后用 `<table>` 封闭 `<tr>` ，那不是我们想要的。而 `<template>` 则完全保留我们储存的内容。\n\n我们也可以将样式和脚本放入 `<template>` 元素中：\n\n```html\n<template>\n  <style>\n    p { font-weight: bold; }\n  </style>\n  <script>\n    alert(\"Hello\");\n  </script>\n</template>\n```\n\n浏览器认为 `<template>` 的内容“不在文档中”：样式不会被应用，脚本也不会被执行， `<video autoplay>` 也不会运行，等。\n\n当我们将内容插入文档时，该内容将变为活动状态（应用样式，运行脚本等）。\n\n## 插入模板\n\n模板的 `content` 属性可看作[DocumentFragment](info:modifying-document#document-fragment) —— 一种特殊的 DOM 节点。\n\n我们可以将其视为普通的DOM节点，除了它有一个特殊属性：将其插入某个位置时，会被插入的则是其子节点。\n\n例如：\n\n```html run\n<template id=\"tmpl\">\n  <script>\n    alert(\"Hello\");\n  </script>\n  <div class=\"message\">Hello, world!</div>\n</template>\n\n<script>\n  let elem = document.createElement('div');\n\n*!*\n  // Clone the template content to reuse it multiple times\n  elem.append(tmpl.content.cloneNode(true));\n*/!*\n\n  document.body.append(elem);\n  // Now the script from <template> runs\n</script>\n```\n\n让我们用 `<template>` 重写上一章的 Shadow DOM 示例：\n\n```html run untrusted autorun=\"no-epub\" height=60\n<template id=\"tmpl\">\n  <style> p { font-weight: bold; } </style>\n  <p id=\"message\"></p>\n</template>\n\n<div id=\"elem\">Click me</div>\n\n<script>\n  elem.onclick = function() {\n    elem.attachShadow({mode: 'open'});\n\n*!*\n    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)\n*/!*\n\n    elem.shadowRoot.getElementById('message').innerHTML = \"Hello from the shadows!\";\n  };\n</script>\n```\n\n在 `(*)` 行，我们将 `tmpl.content` 作为 `DocumentFragment` 克隆和插入，它的子节点（`<style>`，`<p>`）将代为插入。\n\n它们会变成一个 Shadow DOM：\n\n```html\n<div id=\"elem\">\n  #shadow-root\n    <style> p { font-weight: bold; } </style>\n    <p id=\"message\"></p>\n</div>\n```\n\n## 总结\n\n总结一下：\n\n* `<template>` 的内容可以是任何语法正确的 HTML。\n* `<template> ` 内容被视为“超出文档范围”，因此它不会产生任何影响。\n* 我们可以在JavaScript 中访问 `template.content` ，将其克隆以在新组件中重复使用。\n\n`<template>` 标签非常独特，因为：\n\n* 浏览器将检查其中的HTML语法（与在脚本中使用模板字符串不同）。\n* 但允许使用任何顶级 HTML 标签，即使没有适当包装元素的无意义的元素（例如 `<tr>` ）。\n* 其内容是交互式的：插入其文档后，脚本会运行， `<video autoplay>` 会自动播放。\n\n`<template>` 元素不具有任何迭代机制，数据绑定或变量替换的功能，但我们可以在其基础上实现这些功能。",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1585743387
      }
    },
    "slots-composition": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM 插槽，组成",
        "slug": "slots-composition",
        "githubPath": "/8-web-components/5-slots-composition",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n许多类型的组件，例如标签、菜单、照片库等等，需要内容去渲染。\n\n就像浏览器内建的 `<select>` 需要 `<option>` 子项，我们的 `<custom-tabs>` 可能需要实际的标签内容来起作用。并且一个 `<custom-menu>` 可能需要菜单子项。\n\n使用了 `<custom-menu>` 的代码如下所示：\n\n```html\n<custom-menu>\n  <title>Candy menu</title>\n  <item>Lollipop</item>\n  <item>Fruit Toast</item>\n  <item>Cup Cake</item>\n</custom-menu>\n```\n\n……之后，我们的组件应该正确地渲染成具有给定标题和项目、处理菜单事件等的漂亮菜单。\n\n如何实现呢？\n\n我们可以尝试分析元素内容并动态复制重新排列 DOM 节点。这是可能的，但是如果我们要将元素移动到 Shadow DOM，那么文档的 CSS 样式不能在那里应用，因此文档的视觉样式可能会丢失。看起来还需要做一些事情。\n\n幸运的是我们不需要去做。Shadow DOM 支持 `<slot>` 元素，由 light DOM 中的内容自动填充。\n\n## 具名插槽\n\n让我们通过一个简单的例子看下插槽是如何工作的。\n\n在这里 `<user-card>` shadow DOM 提供两个插槽, 从 light DOM 填充：\n\n```html run autorun=\"no-epub\" untrusted height=80\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <div>Name:\n*!*\n        <slot name=\"username\"></slot>\n*/!*\n      </div>\n      <div>Birthday:\n*!*\n        <slot name=\"birthday\"></slot>\n*/!*\n      </div>\n    `;\n  }\n});\n</script>\n\n<user-card>\n  <span *!*slot=\"username\"*/!*>John Smith</span>\n  <span *!*slot=\"birthday\"*/!*>01.01.2001</span>\n</user-card>\n```\n\n在 shadow DOM 中，`<slot name=\"X\">` 定义了一个“插入点”，一个带有 `slot=\"X\"` 的元素被渲染的地方。\n\n然后浏览器执行”组合“：它从 light DOM 中获取元素并且渲染到 shadow DOM 中的对应插槽中。最后，正是我们想要的 —— 一个能被填充数据的通用组件。\n\n这是编译后，不考虑组合的 DOM 结构：\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n```\n\n我们创建了 shadow DOM，所以它当然就存在了，位于 `#shadow-root` 之下。现在元素同时拥有 light DOM 和 shadow DOM。\n\n为了渲染 shadow DOM 中的每一个 `<slot name=\"...\">` 元素，浏览器在 light DOM 中寻找相同名字的 `slot=\"...\"`。这些元素在插槽内被渲染：\n\n![](shadow-dom-user-card.svg)\n\n结果被叫做扁平化（flattened）DOM：\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <!-- slotted element is inserted into the slot -->\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n</user-card>\n```\n\n……但是 \"flattened\" DOM 仅仅被创建用来渲染和事件处理，是“虚拟”的。虽然是渲染出来了，但文档中的节点事实上并没有到处移动！\n\n如果我们调用 `querySelectorAll` 那就很容易验证：节点仍在它们的位置。\n\n```js\n// light DOM <span> 节点位置依然不变，在 `<user-card>` 里\nalert( document.querySelectorAll('user-card span').length ); // 2\n```\n\n因此，扁平化 DOM 是通过插入插槽从 shadow DOM 派生出来的。浏览器渲染它并且用于样式继承、事件传播。但是 JavaScript 在扁平前仍按原样看到文档。\n\n````warn header=\"仅顶层子元素可以设置 slot=\\\"...\\\" 特性\"\n`slot=\"...\"` 属性仅仅对 shadow host 的直接子代 (在我们的例子中的 `<user-card>` 元素) 有效。对于嵌套元素它将被忽略。\n\n例如，这里的第二个 `<span>` 被忽略了(因为它不是 `<user-card>` 的顶层子元素)：\n```html\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <div>\n    <!-- invalid slot, must be direct child of user-card -->\n    <span slot=\"birthday\">01.01.2001</span>\n  </div>\n</user-card>\n```\n````\n\n如果在 light DOM 里有多个相同插槽名的元素，那么它们会被一个接一个地添加到插槽中。\n\n例如这样：\n```html\n<user-card>\n  <span slot=\"username\">John</span>\n  <span slot=\"username\">Smith</span>\n</user-card>\n```\n\n给这个扁平化 DOM 两个元素，插入到 `<slot name=\"username\">` 里：\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <span slot=\"username\">John</span>\n        <span slot=\"username\">Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n</user-card>\n```\n\n## 插槽后备内容\n\n如果我们在一个 `<slot>` 内部放点什么，它将成为后备内容。如果 light DOM 中没有相应填充物的话浏览器就展示它。\n\n例如，在这里的 shadow DOM 中，如果 light DOM 中没有 `slot=\"username\"` 的话 `Anonymous` 就被渲染。\n\n```html\n<div>Name:\n  <slot name=\"username\">Anonymous</slot>\n</div>\n```\n\n## 默认插槽：第一个不具名的插槽\n\nshadow DOM 中第一个没有名字的 `<slot>` 是一个默认插槽。它从 light DOM 中获取没有放置在其他位置的所有节点。\n\n例如，让我们把默认插槽添加到 `<user-card>`，该位置可以收集有关用户的所有未开槽（unslotted）的信息：\n\n```html run autorun=\"no-epub\" untrusted height=140\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n    <fieldset>\n      <legend>Other information</legend>\n*!*\n      <slot></slot>\n*/!*\n    </fieldset>\n    `;\n  }\n});\n</script>\n\n<user-card>\n*!*\n  <div>I like to swim.</div>\n*/!*\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n*!*\n  <div>...And play volleyball too!</div>\n*/!*\n</user-card>\n```\n\n所有未被插入的 light DOM 内容进入 “其他信息” 字段集。\n\n元素一个接一个的附加到插槽中，因此这两个未插入插槽的信息都在默认插槽中。\n\n扁平化的 DOM 看起来像这样：\n\n```html\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n    <fieldset>\n      <legend>About me</legend>\n*!*\n      <slot>\n        <div>Hello</div>\n        <div>I am John!</div>\n      </slot>\n*/!*\n    </fieldset>\n</user-card>\n```\n\n## Menu example\n\n现在让我们回到在本章开头提到的 `<custom-menu>` 。\n\n我们可以使用插槽来分配元素。\n\n这是 `<custom-menu>`：\n\n```html\n<custom-menu>\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n  <li slot=\"item\">Cup Cake</li>\n</custom-menu>\n```\n\n带有适当插槽的 shadow DOM 模版：\n\n```html\n<template id=\"tmpl\">\n  <style> /* menu styles */ </style>\n  <div class=\"menu\">\n    <slot name=\"title\"></slot>\n    <ul><slot name=\"item\"></slot></ul>\n  </div>\n</template>\n```\n\n1. `<span slot=\"title\">` 进入 `<slot name=\"title\">`。\n2. 模版中有许多 `<li slot=\"item\">`，但是只有一个 `<slot name=\"item\">`。因此所有带有 `slot=\"item\"` 的元素都一个接一个地附加到 `<slot name=\"item\">` 上，从而形成列表。\n\n扁平化的 DOM 变为：\n\n```html\n<custom-menu>\n  #shadow-root\n    <style> /* menu styles */ </style>\n    <div class=\"menu\">\n      <slot name=\"title\">\n        <span slot=\"title\">Candy menu</span>\n      </slot>\n      <ul>\n        <slot name=\"item\">\n          <li slot=\"item\">Lollipop</li>\n          <li slot=\"item\">Fruit Toast</li>\n          <li slot=\"item\">Cup Cake</li>\n        </slot>\n      </ul>\n    </div>\n</custom-menu>\n```\n\n可能会注意到，在有效的 DOM 中，`<li>` 必须是 `<ul>` 的直接子代。但这是扁平化的 DOM，它描述了组件的渲染方式，这样的事情在这里自然发生。\n\n我们只需要添加一个 `click` 事件处理程序来打开/关闭列表，并且 `<custom-menu>` 准备好了：\n\n```js\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n\n    // tmpl is the shadow DOM template (above)\n    this.shadowRoot.append( tmpl.content.cloneNode(true) );\n\n    // we can't select light DOM nodes, so let's handle clicks on the slot\n    this.shadowRoot.querySelector('slot[name=\"title\"]').onclick = () => {\n      // open/close the menu\n      this.shadowRoot.querySelector('.menu').classList.toggle('closed');\n    };\n  }\n});\n```\n\n这是完整的演示：\n\n[iframe src=\"menu\" height=140 edit]\n\n当然我们可以为它添加更多的功能：事件、方法等。\n\n## 更新插槽\n\n如果外部代码想动态 添加/移除 菜单项怎么办？\n\n**如果 添加/删除 了插槽元素，浏览器将监视插槽并更新渲染。**\n\n另外，由于不复制 light DOM 节点，而是仅在插槽中进行渲染，所以内部的变化是立即可见的。\n\n因此我们无需执行任何操作即可更新渲染。但是如果组件想知道插槽的更改，那么可以用 `slotchange` 事件。\n\n例如，这里的菜单项在 1 秒后动态插入，而且标题在 2 秒后改变。\n\n```html run untrusted height=80\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // shadowRoot can't have event handlers, so using the first child\n    this.shadowRoot.firstElementChild.addEventListener('slotchange',\n      e => alert(\"slotchange: \" + e.target.name)\n    );\n  }\n});\n\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Lollipop</li>')\n}, 1000);\n\nsetTimeout(() => {\n  menu.querySelector('[slot=\"title\"]').innerHTML = \"New menu\";\n}, 2000);\n</script>\n```\n\n菜单每次都会更新渲染而无需我们干预。\n\n这里有两个 `slotchange` 事件：\n\n1. 在初始化时:\n\n    `slotchange: title` 立即触发, 因为来自 light DOM 的 `slot=\"title\"` 进入了相应的插槽。\n2. 1 秒后:\n\n    `slotchange: item` 触发, 当一个新的 `<li slot=\"item\">` 被添加。\n\n请注意：2 秒后，如果修改了 `slot=\"title\"` 的内容，则不会发生 `slotchange` 事件。因为没有插槽更改。我们修改了 slotted 元素的内容，这是另一回事。\n\n如果我们想通过 JavaScript 跟踪 light DOM 的内部修改，也可以使用更通用的机制: [MutationObserver](info:mutation-observer)。\n\n## 插槽 API\n\n最后让我们来谈谈与插槽相关的 JavaScript 方法。\n\n正如我们之前所见，JavaScript 会查看真实的 DOM，不展开。但是如果 shadow 树有 `{mode: 'open'}` ，那么我们可以找出哪个元素被放进一个插槽，反之亦然，哪个插槽分配了给这个元素：\n\n- `node.assignedSlot` -- 返回 `node` 分配给的 `<slot>` 元素。\n- `slot.assignedNodes({flatten: true/false})` -- 分配给插槽的 DOM 节点。默认情况下，`flatten` 选项为 `false`。如果显式地设置为 `true`，则它将更深入地查看扁平化 DOM ，如果嵌套了组件，则返回嵌套的插槽，如果未分配节点，则返回备用内容。\n- `slot.assignedElements({flatten: true/false})` -- 分配给插槽的 DOM 元素（与上面相同，但仅元素节点）。\n\n当我们不仅需要显示已插入内容的内容，还需要在 JavaScript 中对其进行跟踪时，这些方法非常有用。\n\n例如，如果 `<custom-menu>` 组件想知道它所显示的内容，那么它可以跟踪 `slotchange` 并从 `slot.assignedElements` 获取：\n\n```html run untrusted height=120\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  items = []\n\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // 插槽能被添加/删除/代替\n*!*\n    this.shadowRoot.firstElementChild.addEventListener('slotchange', e => {\n      let slot = e.target;\n      if (slot.name == 'item') {\n        this.items = slot.assignedElements().map(elem => elem.textContent);\n        alert(\"Items: \" + this.items);\n      }\n    });\n*/!*\n  }\n});\n\n// items 在 1 秒后更新\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Cup Cake</li>')\n}, 1000);\n</script>\n```\n\n\n## 小结\n\n通常，如果一个元素含有 shadow DOM，那么其 light DOM 就不会被展示出来。插槽允许在 shadow DOM 中显示 light DOM 子元素。\n\n插槽有两种：\n\n- 具名插槽：`<slot name=\"X\">...</slot>` - 使用 `slot=\"X\"` 获取 light 子元素。\n- 默认插槽：第一个没有名字的 `<slot>`（随后的未命名插槽将被忽略）- 接受不是插槽的 light 子元素。\n- 如果同一插槽中有很多元素 - 它们会被一个接一个地添加。\n- `<slot>` 元素的内容作为备用。如果插槽没有 light 型的子元素，就会显示。\n\n在其插槽内渲染插槽元素的过程称为“组合”。结果称为“扁平化 DOM”。\n\n组合不会真实的去移动节点，从 JavaScript 的视角看 DOM 仍然是相同的。\n\nJavaScript 可以使用以下的方法访问插槽：\n- `slot.assignedNodes/Elements()` - 返回插槽内的 节点/元素。\n- `node.assignedSlot` - 相反的方法，返回一个节点的插槽。\n\n如果我们想知道显示的内容，可以使用以下方法跟踪插槽位的内容：\n- `slotchange` 事件 - 在插槽第一次填充时触发，并且在插槽元素的 添加/删除/替换 操作（而不是其子元素）时触发，插槽是 `event.target` 。\n- 使用 [MutationObserver](info:mutation-observer) 来深入了解插槽内容，并查看其中的更改。\n\n现在，在 shadow DOM 中有来自 light DOM 的元素时，让我们看看如何正确的设置样式。基本规则是 shadow 元素在内部设置样式，light 元素在外部设置样式，但是有一些例外。\n\n我们将在下一章中看到详细内容。",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1660139232
      }
    },
    "shadow-dom-style": {
      "type": "Article",
      "value": {
        "title": "给 Shadow DOM 添加样式",
        "slug": "shadow-dom-style",
        "githubPath": "/8-web-components/6-shadow-dom-style",
        "isFolder": false,
        "weight": 6,
        "content": "\n\nshadow DOM 可以包含 `<style>` 和 `<link rel=\"stylesheet\" href=\"…\">` 标签。在后一种情况下，样式表是 HTTP 缓存的，因此不会为使用同一模板的多个组件重新下载样式表。\n\n一般来说，局部样式只在 shadow 树内起作用，文档样式在 shadow 树外起作用。但也有少数例外。\n\n## :host\n\n `:host` 选择器允许选择 shadow 宿主（包含 shadow 树的元素）。\n\n例如，我们正在创建 `<custom-dialog>` 元素，并且想使它居中。为此，我们需要对 `<custom-dialog>` 元素本身设置样式。\n\n这正是 `:host` 所能做的：\n\n```html run autorun=\"no-epub\" untrusted height=80\n<template id=\"tmpl\">\n  <style>\n    /* 这些样式将从内部应用到 custom-dialog 元素上 */\n    :host {\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n<custom-dialog>\n  Hello!\n</custom-dialog>\n```\n\n## 级联\n\nshadow 宿主（ `<custom-dialog>` 本身）驻留在 light DOM 中，因此它受到文档 CSS 规则的影响。\n\n如果在局部的 `:host` 和文档中都给一个属性设置样式，那么文档样式优先。\n\n例如，如果在文档中我们有如下样式：\n\n```html\n<style>\ncustom-dialog {\n  padding: 0;\n}\n</style>\n```\n……那么 `<custom-dialog>` 将没有 padding。\n\n这是非常有利的，因为我们可以在其 `:host` 规则中设置 “默认” 组件样式，然后在文档中轻松地覆盖它们。\n\n唯一的例外是当局部属性被标记 `!important` 时，对于这样的属性，局部样式优先。\n\n\n## :host(selector)\n\n与 `:host` 相同，但仅在 shadow 宿主与 `selector` 匹配时才应用样式。\n\n例如，我们希望仅当 `<custom-dialog>` 具有 `centered` 属性时才将其居中:\n\n```html run autorun=\"no-epub\" untrusted height=80\n<template id=\"tmpl\">\n  <style>\n*!*\n    :host([centered]) {\n*/!*\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      border-color: blue;\n    }\n\n    :host {\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n\n<custom-dialog centered>\n  Centered!\n</custom-dialog>\n\n<custom-dialog>\n  Not centered.\n</custom-dialog>\n```\n\n现在附加的居中样式只应用于第一个对话框：`<custom-dialog centered>`。\n\n## :host-context(selector)\n\n与 `:host` 相同，但仅当外部文档中的 shadow 宿主或它的任何祖先节点与 `selector` 匹配时才应用样式。\n\n例如，`:host-context(.dark-theme)` 只有在 `<custom-dialog>` 或者 `<custom-dialog>` 的任何祖先节点上有 `dark-theme` 类时才匹配：\n\n```html\n<body class=\"dark-theme\">\n  <!--\n    :host-context(.dark-theme) 只应用于 .dark-theme 内部的 custom-dialog\n  -->\n  <custom-dialog>...</custom-dialog>\n</body>\n```\n\n总之，我们可以使用 `:host`-family 系列的选择器来对组件的主元素进行样式设置，具体取决于上下文。这些样式（除 `!important` 外）可以被文档样式覆盖。\n\n## 给占槽（ slotted ）内容添加样式\n\n现在让我们考虑有插槽的情况。\n\n占槽元素来自 light DOM，所以它们使用文档样式。局部样式不会影响占槽内容。\n\n在下面的例子中，按照文档样式，占槽的 `<span>` 是粗体，但是它不从局部样式中获取 `background`：\n\n```html run autorun=\"no-epub\" untrusted height=80\n<style>\n*!*\n  span { font-weight: bold }\n*/!*\n</style>\n\n<user-card>\n  <div slot=\"username\">*!*<span>John Smith</span>*/!*</div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      span { background: red; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\n结果是粗体，但不是红色。\n\n如果我们想要在我们的组件中设置占槽元素的样式，有两种选择。\n\n首先，我们可以对 `<slot>` 本身进行样式化，并借助 CSS 继承：\n\n```html run autorun=\"no-epub\" untrusted height=80\n<user-card>\n  <div slot=\"username\">*!*<span>John Smith</span>*/!*</div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      slot[name=\"username\"] { font-weight: bold; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\n这里 `<p>John Smith</p>` 变成粗体，因为 CSS 继承在 `<slot>` 和它的内容之间有效。但是在 CSS 中，并不是所有的属性都是继承的。\n\n另一个选项是使用 `::slotted(selector)` 伪类。它根据两个条件来匹配元素：\n\n1. 这是一个占槽元素，来自于 light DOM。插槽名并不重要，任何占槽元素都可以，但只能是元素本身，而不是它的子元素 。\n2. 该元素与 `selector` 匹配。\n\n在我们的例子中，`::slotted(div)` 正好选择了 `<div slot=\"username\">` ，但是没有选择它的子元素：\n\n```html run autorun=\"no-epub\" untrusted height=80\n<user-card>\n  <div slot=\"username\">\n    <div>John Smith</div>\n  </div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n*!*\n      ::slotted(div) { border: 1px solid red; }\n*/!*\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n```\n\n请注意，`::slotted` 选择器不能用于任何插槽中更深层的内容。下面这些选择器是无效的：\n\n```css\n::slotted(div span) {\n  /* 我们插入的 <div> 不会匹配这个选择器 */\n}\n\n::slotted(div) p {\n  /* 不能进入 light DOM 中选择元素 */\n}\n```\n\n此外，`::sloated` 只能在 CSS 中使用，不能在 `querySelector` 中使用。\n\n## 用自定义 CSS 属性作为勾子\n\n如何在主文档中设置组件的内建元素的样式?\n\n像 `:host` 这样的选择器应用规则到 `<custom-dialog>` 元素或 `<user-card>`，但是如何设置在它们内部的 shadow DOM 元素的样式呢？\n\n没有选择器可以从文档中直接影响 shadow DOM 样式。但是，正如我们暴露用来与组件交互的方法那样，我们也可以暴露 CSS 变量（自定义 CSS 属性）来对其进行样式设置。\n\n**自定义 CSS 属性存在于所有层次，包括 light DOM 和 shadow DOM。**\n\n例如，在 shadow DOM 中，我们可以使用 `--user-card-field-color` CSS 变量来设置字段的样式，而外部文档可以设置它的值：\n\n```html\n<style>\n  .field {\n    color: var(--user-card-field-color, black);\n    /* 如果 --user-card-field-color 没有被声明过，则取值为 black */\n  }\n</style>\n<div class=\"field\">Name: <slot name=\"username\"></slot></div>\n<div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n</style>\n```\n\n然后，我们可以在外部文档中为 `<user-card>` 声明此属性：\n\n```css\nuser-card {\n  --user-card-field-color: green;\n}\n```\n\n自定义 CSS 属性穿透 shadow DOM，它们在任何地方都可见，因此内部的 `.field` 规则将使用它。\n\n以下是完整的示例：\n\n```html run autorun=\"no-epub\" untrusted height=80\n<style>\n*!*\n  user-card {\n    --user-card-field-color: green;\n  }\n*/!*\n</style>\n\n<template id=\"tmpl\">\n  <style>\n*!*\n    .field {\n      color: var(--user-card-field-color, black);\n    }\n*/!*\n  </style>\n  <div class=\"field\">Name: <slot name=\"username\"></slot></div>\n  <div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n</template>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));\n  }\n});\n</script>\n\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n```\n\n## 小结\n\nshadow DOM 可以引入样式，如 `<style>` 或 `<link rel=\"stylesheet\">`。\n\n局部样式可以影响：\n\n- shadow 树,\n- shadow 宿主（通过 `:host`-family 系列伪类），\n- 占槽元素（来自 light DOM），`::slotted(selector)` 允许选择占槽元素本身，但不能选择它们的子元素。\n\n文档样式可以影响：\n- shadow 宿主（因为它位于外部文档中）\n- 占槽元素及占槽元素的内容（因为它们同样位于外部文档中）\n\n当 CSS 属性冲突时，通常文档样式具有优先级，除非属性被标记为 `!important`，那么局部样式优先。\n\nCSS 自定义属性穿透 shadow DOM。它们被用作 “勾子” 来设计组件的样式：\n\n1. 组件使用自定义 CSS 属性对关键元素进行样式设置，比如 `var(--component-name-title, <default value>)` 。\n2. 组件作者为开发人员发布这些属性，它们和其他公共的组件方法一样重要。\n3. 当开发人员想要对一个标题进行样式设计时，他们会为 shadow 宿主或宿主上层的元素赋值 `--component-name-title` CSS 属性。\n4. 奥力给！",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1589705041
      }
    },
    "shadow-dom-events": {
      "type": "Article",
      "value": {
        "title": "Shadow DOM 和事件（events）",
        "slug": "shadow-dom-events",
        "githubPath": "/8-web-components/7-shadow-dom-events",
        "isFolder": false,
        "weight": 7,
        "content": "\n\nShadow tree 背后的思想是封装组件的内部实现细节。\n\n假设，在 `<user-card>` 组件的 shadow DOM 内触发一个点击事件。但是主文档内部的脚本并不了解 shadow DOM 内部，尤其是当组件来自于第三方库。\n\n所以，为了保持细节简单，浏览器会**重新定位**（retarget）事件。\n\n**当事件在组件外部捕获时，shadow DOM 中发生的事件将会以 host 元素作为目标。**\n\n这里有个简单的例子：\n\n```html run autorun=\"no-epub\" untrusted height=60\n<user-card></user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<p>\n      <button>Click me</button>\n    </p>`;\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Inner target: \" + e.target.tagName);\n  }\n});\n\ndocument.onclick =\n  e => alert(\"Outer target: \" + e.target.tagName);\n</script>\n```\n\n如果你点击了 button，就会出现以下信息：\n\n1. Inner target: `BUTTON` —— 内部事件处理程序获取了正确的目标，即 shadow DOM 中的元素。\n2. Outer target: `USER-CARD` —— 文档事件处理程序以 shadow host 作为目标。\n\n事件重定向是一件很棒的事情，因为外部文档并不需要知道组件的内部情况。从它的角度来看，事件是发生在 `<user-card>`。\n\n**如果事件发生在 slotted 元素上，实际存在于 light DOM 上，则不会发生重定向。**\n\n例如，在下面的例子中，如果用户点击了 `<span slot=\"username\">`，那么对于 shadow 和 light 处理程序来说，事件目标就是当前这个 `span` 元素。\n\n```html run autorun=\"no-epub\" untrusted height=60\n<user-card id=\"userCard\">\n*!*\n  <span slot=\"username\">John Smith</span>\n*/!*\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div>\n      <b>Name:</b> <slot name=\"username\"></slot>\n    </div>`;\n\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Inner target: \" + e.target.tagName);\n  }\n});\n\nuserCard.onclick = e => alert(`Outer target: ${e.target.tagName}`);\n</script>\n```\n\n如果单击事件发生在 `\"John Smith\"` 上，则对于内部和外部处理程序来说，其目标是 `<span slot=\"username\">`。这是 light DOM 中的元素，所以没有重定向。\n\n另一方面，如果单击事件发生在源自 shadow DOM 的元素上，例如，在 `<b>Name</b>` 上，然后当它冒泡出 shadow DOM 后，其 `event.target` 将重置为 `<user-card>`。\n\n## 冒泡（bubbling）, event.composedPath()\n\n出于事件冒泡的目的，使用扁平 DOM（flattened DOM）。\n\n所以，如果我们有一个 slot 元素，并且事件发生在它的内部某个地方，那么它就会冒泡到 `<slot>` 并继续向上。\n\n使用 `event.composedPath()` 获得原始事件目标的完整路径以及所有 shadow 元素。正如我们从方法名称中看到的那样，该路径是在组合（composition）之后获取的。\n\n在上面的例子中，扁平 DOM 是：\n\n```html\n<user-card id=\"userCard\">\n  #shadow-root\n    <div>\n      <b>Name:</b>\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n</user-card>\n```\n\n\n因此，对于 `<span slot=\"username\">` 上的点击事件，会调用 `event.composedPath()` 并返回一个数组：[`span`, `slot`, `div`, `shadow-root`, `user-card`, `body`, `html`, `document`, `window`]。在组合之后，这正是扁平 DOM 中目标元素的父链。\n\n```warn header=\"Shadow 树详细信息仅提供给 `{mode:'open'}` 树\"\n如果 shadow 树是用 `{mode: 'closed'}` 创建的，那么组合路径就从 host 开始：`user-card` 及其更上层。\n\n这与使用 shadow DOM 的其他方法的原理类似。closed 树内部是完全隐藏的。\n```\n\n\n## event.composed\n\n大多数事件能成功冒泡到 shadow DOM 边界。很少有事件不能冒泡到 shadow DOM 边界。\n\n这由 `composed` 事件对象属性控制。如果 `composed` 是 `true`，那么事件就能穿过边界。否则它仅能在 shadow DOM 内部捕获。\n\n如果你浏览一下 [UI 事件规范](https://www.w3.org/TR/uievents) 就知道，大部分事件都是 `composed: true`：\n\n- `blur`，`focus`，`focusin`，`focusout`，\n- `click`，`dblclick`，\n- `mousedown`，`mouseup` `mousemove`，`mouseout`，`mouseover`，\n- `wheel`，\n- `beforeinput`，`input`，`keydown`，`keyup`。\n\n所有触摸事件（touch events）及指针事件（pointer events）都是 `composed: true`。\n\n但也有些事件是 `composed: false` 的：\n\n- `mouseenter`，`mouseleave`（它们根本不会冒泡），\n- `load`，`unload`，`abort`，`error`，\n- `select`，\n- `slotchange`。\n\n这些事件仅能在事件目标所在的同一 DOM 中的元素上捕获，\n\n## 自定义事件（Custom events）\n\n当我们发送（dispatch）自定义事件，我们需要设置 `bubbles` 和 `composed` 属性都为 `true` 以使其冒泡并从组件中冒泡出来。\n\n例如，我们在 `div#outer` shadow DOM 内部创建 `div#inner` 并在其上触发两个事件。只有 `composed: true` 的那个自定义事件才会让该事件本身冒泡到文档外面：\n\n```html run untrusted height=0\n<div id=\"outer\"></div>\n\n<script>\nouter.attachShadow({mode: 'open'});\n\nlet inner = document.createElement('div');\nouter.shadowRoot.append(inner);\n\n/*\ndiv(id=outer)\n  #shadow-dom\n    div(id=inner)\n*/\n\ndocument.addEventListener('test', event => alert(event.detail));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n*!*\n  composed: true,\n*/!*\n  detail: \"composed\"\n}));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n*!*\n  composed: false,\n*/!*\n  detail: \"not composed\"\n}));\n</script>\n```\n\n## 总结\n\n事件仅仅是在它们的 `composed` 标志设置为 `true` 的时候才能通过 shadow DOM 边界。\n\n内建事件大部分都是 `composed: true` 的，正如相关规范所描述的那样：\n\n- UI 事件 <https://www.w3.org/TR/uievents>。\n- Touch 事件 <https://w3c.github.io/touch-events>。\n- Pointer 事件 <https://www.w3.org/TR/pointerevents>。\n- ……等等。\n\n也有些内建事件它们是 `composed: false` 的：\n\n- `mouseenter`，`mouseleave`（也不冒泡），\n- `load`，`unload`，`abort`，`error`，\n- `select`，\n- `slotchange`。\n\n这些事件仅能在同一 DOM 中的元素上捕获。\n\n如果我们发送一个 `CustomEvent`，那么我们应该显式地设置 `composed: true`。\n\n请注意，如果是嵌套组件，一个 shadow DOM 可能嵌套到另外一个 shadow DOM 中。在这种情况下合成事件冒泡到所有 shadow DOM 边界。因此，如果一个事件仅用于直接封闭组件，我们也可以在 shadow host 上发送它并设置 `composed: false`。这样它就不在组件 shadow DOM 中，也不会冒泡到更高级别的 DOM。",
        "libs": [],
        "children": [],
        "parent": "web-components",
        "updatedAt": 1598680261
      }
    },
    "regular-expressions": {
      "type": "Article",
      "value": {
        "title": "正则表达式",
        "slug": "regular-expressions",
        "githubPath": "/9-regular-expressions",
        "isFolder": true,
        "weight": 9,
        "content": "\n\n正则表达式是一个查找和替换字符串的强有力的方式。",
        "libs": [],
        "children": [
          "regexp-introduction",
          "regexp-character-classes",
          "regexp-unicode",
          "regexp-anchors",
          "regexp-multiline-mode",
          "regexp-boundary",
          "regexp-escaping",
          "regexp-character-sets-and-ranges",
          "regexp-quantifiers",
          "regexp-greedy-and-lazy",
          "regexp-groups",
          "regexp-backreferences",
          "regexp-alternation",
          "regexp-lookahead-lookbehind",
          "regexp-catastrophic-backtracking",
          "regexp-sticky",
          "regexp-methods"
        ]
      }
    },
    "regexp-introduction": {
      "type": "Article",
      "value": {
        "title": "模式（Patterns）和修饰符（flags）",
        "slug": "regexp-introduction",
        "githubPath": "/9-regular-expressions/01-regexp-introduction",
        "isFolder": false,
        "weight": 1,
        "content": "\n\n正则表达式是提供了一种在文本中进行搜索和替换的强大的方式的模式。\n\n在 JavaScript 中，我们可以通过 [RegExp](mdn:js/RegExp) 对象使用它们，也可以与字符串方法结合使用。\n\n## 正则表达式\n\n正则表达式（可叫作 \"regexp\"，或 \"reg\"）包扩 **模式** 和可选的 **修饰符**。\n\n有两种创建正则表达式对象的语法。\n\n较长一点的语法：\n\n```js\nregexp = new RegExp(\"pattern\", \"flags\");\n```\n\n较短一点的语法，使用斜线 `\"/\"`：\n\n```js\nregexp = /pattern/; // 没有修饰符\nregexp = /pattern/gmi; // 带有修饰符 g、m 和 i（后面会讲到）\n```\n\n斜线 `pattern:/.../` 告诉 JavaScript 我们正在创建一个正则表达式。它的作用与字符串引号的作用相同。\n\n在这两种情况下，`regexp` 都会成为内建类 `RegExp` 的一个实例。\n\n这两种语法之间的主要区别在于，使用斜线 `/.../` 的模式不允许插入表达式（如带有 `${...}` 的字符串模板）。它是完全静态的。\n\n在我们写代码时就知道正则表达式时则会使用斜线的方式 —— 这是最常见的情况。当我们需要从动态生成的字符串“动态”创建正则表达式时，更经常使用 `new RegExp`。例如：\n\n```js\nlet tag = prompt(\"What tag do you want to find?\", \"h2\");\n​\nlet regexp = new RegExp(`<${tag}>`); // 如果在上方输入到 prompt 中的答案是 \"h2\"，则与 /<h2>/ 相同\n```\n\n## 修饰符\n\n正则表达式可能会有的会影响搜索结果的修饰符。\n\n在 JavaScript 中，有 6 个修饰符：\n\n`pattern:i`\n: 使用此修饰符后，搜索时不区分大小写：`A` 和 `a` 之间没有区别（请参见下面的示例）。\n\n`pattern:g`\n: 使用此修饰符后，搜索时会寻找所有的匹配项 —— 没有它，则仅返回第一个匹配项。\n\n`pattern:m`\n: 多行模式（详见 <info:regexp-multiline-mode>）。\n\n`pattern:s`\n: 启用 \"dotall\" 模式，允许点 `pattern:.` 匹配换行符 `\\n`（在 <info:regexp-character-classes> 中有详细介绍）。\n\n`pattern:u`\n: 开启完整的 Unicode 支持。该修饰符能够正确处理代理对。详见 <info:regexp-unicode>。\n\n`pattern:y`\n: 粘滞模式，在文本中的确切位置搜索（详见 <info:regexp-sticky>）\n\n\n```smart header=\"颜色\"\n接下来，各部分的颜色如下：\n​\n- 正则表达式 —— `pattern:red`\n- 字符串（我们搜索的地方）—— `subject:blue`\n- 结果 —— `match:green`\n```\n\n## 搜索：str.match\n\n正如前面所提到的，将正则表达式和字符串方法结合一起使用。\n\n`str.match(regexp)` 方法在字符串 `str` 中寻找 `regexp` 的所有匹配项。\n\n它有 3 种工作模式：\n\n1. 如果正则表达式具有修饰符 `pattern:g`，它返回一个由所有匹配项所构成的数组：\n    ```js run\n    let str = \"We will, we will rock you\";\n\n    alert( str.match(/we/gi) ); // We,we（由两个匹配的子字符串构成的数组）\n    ```\n    请注意，`match:We` 和 `match:we` 都被找到了，因为修饰符 `pattern:i` 使得正则表达式在进行搜索时不区分大小写。\n\n2. 如果没有这样的修饰符，它则会以数组形式返回第一个匹配项，索引 `0` 处保存着完整的匹配项，返回的结果的属性中还有一些其他详细信息：\n    ```js run\n    let str = \"We will, we will rock you\";\n\n    let result = str.match(/we/i); // 没有修饰符 g\n\n    alert( result[0] );     // We（第一个匹配项）\n    alert( result.length ); // 1\n\n    // 详细信息：\n    alert( result.index );  // 0（匹配项的位置）\n    alert( result.input );  // We will, we will rock you（源字符串）\n    ```\n    如果正则表达式中有一部分内容被包在括号里，那么返回的数组可能会有 `0` 以外的索引。我们将在 <info:regexp-groups> 中学习这部分相关内容。\n\n3. 最后，如果没有匹配项，则返回 `null`（无论是否有修饰符 `pattern:g`）。\n\n    这是一个非常重要的细微差别。如果没有匹配项，我们不会收到一个空数组，而是会收到 `null`。忘了这一点可能会导致错误，例如：\n\n    ```js run\n    let matches = \"JavaScript\".match(/HTML/); // = null\n\n    if (!matches.length) { // Error: Cannot read property 'length' of null\n      alert(\"Error in the line above\");\n    }\n    ```\n\n    如果我们希望结果始终是一个数组，我们可以这样写：\n\n    ```js run\n    let matches = \"JavaScript\".match(/HTML/)*!* || []*/!*;\n\n    if (!matches.length) {\n      alert(\"No matches\"); // 现在可以了\n    }\n    ```\n\n## 替换：str.replace\n\n`str.replace(regexp, replacement)` 方法使用 `replacement` 替换在字符串 `str` 中找到的 `regexp` 的匹配项（如果带有修饰符 `pattern:g` 则替换所有匹配项，否则只替换第一个）。\n\n例如：\n\n```js run\n// 没有修饰符 g\nalert( \"We will, we will\".replace(/we/i, \"I\") ); // I will, we will\n\n// 带有修饰符 g\nalert( \"We will, we will\".replace(/we/ig, \"I\") ); // I will, I will\n```\n\n第二个参数是字符串 `replacement`。我们可以在其中使用特殊的字符组合来对匹配项进行插入：\n\n| 符号 | 在替换字符串中的行为 |\n|--------|--------|\n|`$&`|插入整个匹配项|\n|<code>$&#096;</code>|插入字符串中匹配项之前的字符串部分|\n|`$'`|插入字符串中匹配项之后的字符串部分|\n|`$n`|如果 `n` 是一个 1-2 位的数字，则插入第 n 个分组的内容，详见 <info:regexp-groups>|\n|`$<name>`|插入带有给定 `name` 的括号内的内容，详见 <info:regexp-groups>|\n| `$$` | 插入字符 `$` |\n\n带有 `pattern:$&` 的一个示例：\n\n```js run\nalert( \"I love HTML\".replace(/HTML/, \"$& and JavaScript\") ); // I love HTML and JavaScript\n```\n\n## 测试：regexp.test\n\n`regexp.test(str)` 方法寻找至少一个匹配项，如果找到了，则返回 `true`，否则返回 `false`。\n\n```js run\nlet str = \"I love JavaScript\";\nlet regexp = /LOVE/i;\n\nalert( regexp.test(str) ); // true\n```\n\n在后面的章节中，我们会学习更多正则表达式，通过更多的例子，也会遇到其他的方法。\n\n关于这些方法的完整信息请见 <info:regexp-methods>。\n\n## 总结\n\n- 正则表达式由模式和可选择修饰符构成：`pattern:g`、`pattern:i`、`pattern:m`、`pattern:u`、`pattern:s` 和 `pattern:y`。\n- 没有修饰符和特殊符号（稍后我们会学到），那么正则表达式的搜索和子字符串的搜索相同。\n- `str.match(regexp)` 方法寻找匹配项：如果带有修饰符 `pattern:g`，则会返回所有匹配项，否则只会返回第一个匹配项。\n- `str.replace(regexp, replacement)` 方法使用 `replacement` 替换 `regexp` 的匹配项：如果带有修饰符 `pattern:g`，则会替换所有匹配项，否则只会替换第一个匹配项。\n- `regexp.test(str)` 方法用于测试，如果找到至少一个匹配项则返回 `true`，否则返回 `false`。",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1667114531
      }
    },
    "regexp-character-classes": {
      "type": "Article",
      "value": {
        "title": "字符类",
        "slug": "regexp-character-classes",
        "githubPath": "/9-regular-expressions/02-regexp-character-classes",
        "isFolder": false,
        "weight": 2,
        "content": "\n\n考虑一个实际的任务 —— 我们有一个电话号码，例如 `\"+7(903)-123-45-67\"`，我们需要将其转换为纯数字：`79031234567`。\n\n为此，我们可以查找并删除所有非数字的内容。字符类可以帮助我们实现它。\n\n**字符类（Character classes）** 是一种特殊的符号，匹配特定集合中的任何符号。\n\n首先，让我们探索“数字”类。它写为 `pattern:\\d`，对应于“任何一位数字”。\n\n例如，让我们找到电话号码的第一个数字：\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet regexp = /\\d/;\n\nalert( str.match(regexp) ); // 7\n```\n\n如果没有修饰符 `pattern:g`，则正则表达式仅查找第一个匹配项，即第一个数字 `pattern:\\d`。\n\n让我们添加修饰符 `pattern:g` 来查找所有数字：\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet regexp = /\\d/g;\n\nalert( str.match(regexp) ); // 匹配项构成的数组：7,9,0,3,1,2,3,4,5,6,7\n\n// 让我们将其输出为纯数字构成的电话号码：\nalert( str.match(regexp).join('') ); // 79031234567\n```\n\n这是数字的字符类。还有其他字符类。\n\n最常用的是：\n\n`pattern:\\d`（\"d\" 来自 \"digit\"）\n: 数字：从 `0` 到 `9` 的字符。\n\n`pattern:\\s`（\"s\" 来自 \"space\"）\n: 空格符号：包括空格，制表符 `\\t`，换行符 `\\n` 和其他少数稀有字符，例如 `\\v`、`\\f` 和 `\\r`。\n\n`pattern:\\w`（\"w\" 来自 \"word\"）\n: “单字”字符：拉丁字母或数字或下划线 `_`。非拉丁字母（如西里尔字母或印地文）不属于 `pattern:\\w`。\n\n例如，`pattern:\\d\\s\\w` 表示“数字”，后跟“空格字符”，后跟“单字字符”，例如 `match:1 a`。\n\n**正则表达式可能同时包含常规符号和字符类。**\n\n例如，`pattern:CSS\\d` 匹配 `match:CSS` 后面带有一个数字的字符串：\n\n```js run\nlet str = \"Is there CSS4?\";\nlet regexp = /CSS\\d/\n\nalert( str.match(regexp) ); // CSS4\n```\n\n我们还可以使用更多字符类：\n\n```js run\nalert( \"I love HTML5!\".match(/\\s\\w\\w\\w\\w\\d/) ); // ' HTML5'\n```\n\n匹配项（每个正则表达式字符类都有对应的结果字符）：\n\n![](love-html5-classes.svg)\n\n## 反向类\n\n对于每个字符类，都有一个“反向类”，用相同的字母表示，但是大写的。\n\n“反向”表示它与所有其他字符匹配，例如：\n\n`pattern:\\D`\n: 非数字：除 `pattern:\\d` 以外的任何字符，例如字母。\n\n`pattern:\\S`\n: 非空格符号：除 `pattern:\\s` 以外的任何字符，例如字母。\n\n`pattern:\\W`\n: 非单字字符：除 `pattern:\\w` 以外的任何字符，例如非拉丁字母或空格。\n\n在本章的开头，我们看到了如何从 `subject:+7(903)-123-45-67` 这样的字符串中创建一个只包含数字的电话号码：找到所有的数字并将它们连接起来。\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.match(/\\d/g).join('') ); // 79031234567\n```\n\n另一种快捷的替代方式是查找非数字 `pattern:\\D` 并将其从字符串中删除：\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.replace(/\\D/g, \"\") ); // 79031234567\n```\n\n## 点（.）匹配“任何字符”\n\n点 `pattern:.` 是一种特殊字符类，它与“除换行符之外的任何字符”匹配。\n\n例如：\n\n```js run\nalert( \"Z\".match(/./) ); // Z\n```\n\n或在正则表达式中间：\n\n```js run\nlet regexp = /CS.4/;\n\nalert( \"CSS4\".match(regexp) ); // CSS4\nalert( \"CS-4\".match(regexp) ); // CS-4\nalert( \"CS 4\".match(regexp) ); // CS 4（空格也是一个字符）\n```\n\n请注意，点表示“任何字符”，而不是“缺少字符”。必须有一个与之匹配的字符：\n\n```js run\nalert( \"CS4\".match(/CS.4/) ); // null，没有匹配项，因为这里没有与点匹配的字符\n```\n\n### 带有修饰符 \"s\" 时点字符类匹配任何字符\n\n默认情况下，点与换行符 `\\n` 不匹配。\n\n例如，正则表达式 `pattern:A.B` 匹配 `match:A`，然后匹配 `match:B` 和它们之间的任何字符，除了换行符`\\n`：\n\n```js run\nalert( \"A\\nB\".match(/A.B/) ); // null（无匹配项）\n```\n\n在很多情况下，我们希望点能够匹配“任何字符”，包括换行符。\n\n这就是修饰符 `pattern:s` 所做的事。如果有一个正则表达式具有该修饰符，那么点 `pattern:.` 能够匹配任何字符：\n\n```js run\nalert( \"A\\nB\".match(/A.B/s) ); // A\\nB（匹配了！）\n```\n\n````warn header=\"IE 浏览器不支持\"\nIE 浏览器不支持 `pattern:s` 修饰符。\n\n幸运的是，有一个替代方案，我们可以使用像 `pattern:[\\s\\S]` 这样的正则表达式来匹配“任何字符”（此模式将在 <info:regexp-character-sets-and-ranges> 中介绍）。\n\n```js run\nalert( \"A\\nB\".match(/A[\\s\\S]B/) ); // A\\nB（匹配了！）\n```\n\n模式 `pattern:[\\s\\S]` 从字面上意思是：“空格字符或非空格字符”。换句话说，“任何字符”。我们可以使用另一对互补的类，例如 `pattern:[\\d\\D]`。甚至是 `pattern:[^]` —— 意思是匹配任何字符，除了什么都没有。\n\n如果我们希望两种“点”都使用相同的模式，也可以使用此技巧：实际的点 `pattern:.` 表现常规方式（“不包括换行符”），以及带有 `pattern:[\\s\\S]` 或类似形式匹配“任何字符”。\n````\n\n````warn header=\"注意空格\"\n通常我们很少注意空格。对我们来说，字符串 `subject:1-5` 和 `subject:1 - 5` 几乎相同。\n\n但是，如果正则表达式未考虑空格，则可能无法正常工作。\n\n让我们尝试查找由连字符（-）分隔的数字：\n\n```js run\nalert( \"1 - 5\".match(/\\d-\\d/) ); // null，没有匹配项！\n```\n\n让我们修复一下，在正则表达式中添加空格 `pattern:\\d - \\d`：\n\n```js run\nalert( \"1 - 5\".match(/\\d - \\d/) ); // 1 - 5，现在可以了\n// 或者我们可以使用 \\s 类：\nalert( \"1 - 5\".match(/\\d\\s-\\s\\d/) ); // 1 - 5，也可以\n```\n\n**一个空格是一个字符。与其他字符同等重要。**\n\n我们无法在正则表达式中添加或删除空格后，还期望它的作用能像之前那样不被改变。\n\n换句话说，在正则表达式中，所有字符都很重要，空格也很重要。\n````\n\n## 总结\n\n存在以下字符类：\n\n- `pattern:\\d` —— 数字。\n- `pattern:\\D` —— 非数字。\n- `pattern:\\s` —— 空格符号，制表符，换行符。\n- `pattern:\\S` —— 除了 `pattern:\\s` 。\n- `pattern:\\w` —— 拉丁字母，数字，下划线 `'_'`。\n- `pattern:\\W` —— 除了 `pattern:\\w`。\n- `pattern:.` —— 带有修饰符 `'s'` 时匹配任何字符，否则匹配除换行符 `\\n` 之外的任何字符。\n\n……但这还不是全部！\n\nJavaScript 用于字符串的 Unicode 编码提供了很多字符属性，例如：这个字母属于哪种语言（如果它是一个字母），它是标点符号吗，等等。\n\n我们也可以通过这些属性进行搜索。这需要修饰符 `pattern:u`，我们将在下一篇文章中介绍。",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1659688141
      }
    },
    "regexp-unicode": {
      "type": "Article",
      "value": {
        "title": "Unicode：修饰符 \"u\" 和类 \\p{...}",
        "slug": "regexp-unicode",
        "githubPath": "/9-regular-expressions/03-regexp-unicode",
        "isFolder": false,
        "weight": 3,
        "content": "\n\nJavaScript 对字符串使用 [Unicode 编码](https://en.wikipedia.org/wiki/Unicode)。大多数字符使用 2 个字节编码，但这种方式只能编码最多 65536 个字符。\n\n这个范围不足以对所有可能的字符进行编码，这就是为什么使用 4 个字节对一些罕见的字符进行编码，比如 `𝒳`（数学符号 X）或 `😄`（笑脸），一些象形文字等等。\n\n下面是一些字符对应的 Unicode 值：\n\n| 字符         | Unicode   | Unicode 中的字节数     |\n| ------------ | --------- | ---------------------- |\n| a            | `0x0061`  | 2                      |\n| ≈            | `0x2248`  | 2                      |\n| 𝒳            | `0x1d4b3` | 4                      |\n| 𝒴            | `0x1d4b4` | 4                      |\n| 😄           | `0x1f604` | 4                      |\n\n所以像 `a` 和 `≈` 这样的字符占用 2 个字节，而 `𝒳`，`𝒴` 和 `😄` 的对应编码则更长，占用 4 个字节。\n\n很久以前，当 JavaScript 被发明出来的时候，Unicode 编码要更加简单：当时没有 4 个字节的字符。所以，有些语言功能现在仍无法正确处理它们。\n\n比如 `length` 认为这里有 2 个字符：\n\n```js run\nalert('😄'.length); // 2\nalert('𝒳'.length); // 2\n```\n\n……但我们可以清楚地认识到这里只有一个字符，对吧？关键在于 `length` 把 4 个字节当成了 2 个 2 字节长的字符。这是不对的，因为它们必须被当作一个整体来考虑（即所谓的“代理对（surrogate pair）”，你可以在 <info:string> 中阅读关于代理对的更多信息）。\n\n默认情况下，正则表达式也会把一个 4 个字节的“长字符”当成一对 2 个字节长的字符。正如在字符串中遇到的情况，这将导致一些奇怪的结果。我们很快会在后面的章节 <info:regexp-character-sets-and-ranges> 中遇到。\n\n与字符串有所不同的是，正则表达式有一个修饰符 `pattern:u` 被用以解决此类问题。当一个正则表达式带有这个修饰符后，4 个字节长的字符将被正确地处理。同时也能够使用 Unicode 属性进行查找了，我们接下来就一起学习它吧。\n\n## Unicode 属性 \\p{...}\n\nUnicode 中的每个字符都有很多属性。它们描述了字符所属的“类别”，包含了关于字符的各种信息。\n\n例如，如果一个字符具有 `Letter` 属性，这意味着这个字符归属于（任意语言的）字母表。而 `Number` 属性则表示这是一个数字：也许是阿拉伯数字，亦或是中文数字，等等。\n\n我们可以查找具有某种属性的字符，写作 `pattern:\\p{…}`。为了使用 `pattern:\\p{…}`，一个正则表达式必须使用修饰符 `pattern:u`。\n\n举个例子，`\\p{Letter}` 表示任何语言中的一个字母。我们也可以使用 `\\p{L}`，因为 `L` 是 `Letter` 的一个别名。对于每种属性而言，几乎都存在对应的缩写别名。\n\n在下面的例子中会找出来 3 种字母：英语、格鲁吉亚语和韩语。\n\n```js run\nlet str = \"A ბ ㄱ\";\n\nalert( str.match(/\\p{L}/gu) ); // A,ბ,ㄱ\nalert( str.match(/\\p{L}/g) ); // null（没有匹配项，因为没有修饰符 \"u\"）\n```\n\n以下是主要的字符类别和它们对应的子类别：\n\n- 字母（Letter）`L`：\n  - 小写（lowercase）`Ll`，\n  - 修饰（modifier）`Lm`，\n  - 首字母大写（titlecase）`Lt`，\n  - 大写（uppercase）`Lu`，\n  - 其它（other）`Lo`。\n- 数字（Number）`N`：\n  - 十进制数字（decimal digit）`Nd`，\n  - 字母数字（letter number）`Nl`，\n  - 其它（other）`No`。\n- 标点符号（Punctuation）`P`：\n  - 连接符（connector）`Pc`，\n  - 横杠（dash）`Pd`，\n  - 起始引号（initial quote）`Pi`，\n  - 结束引号（final quote）`Pf`，\n  - 开（open）`Ps`，\n  - 闭（close）`Pe`，\n  - 其它（other）`Po`。\n- 标记（Mark）`M`（accents etc）：\n  - 间隔合并（spacing combining）`Mc`，\n  - 封闭（enclosing）`Me`，\n  - 非间隔（non-spacing）`Mn`。\n- 符号（Symbol）`S`：\n  - 货币（currency）`Sc`，\n  - 修饰（modifier）`Sk`，\n  - 数学（math）`Sm`，\n  - 其它（other）`So`。\n- 分隔符（Separator）`Z`：\n  - 行（line）`Zl`，\n  - 段落（paragraph）`Zp`，\n  - 空格（space）`Zs`。\n- 其它（Other）`C`：\n  - 控制符（control）`Cc`，\n  - 格式（format）`Cf`，\n  - 未分配（not assigned）`Cn`，\n  - 私有（private use）`Co`，\n  - 代理伪字符（surrogate）`Cs`。\n\n\n因此，比如说我们需要小写的字母，就可以写成 `pattern:\\p{Ll}`，标点符号写作 `pattern:\\p{P}` 等等。\n\n也有其它派生的类别，例如：\n- `Alphabetic`（`Alpha`），包含了字母 `L`，加上字母数字 `Nl`（例如 Ⅻ —— 罗马数字 12），加上一些其它符号 `Other_Alphabetic`（`OAlpha`）。\n- `Hex_Digit` 包括 16 进制数字 `0-9`，`a-f`。\n- ……等等。\n\nUnicode 支持很多不同的属性，列出整个清单需要占用大量的篇幅，因此在这里列出相关的链接：\n\n- 列出一个字符的所有属性：<https://unicode.org/cldr/utility/character.jsp>.\n- 按照属性列出所有的字符：<https://unicode.org/cldr/utility/list-unicodeset.jsp>.\n- 属性的对应缩写形式：<https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt>.\n- 以文本格式整理的所有 Unicode 字符，包含了所有的属性：<https://www.unicode.org/Public/UCD/latest/ucd/>.\n\n### 举例：16 进制数字\n\n举个例子，让我们来查找 16 进制数字，写作 `xFF` 其中 `F` 是一个 16 进制的数字（0..9 或者 A..F）。\n\n一个 16 进制数字可以表示为 `pattern:\\p{Hex_Digit}`：\n\n```js run\nlet regexp = /x\\p{Hex_Digit}\\p{Hex_Digit}/u;\n\nalert(\"number: xAF\".match(regexp)); // xAF\n```\n\n### 举例：中文字符\n\n让我们再来查找中文字符。\n\n有一个 Unicode 属性 `Script`（一个书写系统），这个属性可能有一个值：`Cyrillic`、`Greek`、`Arabic`、`Han`（中文）等等，[这里是一个完整的列表](https://en.wikipedia.org/wiki/Script_(Unicode))。\n\n要在给定的书写系统中查找字符，我们需要使用 `pattern:Script=<value>`，例如对于西里尔字母：`pattern:\\p{sc=Cyrillic}`，中文象形文字：`pattern:\\p{sc=Han}`，等等。\n\n```js run\nlet regexp = /\\p{sc=Han}/gu; // 返回中文象形文字\n\nlet str = `Hello Привет 你好 123_456`;\n\nalert( str.match(regexp) ); // 你,好\n```\n\n### 举例：货币\n\n表示货币的字符，例如 `$`、`€` 和 `¥`，具有 Unicode 属性 `pattern:\\p{Currency_Symbol}`，缩写为 `pattern:\\p{Sc}`。\n\n让我们用它来查找格式为“货币，接着是一个数字”的价格：\n\n```js run\nlet regexp = /\\p{Sc}\\d/gu;\n\nlet str = `Prices: $2, €1, ¥9`;\n\nalert( str.match(regexp) ); // $2,€1,¥9\n```\n\n稍后，在文章 <info:regexp-quantifiers> 中我们将学习如何查找包含很多位的数字。\n\n## 总结\n\n修饰符 `pattern:u` 表示启用正则表达式中对 Unicode 的支持。\n\n这意味着两件事：\n\n1. 4 个字节长的字符被以正确的方式处理：被看成单个字符，而不是 2 个 2 字节长的字符。\n2. Unicode 属性可以被用于查找：`\\p{…}`。\n\n有了 unicode 属性我们可以查找给定语言中的词，特殊字符（引用，货币）等等。",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1659781459
      }
    },
    "regexp-anchors": {
      "type": "Article",
      "value": {
        "title": "锚点：字符串开始 ^ 和末尾 $",
        "slug": "regexp-anchors",
        "githubPath": "/9-regular-expressions/04-regexp-anchors",
        "isFolder": false,
        "weight": 4,
        "content": "\n\n插入符号 `pattern:^` 和美元符号 `pattern:$` 在正则表达式中具有特殊的含义。它们被称为“锚点”。\n\n插入符号 `pattern:^` 匹配文本开头，而美元符号 `pattern:$` 则匹配文本末尾。\n\n举个例子，让我们测试一下文本是否以 `Mary` 开头：\n\n```js run\nlet str1 = \"Mary had a little lamb\";\nalert( /^Mary/.test(str1) ); // true\n```\n\n该模式 `pattern:^Mary` 表示：字符串开始，紧接着就是 \"Mary\"。\n\n与此类似，我们可以用 `pattern:snow$` 来测试文本是否以 `snow` 结尾：\n\n```js run\nlet str1 = \"it's fleece was white as snow\";\nalert( /snow$/.test(str1) ); // true\n```\n\n在以上这些特殊的例子中我们实际上可以用 `startsWith/endsWith` 来代替。正则表达式应该被用于更加复杂的测试。\n\n## 测试完全匹配\n\n这两个锚点 `pattern:^...$` 放在一起通常被用于测试一个字符串是否完全匹配一个模式。例如，检查用户输入的格式是否正确。\n\n让我们测试一个字符串是否是 `12:34` 格式的时间。即，两位数，然后是一个冒号，接着是另一个两位数。\n\n用正则表达式来表示就是 `pattern:\\d\\d:\\d\\d`：\n\n```js run\nlet goodInput = \"12:34\";\nlet badInput = \"12:345\";\n\nlet regexp = /^\\d\\d:\\d\\d$/;\nalert( regexp.test(goodInput) ); // true\nalert( regexp.test(badInput) ); // false\n```\n\n在这个例子中 `pattern:\\d\\d:\\d\\d` 所对应的匹配项必须正好在文本 `pattern:^` 的开头之后开始，并且结尾 `pattern:$` 必须紧跟其后。\n\n整个字符串必须完全符合这个格式。如果其中有任何偏差或额外的字符，结果将为 `false`。\n\n如果有修饰符 `pattern:m`，那么锚点的行为将会不同。我们将在下一篇文章中学习这一点。\n\n```smart header=\"锚点“宽度”为零\"\n锚点 `pattern:^` 和 `pattern:$` 属于测试。它们的宽度为零。\n\n换句话说，它们并不匹配一个具体的字符，而是让正则引擎测试所表示的条件（文本开头/文本末尾）。\n```",
        "libs": [],
        "children": [
          "start-end"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1659702232
      }
    },
    "start-end": {
      "type": "Task",
      "value": {
        "title": "正则表达式 ^$",
        "slug": "start-end",
        "githubPath": "/9-regular-expressions/04-regexp-anchors/1-start-end",
        "weight": 1,
        "libs": [],
        "content": "\n\n什么字符串可以匹配模式 `^$`？",
        "solution": "空字符串是唯一的匹配项：它开始并立即结束。\n\n这个题目再次证明了锚点不是字符串，而是测试。\n\n对于空字符串 `\"\"`，正则表达式引擎将会首先匹配 `pattern:^`（输入开始），匹配成功，然后立即匹配结束 `pattern:$`，也匹配成功。所空字符串是匹配项。",
        "parent": "regexp-anchors",
        "version": 1
      }
    },
    "regexp-multiline-mode": {
      "type": "Article",
      "value": {
        "title": "锚点 ^ $ 的多行模式，修饰符 \"m\"",
        "slug": "regexp-multiline-mode",
        "githubPath": "/9-regular-expressions/05-regexp-multiline-mode",
        "isFolder": false,
        "weight": 5,
        "content": "\n\n多行模式由修饰符 `pattern:m` 启用。\n\n它只影响 `pattern:^` 和 `pattern:$` 的行为。\n\n在多行模式下，它们不仅仅匹配文本的开始与末尾，还匹配每一行的开始与末尾。\n\n## 搜索行的开头 ^\n\n在这个有多行文本的例子中，模式 `/^\\d/gm` 将从每行的开头取一个数字：\n\n```js run\nlet str = `1st place: Winnie\n2nd place: Piglet\n3rd place: Eeyore`;\n\n*!*\nconsole.log( str.match(/^\\d/gm) ); // 1, 2, 3\n*/!*\n```\n\n没有修饰符 `pattern:m` 时，仅会匹配第一个数字：\n\n```js run\nlet str = `1st place: Winnie\n2nd place: Piglet\n3rd place: Eeyore`;\n\n*!*\nconsole.log( str.match(/^\\d/g) ); // 1\n*/!*\n```\n\n这是因为默认情况下，锚点 `^` 仅匹配文本的开头，在多行模式下，它匹配行的开头。\n\n```smart\n“行的开头”表示“就在换行符之后”：多行模式下的测试 `pattern:^` 匹配所有以换行符 `\\n` 开头的位置。\n\n以及在文本开始的位置。\n```\n\n## 搜索行的末尾 $\n\n美元符 `pattern:$` 的行为也类似。\n\n正则表达式 `pattern:\\d$` 寻找每行的最后一个数字\n\n```js run\nlet str = `Winnie: 1\nPiglet: 2\nEeyore: 3`;\n\nconsole.log( str.match(/\\d$/gm) ); // 1,2,3\n```\n\n没有修饰符 `pattern:m`，那么美元符 `pattern:$` 将只会匹配整个文本的末尾，所以只有最后一个数字会被匹配。\n\n```smart\n“行的末尾”表示“就在换行符之前”：多行模式下的测试 `pattern:$` 匹配所有以换行符 `\\n` 结尾的位置。\n\n以及在文本末尾的位置。\n```\n\n## 搜索 \\n 而不是 ^ $\n\n要寻找新的一行，我们不仅可以使用锚点 `pattern:^` 和 `pattern:$`，也可以使用换行符 `\\n`。\n\n区别是什么？让我们看个例子。\n\n在这里我们使用 `pattern:\\d\\n` 进行搜索，而不是使用 `pattern:\\d$`：\n\n```js run\nlet str = `Winnie: 1\nPiglet: 2\nEeyore: 3`;\n\nconsole.log( str.match(/\\d\\n/g) ); // 1\\n,2\\n\n```\n\n正如我们所看到的，这里找到了 2 个匹配项而不是 3 个。\n\n这是因为在 `subject:3` 之后没有换行符（但是有文本末尾，所以它匹配 `pattern:$`）。\n\n另一个区别是，现在每个匹配项都包含一个换行符 `match:\\n`。与锚点 `pattern:^` `pattern:$` 不同，锚点只测试条件（行的开始/末尾），而 `\\n` 是一个字符，因此它成为了结果的一部分。\n\n因此，当我们需要结果中有换行符时，使用 `\\n`。而锚点则用于在行的开头/末尾查找某些内容。",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1667114531
      }
    },
    "regexp-boundary": {
      "type": "Article",
      "value": {
        "title": "词边界：\\b",
        "slug": "regexp-boundary",
        "githubPath": "/9-regular-expressions/06-regexp-boundary",
        "isFolder": false,
        "weight": 6,
        "content": "\n\n词边界 `pattern:\\b` 是一种检查，就像 `pattern:^` 和 `pattern:$` 一样。\n\n当正则表达式引擎（实现正则表达式搜索的程序模块）遇到 `pattern:\\b` 时，它会检查字符串中的位置是否是词边界。\n\n有三种不同的位置可作为词边界：\n\n- 在字符串开头，如果第一个字符是单词字符 `pattern:\\w`。\n- 在字符串中的两个字符之间，其中一个是单词字符 `pattern:\\w`，另一个不是。\n- 在字符串末尾，如果最后一个字符是单词字符 `pattern:\\w`。\n\n例如，可以在 `subject:Hello, Java!` 中找到 `pattern:\\bJava\\b` 的匹配项，其中 `subject:Java` 是一个独立的单词，而在 `subject:Hello, JavaScript!` 中则不行。\n\n```js run\nalert( \"Hello, Java!\".match(/\\bJava\\b/) ); // Java\nalert( \"Hello, JavaScript!\".match(/\\bJava\\b/) ); // null\n```\n\n在字符串 `subject:Hello, Java!` 中，以下位置对应于 `pattern:\\b`：\n\n![](hello-java-boundaries.svg)\n\n因此，它与模式 `pattern:\\bHello\\b` 相匹配，因为：\n\n1. 字符串的开头符合第一个检查 `pattern:\\b`。\n2. 然后匹配了单词 `pattern:Hello`。\n3. 然后与 `pattern:\\b` 再次匹配，因为我们在 `subject:o` 和逗号之间。\n\n所以模式 `pattern:\\bHello\\b` 会匹配，但 `pattern:\\bHell\\b` 不会匹配（因为在 `l` 之后没有单词边界），`Java!\\b` 也不会匹配（因为感叹号不是单词字符 `pattern:\\w`，所以其后没有词边界）。\n\n```js run\nalert( \"Hello, Java!\".match(/\\bHello\\b/) ); // Hello\nalert( \"Hello, Java!\".match(/\\bJava\\b/) );  // Java\nalert( \"Hello, Java!\".match(/\\bHell\\b/) );  // null（无匹配项）\nalert( \"Hello, Java!\".match(/\\bJava!\\b/) ); // null（无匹配项）\n```\n\n`pattern:\\b` 既可以用于单词，也可以用于数字。\n\n例如，模式 `pattern:\\b\\d\\d\\b` 查找独立的两位数。换句话说，它查找的是两位数，其周围是与 `pattern:\\w` 不同的字符，例如空格或标点符号（或文本开头/结尾）。\n\n```js run\nalert( \"1 23 456 78\".match(/\\b\\d\\d\\b/g) ); // 23,78\nalert( \"12,34,56\".match(/\\b\\d\\d\\b/g) ); // 12,34,56\n```\n\n```warn header=\"词边界 `pattern:\\b` 不适用于非拉丁字母\"\n词边界测试 `pattern:\\b` 检查该位置的一侧是否匹配 `pattern:\\w`，而另一侧则不匹配 \"`pattern:\\w`\"。\n\n但是，`pattern:\\w` 表示拉丁字母 `a-z`（或数字或下划线），所以此检查不适用于其他字符，如西里尔字母（cyrillic letters）或象形文字（hieroglyphs）。\n```",
        "libs": [],
        "children": [
          "find-time-hh-mm"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1659753186
      }
    },
    "find-time-hh-mm": {
      "type": "Task",
      "value": {
        "title": "查找时间",
        "slug": "find-time-hh-mm",
        "githubPath": "/9-regular-expressions/06-regexp-boundary/1-find-time-hh-mm",
        "weight": 1,
        "libs": [],
        "content": "\n\n时间的格式是：`小时:分钟`。小时和分钟都是两位数，例如 `09:00`。\n\n编写正则表达式在字符串 `subject:Breakfast at 09:00 in the room 123:456.` 中查找时间。\n\nP.S. 在这个任务里没有必要校验时间的正确性，所以 `25:99` 也可算做有效的结果。\n\nP.P.S. 正则表达式不应该匹配 `123:456`。",
        "solution": "答案是：`pattern:\\b\\d\\d:\\d\\d\\b`。\n\n```js run\nalert( \"Breakfast at 09:00 in the room 123:456.\".match( /\\b\\d\\d:\\d\\d\\b/ ) ); // 09:00\n```",
        "parent": "regexp-boundary",
        "version": 1
      }
    },
    "regexp-escaping": {
      "type": "Article",
      "value": {
        "title": "转义，特殊字符",
        "slug": "regexp-escaping",
        "githubPath": "/9-regular-expressions/07-regexp-escaping",
        "isFolder": false,
        "weight": 7,
        "content": "\n\n正如我们所看到的，反斜杠 `pattern:\\` 用于表示字符类，例如 `pattern:\\d`。所以它是正则表达式中的一个特殊字符（就像在常规字符串中一样）。\n\n还存在其它特殊字符，这些字符在正则表达式中有特殊的含义，例如 `pattern:[ ] { } ( ) \\ ^ $ . | ? * +`。它们用于执行更强大的搜索。\n\n现在并不需要尝试记住它们 —— 当我们分别学习它们的时候，你自然而然就会记住了。\n\n## 转义\n\n假如我们想要找到一个点号 `.`。\n\n要将特殊字符用作常规字符，请在其前面加上反斜杠：`pattern:\\.`。\n\n这就是所谓的“转义字符”。\n\n例如：\n```js run\nalert( \"Chapter 5.1\".match(/\\d\\.\\d/) ); // 5.1（匹配了！）\nalert( \"Chapter 511\".match(/\\d\\.\\d/) ); // null（寻找一个真正的点 \\.）\n```\n\n括号也是特殊字符，所以如果我们想要查找它们，我们应该使用 `pattern:\\(`。下面的例子会查找一个字符串 `\"g()\"`：\n\n```js run\nalert( \"function g()\".match(/g\\(\\)/) ); // \"g()\"\n```\n\n如果我们想查找反斜杠 `\\`，我们就应该使用两个反斜杠：\n\n```js run\nalert( \"1\\\\2\".match(/\\\\/) ); // '\\'\n```\n\n## 一个斜杠\n\n斜杠符号 `'/'` 并不是一个特殊字符，但是它被用于在 Javascript 中开启和关闭正则匹配：`pattern:/...pattern.../`，所以我们也应该转义它。\n\n下面是搜索斜杠 `'/'` 的表达式：\n\n```js run\nalert( \"/\".match(/\\//) ); // '/'\n```\n\n从另一个方面看，如果我们没使用 `pattern:/.../`，而是使用另一种 `new RegExp` 的方式创建正则表达式，则不需要转义斜杠：\n\n```js run\nalert( \"/\".match(new RegExp(\"/\")) ); // 找到了 /\n```\n\n## new RegExp\n\n如果我们使用 `new RegExp` 创建正则表达式，那么我们不必转义 `/`，但需要进行一些其他转义。\n\n例如，考虑下面这个示例：\n\n```js run\nlet reg = new RegExp(\"\\d\\.\\d\");\n\nalert( \"Chapter 5.1\".match(reg) ); // null\n```\n\n在之前的示例中我们使用 `pattern:/\\d\\.\\d/` 进行类似的搜索没问题，但 `new RegExp(\"\\d\\.\\d\")` 不起作用，为什么？\n\n因为反斜杠被字符串“消耗”了。我们可能还记得，常规字符串有自己的特殊字符，例如 `\\n`，反斜杠用于转义。\n\n下面是 \"\\d\\.\\d\" 的感知形式：\n\n```js run\nalert(\"\\d\\.\\d\"); // d.d\n```\n\n在字符串中的反斜杠表示转义或者类似 `\\n` 这种只能在字符串中使用的特殊字符。这个引用会“消耗”并且解释这些字符，比如说：\n\n- `\\n` —— 变成一个换行字符，\n- `\\u1234` —— 变成该编码所对应的 Unicode 字符，\n- ……而当没有特殊含义时：如 `pattern:\\d` 或者 `pattern:\\z`，碰到这种情况时则会自动移除反斜杠。\n\n所以调用 `new RegExp` 会获得一个没有反斜杠的字符串。这就是搜索不起作用的原因！\n\n如果要修复这个问题，我们需要双斜杠，因为引用会把 `\\\\` 变为 `\\`：\n\n```js run\n*!*\nlet regStr = \"\\\\d\\\\.\\\\d\";\n*/!*\nalert(regStr); // \\d\\.\\d（现在对了）\n\nlet regexp = new RegExp(regStr);\n\nalert( \"Chapter 5.1\".match(regexp) ); // 5.1\n```\n\n## Summary\n\n- 要在字面意义上搜索特殊字符 `pattern:[ \\ ^ $ . | ? * + ( )`，我们需要在它们前面加上一个反斜杠 `\\`（“转义它们”）。\n- 如果在 `pattern:/.../` 内（但不在 `new RegExp` 内），我们还需要转义 `/`。\n- 当将字符串传递给给 `new RegExp` 时，我们需要双反斜杠 `\\\\`，因为字符串引号会消耗一个反斜杠。",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1659957066
      }
    },
    "regexp-character-sets-and-ranges": {
      "type": "Article",
      "value": {
        "title": "集合和范围 [...]",
        "slug": "regexp-character-sets-and-ranges",
        "githubPath": "/9-regular-expressions/08-regexp-character-sets-and-ranges",
        "isFolder": false,
        "weight": 8,
        "content": "\n\n在方括号 `[…]` 中的几个字符或者字符类表示“搜索给定字符中的任意一个”。\n\n## 集合\n\n例如，`pattern:[eao]` 表示以下 3 个字符中的任何一个：`'a'`、`'e'` 或 `'o'` 。\n\n这就是所谓的 **集合**。在正则表达式中，可以将集合和常规字符一起使用。\n\n```js run\n// 查找 [t 或 m]，然后匹配 \"op\"\nalert( \"Mop top\".match(/[tm]op/gi) ); // \"Mop\", \"top\"\n```\n\n请注意，虽然集合中有多个字符，但它们在匹配中只会对应其中的一个。\n\n所以在下面的示例中并没有匹配项：\n\n```js run\n// 查找 \"V\"，然后匹配 [o 或 i]，之后匹配 \"la\"\nalert( \"Voila\".match(/V[oi]la/) ); // null，无匹配项\n```\n\n这个模式会搜索：\n\n- `pattern:V`，\n- 然后匹配其中的 **一个字符** `pattern:[oi]`，\n- 然后匹配 `pattern:la`。\n\n所以可以匹配上 `match:Vola` 或者 `match:Vila`。\n\n## 范围\n\n方括号也可以包含 **字符范围**。\n\n例如，`pattern:[a-z]` 表示从 `a` 到 `z` 范围内的字符，`pattern:[0-5]` 表示从 `0` 到 `5` 的数字。\n\n在下面的示例中，我们将搜索首先是 `\"x\"`，然后有两位数或两个在 `A` 到 `F` 范围内的字符紧随其后的字符串。\n\n```js run\nalert( \"Exception 0xAF\".match(/x[0-9A-F][0-9A-F]/g) ); // xAF\n```\n\n`pattern:[0-9A-F]` 中有两个范围：它搜索一个字符，该字符要么是在 `0` 到 `9` 范围内的数字，要么是从 `A` 到 `F` 的字母。\n\n如果我们还想查找小写字母，则可以添加范围 `a-f`：`pattern:[0-9A-Fa-f]`。或添加标志 `pattern:i`。\n\n我们也可以在 `[…]` 中使用字符类。\n\n例如，如果我们想查找单词字符 `pattern:\\w` 或连字符 `pattern:-`，则集合可以写为 `pattern:[\\w-]`。\n\n也可以组合多个类，例如 `pattern:[\\s\\d]` 表示“空格字符或数字”。\n\n```smart header=\"字符类是某些字符集合的简写\"\n例如：\n\n* **\\d** —— 和 `pattern:[0-9]` 相同，\n* **\\w** —— 和 `pattern:[a-zA-Z0-9_]` 相同，\n* **\\s** —— 和 `pattern:[\\t\\n\\v\\f\\r ]` 外加少量罕见的 Unicode 空格字符相同。\n```\n\n### 示例：多语言 \\w\n\n由于字符类 `pattern:\\w` 是简写的 `pattern:[a-zA-Z0-9_]`，因此无法找到中文象形文字，西里尔字母等。\n\n我们可以编写一个更通用的模式，该模式可以查找任何语言中的单词字符。借助 Unicode 属性很容易实现：`pattern:[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]`。\n\n让我们理解一下。类似于 `pattern:\\w`，我们正在制作一组属于我们自己的包含具有以下 Unicode 属性的字符：\n\n* `Alphabetic` (`Alpha`) —— 字母，\n* `Mark` (`M`) —— 音调，\n* `Decimal_Number` (`Nd`) —— 数字，\n* `Connector_Punctuation` (`Pc`) —— 下划线 `'_'` 和类似的字符，\n* `Join_Control` (`Join_C`) —— 两个特殊代码 `200c` 和 `200d`，用于连字，例如阿拉伯语。\n\n使用示例：\n\n```js run\nlet regexp = /[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]/gu;\n\nlet str = `Hi 你好 12`;\n\n// 找出所有字母和数字：\nalert( str.match(regexp) ); // H,i,你,好,1,2\n```\n\n当然，我们可以编辑这个模式：添加 Unicode 属性或删除它们。<info:regexp-unicode> 一文更详细地介绍了 Unicode 属性。\n\n```warn header=\"IE 浏览器不支持 Unicode 属性\"\nIE 浏览器未实现 Unicode 属性 `pattern:p{...}`。如果我们真的需要它们，可以使用库 [XRegExp](http://xregexp.com/)。\n\n或者只是使用我们感兴趣的语言中的字符范围，例如西里尔字母范围 `pattern:[а-я]`。\n```\n\n## 排除范围\n\n除了普通的范围匹配，还有像这样 `pattern:[^…]` 的“排除”范围匹配。\n\n通过在开头添加插入符号 `^` 来表示匹配所有 **除了给定的字符** 之外的任意字符。\n\n例如：\n\n- `pattern:[^aeyo]` —— 匹配除了 `'a'`、`'e'`、`'y'` 或 `'o'` 之外的任何字符。\n- `pattern:[^0-9]` —— 匹配除了数字之外的任何字符，与 `\\D` 作用相同。\n- `pattern:[^\\s]` —— 匹配任何非空格字符，与 `\\S` 作用相同。\n\n下面的示例搜索除了字母、数字和空格之外的任何字符：\n\n```js run\nalert( \"alice15@gmail.com\".match(/[^\\d\\sA-Z]/gi) ); // @ and .\n```\n\n## […] 中的转义\n\n通常当我们想要准确地找到一个特殊字符时，我们需要像 `pattern:\\.` 这样对其进行转义。如果我们需要反斜杠，那么我们需要使用 `pattern:\\\\`，等等。\n\n在方括号，我们可以使用绝大多数特殊字符而无需转义：\n\n- 符号 `pattern:. + ( )` 无需转义。\n- 在开头或结尾（未定义范围）的连字符 `pattern:-` 不会被转义。\n- 插入符号 `pattern:^` 仅在开头会被转义（表示排除）。\n- 右方括号 `pattern:]` 总是会被转义（如果我们需要寻找那个符号）。\n\n换句话说，除了在方括号中有特殊含义的字符外，其它所有特殊字符都是允许不转义的。\n\n方括号中的点 `.` 表示的就是一个点。模式 `pattern:[.,]` 将会搜索字符之一：点或逗号。\n\n在下面的示例中，正则表达式 `pattern:[-().^+]` 查找 `-().^+` 中的任何字符：\n\n```js run\n// 不需要转义\nlet reg = /[-().^+]/g;\n\nalert( \"1 + 2 - 3\".match(reg) ); // 匹配 +，-\n```\n\n……但是如果你为了“以防万一”转义了它们，这也不会有任何问题：\n\n```js run\n// 转义其中的所有字符\nlet reg = /[\\-\\(\\)\\.\\^\\+]/g;\n\nalert( \"1 + 2 - 3\".match(reg) ); // 仍能正常工作：+，-\n```\n\n## 范围和修饰符 \"u\"\n\n如果集合中有代理对（surrogate pairs），则需要标志 `pattern:u` 才能使它们正常工作。\n\n例如，让我们在字符串 `subject:𝒳` 中查找 `pattern:[𝒳𝒴]`：\n\n```js run\nalert( '𝒳'.match(/[𝒳𝒴]/) ); // 显示了一个奇怪的字符，像 [?]\n//（搜索执行不正确，返回了半个字符）\n```\n\n结果不正确，因为默认情况下正则表达式“不知道”代理对。\n\n正则表达式引擎认为 `[𝒳𝒴]` —— 不是两个字符，而是四个字符：\n1. `𝒳` 的左半部分 `(1)`，\n2. `𝒳` 的右半部分 `(2)`，\n3. `𝒴` 的左半部分 `(3)`，\n4. `𝒴` 的右半部分 `(4)`。\n\n我们可以看到它们的编码，如下所示：\n\n```js run\nfor(let i=0; i<'𝒳𝒴'.length; i++) {\n  alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500\n};\n```\n\n因此，上面的示例查找并显示了 `𝒳` 的左半部分。\n\n如果我们添加了修饰符 `pattern:u`，那么行为就正常了：\n\n```js run\nalert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳\n```\n\n当我们查找范围时也会出现类似的情况，就像 `[𝒳-𝒴]`。\n\n如果我们忘记添加修饰符 `pattern:u`，则会出现错误：\n\n```js run\n'𝒳'.match(/[𝒳-𝒴]/); // Error: Invalid regular expression\n```\n\n因为，没有修饰符 `pattern:u` 时，代理对将被视为两个字符，所以 `[𝒳-𝒴]` 被理解为 `[<55349><56499>-<55349><56500>]`（每个代理对都替换为其代码）。现在很容易看出范围 `56499-55349` 是无效的：其起始代码 `56499` 大于终止代码 `55349`。这就是错误的原因。\n\n带有修饰符 `pattern:u` 时，该模式就可以正常匹配了：\n\n```js run\n// 查找从 𝒳 到 𝒵 的字符\nalert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴\n```",
        "libs": [],
        "children": [
          "find-range-1",
          "find-time-2-formats"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1659764891
      }
    },
    "find-range-1": {
      "type": "Task",
      "value": {
        "title": "Java[^script]",
        "slug": "find-range-1",
        "githubPath": "/9-regular-expressions/08-regexp-character-sets-and-ranges/1-find-range-1",
        "weight": 1,
        "libs": [],
        "content": "\n\n我们有一个正则表达式 `pattern:/Java[^script]/`。\n\n它会和字符串 `subject:Java` 中的任何一部分匹配吗？`subject:JavaScript` 呢？",
        "solution": "·答案：**不会，会**。\n\n- 不会。在字符串 `subject:Java` 中，它不会匹配任何内容，因为 `pattern:[^script]` 表示“除了给定的字符之外的任何字符”。因此，这个正则表达式会查找 `\"Java\"` 后面是否有匹配这个规则的字符，但是这已经是整个字符串的结尾了，后面没有任何字符。\n\n    ```js run\n    alert( \"Java\".match(/Java[^script]/) ); // null\n    ```\n\n- 会。因为 `pattern:[^script]` 部分匹配到了字符 `\"S\"`。它不是 `pattern:script`。由于正则表达式区分大小写（没有 `pattern:i` 修饰符），因此它将 `\"S\"` 视为与 `\"s\"` 不同的字符。\n\n    ```js run\n    alert( \"JavaScript\".match(/Java[^script]/) ); // \"JavaS\"\n    ```",
        "parent": "regexp-character-sets-and-ranges",
        "version": 1
      }
    },
    "find-time-2-formats": {
      "type": "Task",
      "value": {
        "title": "找到 hh:mm 或者 hh-mm 格式的时间",
        "slug": "find-time-2-formats",
        "githubPath": "/9-regular-expressions/08-regexp-character-sets-and-ranges/2-find-time-2-formats",
        "weight": 2,
        "libs": [],
        "content": "\n\n时间可以通过 `hours:minutes` 或 `hours-minutes` 格式来表示。小时和分钟都有两位数：`09:00` 或 `21-30`。\n\n写一个正则表达式来找到它们：\n\n```js\nlet regexp = /your regexp/g;\nalert( \"Breakfast at 09:00. Dinner at 21-30\".match(regexp) ); // 09:00, 21-30\n```\n\nP.S. 在这个任务中，我们假设时间总是正确的，不需要过滤像 \"45:67\" 这样错误的时间字符串。稍后我们也会处理这个问题。",
        "solution": "答案：`pattern:\\d\\d[-:]\\d\\d`。\n\n```js run\nlet regexp = /\\d\\d[-:]\\d\\d/g;\nalert( \"Breakfast at 09:00. Dinner at 21-30\".match(regexp) ); // 09:00, 21-30\n```\n\n请注意，破折号 `pattern:'-'` 在方括号中有特殊含义，但只有当它位于其它字符之间而不是开头或结尾时这个含义才会起作用，所以我们不需要对其进行转义。",
        "parent": "regexp-character-sets-and-ranges",
        "version": 1
      }
    },
    "regexp-quantifiers": {
      "type": "Article",
      "value": {
        "title": "量词 +, *, ? 和 {n}",
        "slug": "regexp-quantifiers",
        "githubPath": "/9-regular-expressions/09-regexp-quantifiers",
        "isFolder": false,
        "weight": 9,
        "content": "\n\n假设我们有一个像这样 `+7(903)-123-45-67` 的字符串，并想要找到其中所有数字。但与之前不同的是，我们对单个数字不感兴趣，只对全数感兴趣：`7, 903, 123, 45, 67`。\n\n数字是一个或多个数字 `pattern:\\d` 的序列。为了标记我们需要的数量，我们需要加一个 **量词**。\n\n## 数量 {n}\n\n最简单的量词便是大括号中的数字：`pattern:{n}`。\n\n在一个字符（或一个字符类，或 `[...]` 等）后附加一个量词，用来指出我们具体需要的数量。\n\n它有一些高级的形式，让我们看一些例子：\n\n确切的位数：`pattern:{5}`\n: `pattern:\\d{5}` 表示 5 位数，与 `pattern:\\d\\d\\d\\d\\d` 相同。\n\n    下面这个例子查找一个五位数的数字：\n\n    ```js run\n    alert( \"I'm 12345 years old\".match(/\\d{5}/) ); //  \"12345\"\n    ```\n\n    我们可以添加 `\\b` 来排除位数更多的数字：`pattern:\\b\\d{5}\\b`。\n\n范围：`pattern:{3,5}`，匹配 3-5 个\n: 要查找 3-5 位的数字，我们可以将限制写在花括号中：`pattern:\\d{3,5}`\n\n    ```js run\n    alert( \"I'm not 12, but 1234 years old\".match(/\\d{3,5}/) ); // \"1234\"\n    ```\n\n    我们可以省略上限。\n    \n    那么正则表达式 `pattern:\\d{3,}` 就会查找位数大于等于 `3` 的数字：\n\n    ```js run\n    alert( \"I'm not 12, but 345678 years old\".match(/\\d{3,}/) ); // \"345678\"\n    ```\n\n让我们回到字符串 `+7(903)-123-45-67`。\n\n我们如果需要一个及以上的数字，就使用 `pattern:\\d{1,}`：\n\n```js run\nlet str = \"+7(903)-123-45-67\";\n\nlet numbers = str.match(/\\d{1,}/g);\n\nalert(numbers); // 7,903,123,45,67\n```\n\n## 缩写\n\n大多数常用的量词都有简写形式：\n\n`pattern:+`\n: 代表“一个或多个”，与 `pattern:{1,}` 相同。\n\n    例如，`pattern:\\d+` 用来查找所有数字：\n\n    ```js run\n    let str = \"+7(903)-123-45-67\";\n\n    alert( str.match(/\\d+/g) ); // 7,903,123,45,67\n    ```\n\n`pattern:?`\n: 代表“零个或一个”，与 `pattern:{0,1}` 相同。换句话说，它使得符号变得可选。\n\n    例如，模式 `pattern:ou?r` 查找 `match:o`，后跟零个或一个 `match:u`，然后是 `match:r`。\n\n    所以 `pattern:colou?r` 会找到 `match:color` 和 `match:colour`：\n\n    ```js run\n    let str = \"Should I write color or colour?\";\n\n    alert( str.match(/colou?r/g) ); // color, colour\n    ```\n\n`pattern:*`\n: 代表“零个及以上”，与 `{0,}` 相同。也就是说，字符可以出现任何次数或者不出现。\n\n    例如，`pattern:\\d0*` 查找一个数字后面跟着任意数量的零（可能有很多或没有）的数字：\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0*/g) ); // 100, 10, 1\n    ```\n\n    将其与 `pattern:+`（一个或更多）做比较：\n\n    ```js run\n    alert( \"100 10 1\".match(/\\d0+/g) ); // 100, 10\n    // 1 没有被匹配出来，因为 0+ 要求至少有一个 0\n    ```\n\n## 更多示例\n\n量词是很常用的。它们是构成复杂正则表达式的主要“模块”，所以让我们看更多示例。\n\n小数的正则表达式（带浮点的数字）：`pattern:\\d+\\.\\d+`\n\n实现：\n```js run\nalert( \"0 1 12.345 7890\".match(/\\d+\\.\\d+/g) ); // 12.345\n```\n\n”没有特性（attribute）的打开的 HTML 标签（例如 `<span>` 或 `<p>`）“的正则表达式。\n\n1. 最简单的：`pattern:/<[a-z]+>/i`\n\n    ```js run\n    alert( \"<body> ... </body>\".match(/<[a-z]+>/gi) ); // <body>\n    ```\n\n    正则表达式查找的匹配项是字符 `pattern:'<'` 后跟一个或多个拉丁字母，然后是 `pattern:'>'`。\n\n2. 进阶版：`pattern:/<[a-z][a-z0-9]*>/i`\n\n    根据标准，HTML 标签名称可以在除了第一个位置之外的任何位置有一个数字，例如 `<h1>`。\n\n    ```js run\n    alert( \"<h1>Hi!</h1>\".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>\n    ```\n\n**“打开或关闭的不带特性的 HTML 标签”的正则表达式：`pattern:/<\\/?[a-z][a-z0-9]*>/i`**\n\n我们在模式开头附近添加了一个可选的斜杠 `pattern:/?`。必须用一个反斜杠转义它，否则 JavaScript 会认为它是这个模式的结束符。\n\n```js run\nalert( \"<h1>Hi!</h1>\".match(/<\\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>\n```\n\n```smart header=\"为了使正则表达式更精确，我们通常需要使其更复杂\"\n我们能够从这些例子中看到一个共同的规则：正则表达式越精确 —— 它就越长越复杂。\n\n例如，对于 HTML 标签，我们可以使用更简单的正则表达式：`pattern:<\\w+>`。但是由于 HTML 对标签名称有更严格的限制，所以 `pattern:<[a-z][a-z0-9]*>` 更可靠\n\n我们可以使用 `pattern:<\\w+>` 还是需要 `pattern:<[a-z][a-z0-9]*>`？\n\n在实际开发中，这两种变体都是可以接受的。具体用哪个取决于我们对于“额外”匹配的宽容程度，以及通过其他方式将它们从结果中删除的困难程度。\n```",
        "libs": [],
        "children": [
          "find-text-manydots",
          "find-html-colors-6hex"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1659778099
      }
    },
    "find-text-manydots": {
      "type": "Task",
      "value": {
        "title": "如何找到省略号 \"...\"？",
        "slug": "find-text-manydots",
        "githubPath": "/9-regular-expressions/09-regexp-quantifiers/1-find-text-manydots",
        "weight": 1,
        "libs": [],
        "importance": 5,
        "content": "\n\n创建一个正则表达式来查找省略号：连续 3（或更多）个点。\n\n例如：\n\n```js\nlet regexp = /你的正则表达式/g;\nalert( \"Hello!... How goes?.....\".match(regexp) ); // ..., .....\n```",
        "solution": "答案：\n\n```js run\nlet regexp = /\\.{3,}/g;\nalert( \"Hello!... How goes?.....\".match(regexp) ); // ..., .....\n```\n\n请注意，点（.）是一个特殊字符，所以我们必须对其进行转义，即将其插入为 `\\.`。",
        "parent": "regexp-quantifiers",
        "version": 1
      }
    },
    "find-html-colors-6hex": {
      "type": "Task",
      "value": {
        "title": "针对 HTML 颜色的正则表达式",
        "slug": "find-html-colors-6hex",
        "githubPath": "/9-regular-expressions/09-regexp-quantifiers/2-find-html-colors-6hex",
        "weight": 2,
        "libs": [],
        "content": "\n\n创建一个正则表达式来查找格式为 `#ABCDEF` 的 HTML 颜色值：首个字符是 `#`，后面紧接着的是六位的十六进制字符。\n\n用例：\n\n```js\nlet regexp = /...你的正则表达式.../\n\nlet str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678\";\n\nalert( str.match(regexp) )  // #121212,#AA00ef\n```\n\nP.S. 在这个任务中，我们不需要其他的颜色格式，例如 `#123` 或 `rgb(1,2,3)` 等。",
        "solution": "我们需要寻找首个字符是 `#`，后面紧接着的是六位的十六进制字符的匹配项。\n\n一个十六进制字符可以描述为 `pattern:[0-9a-fA-F]`。如果我们使用修饰符 `i`，那么只需要 `pattern:[0-9a-f]`。\n\n然后我们可以使用量词 `pattern:{6}` 来查找其 6 个字符。\n\n那么，我们得到正则表达式：`pattern:/#[a-f0-9]{6}/gi`。\n\n```js run\nlet regexp = /#[a-f0-9]{6}/gi;\n\nlet str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2\"\n\nalert( str.match(regexp) );  // #121212,#AA00ef\n```\n\n问题是其从更长的序列中匹配了颜色值：\n\n```js run\nalert( \"#12345678\".match( /#[a-f0-9]{6}/gi ) ) // #123456\n```\n\n为了解决这个问题，我们可以在末尾加上 `pattern:\\b`：\n\n```js run\n// 颜色值\nalert( \"#123456\".match( /#[a-f0-9]{6}\\b/gi ) ); // #123456\n\n// 不是颜色值\nalert( \"#12345678\".match( /#[a-f0-9]{6}\\b/gi ) ); // null\n```",
        "parent": "regexp-quantifiers",
        "version": 1
      }
    },
    "regexp-greedy-and-lazy": {
      "type": "Article",
      "value": {
        "title": "贪婪量词和惰性量词",
        "slug": "regexp-greedy-and-lazy",
        "githubPath": "/9-regular-expressions/10-regexp-greedy-and-lazy",
        "isFolder": false,
        "weight": 10,
        "content": "\n\n量词乍一看非常简单，但实际上它们可能很棘手。\n\n如果我们打算寻找比 `pattern:/\\d+/` 更复杂的东西，就需要理解搜索的工作原理。\n\n以接下来的任务为例。\n\n有一个文本，我们需要用书名号：`«...»` 来代替所有的引号 `\"...\"`。在许多国家，书名号是排版的首选。\n\n例如：`\"Hello, world\"` 应该变成 `«Hello, world»`。还有其他引用，例如 `„Witam, świat!”`（波兰语）或 `「你好，世界」`（中文），但对于我们的任务，让我们选择 `«...»` 吧。\n\n首先要做的是定位带引号的字符串，然后替换它们。\n\n像 `pattern:/\".+\"/g`（一个引号，然后是一些内容，然后是另一个引号）这样的正则表达式看起来可能很合适，但事实并非如此！\n\n让我们试一下：\n\n```js run\nlet regexp = /\".+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(regexp) ); // \"witch\" and her \"broom\"\n```\n\n……可以看出来它的运行结果与预期不同！\n\n它没有找到匹配项 `match:\"witch\"` 和 `match:\"broom\"`，而是找到：`match:\"witch\" and her \"broom\"`。\n\n这可被称为“贪婪是万恶之源”。\n\n## 贪婪搜索\n\n为了查找到一个匹配项，正则表达式引擎采用了以下算法：\n\n- 对于字符串中的每一个位置\n    - 尝试匹配该位置的模式。\n    - 如果未匹配，则转到下一个位置。\n\n这样简单的描述并不能说清楚这个正则表达式匹配失败的原因，所以让我们详细说明一下模式 `pattern:\".+\"` 是如何进行搜索的。\n\n1. 该模式的第一个字符是一个引号 `pattern:\"`。\n\n    正则表达式引擎尝试在源字符串 `subject:a \"witch\" and her \"broom\" is one` 的位置 0 找到它，但那里有 `subject:a`，所以匹配失败。\n\n    然后继续前进：移至源字符串中的下一个位置，并尝试匹配模式中的第一个字符，再次失败，最终在第三个位置匹配到了引号：\n\n    ![](witch_greedy1.svg)\n\n2. 找到引号后，引擎就尝试去匹配模式中的剩余字符。它尝试查看剩余的字符串是否符合 `pattern:.+\"`。\n\n    在我们的用例中，模式中的下一个字符为 `pattern:.`（一个点）。它表示匹配除了换行符之外的任意字符，所以将会匹配下一个字符 `match:'w'`：\n\n    ![](witch_greedy2.svg)\n\n3. 然后由于量词 `pattern:.+`，点会重复。正则表达式引擎一个接一个字符地进行匹配。\n\n    ……什么时候会不匹配？点（.）能够匹配所有字符，所以只有在移至字符串末尾时才停止匹配：\n\n    ![](witch_greedy3.svg)\n\n4. 现在引擎完成了对重复模式 `pattern:.+` 的搜索，并且试图寻找模式中的下一个字符。是引号 `pattern:\"`。但是有一个问题：对字符串的遍历已经结束，没有更多字符了！\n\n    正则表达式引擎知道它为 `pattern:.+` 匹配太多项了，所以开始 **回溯**。\n\n    换句话说，它去掉了量词匹配项的最后一个字符：\n\n    ![](witch_greedy4.svg)\n\n    现在它假设 `pattern:.+` 的匹配在字符串的倒数第一个字符前的位置结束，并尝试从该位置匹配模式的剩余部分。\n\n    如果那里有引号，则搜索将结束，但最后一个字符是 `subject:'e'`，所以不匹配。 \n\n5. ……所以引擎会将 `pattern:.+` 的重复次数减少一个字符：\n\n    ![](witch_greedy5.svg)\n\n    引号 `pattern:'\"'` 与 `subject:'n'` 不匹配。\n\n6. 引擎不断进行回溯：它减少 `pattern:'.'` 的重复次数，直到模式的其余部分（在我们的用例中是 `pattern:'\"'`）匹配到结果：\n\n    ![](witch_greedy6.svg)\n\n7. 匹配完成。\n\n8. 所以，第一次匹配项是 `match:\"witch\" and her \"broom\"`。如果正则表达式具有修饰符 `pattern:g`，则搜索将从第一个匹配结束的地方继续。字符串 `subject:is one` 的剩余部分不再有引号，因此没有更多匹配项。\n\n这可能不是我们所期望的，但这就是它的工作方式。\n\n**在贪婪模式下（默认情况），量词都会尽可能多地重复。**\n\n正则表达式引擎尝试用 `pattern:.+` 去匹配尽可能多的字符，然后在模式的其余部分不匹配时再将其逐一缩短。\n\n对于这个任务，我们想要得是另一种结果。这也就是惰性量词模式的用途。\n\n## 惰性模式\n\n惰性模式中的量词与贪婪模式中的是相反的。它表示：“重复最少的次数”。\n\n我们可以通过在量词后面添加一个问号 `pattern:'?'` 来启用它，这样匹配模式就变成了 `pattern:*?` 或 `pattern:+?`，甚至将 `pattern:'?'` 变成 `pattern:??`。\n\n这么说吧：通常问号 `pattern:?` 本身就是一个量词（0 或 1），但如果将其放到 **另一个量词（甚至是它自己）后面**，就会有不同的含义 —— 它将匹配的模式从贪婪转为惰性。\n\n正则表达式 `pattern:/\".+?\"/g` 能够按预期工作了：它找到了 `match:\"witch\"` 和 `match:\"broom\"`：\n\n```js run\nlet regexp = /\".+?\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(regexp) ); // \"witch\", \"broom\"\n```\n\n为了更清楚地理解这个变化，我们来一步步解析这个搜索过程。\n\n1. 第一步是一样的：它在第三个字符的位置找到了模式的开头 `pattern:'\"'`：\n\n    ![](witch_greedy1.svg)\n\n2. 下一步也是类似的：引擎为 `pattern:'.'` 找到了一个匹配项：\n\n    ![](witch_greedy2.svg)\n\n3. 接下来的搜索就有些不同了。因为我们对 `pattern:+?` 启用了惰性模式，引擎不会去尝试多匹配一个点的匹配字符，而会停止并立即尝试对剩余的模式 `pattern:'\"'` 进行匹配：\n\n    ![](witch_lazy3.svg)\n\n    如果这里有一个引号，搜索就会停止，但这里是一个 `'i'`，所以没有匹配到引号。\n4. 接着，正则表达式引擎增加对点的重复搜索次数，并且再次尝试：\n\n    ![](witch_lazy4.svg)\n\n    又失败了。然后重复次数一次又一次的增加……\n5. ……直到找到了模式中的剩余部分的匹配项：\n\n    ![](witch_lazy5.svg)\n\n6. 接下来的搜索从当前匹配的结尾开始，并产生了下一个匹配项：\n\n    ![](witch_lazy6.svg)\n\n在这个例子中，我们看到了惰性模式的 `pattern:+?` 是怎样工作的。量词 `pattern:*?` 和 `pattern:??` 的工作方式类似 —— 正则表达式引擎仅在模式的其余部分无法在给定位置匹配时增加重复次数。\n\n**惰性模式仅对带有 `?` 的量词启用**\n\n其它量词依旧保持贪婪模式。\n\n例如：\n\n```js run\nalert( \"123 456\".match(/\\d+ \\d+?/) ); // 123 4\n```\n\n1. 模式 `pattern:\\d+` 尝试匹配尽可能多的数字（贪婪模式），因此在它找到 `match:123` 时停止，因为下一个字符为空格 `pattern:' '`。\n2. 然后模式中有一个空格，正好匹配。\n3. 然后是 `pattern:\\d+?`。此量词处于惰性模式，所以它匹配一个数字 `match:4` 后开始尝试去检查模式的剩余部分是否匹配。\n\n    ……但是在 `pattern:\\d+?` 之后没有其它内容了。\n\n    惰性模式在不必要的情况下不会重复任何东西。模式结束，我们找到了匹配项 `match:123 4`。\n\n```smart header=\"优化\"\n现在正则表达式引擎会通过优化内部算法来提升效率。所以它们的工作方式和所描述的算法可能略有不同。\n\n但如果只是为了了解正则表达式的工作原理和如何构建正则表达式我们不需要知道这些。它们仅用于内部算法优化。\n\n复杂的正则表达式是很难优化的，因此搜索的过程也可以完全按照描述的方式进行。\n```\n\n## 替代方法\n\n使用正则表达式，通常有不止一种方式可以做相同的事。\n\n在我们的例子中，我们可以在不启用惰性模式的情况下使用正则表达式 `pattern:\"[^\"]+\"` 找到带引号的字符串：\n\n```js run\nlet regexp = /\"[^\"]+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(regexp) ); // \"witch\", \"broom\"\n```\n\n正则表达式 `pattern:\"[^\"]+\"` 给出了正确答案，因为它查找一个引号 `pattern:'\"'` 后跟一个或更多非引号 `pattern:[^\"]` 的字符，然后是结束的引号。\n\n当引擎寻找 `pattern:[^\"]+` 时，它会在匹配到结束的引号时停止重复，这样就完成了。\n\n请注意，这个逻辑并不能取代惰性量词！\n\n它们是不同的。我们在不同情况下可能会需要使用到其中的一个或另一个。\n\n**让我们再来看一个使用惰性量词失败而使用这种变体能获得预期结果的例子。**\n\n例如，我们想要找到 `<a href=\"...\" class=\"doc\">` 形式的带有任意 `href` 的链接。\n\n该使用哪个正则表达式呢？\n\n首先可能会想到：`pattern:/<a href=\".*\" class=\"doc\">/g`。\n\n验证一下：\n```js run\nlet str = '...<a href=\"link\" class=\"doc\">...';\nlet regexp = /<a href=\".*\" class=\"doc\">/g;\n\n// 有效！\nalert( str.match(regexp) ); // <a href=\"link\" class=\"doc\">\n```\n\n……但如果文本中有多个链接呢？\n\n```js run\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet regexp = /<a href=\".*\" class=\"doc\">/g;\n\n// 蛤！一个匹配项中有两个链接！\nalert( str.match(regexp) ); // <a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\n现在这个结果是错的，原因与我们的 \"witches\" 示例相同。量词 `pattern:.*` 占用了太多字符。\n\n匹配结果如下：\n\n```html\n<a href=\".....................................\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\n让我们启用惰性量词 `pattern:.*?` 来修改模式：\n\n```js run\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet regexp = /<a href=\".*?\" class=\"doc\">/g;\n\n// 正确了！\nalert( str.match(regexp) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\n现在能成功了，有两个匹配项：\n\n```html\n<a href=\".....\" class=\"doc\">    <a href=\".....\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n```\n\n……但是让我们用另外一个文本来测试看看：\n\n```js run\nlet str = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet regexp = /<a href=\".*?\" class=\"doc\">/g;\n\n// 错误的匹配！\nalert( str.match(regexp) ); // <a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n```\n\n现在它匹配错了。匹配项不仅包括了一个链接，还包括了它后面的很多文本，包括 `<p...>`。\n\n为什么？\n\n原因如下：\n\n1. 首先，正则表达式寻找链接的开始：`match:<a href=\"`。\n2. 然后它寻找 `pattern:.*?`，取一个字符（惰性的！），然后检查字符串的剩余部分是否与模式的剩余部分匹配（未匹配）。\n3. 然后再取一个字符到 `pattern:.*?` 中，以此类推……直到最终到达 `match:\" class=\"doc\">`。\n\n但问题是：这已经超出了链接 `<a...>`，已经在另一个标签 `<p>` 中了。这不是我们想要的。\n\n这是与匹配项在文本上对齐的示例：\n\n```html\n<a href=\"...................................\" class=\"doc\">\n<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n```\n\n所以，我们需要模式寻找 `<a href=\"...something...\" class=\"doc\">`，但贪婪模式和惰性模式都有问题。\n\n正确的变体可以是这样的：`pattern:href=\"[^\"]*\"`。它会获取 `href` 特性中的所有字符直到最近的引号，正好符合我们的需求。\n\n举个例子：\n\n```js run\nlet str1 = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet str2 = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet regexp = /<a href=\"[^\"]*\" class=\"doc\">/g;\n\n// 有效！\nalert( str1.match(regexp) ); // null，无匹配项，这是对的\nalert( str2.match(regexp) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n```\n\n## 总结\n\n量词有两种工作模式：\n\n贪婪模式\n: 默认情况下，正则表达式引擎会尝试尽可能多地重复量词字符。例如，`pattern:\\d+` 会消耗所有可能的字符。当无法消耗更多（在尾端没有更多的数字或字符串）时，然后它再匹配模式的剩余部分。如果没有匹配，则减少重复的次数（回溯），并再次尝试。\n\n惰性模式\n: 通过在量词后添加问号 `pattern:?` 来启用。正则表达式引擎尝试在每次重复量化字符之前匹配模式的其余部分。\n\n正如我们所见，惰性模式并不是贪婪搜索的“灵丹妙药”。另一种方式是使用排除项“微调”贪婪搜索，如模式 `pattern:\"[^\"]+\"`。",
        "libs": [],
        "children": [
          "lazy-greedy",
          "find-html-comments",
          "find-html-tags-greedy-lazy"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1659956999
      }
    },
    "lazy-greedy": {
      "type": "Task",
      "value": {
        "title": "/d+? d+?/ 的匹配项",
        "slug": "lazy-greedy",
        "githubPath": "/9-regular-expressions/10-regexp-greedy-and-lazy/1-lazy-greedy",
        "weight": 1,
        "libs": [],
        "content": "\n\n匹配的结果是什么？\n\n```js\nalert( \"123 456\".match(/\\d+? \\d+?/g) ); // ?\n```",
        "solution": "结果是：`match:123 4`。\n\n首先，惰性模式 `pattern:\\d+?` 尝试去获取尽可能少的数字，但它必须到达空格，因此需要匹配到 `match:123`。\n\n然后，第二个 `\\d+?` 就只获取一个数字，因为这就已经足够了。",
        "parent": "regexp-greedy-and-lazy",
        "version": 1
      }
    },
    "find-html-comments": {
      "type": "Task",
      "value": {
        "title": "查找 HTML 注释",
        "slug": "find-html-comments",
        "githubPath": "/9-regular-expressions/10-regexp-greedy-and-lazy/3-find-html-comments",
        "weight": 3,
        "libs": [],
        "content": "\n\n找出文本中的所有 HTML 注释：\n\n```js\nlet regexp = /你的正则表达式/g;\n\nlet str = `... <!-- My -- comment\n test --> ..  <!----> .. \n`;\n\nalert( str.match(regexp) ); // '<!-- My -- comment \\n test -->', '<!---->'\n```",
        "solution": "我们需要找到注释的起始位置 `match:<!--`，然后获取字符直到注释的末尾 `match:-->`。\n\n行得通的表达式可以是 `pattern:<!--.*?-->` —— 惰性量词使得点在 `match:-->` 之前 停止。我们还需要为点添加修饰符 `pattern:s` 以包含换行符。\n\n否则找不到多行注释：\n\n```js run\nlet regexp = /<!--.*?-->/gs;\n\nlet str = `... <!-- My -- comment\n test --> ..  <!----> ..\n`;\n\nalert( str.match(regexp) ); // '<!-- My -- comment \\n test -->', '<!---->'\n```",
        "parent": "regexp-greedy-and-lazy",
        "version": 1
      }
    },
    "find-html-tags-greedy-lazy": {
      "type": "Task",
      "value": {
        "title": "寻找 HTML 标签",
        "slug": "find-html-tags-greedy-lazy",
        "githubPath": "/9-regular-expressions/10-regexp-greedy-and-lazy/4-find-html-tags-greedy-lazy",
        "weight": 4,
        "libs": [],
        "content": "\n\n创建一个正则表达式来寻找所有（开始和结束）HTML 标签及其特性。\n\n用例：\n\n```js run\nlet regexp = /你的正则表达式/g;\n\nlet str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(regexp) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n```\n\n这里我们假设标签特征中不包含 `<` 和 `>`（包括被引号包裹的内容），这样就简单多了。",
        "solution": "答案是 `pattern:<[^<>]+>`。\n\n```js run\nlet regexp = /<[^<>]+>/g;\n\nlet str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(regexp) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n```",
        "parent": "regexp-greedy-and-lazy",
        "version": 1
      }
    },
    "regexp-groups": {
      "type": "Article",
      "value": {
        "title": "捕获组",
        "slug": "regexp-groups",
        "githubPath": "/9-regular-expressions/11-regexp-groups",
        "isFolder": false,
        "weight": 11,
        "content": "\n\n模式的一部分可以用括号括起来 `pattern:(...)`。这被称为“捕获组（capturing group）”。\n\n这有两个影响：\n\n1. 它允许将匹配的一部分作为结果数组中的单独项。\n2. 如果我们将量词放在括号后，则它将括号视为一个整体。\n\n## 示例\n\n让我们看看在示例中的括号是如何工作的。\n\n### 示例：gogogo\n\n不带括号，模式 `pattern:go+` 表示 `subject:g` 字符，其后 `subject:o` 重复一次或多次。例如 `match:goooo` 或 `match:gooooooooo`。\n\n括号将字符组合，所以 `pattern:(go)+` 匹配 `match:go`，`match:gogo`，`match:gogogo`等。\n\n```js run\nalert( 'Gogogo now!'.match(/(go)+/ig) ); // \"Gogogo\"\n```\n\n### 示例：域名\n\n让我们做些更复杂的事 —— 搜索域名的正则表达式。\n\n例如：\n\n```\nmail.com\nusers.mail.com\nsmith.users.mail.com\n```\n\n正如我们所看到的，一个域名由重复的单词组成，每个单词后面有一个点，除了最后一个单词。\n\n在正则表达式中是 `pattern:(\\w+\\.)+\\w+`：\n\n```js run\nlet regexp = /(\\w+\\.)+\\w+/g;\n\nalert( \"site.com my.site.com\".match(regexp) ); // site.com,my.site.com\n```\n\n搜索有效，但该模式无法匹配带有连字符的域名，例如 my-site.com，因为连字符不属于 `pattern:\\w` 类。\n\n我们可以通过用 `pattern:[\\w-]` 替换 `pattern:\\w` 来匹配除最后一个单词以外的每个单词：`pattern:([\\w-]+\\.)+\\w+`。\n\n### 示例：电子邮件\n\n扩展一下上面这个示例。我们可以基于它为电子邮件创建一个正则表达式。\n\n电子邮件的格式为：`name@domain`。名称可以是任何单词，允许使用连字符和点。在正则表达式中为 `pattern:[-.\\w]+`。\n\n模式：\n\n```js run\nlet regexp = /[-.\\w]+@([\\w-]+\\.)+[\\w-]+/g;\n\nalert(\"my@mail.com @ his@site.com.uk\".match(regexp)); // my@mail.com, his@site.com.uk\n```\n\n该正则表达式并不完美的，但多数情况下都能正确匹配，并且有助于修复输入邮箱时的意外错误输入。唯一真正可靠的电子邮件检查只能通过发送电子邮件来完成。\n\n## 匹配中的括号的内容\n\n括号被从左到右编号。正则引擎会记住它们各自匹配的内容，并允许在结果中获取它。\n\n方法 `str.match(regexp)`，如果 `regexp` 没有修饰符 `g`，将查找第一个匹配项，并将它作为数组返回：\n\n1. 在索引 `0` 处：完整的匹配项。\n2. 在索引 `1` 处：第一个括号的内容。\n3. 在索引 `2` 处：第二个括号的内容。\n4. ……等等……\n\n例如，我们想找到 HTML 标签 `pattern:<.*?>` 并处理它们。将标签内容（尖括号内的内容）放在单独的变量中会很方便。\n\n让我们将内部内容包装在括号中，像这样：`pattern:<(.*?)>`。\n\n现在，我们在结果数组中得到了标签的整体 `match:<h1>` 及其内容 `match:h1`：\n\n```js run\nlet str = '<h1>Hello, world!</h1>';\n\nlet tag = str.match(/<(.*?)>/);\n\nalert( tag[0] ); // <h1>\nalert( tag[1] ); // h1\n```\n\n### 嵌套组\n\n括号可以嵌套。在这种情况下，编号也从左到右。\n\n例如，在搜索标签 `subject:<span class=\"my\">` 时，我们可能会对以下内容感兴趣：\n\n1. 整个标签的内容：`match:span class=\"my\"`。\n2. 标签名称：`match:span`。\n3. 标签特性：`match:class=\"my\"`。\n\n让我们为它们添加括号：`pattern:<(([a-z]+)\\s*([^>]*))>`。\n\n这是它们的编号方式（根据左括号从左到右）：\n\n![](regexp-nested-groups-pattern.svg)\n\n验证：\n\n```js run\nlet str = '<span class=\"my\">';\n\nlet regexp = /<(([a-z]+)\\s*([^>]*))>/;\n\nlet result = str.match(regexp);\nalert(result[0]); // <span class=\"my\">\nalert(result[1]); // span class=\"my\"\nalert(result[2]); // span\nalert(result[3]); // class=\"my\"\n```\n\n`result` 的索引 0 中始终保存的是正则表达式的完整匹配项。\n\n然后是按左括号从左到右编号的组。第一组返回为 `result[1]`。它包含了整个标签内容。\n\n然后是 `result[2]`，从第二个左括号开始分组 `pattern:([a-z]+)` —— 标签名称，然后在 `result[3]` 中：`pattern:([^>]*)`。\n\n字符串中每个组的内容：\n\n![](regexp-nested-groups-matches.svg)\n\n### 可选组\n\n即使组是可选的并且在匹配项中不存在（例如，具有量词 `pattern:(...)?`），也存在相应的 `result` 数组项，并且等于 `undefined`。\n\n例如，让我们考虑正则表达式 `pattern:a(z)?(c)?`。它查找 `\"a\"`，后面是可选的 `\"z\"`，然后是可选的 `\"c\"`。\n\n如果我们在单个字母的字符串上运行 `subject:a`，则结果为：\n\n```js run\nlet match = 'a'.match(/a(z)?(c)?/);\n\nalert( match.length ); // 3\nalert( match[0] ); // a（完整的匹配项）\nalert( match[1] ); // undefined\nalert( match[2] ); // undefined\n```\n\n数组的长度为 `3`，但所有组均为空。\n\n对字符串 `subject:ac` 的匹配会更复杂：\n\n```js run\nlet match = 'ac'.match(/a(z)?(c)?/)\n\nalert( match.length ); // 3\nalert( match[0] ); // ac（完整的匹配项）\nalert( match[1] ); // undefined, 因为没有 (z)? 的匹配项\nalert( match[2] ); // c\n```\n\n数组长度依然是：`3`。但没有组 `pattern:(z)?` 的匹配项，所以结果是 `[\"ac\", undefined, \"c\"]`。\n\n## 带有组搜索所有匹配项：matchAll\n\n```warn header=\"`matchAll` 是一个新方法，可能需要使用 polyfill\"\n旧的浏览器不支持 `matchAll`。\n\n可能需要进行 polyfill，例如 <https://github.com/ljharb/String.prototype.matchAll>.\n```\n\n当我们搜索所有匹配项（修饰符 `pattern:g`）时，`match` 方法不会返回组的内容。\n\n例如，让我们查找字符串中的所有标签：\n\n```js run\nlet str = '<h1> <h2>';\n\nlet tags = str.match(/<(.*?)>/g);\n\nalert( tags ); // <h1>,<h2>\n```\n\n结果是一个匹配数组，但没有每个匹配项的详细信息。但是实际上，我们通常需要在结果中获取捕获组的内容。\n\n要获取它们，我们应该使用方法 `str.matchAll(regexp)` 进行搜索。\n\n在使用 `match` 很长一段时间后，它才被作为“新的改进版本”被加入到 JavaScript 中。\n\n就像 `match` 一样，它寻找匹配项，但有 3 个区别：\n\n1. 它返回的不是数组，而是一个可迭代的对象。\n2. 当存在修饰符 `pattern:g` 时，它将每个匹配项以包含组的数组的形式返回。\n3. 如果没有匹配项，则返回的不是 `null`，而是一个空的可迭代对象。\n\n例如：\n\n```js run\nlet results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n\n// results —— 不是数组，而是一个迭代对象\nalert(results); // [object RegExp String Iterator]\n\nalert(results[0]); // undefined (*)\n\nresults = Array.from(results); // 让我们将其转换为数组\n\nalert(results[0]); // <h1>,h1（第一个标签）\nalert(results[1]); // <h2>,h2（第二个标签）\n```\n\n我们可以看到，第一个区别非常重要，如 `(*)` 行所示。我们无法获得 `results[0]` 的匹配项，因为该对象并不是伪数组。我们可以使用 `Array.from` 把它变成一个真正的 `Array`。在 <info:iterable> 一文中有关于伪数组和可迭代对象的更多详细内容。\n\n如果我们只需要遍历结果，则 `Array.from` 没有必要：\n\n```js run\nlet results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n\nfor(let result of results) {\n  alert(result);\n  // 第一个 alert：<h1>,h1\n  // 第二个：<h2>,h2\n}\n```\n\n……或使用解构：\n\n```js\nlet [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n```\n\n`matchAll` 返回的每个匹配项，与不带修饰符 `pattern:g` 的 `match` 所返回的格式相同：具有额外 `index`（字符串中的匹配索引）属性和 `input`（源字符串）的数组：\n\n```js run\nlet results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n\nlet [tag1, tag2] = results;\n\nalert( tag1[0] ); // <h1>\nalert( tag1[1] ); // h1\nalert( tag1.index ); // 0\nalert( tag1.input ); // <h1> <h2>\n```\n\n```smart header=\"为什么 `matchAll` 的结果是可迭代对象而不是数组？\"\n为什么这个方法这样设计？原因很简单 —— 为了优化。\n\n调用 `matchAll` 不会执行搜索。相反，它返回一个可迭代对象，最初没有结果。每次我们迭代它时才会执行搜索，例如在循环中。\n\n因此，这将根据需要找出尽可能多的结果，而不是全部。\n\n例如，文本中可能有 100 个匹配项，但在一个 `for..of` 循环中，我们找到了 5 个匹配项，然后觉得足够了并做出一个 `break`。这时引擎就不会花时间查找其他 95 个匹配。\n```\n\n## 命名组\n\n用数字记录组很困难。对于简单的模式，它是可行的，但对于更复杂的模式，计算括号很不方便。我们有一个更好的选择：给括号命名。\n\n在左括号后紧跟着放置 `pattern:?<name>` 即可完成对括号的命名。\n\n例如，让我们查找 \"year-month-day\" 格式的日期：\n\n```js run\n*!*\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\n*/!*\nlet str = \"2019-04-30\";\n\nlet groups = str.match(dateRegexp).groups;\n\nalert(groups.year); // 2019\nalert(groups.month); // 04\nalert(groups.day); // 30\n```\n\n正如你所看到的，匹配的组在 `.groups` 属性中。\n\n要查找所有日期，我们可以添加修饰符 `pattern:g`。\n\n我们还需要 `matchAll` 以获取完整的组匹配：\n\n```js run\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;\n\nlet str = \"2019-10-30 2020-01-01\";\n\nlet results = str.matchAll(dateRegexp);\n\nfor(let result of results) {\n  let {year, month, day} = result.groups;\n\n  alert(`${day}.${month}.${year}`);\n  // 第一个 alert：30.10.2019\n  // 第二个：01.01.2020\n}\n```\n\n## 替换中的捕获组\n\n让我们能够替换 `str` 中 `regexp` 的所有匹配项的方法 `str.replace(regexp, replacement)` 允许我们在 `replacement` 字符串中使用括号中的内容。这使用 `pattern:$n` 来完成，其中 `pattern:n` 是组号。\n\n例如，\n\n```js run\nlet str = \"John Bull\";\nlet regexp = /(\\w+) (\\w+)/;\n\nalert( str.replace(regexp, '$2, $1') ); // Bull, John\n```\n\n对于命名的括号，引用为 `pattern:$<name>`。\n\n例如，让我们将日期格式从 \"year-month-day\" 更改为 \"day.month.year\"：\n\n```js run\nlet regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;\n\nlet str = \"2019-10-30, 2020-01-01\";\n\nalert( str.replace(regexp, '$<day>.$<month>.$<year>') );\n// 30.10.2019, 01.01.2020\n```\n\n## 非捕获组 ?:\n\n有时我们需要用括号才能正确应用量词，但我们不希望它们的内容出现在结果中。\n\n可以通过在开头添加 `pattern:?:` 来排除组。\n\n例如，如果我们要查找 `pattern:(go)+`，但不希望括号内容（`go`）作为一个单独的数组项，则可以编写：`pattern:(?:go)+`。\n\n在下面的示例中，我们仅将名称 `match:John` 作为匹配项的单独成员：\n\n```js run\nlet str = \"Gogogo John!\";\n\n*!*\n// ?: 从捕获组中排除 'go'\nlet regexp = /(?:go)+ (\\w+)/i;\n*/!*\n\nlet result = str.match(regexp);\n\nalert( result[0] ); // Gogogo John（完整的匹配项）\nalert( result[1] ); // John\nalert( result.length ); // 2（在数组中没有其他数组项）\n```\n\n## 总结\n\n括号将正则表达式中的一部分组合在一起，以便量词可以整体应用。\n\n括号组从左到右编号，可以选择用 `(?<name>...)` 命名。\n\n可以在结果中获得按组匹配的内容：\n\n* 方法 `str.match` 仅当不带修饰符 `pattern:g` 时返回捕获组。\n* 方法 `str.matchAll` 始终返回捕获组。\n\n如果括号没有名称，则匹配数组按编号提供其内容。命名括号还可使用属性 `groups`。\n\n我们还可以在 `str.replace` 的替换字符串中使用括号内容：通过数字 `$n` 或者名称 `$<name>`。\n\n可以通过在组的开头添加 `pattern:?:` 来排除编号。当我们需要对整个组应用量词，但不希望将其作为结果数组中的单独项时这很有用。我们也不能在替换字符串中引用这样的括号。",
        "libs": [],
        "children": [
          "test-mac",
          "find-webcolor-3-or-6",
          "find-decimal-numbers",
          "parse-expression"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1674989062
      }
    },
    "test-mac": {
      "type": "Task",
      "value": {
        "title": "检查 MAC 地址",
        "slug": "test-mac",
        "githubPath": "/9-regular-expressions/11-regexp-groups/01-test-mac",
        "weight": 1,
        "libs": [],
        "content": "\n\n网络接口的 [MAC 地址](https://en.wikipedia.org/wiki/MAC_address) 由 6 个以冒号分隔的两位十六进制数字组成。\n\n例如：`subject:'01:32:54:67:89:AB'`。\n\n编写一个检查字符串是否为 MAC 地址的正则表达式。\n\n用例：\n```js\nlet regexp = /你的正则表达式/;\n\nalert( regexp.test('01:32:54:67:89:AB') ); // true\n\nalert( regexp.test('0132546789AB') ); // false (没有冒号分隔)\n\nalert( regexp.test('01:32:54:67:89') ); // false (5 个数字，必须为 6 个)\n\nalert( regexp.test('01:32:54:67:89:ZZ') ) // false (尾部为 ZZ)\n```",
        "solution": "一个两位的十六进制数可以用 `pattern:[0-9a-f]{2}`（假设已设定修饰符 `pattern:i`）进行匹配。\n\n我们需要匹配数字 `NN`，然后再重复 5 次 `:NN`（匹配更多数字）；\n\n所以正则表达式为：`pattern:[0-9a-f]{2}(:[0-9a-f]{2}){5}`\n\n现在让我们验证一下此匹配规则可以捕获整个文本：从开头开始，在结尾结束。这是通过将模式包装在 `pattern:^...$` 中实现的。\n\n最终：\n\n```js run\nlet regexp = /^[0-9a-f]{2}(:[0-9a-f]{2}){5}$/i;\n\nalert( regexp.test('01:32:54:67:89:AB') ); // true\n\nalert( regexp.test('0132546789AB') ); // false (没有分号分隔)\n\nalert( regexp.test('01:32:54:67:89') ); // false (5 个数字，必须为 6 个)\n\nalert( regexp.test('01:32:54:67:89:ZZ') ) // false (尾部为 ZZ)\n```",
        "parent": "regexp-groups",
        "version": 1
      }
    },
    "find-webcolor-3-or-6": {
      "type": "Task",
      "value": {
        "title": "找出形如 #abc 或 #abcdef 的颜色值",
        "slug": "find-webcolor-3-or-6",
        "githubPath": "/9-regular-expressions/11-regexp-groups/02-find-webcolor-3-or-6",
        "weight": 2,
        "libs": [],
        "content": "\n\n编写一个匹配 `#abc` 或 `#abcdef` 格式的颜色值的正则表达式。即：`#` 后跟着 3 个或 6 个十六进制的数字。\n\n用例：\n```js\nlet regexp = /你的正则表达式/g;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(regexp) ); // #3f3 #AA00ef\n```\n\nP.S. 必须只匹配 3 位或 6 位十六进制数字的颜色值。不应该匹配 4 位数字的值，例如 `#abcd`。",
        "solution": "查找 `#` 号后跟着 3 位十六进制数的颜色值 `#abc` 的正则表达式：`pattern:/#[a-f0-9]{3}/i`。\n\n我们可以再添加 3 位可选的十六进制数字。这样刚好，不多不少。只匹配 `#` 号后跟着 3 位或 6 位十六进制数字的颜色值。\n\n我们使用量词 `pattern:{1,2}` 来实现：所以正则表达式为 `pattern:/#([a-f0-9]{3}){1,2}/i`。\n\n这里将模式 `pattern:[a-f0-9]{3}` 用括号括起来，以在其外面应用量词 `pattern:{1,2}`。\n\n用例：\n\n```js run\nlet regexp = /#([a-f0-9]{3}){1,2}/gi;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(regexp) ); // #3f3 #AA00ef #abc\n```\n\n这里存在一个小问题：上面的模式会匹配 `subject:#abcd` 中的 `match:#abc`。为避免这一问题，我们可以在最后添加 `pattern:\\b`。\n\n```js run\nlet regexp = /#([a-f0-9]{3}){1,2}\\b/gi;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(regexp) ); // #3f3 #AA00ef\n```",
        "parent": "regexp-groups",
        "version": 1
      }
    },
    "find-decimal-numbers": {
      "type": "Task",
      "value": {
        "title": "找出所有数字",
        "slug": "find-decimal-numbers",
        "githubPath": "/9-regular-expressions/11-regexp-groups/03-find-decimal-numbers",
        "weight": 3,
        "libs": [],
        "content": "\n\n编写一个正则表达式，找出所有十进制数字，包括整数、浮点数和负数。\n\n用例：\n\n```js\nlet regexp = /你的正则表达式/g;\n\nlet str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(regexp) ); // -1.5, 0, 2, -123.4\n```",
        "solution": "带有可选小数部分的正数：`pattern:\\d+(\\.\\d+)?`。\n\n让我们在开头加上可选的 `pattern:-`：\n\n```js run\nlet regexp = /-?\\d+(\\.\\d+)?/g;\n\nlet str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(regexp) );   // -1.5, 0, 2, -123.4\n```",
        "parent": "regexp-groups",
        "version": 1
      }
    },
    "parse-expression": {
      "type": "Task",
      "value": {
        "title": "解析表达式",
        "slug": "parse-expression",
        "githubPath": "/9-regular-expressions/11-regexp-groups/04-parse-expression",
        "weight": 4,
        "libs": [],
        "content": "\n\n一个算术表达式由 2 个数字和一个它们之间的运算符组成，例如：\n\n- `1 + 2`\n- `1.2 * 3.4`\n- `-3 / -6`\n- `-2 - 2`\n\n运算符为 `\"+\"`、`\"-\"`、`\"*\"` 或 `\"/\"` 中之一。\n\n在开头、之间的部分或末尾可能有额外的空格。\n\n创建一个函数 `parse(expr)`，它接受一个表达式作为参数，并返回一个包含 3 个元素的数组：\n\n1. 第一个数字\n2. 运算符\n3. 第二个数字\n\n用例：\n\n```js\nlet [a, op, b] = parse(\"1.2 * 3.4\");\n\nalert(a); // 1.2\nalert(op); // *\nalert(b); // 3.4\n```",
        "solution": "匹配数字的正则表达式：`pattern:-?\\d+(\\.\\d+)?`。我们在上一题创建了这个表达式。\n\n我们可以使用 `pattern:[-+*/]` 匹配运算符。连字符 `pattern:-` 在方括号中的最前面，因为在中间它表示字符范围，而我们只想让其表示字符 `-`。\n\n在 JavaScript 正则表达式 `pattern:/.../` 中，我们应该对 `/` 进行转义，稍后我们会对其进行处理。\n\n我们需要一个数字、一个运算符以及另一个数字。其间可能会有空格。\n\n完整的正则表达式为：`pattern:-?\\d+(\\.\\d+)?\\s*[-+*/]\\s*-?\\d+(\\.\\d+)?`。\n\n它包含 3 个部分，以 `pattern:\\s*` 分隔：\n1. `pattern:-?\\d+(\\.\\d+)?` —— 第一个数字，\n2. `pattern:[-+*/]` —— 运算符，\n3. `pattern:-?\\d+(\\.\\d+)?` —— 第二个数字。\n\n为了使这里的每一部分成为结果数组中的单独元素，所以我们把它们括在括号里：`pattern:(-?\\d+(\\.\\d+)?)\\s*([-+*/])\\s*(-?\\d+(\\.\\d+)?)`。\n\n使用示例：\n\n```js run\nlet regexp = /(-?\\d+(\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(\\.\\d+)?)/;\n\nalert( \"1.2 + 12\".match(regexp) );\n```\n\n结果包括：\n\n- `result[0] == \"1.2 + 12\"` (完整的匹配项)\n- `result[1] == \"1.2\"` (第一组 `(-?\\d+(\\.\\d+)?)` —— 第一个数字，包括小数部分)\n- `result[2] == \".2\"` (第二组 `(\\.\\d+)?` —— 第一个数字的小数部分)\n- `result[3] == \"+\"` (第三组 `([-+*\\/])` —— 运算符)\n- `result[4] == \"12\"` (第四组 `(-?\\d+(\\.\\d+)?)` —— 第二个数字)\n- `result[5] == undefined`（第五组 `(\\.\\d+)?` —— 第二个数字的小数部分不存在，所以这里是 undefined）\n\n我们只想要数字和运算符，不需要完全匹配的以及小数部分结果，所以让我们稍微“清理”一下结果。\n\n我们可以使用数组的 `shift` 方法 `result.shift()` 来删去完全匹配的结果（数组的第一项）。\n\n可以通过在开头添加 `pattern:?:` 来排除包含小数部分（数字 2 和 4）`pattern:(.\\d+)` 的组：`pattern:(?:\\.\\d+)?`。\n\n最终的解决方案：\n\n```js run\nfunction parse(expr) {\n  let regexp = /(-?\\d+(?:\\.\\d+)?)\\s*([-+*\\/])\\s*(-?\\d+(?:\\.\\d+)?)/;\n\n  let result = expr.match(regexp);\n\n  if (!result) return [];\n  result.shift();\n\n  return result;\n}\n\nalert( parse(\"-1.23 * 3.45\") );  // -1.23, *, 3.45\n```",
        "parent": "regexp-groups",
        "version": 1
      }
    },
    "regexp-backreferences": {
      "type": "Article",
      "value": {
        "title": "模式中的反向引用：\\N 和 \\k<name>",
        "slug": "regexp-backreferences",
        "githubPath": "/9-regular-expressions/12-regexp-backreferences",
        "isFolder": false,
        "weight": 12,
        "content": "\n\n我们不仅可以在结果或替换字符串中使用捕获组 `pattern:(...)` 的内容，还可以在模式本身中使用它们。\n\n## 按编号反向引用：\\N\n\n可以使用 `pattern:\\N` 在模式中引用一个组，其中 `N` 是组号。\n\n为了弄清这有什么用，让我们考虑一个任务。\n\n我们需要找到带引号的字符串：单引号 `subject:'...'` 或双引号 `subject:\"...\"` —— 应匹配这两种变体。\n\n如何找到它们？\n\n我们可以将两种引号都放在方括号中：`pattern:['\"](.*?)['\"]`，但它会找到带有混合引号的字符串，例如 `match:\"...'` 和 `match:'...\"`。当一种引号出现在另一种引号内，比如在字符串 `subject:\"She's the one!\"` 中时，便会导致不正确的匹配：\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\nlet regexp = /['\"](.*?)['\"]/g;\n\n// 不是我们想要的结果\nalert( str.match(regexp) ); // \"She'\n```\n\n正如我们所看到的，该模式找到了一个开头的引号 `match:\"`，然后文本被匹配，直到另一个引号 `match:'`，该匹配结束。\n\n为了确保模式查找的结束引号与开始的引号完全相同，我们可以将其包装到捕获组中并对其进行反向引用：`pattern:(['\"])(.*?)\\1`。\n\n这是正确的代码：\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\n*!*\nlet regexp = /(['\"])(.*?)\\1/g;\n*/!*\n\nalert( str.match(regexp) ); // \"She's the one!\"\n```\n\n现在可以了！正则表达式引擎会找到第一个引号 `pattern:(['\"])` 并记住其内容。那是第一个捕获组。\n\n在模式中 `pattern:\\1` 表示“找到与第一组相同的文本”，在我们的示例中为完全相同的引号。\n\n与此类似，`pattern:\\2` 表示第二组的内容，`pattern:\\3` —— 第三分组，依此类推。\n\n```smart\n如果我们在捕获组中使用 `?:`，那么我们将无法引用它。用 `(?:...)` 捕获的组被排除，引擎不会记住它。\n```\n\n```warn header=\"不要搞混了：在模式中用 `pattern:\\1`，在替换项中用：`pattern:$1`\"\n在替换字符串中我们使用美元符号：`pattern:$1`，而在模式中 —— 使用反斜杠 `pattern:\\1`。\n```\n\n## 按命名反向引用：`\\k<name>`\n\n如果一个正则表达式中有很多括号，给它们起个名字会便于引用。\n\n要引用命名的捕获组，我们可以使用：`pattern:\\k<name>`。\n\n在下面的示例中，带引号的组被命名为 `pattern:?<quote>`，因此反向引用为 `pattern:\\k<quote>`：\n\n```js run\nlet str = `He said: \"She's the one!\".`;\n\n*!*\nlet regexp = /(?<quote>['\"])(.*?)\\k<quote>/g;\n*/!*\n\nalert( str.match(regexp) ); // \"She's the one!\"\n```",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1659861377
      }
    },
    "regexp-alternation": {
      "type": "Article",
      "value": {
        "title": "选择 (OR) |",
        "slug": "regexp-alternation",
        "githubPath": "/9-regular-expressions/13-regexp-alternation",
        "isFolder": false,
        "weight": 13,
        "content": "\n\n选择是正则表达式中的一个术语，实际上是一个简单的“或”。\n\n在正则表达式中，它用竖线 `pattern:|` 表示。\n\n例如，我们想要找出编程语言：HTML、PHP、Java 或 JavaScript。\n\n对应的正则表达式为：`pattern:html|php|java(script)?`。\n\n用例如下：\n\n```js run\nlet regexp = /html|php|css|java(script)?/gi;\n\nlet str = \"First HTML appeared, then CSS, then JavaScript\";\n\nalert( str.match(regexp) ); // 'HTML', 'CSS', 'JavaScript'\n```\n\n我们看到过类似的东西 —— 方括号。它允许我们在多个字符中进行选择，例如 `pattern:gr[ae]y` 匹配 `match:gray` 或 `match:grey`。\n\n方括号只允许字符或字符类。选择允许任何表达式。正则表达式 `pattern:A|B|C` 表示表达式 `A`、`B` 或 `C` 其一均可。\n\n例如：\n\n- `pattern:gr(a|e)y` 等同于 `pattern:gr[ae]y`。\n- `pattern:gra|ey` 表示 `match:gra` 或 `match:ey`。\n\n要将选择应用于模式中一部分内容的选择，我们可以将其括在括号中：\n- `pattern:I love HTML|CSS` 匹配 `match:I love HTML` 或 `match:CSS`。\n- `pattern:I love (HTML|CSS)` 匹配 `match:I love HTML` 或 `match:I love CSS`。\n\n## 示例：用于时间匹配的正则表达式\n\n在之前的章节中有个任务是构建用于查找形如 `hh:mm` 的时间字符串，例如 `12:00`。但是简单的 `pattern:\\d\\d:\\d\\d` 太模糊了。它也会匹配 `25:99`（因为 25 和 99 都与模式匹配，但这不是有效的时间）。\n\n如何构建更好的模式？\n\n我们可以应用更精细的匹配。首先，对于时间：\n\n- 如果第一位数是 `0` 或 `1`，那么下一位数可以是任何数值：`pattern:[01]\\d`。\n- 否则，如果第一位数是 `2`，那么下一位数必须是 `pattern:[0-3]`。\n- 不允许其他的首位数。\n\n我们可以使用选择在正则表达式中编写这两种变体：`pattern:[01]\\d|2[0-3]`。\n\n接下来，分钟必须为从 `00` 到 `59` 的数。写成正则表达式即为 `pattern:[0-5]\\d`：第一个数字 `0-5`，然后是任何数字。\n\n如果我们将小时和分钟的正则表达式组合在一起，我们会得到：`pattern:[01]\\d|2[0-3]:[0-5]\\d`\n\n我们差不多完成了，但有一个问题。选择 `pattern:|` 现在恰好位于 `pattern:[01]\\d` 和 `pattern:2[0-3]:[0-5]\\d` 之间。\n\n也就是说：它只匹配符号左侧或右侧任一表达式。\n\n```\n[01]\\d  |  2[0-3]:[0-5]\\d\n```\n\n此模式查找 `pattern:[01]\\d` 或 `pattern:2[0-3]:[0-5]\\d`。\n\n但这是错误的，应该只在正则表达式的“小时”部分使用选择，以允许 `pattern:[01]\\d` 或 `pattern:2[0-3]`。让我们通过将“小时”括在括号中来纠正这个问题：`pattern:([01]\\d|2[0-3]):[0-5]\\d`\n\n最终的解决方案：\n\n```js run\nlet regexp = /([01]\\d|2[0-3]):[0-5]\\d/g;\n\nalert(\"00:00 10:10 23:59 25:99 1:2\".match(regexp)); // 00:00,10:10,23:59\n```",
        "libs": [],
        "children": [
          "find-programming-language",
          "find-matching-bbtags",
          "match-quoted-string",
          "match-exact-tag"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1659867098
      }
    },
    "find-programming-language": {
      "type": "Task",
      "value": {
        "title": "查找编程语言",
        "slug": "find-programming-language",
        "githubPath": "/9-regular-expressions/13-regexp-alternation/01-find-programming-language",
        "weight": 1,
        "libs": [],
        "content": "\n\n有很多编程语言，例如 Java、JavaScript、PHP、C 或 C++。\n\n构建一个正则表达式，用来匹配字符串 `subject:Java JavaScript PHP C++ C` 中包含的编程语言：\n\n```js\nlet regexp = /你的正则表达式/g;\n\nalert(\"Java JavaScript PHP C++ C\".match(regexp)); // Java JavaScript PHP C++ C\n```",
        "solution": "首先想到的解法是列出所有编程语言，在它们之间加上 `|` 符号。\n\n但运行结果不符合预期：\n\n```js run\nlet regexp = /Java|JavaScript|PHP|C|C\\+\\+/g;\n\nlet str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(regexp) ); // Java,Java,PHP,C,C\n```\n\n正则表达式引擎注意查找选择。也就是说：它先检查是否存在 `match:Java`，不存在 —— 接着匹配 `match:JavaScript` 及其后的字符串。\n\n结果，`match:JavaScript` 永远匹配不到，因为 `match:Java` 先被匹配了。\n\n`match:C` 和 `match:C++` 同理。\n\n这个问题有两个解决方式：\n\n1. 更改顺序以先检查较长的匹配项：`pattern:JavaScript|Java|C\\+\\+|C|PHP`。\n2. 合并相同前缀：`pattern:Java(Script)?|C(\\+\\+)?|PHP`。\n\n测试一下：\n\n```js run\nlet regexp = /Java(Script)?|C(\\+\\+)?|PHP/g;\n\nlet str = \"Java, JavaScript, PHP, C, C++\";\n\nalert( str.match(regexp) ); // Java,JavaScript,PHP,C,C++\n```",
        "parent": "regexp-alternation",
        "version": 1
      }
    },
    "find-matching-bbtags": {
      "type": "Task",
      "value": {
        "title": "查找 bbtag 对",
        "slug": "find-matching-bbtags",
        "githubPath": "/9-regular-expressions/13-regexp-alternation/02-find-matching-bbtags",
        "weight": 2,
        "libs": [],
        "content": "\n\n“bb-tag” 形如 `[tag]...[/tag]`，`tag` 匹配 `b`、`url` 或 `quote` 中之一。\n\n例如：\n```\n[b]text[/b]\n[url]http://google.com[/url]\n```\n\nBB-tags 可以嵌套。但标签不能自嵌套，比如：\n\n```\n可以：\n[url] [b]http://google.com[/b] [/url]\n[quote] [b]text[/b] [/quote]\n\n不可以：\n[b][b]text[/b][/b]\n```\n\n标签可以包含换行，通常：\n\n```\n[quote]\n  [b]text[/b]\n[/quote]\n```\n\n构造一个正则表达式用于查找所有 BB-tags 及其内容。\n\n例如：\n\n```js\nlet regexp = /your regexp/flags;\n\nlet str = \"..[url]http://google.com[/url]..\";\nalert( str.match(regexp) ); // [url]http://google.com[/url]\n```\n\n如果标签嵌套，那么我们需要记录匹配的外层标签（如果需要，我们可以继续在其内容中搜索）：\n\n```js\nlet regexp = /你的正则表达式/flags;\n\nlet str = \"..[url][b]http://google.com[/b][/url]..\";\nalert( str.match(regexp) ); // [url][b]http://google.com[/b][/url]\n```",
        "solution": "起始标签是 `pattern:\\[(b|url|quote)\\]`。\n\n匹配字符串直到遇到结束标签 —— 让我们使用模式 `pattern:.*?` 和修饰符 `pattern:s` 来匹配包括换行符在内的任何字符，然后向结束标签添加反向引用。\n\n完整模式为：`pattern:\\[(b|url|quote)\\].*?\\[/\\1]`。\n\n代码运行如下：\n\n```js run\nlet regexp = /\\[(b|url|quote)].*?\\[\\/\\1]/gs;\n\nlet str = `\n  [b]hello![/b]\n  [quote]\n    [url]http://google.com[/url]\n  [/quote]\n`;\n\nalert( str.match(regexp) ); // [b]hello![/b],[quote][url]http://google.com[/url][/quote]\n```\n\n请注意，除了转义 `pattern:[` 之外，我们还必须为结束标签 `pattern:[\\/\\1]` 转义一个斜线，因为通常斜线会关闭模式。",
        "parent": "regexp-alternation",
        "version": 1
      }
    },
    "match-quoted-string": {
      "type": "Task",
      "value": {
        "title": "查找引用的字符串",
        "slug": "match-quoted-string",
        "githubPath": "/9-regular-expressions/13-regexp-alternation/03-match-quoted-string",
        "weight": 3,
        "libs": [],
        "content": "\n\n构建一个正则表达式以查找双引号 `subject:\"...\"` 中的字符串。\n\n字符串应该支持转义，就像 JavaScript 字符串一样。例如，引号可以插入为 `subject:\\\"`，换行符可以插入为 `subject:\\n`，而反斜线本身可以插入为 `subject:\\\\`。\n\n```js\nlet str = \"Just like \\\"here\\\".\";\n```\n\n请注意，转义的引号 `subject:\\\"` 不会结束字符串匹配。\n\n所以，我们应该匹配两个引号之间的内容，且忽略中间转义的引号。\n\n这是任务的基本部分，否则这个任务就没什么意思了。\n\n要匹配的字符串示例：\n```js\n.. *!*\"test me\"*/!* ..  \n.. *!*\"Say \\\"Hello\\\"!\"*/!* ..（其中有被转义的引号）\n.. *!*\"\\\\\"*/!* ..（其中有双反斜线）\n.. *!*\"\\\\ \\\"\"*/!* ..（其中有双反斜线和被转义的引号）\n```\n\n在 JavaScript 中，双反斜线用于把反斜线转义为字符串，如下所示：\n\n```js run\nlet str = ' .. \"test me\" .. \"Say \\\\\"Hello\\\\\"!\" .. \"\\\\\\\\ \\\\\"\" .. ';\n\n// 存储中的字符串\nalert(str); //  .. \"test me\" .. \"Say \\\"Hello\\\"!\" .. \"\\\\ \\\"\" ..\n```",
        "solution": "解决方案：`pattern:/\"(\\\\.|[^\"\\\\])*\"/g`。\n\n一步一步来分析一下：\n\n- 首先匹配左双引号 `pattern:\"`\n- 接着如果有反斜线 `pattern:\\\\`，则匹配其后跟随的任意字符（.）。（技术上，我们必须在模式中用双反斜线，因为它是一个特殊的字符，但实际上是一个反斜线字符）。\n- 如果没有，则匹配除双引号（表示字符串的末尾）和反斜线（排除仅存在反斜杠的情况，反斜杠仅在和其后字符一起使用时有效）外的任何字符：`pattern:[^\"\\\\]`。\n- ……继续匹配直到遇到右双引号\n\n代码运行如下：\n\n```js run\nlet regexp = /\"(\\\\.|[^\"\\\\])*\"/g;\nlet str = ' .. \"test me\" .. \"Say \\\\\"Hello\\\\\"!\" .. \"\\\\\\\\ \\\\\"\" .. ';\n\nalert( str.match(regexp) ); // \"test me\",\"Say \\\"Hello\\\"!\",\"\\\\ \\\"\"\n```",
        "parent": "regexp-alternation",
        "version": 1
      }
    },
    "match-exact-tag": {
      "type": "Task",
      "value": {
        "title": "查找完整标签",
        "slug": "match-exact-tag",
        "githubPath": "/9-regular-expressions/13-regexp-alternation/04-match-exact-tag",
        "weight": 4,
        "libs": [],
        "content": "\n\n写出一个正则表达式，用于查找 `<style...>` 标签。它应该匹配完整的标签：该标签可能没有特性（attributes）`<style>`，也可能有很多特性 `<style type=\"...\" id=\"...\">`。\n\n……同时正则表达式不应该匹配 `<styler>`！\n\n例如：\n\n```js\nlet regexp = /你的正则表达式/g;\n\nalert( '<style> <styler> <style test=\"...\">'.match(regexp) ); // <style>, <style test=\"...\">\n```",
        "solution": "模式的开头很明显：`pattern:<style`。\n\n……但我们不能简单地将表达式写为 `pattern:<style.*?>`，因为会匹配上 `match:<styler>`。\n\n我们要匹配的是在 `match:<style` 之后紧跟着一个空格然后是可选的其他内容，或者直接是闭标签 `match:>`。\n\n写成正则表达式即为：`pattern:<style(>|\\s.*?>)`。\n\n代码运行如下：\n\n```js run\nlet regexp = /<style(>|\\s.*?>)/g;\n\nalert( '<style> <styler> <style test=\"...\">'.match(regexp) ); // <style>, <style test=\"...\">\n```",
        "parent": "regexp-alternation",
        "version": 1
      }
    },
    "regexp-lookahead-lookbehind": {
      "type": "Article",
      "value": {
        "title": "前瞻断言与后瞻断言",
        "slug": "regexp-lookahead-lookbehind",
        "githubPath": "/9-regular-expressions/14-regexp-lookahead-lookbehind",
        "isFolder": false,
        "weight": 14,
        "content": "\n\n有时我们只需要为一个模式找到那些在另一个模式之后或之前的匹配项。\n\n有一种特殊的语法，称为“前瞻断言（lookahead）”和“后瞻断言（lookbehind）”。\n\n首先，让我们从字符串中查找价格，例如 `subject:1 turkey costs 30€`。即：一个数字，后跟`subject:€`符号。\n\n## 前瞻断言\n\n语法为：`pattern:x(?=y)`，它表示“仅在后面是 `pattern:Y` 时匹配 `pattern:X`”。这里的 `pattern:X` 和 `pattern:Y` 可以是任何模式。\n\n那么对于一个后面跟着 `€` 的整数，正则表达式应该为：`pattern:\\d+(?=€)`。\n\n```js run\nlet str = \"1 turkey costs 30€\";\n\nalert( str.match(/\\d+(?=€)/) ); // 30，数字 1 被忽略了，因为它后面没有 €\n```\n\n请注意：前瞻断言只是一个测试，括号 `pattern:(?=...)` 中的内容不包含在匹配结果 `match:30` 中。\n\n当我们查找 `pattern:X(?=Y)` 时，正则表达式引擎会找到 `pattern:X`，然后检查其后是否有 `pattern:Y`。如果没有，则跳过潜在匹配，并继续搜索。\n\n更复杂的测试也是可能的，例如 `pattern:X(?=Y)(?=Z)` 表示：\n\n1. 寻找 `pattern:X`。\n2. 检查 `pattern:Y` 是否紧跟在 `pattern:X` 之后（如果不是则跳过）。\n3. 检查 `pattern:Z` 是否也在 `pattern:X` 之后（如果不是则跳过）。\n4. 如果两个测试都通过了，那么 `pattern:X` 是匹配的，否则继续搜索。 \n\n换句话说，这样的模式意味着我们同时在寻找 `pattern:X` 后跟 `pattern:Y` 和 `pattern:Z`。\n\n这只有在模式 `pattern:Y` 和 `pattern:Z` 不是互斥的情况下才可行。\n\n例如，`pattern:\\d+(?=\\s)(?=.*30)` 查找后跟着空格 `pattern:(?=\\s)` 的 `pattern:\\d+`，并且有 ` 30` 在它之后的某个地方 `pattern:(?=.*30)`：\n\n```js run\nlet str = \"1 turkey costs 30€\";\n\nalert( str.match(/\\d+(?=\\s)(?=.*30)/) ); // 1\n```\n\n在我们给出的字符串中，与数字 `1` 完全匹配。\n\n## 否定的前瞻断言\n\n假设我们想要一个数量，而不是来自同一字符串的价格。那是一个数字 `pattern:\\d+`，后面不是 `subject:€`。\n\n为此，我们可以使用否定的前瞻断言。\n\n语法是：`pattern:X(?!Y)`，意思是“搜索 `pattern:X`，但前提是后面没有 `pattern:Y`”。\n\n```js run\nlet str = \"2 turkeys cost 60€\";\n\nalert( str.match(/\\d+\\b(?!€)/g) ); // 2（价格不匹配）\n```\n\n## 后瞻断言\n\n```warn header=\"后瞻断言的浏览器兼容情况\"\n请注意：非 V8 引擎的浏览器不支持后瞻断言，例如 Safari、Internet Explorer。\n```\n\n前瞻断言允许添加一个“后面要跟着什么”的条件判断。\n\n后瞻断言也类似，只不过它是在相反的方向上进行条件判断。也就是说，它只允许匹配前面有特定字符串的模式。\n\n语法为如下：\n- 肯定的后瞻断言：`pattern:(?<=Y)X`，匹配 `pattern:X`，仅在前面是 `pattern:Y` 的情况下。\n- 否定的后瞻断言：`pattern:(?<!Y)X`，匹配 `pattern:X`，仅在前面不是 `pattern:Y` 的情况下。\n\n例如，让我们把价格换成美元。美元符号通常在数字前面，所以要查找 `$30` 我们将使用 `pattern:(?<=\\$)\\d+` —— 一个前面带 `subject:$` 的数值：\n\n```js run\nlet str = \"1 turkey costs $30\";\n\n// 美元符号被转义 \\$\nalert( str.match(/(?<=\\$)\\d+/) ); // 30（跳过了仅仅是数字的值）\n```\n\n如果我们需要找到量词 —— 一个前面不带 `subject:$` 的数字，我们可以使用否定的后瞻断言：`pattern:(?<!\\$)\\d+`\n\n```js run\nlet str = \"2 turkeys cost $60\";\n\nalert( str.match(/(?<!\\$)\\b\\d+/g) ); // 2（价格不匹配）\n```\n\n## 捕获组\n\n一般来说，前瞻断言和后瞻断言括号中的内容不会成为结果的一部分。\n\n例如，在模式 `pattern:\\d+(?!€)` 中，`pattern:€` 符号就不会出现在匹配结果中。这是很自然的事：我们寻找一个数字 `pattern:\\d+`，而 `pattern:(?=€)` 只是一个测试，表示要匹配的数字后面应该紧跟着 `subject:€` 字符。\n\n但在某些情况下，我们可能还想捕获前瞻断言和后瞻断言所匹配的内容，或者部分内容。这也是可行的。只需要将该部分包装在额外的括号中。\n\n在下面的示例中，货币符号 `pattern:(€|kr)` 和金额一起被捕获了：\n\n```js run\nlet str = \"1 turkey costs 30€\";\nlet regexp = /\\d+(?=(€|kr))/; // €|kr 两侧有额外的括号\n\nalert( str.match(regexp) ); // 30, €\n```\n\n后瞻断言也一样：\n\n```js run\nlet str = \"1 turkey costs $30\";\nlet regexp = /(?<=(\\$|£))\\d+/;\n\nalert( str.match(regexp) ); // 30, $\n```\n\n## 总结\n\n当我们想根据前面/后面的上下文匹配某些内容的时候，前瞻断言和后瞻断言（通常被称为“环视断言”）很有用。\n\n对于简单的正则表达式，我们可以手动执行类似的操作。即：不管上下文，匹配所有可匹配的内容，然后在循环中根据上下文进行过滤。\n\n请记住，`str.match`（没有修饰符 `pattern:g`）和 `str.matchAll`（总是）将匹配项作为具有 `index` 属性的数组返回，因此我们知道它在文本中的确切位置，并且可以检查上下文。\n\n但通常环视断言更方便。\n\n环视断言类型：\n\n| 模式            | 类型             | 匹配 |\n|--------------------|------------------|---------|\n| `X(?=Y)`   | 肯定的前瞻断言 | `pattern:X` 后紧跟着 `pattern:Y` |\n| `X(?!Y)`   | 否定的前瞻断言 | `pattern:X` 后没紧跟着 `pattern:Y` |\n| `(?<=Y)X` |  肯定的后瞻断言 | `pattern:X` 紧跟在 `pattern:Y` 后面 |\n| `(?<!Y)X` | 否定的后瞻断言 | `pattern:X` 没紧跟在 `pattern:Y` 后面 |",
        "libs": [],
        "children": [
          "find-non-negative-integers",
          "insert-after-head"
        ],
        "parent": "regular-expressions",
        "updatedAt": 1667114531
      }
    },
    "find-non-negative-integers": {
      "type": "Task",
      "value": {
        "title": "找到非负整数",
        "slug": "find-non-negative-integers",
        "githubPath": "/9-regular-expressions/14-regexp-lookahead-lookbehind/1-find-non-negative-integers",
        "weight": 1,
        "libs": [],
        "content": "\n\n这里有一个由整数组成的字符串。\n\n创建一个正则表达式来找出所有的非负整数（包括 0）。\n\n使用示例：\n```js\nlet regexp = /你的正则表达式/g;\n\nlet str = \"0 12 -5 123 -18\";\n\nalert( str.match(regexp) ); // 0, 12, 123\n```",
        "solution": "整数的正则表达式是 `pattern:\\d+` 。\n\n我们可以通过在它前面加上否定的后瞻断言来排除负数：`pattern:(?<!-)\\d+`。\n\n尽管如此，如果我们现在尝试使用上面的正则表达式，会发现有一个“例外”情况：\n\n```js run\nlet regexp = /(?<!-)\\d+/g;\n\nlet str = \"0 12 -5 123 -18\";\n\nconsole.log( str.match(regexp) ); // 0, 12, 123, *!*8*/!*\n```\n\n正如我们所看到的，它从 `subject:-18` 中配到了 `match:8`。要排除这种情况，我们需要确保正则表达式要从一个数的开头开始匹配数字，而不是从另一个（不匹配的）数字的中间开始进行匹配。\n\n我们可以通过指定另一个否定的后瞻断言来实现这一点：`pattern:(?<!-)(?<!\\d)\\d+`。现在 `pattern:(?<!\\d)` 确保匹配不会从另一个数字之后开始进行匹配了，这正是我们所需要的。\n\n我们也可以把它们合并成一个后瞻断言：\n\n```js run\nlet regexp = /(?<![-\\d])\\d+/g;\n\nlet str = \"0 12 -5 123 -18\";\n\nalert( str.match(regexp) ); // 0, 12, 123\n```",
        "parent": "regexp-lookahead-lookbehind",
        "version": 1
      }
    },
    "insert-after-head": {
      "type": "Task",
      "value": {
        "title": "在标签头后插入",
        "slug": "insert-after-head",
        "githubPath": "/9-regular-expressions/14-regexp-lookahead-lookbehind/2-insert-after-head",
        "weight": 2,
        "libs": [],
        "content": "\n\n我们有一个带有 HTML 文档的字符串。\n\n编写一个正则表达式，在 `<body>` 标签之后立即插入 `<h1>Hello</h1>`。标签可能具有特性（attribute）。\n\n例如：\n\n```js\nlet regexp = /你的正则表达式/;\n\nlet str = `\n<html>\n  <body style=\"height: 200px\">\n  ...\n  </body>\n</html>\n`;\n\nstr = str.replace(regexp, `<h1>Hello</h1>`);\n```\n\n之后，`str` 的值应该为：\n\n```html\n<html>\n  <body style=\"height: 200px\"><h1>Hello</h1>\n  ...\n  </body>\n</html>\n```",
        "solution": "为了在 `<body>` 标签后面插入内容，我们必须先找到它。我们可以使用正则表达式 `pattern:<body.*?>` 来实现。\n\n在本任务中，我们不需要修改 `<body>` 标签。我们只需要在它后面添加文本。\n\n我们可以这样做：\n\n```js run\nlet str = '...<body style=\"...\">...';\nstr = str.replace(/<body.*?>/, '$&<h1>Hello</h1>');\n\nalert(str); // ...<body style=\"...\"><h1>Hello</h1>...\n```\n\n在替换字符串中，`$&` 表示匹配本身，即源文本中与 `pattern:<body.*?>` 相对应的部分。它会被它自身加上 `<h1>Hello</h1>` 替换。\n\n另一种方法是使用后瞻断言：\n\n```js run\nlet str = '...<body style=\"...\">...';\nstr = str.replace(/(?<=<body.*?>)/, `<h1>Hello</h1>`);\n\nalert(str); // ...<body style=\"...\"><h1>Hello</h1>...\n```\n\n正如你所看到的，这个正则表达式中只有后瞻断言部分。\n\n它的工作原理如下：\n- 在文本的每个位置。\n- 检查它前面是否有 `pattern:<body.*?>`。\n- 如果有，就匹配该位置。\n\n标签 `pattern:<body.*?>` 不会被作为结果返回。这个正则表达式的结果实际上是一个空字符串，但它只匹配前面紧挨着 `pattern:<body.*?>` 的位置。\n\n因此，它将紧挨着 `pattern:<body.*?>` 的“空位置”替换为了 `<h1>Hello</h1>`。这样就在 `<body>` 之后插入了内容。\n\nP.S. 正则表达式中的修饰符，例如 `pattern:s` 和 `pattern:i` 也很有用：`pattern:/<body.*?>/si`。这里修饰符 `pattern:s` 使得 `.` 可以匹配换行符，而修饰符 `pattern:i` 使 `pattern:<body>` 大小写不敏感，可以匹配 `match:<BODY>`。",
        "parent": "regexp-lookahead-lookbehind",
        "version": 1
      }
    },
    "regexp-catastrophic-backtracking": {
      "type": "Article",
      "value": {
        "title": "灾难性回溯",
        "slug": "regexp-catastrophic-backtracking",
        "githubPath": "/9-regular-expressions/15-regexp-catastrophic-backtracking",
        "isFolder": false,
        "weight": 15,
        "content": "\n\n有些正则表达式看起来很简单，但执行起来耗时却非常长，甚至会导致 JavaScript 引擎“挂起”。\n\n大多数开发者迟早会遇到这样的情况。典型的症状就是 —— 正则表达式有时可以正常工作，但对于某些字符串，它会消耗 100% 的 CPU 算力，出现“挂起”的现象。\n\n在这种情况下，Web 浏览器会建议终止脚本并重新加载页面。这显然不是我们愿意看到的。\n\n对于服务器端 JavaScript，这样的正则表达式可能会挂起服务器进程，这甚至更糟。所以我们绝对应该研究研究它。\n\n## 举例\n\n假设，我们现在有一个字符串，我们想检查其中是否包含一些后面跟着可选空格 `pattern:\\s?` 的单词 `pattern:\\w+`。\n\n构造此正则表达式最显而易见的方式是一个单词后跟着一个可选空格 `pattern:\\w+\\s?`，然后用 `*` 重复它。\n\n写成正则表达式即 `pattern:^(\\w+\\s?)*$`，它指定 0 个及以上这样的词，从开头 `pattern:^` 开始，并在行的结尾 `pattern:$` 结束。\n\n运行一下：\n\n```js run\nlet regexp = /^(\\w+\\s?)*$/;\n\nalert( regexp.test(\"A good string\") ); // true\nalert( regexp.test(\"Bad characters: $@#\") ); // false\n```\n\n这似乎能正常工作。结果是正确的。但在特定的字符串上，它会消耗很多时间。它耗时太久以至于让 CPU 会跑满 100% 负载，导致 JavaScript 引擎“挂起”。\n\n如果你运行下面这个例子，由于 JavaScript 会进导致“挂起”，所以你可能什么结果都看不到。此时浏览器会停止对事件的响应，UI 也会停止工作。一段时间之后，浏览器会建议重新加载页面。所以请谨慎对待：\n\n```js run\nlet regexp = /^(\\w+\\s?)*$/;\nlet str = \"An input string that takes a long time or even makes this regexp hang!\";\n\n// 会耗费很长时间\nalert( regexp.test(str) );\n```\n\n有一些正则表达式引擎可以很好地处理这样的搜索，例如从 8.8 版本开始的 V8 引擎（因此 88 及以上版本的 Google Chrome 不会在这里挂起），而火狐（Firefox）浏览器确实会挂起。\n\n## 简化的例子\n\n问题出在哪？为什么正则表达式会导致“挂起”？\n\n为了理解它，我们来简化一下例子：移除空格符 `pattern:\\s?`，使其简化为 `pattern:^(\\w+)*$`。\n\n同时为了让问题更明显，再用 `pattern:\\d` 替换掉 `pattern:\\w`。生成的新正则表达式执行时仍会导致挂起，例如：\n\n```js run\nlet regexp = /^(\\d+)*$/;\n\nlet str = \"012345678901234567890123456789z\";\n\n// 会消耗很长时间（请小心！）\nalert( regexp.test(str) );\n```\n\n所以正则表达式哪里出了问题？\n\n首先，有人可能会注意到这个正则表达式的 `pattern:(\\d+)*` 部分有点奇怪。量词 `pattern:*` 看起来没什么必要。如果我们要匹配一个数字，那可以使用 `pattern:\\d+`。\n\n实际上，正则表达式很死板。我们通过简化前面的例子得到了一个简化版的正则表达式。但慢的原因是一样的。所以让我们来理解一下它的执行过程，然后问题的原因就会显而易见了。\n\n在 `subject:123456789z` 这行（清楚起见，这里缩短了字符串，请注意末尾的非数字字符 `subject:z`，这很重要）中搜索 `pattern:^(\\d+)*$` 时到底发生了什么，为什么耗时这么久？\n\n下面是正则表达式引擎的执行过程：\n\n1. 首先，正则表达式引擎尝试查找括号中的内容：数字 `pattern:\\d+`。加号 `pattern:+` 默认为贪婪模式，所以它消耗了所有数字：\n\n    ```\n    \\d+.......\n    (123456789)z\n    ```\n\n    消耗完所有数字后，认为找到了 `pattern:\\d+`（如 `match:123456789`）。\n    \n    然后它尝试应用星号量词，但此时已经没有更多数字了，所以星号没有给出任何信息。\n\n    模式中接下来的 `pattern:$` 匹配字符串的结束，但是我们例子的文字中有 `subject:z`，所以匹配失败：\n\n    ```\n               X\n    \\d+........$\n    (123456789)z\n    ```\n\n2. 由于没有匹配结果，贪婪量词 `pattern:+` 的重复匹配次数会减一，并回溯一个字符。\n\n    现在 `pattern:\\d+` 会匹配除了最后一个数字之外的所有数字（`match:12345678`）：\n    ```\n    \\d+.......\n    (12345678)9z\n    ```\n3. 然后引擎尝试从新位置 (`9`) 继续搜索。\n\n    星号 `pattern:(\\d+)*` 可以成功应用 —— 它匹配到了数字 `match:9`：\n\n    ```\n\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n    引擎再次去尝试匹配 `pattern:$`，但又失败了，因为它遇到了 `subject:z`：\n\n    ```\n                 X\n    \\d+.......\\d+\n    (12345678)(9)z\n    ```\n\n\n4. 没有匹配结果，所以引擎继续回溯，减少重复匹配次数。回溯通常是这样工作的：最后一个贪婪量词逐渐减少重复次数，直到达到最小值。然后前一个贪婪量词再减少重复次数，以此类推。\n\n    它会尝试所有可能的排列组合，这里是它们的例子。\n\n    第一个数字 `pattern:\\d+` 有 7 位数，后面跟着一个 2 位数的数字：\n\n    ```\n                 X\n    \\d+......\\d+\n    (1234567)(89)z\n    ```\n\n    第一个数字有 7 位数，后面跟着两个 1 位数：\n\n    ```\n                   X\n    \\d+......\\d+\\d+\n    (1234567)(8)(9)z\n    ```\n\n    第一个数字有 6 位数，后面跟着一个 3 位数：\n\n    ```\n                 X\n    \\d+.......\\d+\n    (123456)(789)z\n    ```\n\n    第一个数字有 6 位数，后面跟着两个数字：\n\n    ```\n                   X\n    \\d+.....\\d+ \\d+\n    (123456)(78)(9)z\n    ```\n\n    ……以此类推。\n\n\n有很多种方式可以将数字序列 `123456789` 拆分为多个数字。准确地说，有 <code>2<sup>n</sup>-1</code> 种，其中 `n` 是序列的长度。\n\n- 对于 `123456789`，`n=9`，也就是说有 511 种组合。\n- 对于更长一点的 `n=20` 的字符串，差不多有 100 万种组合。\n- 对于 `n=30` —— 又增加了 1000 倍以上（1073741823 种组合）。\n\n搜索需要这么长时间正是因为在一个一个地尝试这么多种组合。\n\n## 回到单词和字符串\n\n在我们第一个例子中，当我们用 `pattern:^(\\w+\\s?)*$` 这种模式在字符串 `subject:An input that hangs!` 中查找单词时，就会发生类似的问题。\n\n就是因为一个单词 `pattern:\\w+` 可以被表示成很多种：\n\n```\n(input)\n(inpu)(t)\n(inp)(u)(t)\n(in)(p)(ut)\n...\n```\n\n以我们人的角度来看，很显然它无法匹配成功，因为示例中的字符串以叹号 `!` 结尾，然而正则表达式期望在的是一个单词 `pattern:\\w` 末尾有或没有空格 `pattern:\\s`。但引擎理解不了这种状况。\n\n它尝试了 `pattern:(\\w+\\s?)*` 的所有排列组合试图去囊括整个字符串，包括带空格 `pattern:(\\w+\\s)*` 的情形和不带空格 `pattern:(\\w+)*` 的情形（因为空格 `pattern:\\s?` 是可选的）。由于各种排列组合的数量（我们已经通过计算直观感受过了）太多了，所以耗费了大量时间去查询。\n\n那怎么办？\n\n我们应该改用懒惰模式吗？\n\n不幸的是，这没用：如果我们用 `pattern:\\w+?` 去替代 `pattern:\\w+`，还是会挂起。排列组合的顺序会变化，但是总数不变。\n\n有些正则表达式引擎具有对棘手内容的测试和自动化有限处理，可以避免遍历所有排列组合来优化速度，但大多数引擎没有，而且也不是在所有情况下都有效果。\n\n## 如何解决？\n\n主要有 2 种解决方式。\n\n第一种是减少可能的组合数量。\n\n让我们把正则表达式重写为 `pattern:^(\\w+\\s)*\\w*$` 以使空格变为非可选的 —— 我们将查找任意数量的单词后跟空格 `pattern:(\\w+\\s)*`，然后跟着最后一个单词 `pattern:\\w*`（可选）。\n\n这个正则表达式等同于之前那个（匹配内容相同），并且运行起来也没问题：\n\n```js run\nlet regexp = /^(\\w+\\s)*\\w*$/;\nlet str = \"An input string that takes a long time or even makes this regex hang!\";\n\nalert( regexp.test(str) ); // false\n```\n\n为什么问题消失了？\n\n因为现在空格是强制性的。\n\n前面的正则表达式，如果我们省略空格，就会变成 `pattern:(\\w+)*`，导致单个单词中有很多 `\\w+` 组合 。\n\n所以 `subject:input` 可以匹配为 `pattern:\\w+` 的两次重复，如下所示：\n\n```\n\\w+  \\w+\n(inp)(ut)\n```\n\n新模式有所不同：`pattern:(\\w+\\s)*` 指定单词的重复后面跟着一个空格！`subject:input` 字符串不能匹配为 `pattern:\\w+\\s` 的两次重复，因为空格是强制性的。\n\n现在节省了尝试大量（实际上是大多数）组合所需的时间。\n\n## 防止回溯\n\n有时候重写正则表达式会比较麻烦。在上面的示例中，这很容易，但如何做到这一点并不总是很明显。\n\n此外，重写的正则表达式通常更复杂，这并不好。在不做其他更改的情况下，正则表达式已经够复杂了。\n\n幸运的是，还有另一种方式。我们可以禁止量词的回溯。\n\n问题的根源在于正则表达式引擎尝试了许多对人类看来显然是错误的组合。\n\n例如，正则表达式 `pattern:(\\d+)*$` 中 `pattern:+` 对于我们人类来说很明显不应去回溯。就算我们用两个单独的 `pattern:\\d+\\d+` 去替换一个 `pattern:\\d+`，也根本没变化：\n\n```\n\\d+........\n(123456789)!\n\n\\d+...\\d+....\n(1234)(56789)!\n```\n\n在原先的那个例子 `pattern:^(\\w+\\s?)*$` 中，我们可能希望在 `pattern:\\w+` 中禁止回溯。即：`pattern:\\w+` 应该匹配一个完整的单词，并且具有最大可能的长度。无需降低 `pattern:\\w+` 的重复次数或将其拆分为两个单词 `pattern:\\w+\\w+` 等等。\n\n为此，现代正则表达式引擎支持占有型量词（Possessive Quantifiers）。如果我们在常规量词之后添加 `pattern:+`，则常规量词就变成了占有型量词。也就是说，我们可以使用 `pattern:\\d++` 替代 `pattern:\\d+` 来阻止 `pattern:+` 回溯。\n\n占有型量词实际上比“常规”量词更简单。它们只是尽可能多地匹配，没有任何回溯。没有回溯的搜索过程更简单。\n\n还有所谓的“原子捕获组” —— 一种禁用括号内回溯的方法。\n\n……但坏消息是，JavaScript 并不支持它。\n\n我们可以通过使用“前瞻变换（lookahead transform）”来模拟它们。\n\n### 用前瞻视角解决问题\n\n所以，我们来到了真正的高阶主题。我们希望量词，例如 `pattern:+` 不要回溯，因为有时回溯没有意义。\n\n在不回溯的情况下尽可能多地重复 `pattern:\\w` 的模式可以写为：`pattern:(?=(\\w+))\\1`。当然，我们可以采用另一种模式来代替 `pattern:\\w`。\n\n这可能看起来很奇怪，但它实际上是一个非常简单的转换。\n\n让我们解读一下：\n\n- 前瞻断言 `pattern:?=` 从当前位置开始，向前查找最长的单词 `pattern:\\w+`。\n- 引擎不会去记住带有 `pattern:?=...` 的括号中的内容。所以将 `pattern:\\w+` 放入括号中，这样引擎就会记住这些内容了。\n- ……然后用 `pattern:\\1` 来引用括号中的内容。\n\n也就是说：我们先进行前瞻查找 —— 如果有符合 `pattern:\\w+` 的单词，我们就可将其匹配为 `pattern:\\1`。\n\n为什么？因为前瞻断言查找到一个单词 `pattern:\\w+`，将其作为一个整体，然后将其捕获为 `pattern:\\1`。所以我们最终实现了一种占有型加号 `pattern:+` 量词。它只捕获整个单词 `pattern:\\w+`，而不会只捕获一部分。\n\n例如，在单词 `subject:JavaScript` 中不仅可以匹配 `match:Java`，而且可以忽略 `match:Script`，以匹配模式的其余部分。\n\n下面是 2 个模式的对比：\n\n```js run\nalert( \"JavaScript\".match(/\\w+Script/)); // JavaScript\nalert( \"JavaScript\".match(/(?=(\\w+))\\1Script/)); // null\n```\n\n1. 第一个变体 `pattern:\\w+` 首先捕获整个 `subject:JavaScript` 单词，然而接下来 `pattern:+` 会一个字符一个字符地进行回溯，试图匹配整个模式的其余部分，直到 `pattern:\\w+` 匹配到了 `match:Java` 时，它最终才匹配成功。\n2. 第二个变体 `pattern:(?=(\\w+))` 前瞻查找并匹配整个单词 `subject:JavaScript`，然后把整个单词作为一个整体包含进 `pattern:\\1` 中，所以在它后面就无法查找到 `subject:Script` 了。\n\n当我们需要禁止 `pattern:+` 进行回溯，只需要把 `pattern:(?=(\\w+))\\1` 中的 `pattern:\\w` 替换成更复杂的正则表达式就能实现了。\n\n```smart\n这些文章中有更多关于占有型量词和前瞻断言之间关系的内容：[正则表达式：使用前瞻断言模拟原子分组（和占有型量词）](http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead) 和 [模拟原子组](http://blog.stevenlevithan.com/archives/mimic-atomic-groups)。\n```\n\n现在让我们用前瞻断言重写第一个例子中的正则表达式来防止回溯吧：\n\n```js run\nlet regexp = /^((?=(\\w+))\\2\\s?)*$/;\n\nalert( regexp.test(\"A good string\") ); // true\n\nlet str = \"An input string that takes a long time or even makes this regex hang!\";\n\nalert( regexp.test(str) ); // false，有效且执行的很快！\n```\n\n这里我们用 `pattern:\\2` 而不是 `pattern:\\1`，因为这里有额外的外部括号。为了防止数字弄混了，我们可以给括号命名，例如 `pattern:(?<word>\\w+)`。\n\n```js run\n// 括号被命名为 ?<word>，使用 \\k<word> 进行引用\nlet regexp = /^((?=(?<word>\\w+))\\k<word>\\s?)*$/;\n\nlet str = \"An input string that takes a long time or even makes this regex hang!\";\n\nalert( regexp.test(str) ); // false\n\nalert( regexp.test(\"A correct string\") ); // true\n```\n\n本文所描述的问题称作“灾难性回溯（Catastrophic Backtracking）”，又译作“回溯陷阱”。\n\n我们介绍了两种解决方式：\n- 重写正则表达式，以尽可能降低可能的组合数量。\n- 防止回溯。",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1660014721
      }
    },
    "regexp-sticky": {
      "type": "Article",
      "value": {
        "title": "粘性修饰符 \"y\"，在位置处搜索",
        "slug": "regexp-sticky",
        "githubPath": "/9-regular-expressions/16-regexp-sticky",
        "isFolder": false,
        "weight": 16,
        "content": "\n\n`pattern:y` 修饰符让我们能够在源字符串中的指定位置进行搜索。\n\n为了掌握 `pattern:y` 修饰符的使用方式，让我们来看一个实际的例子。\n\n正则表达式的常见任务之一就是“词法分析”：例如我们得到了一个代码文本，我们需要找到它的结构元素。例如，HTML 有标签和特性（attribute），JavaScript 代码有函数、变量等。\n\n编写词法分析器是一个特殊的领域，有自己的工具和算法，所以我们不做过多的深入，但有一个共同的任务：在给定的位置读取一些内容。\n\n例如，我们有一个代码字符串 `subject:let varName = \"value\"`，我们需要从中读取变量名，这个变量名从位置 `4` 开始。\n\n我们将使用正则表达式 `pattern:\\w+` 来查找变量名。实际上，JavaScript 的变量名需要更复杂的正则表达式才能准确匹配，但在这里并不重要。\n\n- 调用 `str.match(/\\w+/)` 将只会找到该行中的第一个单词 (`let`)。不是这个。\n- 我们可以添加修饰符 `pattern:g`。但是调用 `str.match(/\\w+/g)` 会查找文本中的所有单词，而我们需要位置 `4` 的一个单词。同样，不是我们需要的。\n\n**那么，如何在给定位置准确搜索正则表达式？**。\n\n让我们尝试使用方法 `regexp.exec(str)`。\n\n对于没有修饰符 `pattern:g` 和 `pattern:y` 的 `regexp`，此方法仅查找第一个匹配项，就像 `str.match(regexp)` 一样。\n\n……但是如果有修饰符 `pattern:g`，那么它就会从存储在 `regexp.lastIndex` 属性中的位置开始在字符串 `str` 中进行搜索。如果找到匹配项，则将在匹配后立即将 `regexp.lastIndex` 设置为索引。\n\n换句话说，`regexp.lastIndex` 作为搜索的起点，每个 `regexp.exec(str)` 调用都会将其重置为新值（“在最后一次匹配后”）。当然，这只是在有 `pattern:g` 修饰符的情况下才会这样。\n\n因此，连续调用 `regexp.exec(str)` 会一个接一个地返回匹配。\n\n以下是此类调用的示例：\n\n```js run\nlet str = 'let varName'; // 让我们找出字符串中的所有单词\nlet regexp = /\\w+/g;\n\nalert(regexp.lastIndex); // 0 (初始值 lastIndex=0)\n\nlet word1 = regexp.exec(str);\nalert(word1[0]); // let (第一个单词)\nalert(regexp.lastIndex); // 3 (匹配后的位置)\n\nlet word2 = regexp.exec(str);\nalert(word2[0]); // varName (第二个单词)\nalert(regexp.lastIndex); // 11 (匹配后的位置)\n\nlet word3 = regexp.exec(str);\nalert(word3); // null (没有更多匹配项)\nalert(regexp.lastIndex); // 0 (搜索结束后重置索引)\n```\n\n我们可以通过循环获取所有匹配。\n\n```js run\nlet str = 'let varName';\nlet regexp = /\\w+/g;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Found ${result[0]} at position ${result.index}` );\n  // 在位置 0 发现了 let，然后\n  // 在位置 4 发现 varName\n}\n```\n\n`regexp.exec` 的这种使用方式可以作为 `str.matchAll` 方法的替代，可以对匹配过程进行更多控制。\n\n让我们回到我们的任务。\n\n我们可以手动将 `lastIndex` 设置为 `4`，从给定的位置开始搜索！\n\n像这样：\n\n```js run\nlet str = 'let varName = \"value\"';\n\nlet regexp = /\\w+/g; // 没有修饰符 \"g\"，lastIndex 属性会被忽略\n\n*!*\nregexp.lastIndex = 4;\n*/!*\n\nlet word = regexp.exec(str);\nalert(word); // varName\n```\n\n哇塞！问题解决了！\n\n我们从位置 `regexp.lastIndex = 4` 开始搜索 `pattern:\\w+`。\n\n结果是正确的。\n\n……但是等等，没那么快。\n\n请注意：`regexp.exec` 调用从位置 `lastIndex` 开始搜索，然后继续搜索。如果 `lastIndex` 位置没有单词，但单词在这之后的某个位置，那么单词也会被找到：\n\n```js run\nlet str = 'let varName = \"value\"';\n\nlet regexp = /\\w+/g;\n\n*!*\n// 从位置 3 开始搜索\nregexp.lastIndex = 3;\n*/!*\n\nlet word = regexp.exec(str); \n// 在位置 4 找到匹配项\nalert(word[0]); // varName\nalert(word.index); // 4\n```\n\n对于某些任务，包括词法分析，这是错误的。我们需要在文本的给定位置准确地找到匹配，而不是在它之后的某个位置。这就是修饰符 \"y\" 的用途。\n\n**修饰符 `pattern:y` 使 `regexp.exec` 精确搜索位置 `lastIndex`，而不是“从”它开始。** \n\n下面是带有修饰符 `pattern:y` 的相同搜索：\n\n```js run\nlet str = 'let varName = \"value\"';\n\nlet regexp = /\\w+/y;\n\nregexp.lastIndex = 3;\nalert( regexp.exec(str) ); // null（位置 3 有一个空格，不是单词）\n\nregexp.lastIndex = 4;\nalert( regexp.exec(str) ); // varName（在位置 4 的单词）\n```\n\n正如我们所看到的，正则表达式 `pattern:/\\w+/y` 在位置 `3` 处不匹配（不同于修饰符 `pattern:g`)，但在位置 `4` 处匹配。\n\n这不仅是我们所需要的，当使用修饰符 `pattern:y` 时，还有一个重要的性能提升。\n\n想象一下，我们有一个很长的文本，其中根本没有匹配项。然后使用修饰符 `pattern:g` 进行搜索，会一直搜索到文本的末尾，并且什么也找不到，这将比使用修饰符 `pattern:y` 的搜索花费更多的时间，后者只检查确切的位置。\n\n在像词法分析这样的任务中，通常会在一个确切的位置进行多次搜索，以检查我们在那里有什么。使用修饰符 `pattern:y` 是正确实现和良好性能的关键。",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1660036079
      }
    },
    "regexp-methods": {
      "type": "Article",
      "value": {
        "title": "正则表达式和字符串的方法",
        "slug": "regexp-methods",
        "githubPath": "/9-regular-expressions/17-regexp-methods",
        "isFolder": false,
        "weight": 17,
        "content": "\n\n在本文中，我们将深入介绍与正则表达式配合使用的各种方法。\n\n## str.match(regexp)\n\n`str.match(regexp)` 方法在字符串 `str` 中查找 `regexp` 的匹配项。\n\n它有 3 种模式：\n\n1. 如果 `regexp` 不带有修饰符 `pattern:g`，则它以数组的形式返回第一个匹配项，其中包含捕获组和属性 `index`（匹配项的位置）、`input`（输入字符串，等于 `str `）：\n\n    ```js run\n    let str = \"I love JavaScript\";\n\n    let result = str.match(/Java(Script)/);\n\n    alert( result[0] );     // JavaScript（完全匹配）\n    alert( result[1] );     // Script（第一个分组）\n    alert( result.length ); // 2\n\n    // 其他信息：\n    alert( result.index );  // 7（匹配位置）\n    alert( result.input );  // I love JavaScript（源字符串）\n    ```\n\n2. 如果 `regexp` 带有修饰符 `pattern:g`，则它将返回一个包含所有匹配项的数组，但不包含捕获组和其它详细信息。\n    ```js run\n    let str = \"I love JavaScript\";\n\n    let result = str.match(/Java(Script)/g);\n\n    alert( result[0] ); // JavaScript\n    alert( result.length ); // 1\n    ```\n\n3. 如果没有匹配项，则无论是否带有修饰符 `pattern:g`，都将返回 `null`。\n\n    这是一个重要的细微差别。如果没有匹配项，我们得到的不是一个空数组，而是 `null`。忘记这一点很容易出错，例如：\n\n    ```js run\n    let str = \"I love JavaScript\";\n\n    let result = str.match(/HTML/);\n\n    alert(result); // null\n    alert(result.length); // Error: Cannot read property 'length' of null\n    ```\n\n    如果我们希望结果是一个数组，我们可以这样写：\n\n    ```js\n    let result = str.match(regexp) || [];\n    ```\n\n## str.matchAll(regexp)\n\n[recent browser=\"new\"]\n\n方法 `str.matchAll(regexp)` 是 `str.match` 的“更新、改进”的变体。\n\n它主要用来搜索所有组的所有匹配项。\n\n与 `match` 相比有 3 个区别：\n\n1. 它返回一个包含匹配项的可迭代对象，而不是数组。我们可以用 `Array.from` 将其转换为一个常规数组。\n2. 每个匹配项均以一个包含捕获组的数组形式返回（返回格式与不带修饰符 `pattern:g` 的 `str.match` 相同）。\n3. 如果没有结果，则返回的是一个空的可迭代对象而不是 `null`。\n\n用法示例：\n\n```js run\nlet str = '<h1>Hello, world!</h1>';\nlet regexp = /<(.*?)>/g;\n\nlet matchAll = str.matchAll(regexp);\n\nalert(matchAll); // [object RegExp String Iterator]，不是数组，而是一个可迭代对象\n\nmatchAll = Array.from(matchAll); // 现在是数组了\n\nlet firstMatch = matchAll[0];\nalert( firstMatch[0] );  // <h1>\nalert( firstMatch[1] );  // h1\nalert( firstMatch.index );  // 0\nalert( firstMatch.input );  // <h1>Hello, world!</h1>\n```\n\n如果我们用 `for..of` 来遍历 `matchAll` 的匹配项，那么我们就不需要 `Array.from` 了。\n\n## str.split(regexp|substr, limit)\n\n使用正则表达式（或子字符串）作为分隔符来分割字符串。\n\n我们可以用 `split` 来分割字符串，像这样：\n\n```js run\nalert('12-34-56'.split('-')) // 数组 ['12', '34', '56']\n```\n\n但同样，我们也可以用正则表达式：\n\n```js run\nalert('12, 34, 56'.split(/,\\s*/)) // 数组 ['12', '34', '56']\n```\n\n## str.search(regexp)\n\n方法 `str.search(regexp)` 返回第一个匹配项的位置，如果没找到，则返回 `-1`：\n\n```js run\nlet str = \"A drop of ink may make a million think\";\n\nalert( str.search( /ink/i ) ); // 10（第一个匹配位置）\n```\n\n**重要限制：`search` 仅查找第一个匹配项。**\n\n如果我们需要其他匹配项的位置，则应使用其他方法，例如用 `str.matchAll(regexp)` 查找所有位置。\n\n## str.replace(str|regexp, str|func)\n\n这是用于搜索和替换的通用方法，是最有用的方法之一。它是搜索和替换字符串的瑞士军刀。  \n\n我们可以在不使用正则表达式的情况下使用它来搜索和替换子字符串：\n\n```js run\n// 用冒号替换连字符\nalert('12-34-56'.replace(\"-\", \":\")) // 12:34-56\n```\n\n不过有一个陷阱。\n\n**当 `replace` 的第一个参数是字符串时，它只替换第一个匹配项。**\n\n你可以在上面的示例中看到：只有第一个 `\"-\"` 被替换为了 `\":\"`。\n\n如要找到所有的连字符，我们不应该用字符串 `\"-\"`，而应使用带 `pattern:g` 修饰符的正则表达式 `pattern:/-/g`：\n\n```js run\n// 将所有连字符都替换为冒号\nalert( '12-34-56'.replace( *!*/-/g*/!*, \":\" ) )  // 12:34:56\n```\n\n第二个参数是替换字符串。我们可以在其中使用特殊字符：\n\n| 符号 | 替换字符串中的行为 |\n|--------|--------|\n|`$&`|插入整个匹配项|\n|<code>$&#096;</code>|插入字符串中匹配项之前的字符串部分|\n|`$'`|插入字符串中匹配项之后的字符串部分|\n|`$n`|如果 `n` 是一个 1-2 位的数字，则插入第 n 个分组的内容，详见 <info:regexp-groups>|\n|`$<name>`|插入带有给定 `name` 的括号内的内容，详见 <info:regexp-groups>|\n|`$$`|插入字符 `$` |\n\n例如：\n\n```js run\nlet str = \"John Smith\";\n\n// 交换名字和姓氏\nalert(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John\n```\n\n**对于需要“智能”替换的场景，第二个参数可以是一个函数。**\n\n每次匹配都会调用这个函数，并且返回的值将作为替换字符串插入。\n\n该函数 `func(match, p1, p2, ..., pn, offset, input, groups)` 带参数调用：\n\n1. `match` —— 匹配项，\n2. `p1, p2, ..., pn` —— 捕获组的内容（如有），\n3. `offset` —— 匹配项的位置，\n4. `input` —— 源字符串，\n5. `groups` —— 具有命名的捕获组的对象。\n\n如果正则表达式中没有括号，则只有 3 个参数：`func(str, offset, input)`。\n\n例如，将所有匹配项都大写：\n\n```js run\nlet str = \"html and css\";\n\nlet result = str.replace(/html|css/gi, str => str.toUpperCase());\n\nalert(result); // HTML and CSS\n```\n\n将每个匹配项替换为其在字符串中的位置：\n\n```js run\nalert(\"Ho-Ho-ho\".replace(/ho/gi, (match, offset) => offset)); // 0-3-6\n```\n\n在下面的示例中，有两对括号，因此将使用 5 个参数调用替换函数：第一个是完全匹配项，然后是 2 对括号，然后是（在示例中未使用）匹配位置和源字符串：\n\n```js run\nlet str = \"John Smith\";\n\nlet result = str.replace(/(\\w+) (\\w+)/, (match, name, surname) => `${surname}, ${name}`);\n\nalert(result); // Smith, John\n```\n\n如果有许多组，用 rest 参数（...）可以很方便的访问：\n\n```js run\nlet str = \"John Smith\";\n\nlet result = str.replace(/(\\w+) (\\w+)/, (...match) => `${match[2]}, ${match[1]}`);\n\nalert(result); // Smith, John\n```\n\n或者，如果我们使用的是命名组，则带有它们的 `groups` 对象始终是最后一个对象，所以我们可以像这样获取它：\n\n```js run\nlet str = \"John Smith\";\n\nlet result = str.replace(/(?<name>\\w+) (?<surname>\\w+)/, (...match) => {\n  let groups = match.pop();\n\n  return `${groups.surname}, ${groups.name}`;\n});\n\nalert(result); // Smith, John\n```\n\n使用函数可以为我们提供终极替换功能，因为它可以获取匹配项的所有信息，可以访问外部变量，可以做任何事。\n\n## str.replaceAll(str|regexp, str|func)\n\n这个方法与 `str.replace` 本质上是一样的，但有两个主要的区别：\n\n1. 如果第一个参数是一个字符串，它会替换 **所有出现的** 和第一个参数相同的字符串​，​而 `replace` 只会替换 **第一个**。\n2. 如果第一个参数是一个没有修饰符 `g` 的正则表达式，则会报错。带有修饰符 `g`，它的工作方式与 `replace` 相同。\n\n`replaceAll` 的主要用途是替换所有出现的字符串。\n\n像这样：\n\n```js run\n// 使用冒号替换所有破折号\nalert('12-34-56'.replaceAll(\"-\", \":\")) // 12:34:56\n```\n\n\n## regexp.exec(str)\n\n`regexp.exec(str)` 方法返回字符串 `str` 中的 `regexp` 匹配项。与以前的方法不同，它是在正则表达式而不是在字符串上调用的。\n\n它的行为取决于正则表达式是否具有修饰符 `pattern:g`。\n\n如果没有修饰符 `pattern:g`，则 `regexp.exec(str)` 会返回与 第一个匹配项，就像 `str.match(regexp)` 那样。这种行为并没有带来任何新的东西。\n\n但是，如果有修饰符 `pattern:g`，那么：\n- 调用 `regexp.exec(str)` 会返回第一个匹配项，并将紧随其后的位置保存在属性 `regexp.lastIndex` 中。\n- 下一次这样的调用会从位置 `regexp.lastIndex` 开始搜索，返回下一个匹配项，并将其后的位置保存在 `regexp.lastIndex` 中。\n- ……以此类推。\n- 如果没有匹配项，则 `regexp.exec` 返回 `null`，并将 `regexp.lastIndex` 重置为 `0`。\n\n因此，重复调用会一个接一个地返回所有匹配项，使用属性 `regexp.lastIndex` 来跟踪当前搜索位置。\n\n过去，在将 `str.matchAll` 方法添加到 JavaScript 之前，会在循环中调用 `regexp.exec` 来获取组的所有匹配项：\n\n```js run\nlet str = 'More about JavaScript at https://javascript.info';\nlet regexp = /javascript/ig;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Found ${result[0]} at position ${result.index}` );\n  // 在位置 11 找到了 JavaScript，然后\n  // 在位置 33 找到了 javascript\n}\n```\n\n这现在也有效，尽管对于较新的浏览器 `str.matchAll` 通常更方便。\n\n**我们可以通过手动设置 `lastIndex`，用 `regexp.exec` 从给定位置进行搜索。**\n\n例如：\n\n```js run\nlet str = 'Hello, world!';\n\nlet regexp = /\\w+/g; // 没有修饰符 \"g\"，lastIndex 属性会被忽略\nregexp.lastIndex = 5; // 从第 5 个位置搜索（从逗号开始）\n\nalert( regexp.exec(str) ); // world\n```\n\n如果正则表达式带有修饰符 `pattern:y`，则搜索将精确地在 `regexp.lastIndex` 位置执行，不会再进一步。\n\n让我们将上面示例中的 `pattern:g` 修饰符替换为 `pattern:y`。现在没有找到匹配项，因为在位置 `5` 处没有单词：\n\n```js run\nlet str = 'Hello, world!';\n\nlet regexp = /\\w+/y;\nregexp.lastIndex = 5; // 在位置 5 精确查找\n\nalert( regexp.exec(str) ); // null\n```\n\n当我们需要通过正则表达式在确切位置而不是其后的某处从字符串中“读取”某些内容时，这很方便。\n\n## regexp.test(str)\n\n方法 `regexp.test(str)` 查找匹配项，然后返回 `true/false` 表示是否存在。\n\n例如：\n\n```js run\nlet str = \"I love JavaScript\";\n\n// 这两个测试相同\nalert( *!*/love/i*/!*.test(str) ); // true\nalert( str.search(*!*/love/i*/!*) != -1 ); // true\n```\n\n一个否定答案的例子：\n\n```js run\nlet str = \"Bla-bla-bla\";\n\nalert( *!*/love/i*/!*.test(str) ); // false\nalert( str.search(*!*/love/i*/!*) != -1 ); // false\n```\n\n如果正则表达式带有修饰符 `pattern:g`，则 `regexp.test` 从  `regexp.lastIndex` 属性开始查找并更新此属性，就像 `regexp.exec` 一样。\n\n因此，我们可以用它从给定位置进行查找：\n\n```js run\nlet regexp = /love/gi;\n\nlet str = \"I love JavaScript\";\n\n// 从位置 10 开始搜索：\nregexp.lastIndex = 10;\nalert( regexp.test(str) ); // false（没有匹配项）\n```\n\n````warn header=\"相同的全局正则表达式在不同的源字符串上测试可能会失败\"\n如果我们在不同的源字符串上应用相同的全局正则表达式，可能会出现错误的结果，因为 `regexp.test` 的调用会增加 `regexp.lastIndex` 属性值，因此在另一个字符串中的搜索可能是从非 0 位置开始的。\n\n例如，这里我们在同一文本上调用 `regexp.test` 两次，而第二次调用失败了：\n\n```js run\nlet regexp = /javascript/g;  // （新建立的 regexp：regexp.lastIndex=0)\n\nalert( regexp.test(\"javascript\") ); // true（现在 regexp.lastIndex=10）\nalert( regexp.test(\"javascript\") ); // false\n```\n\n这正是因为在第二个测试中 `regexp.lastIndex` 不为零。\n\n如要解决这个问题，我们可以在每次搜索之前设置 `regexp.lastIndex = 0`。或者，不要在正则表达式上调用方法，而是使用字符串方法 `str.match/search/...`，这些方法不使用 `lastIndex`。\n````",
        "libs": [],
        "children": [],
        "parent": "regular-expressions",
        "updatedAt": 1667114531
      }
    }
  }
}